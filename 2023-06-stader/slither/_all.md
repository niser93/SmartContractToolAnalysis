
# SLITHER ANALYSIS

## reentrancy-eth
### Severity: High

### PermissionedPool.sol


```
Reentrancy in PermissionedPool.stakeUserETHToBeaconChain() (PermissionedPool.sol#2445-2482):
	External calls:
	- selectedOperatorCapacity = IPermissionedNodeRegistry(nodeRegistryAddress).allocateValidatorsAndUpdateOperatorId(requiredValidators) (PermissionedPool.sol#2451-2452)
	- preDepositOnBeaconChain(nodeRegistryAddress,vaultFactory,ethDepositContract,validatorId) (PermissionedPool.sol#2471)
		- IDepositContract(_ethDepositContract).deposit{value: preDepositSize}(pubkey,withdrawCredential,preDepositSignature,depositDataRoot) (PermissionedPool.sol#2666-2671)
		- IPermissionedNodeRegistry(_nodeRegistryAddress).markValidatorStatusAsPreDeposit(pubkey) (PermissionedPool.sol#2672)
	- IPermissionedNodeRegistry(nodeRegistryAddress).updateQueuedValidatorIndex(i,nextQueuedValidatorIndex + validatorToDeposit) (PermissionedPool.sol#2473-2476)
	External calls sending eth:
	- preDepositOnBeaconChain(nodeRegistryAddress,vaultFactory,ethDepositContract,validatorId) (PermissionedPool.sol#2471)
		- IDepositContract(_ethDepositContract).deposit{value: preDepositSize}(pubkey,withdrawCredential,preDepositSignature,depositDataRoot) (PermissionedPool.sol#2666-2671)
	State variables written after the call(s):
	- increasePreDepositValidatorCount(validatorToDeposit) (PermissionedPool.sol#2461)
		- preDepositValidatorCount += _count (PermissionedPool.sol#2636)
	PermissionedPool.preDepositValidatorCount (PermissionedPool.sol#2387) can be used in cross function reentrancies:
	- PermissionedPool.preDepositValidatorCount (PermissionedPool.sol#2387)



    
2451         uint256[] memory selectedOperatorCapacity = IPermissionedNodeRegistry(nodeRegistryAddress)
2452             .allocateValidatorsAndUpdateOperatorId(requiredValidators);



    
2471                 preDepositOnBeaconChain(nodeRegistryAddress, vaultFactory, ethDepositContract, validatorId);



    
2666         IDepositContract(_ethDepositContract).deposit{value: preDepositSize}(
2667             pubkey,
2668             withdrawCredential,
2669             preDepositSignature,
2670             depositDataRoot
2671         );



    
2672         IPermissionedNodeRegistry(_nodeRegistryAddress).markValidatorStatusAsPreDeposit(pubkey);



    
2473             IPermissionedNodeRegistry(nodeRegistryAddress).updateQueuedValidatorIndex(
2474                 i,
2475                 nextQueuedValidatorIndex + validatorToDeposit
2476             );



    
2471                 preDepositOnBeaconChain(nodeRegistryAddress, vaultFactory, ethDepositContract, validatorId);



    
2666         IDepositContract(_ethDepositContract).deposit{value: preDepositSize}(
2667             pubkey,
2668             withdrawCredential,
2669             preDepositSignature,
2670             depositDataRoot
2671         );



    
2461             increasePreDepositValidatorCount(validatorToDeposit);



    
2636         preDepositValidatorCount += _count;



```

### PermissionlessNodeRegistry.sol


```
Reentrancy in PermissionlessNodeRegistry.markValidatorReadyToDeposit(bytes[],bytes[],bytes[]) (PermissionlessNodeRegistry.sol#2444-2495):
	External calls:
	- IStaderInsuranceFund(staderConfig.getStaderInsuranceFund()).depositFund{value: frontRunValidatorsLength * FRONT_RUN_PENALTY}() (PermissionlessNodeRegistry.sol#2471-2473)
	- handleInvalidSignature(validatorId_scope_3) (PermissionlessNodeRegistry.sol#2489)
		- IOperatorRewardsCollector(staderConfig.getOperatorRewardsCollector()).depositFor{value: (COLLATERAL_ETH - staderConfig.getPreDepositSize())}(operatorAddress) (PermissionlessNodeRegistry.sol#2898-2900)
	State variables written after the call(s):
	- handleInvalidSignature(validatorId_scope_3) (PermissionlessNodeRegistry.sol#2489)
		- validatorRegistry[_validatorId].status = ValidatorStatus.INVALID_SIGNATURE (PermissionlessNodeRegistry.sol#2895)
	PermissionlessNodeRegistry.validatorRegistry (PermissionlessNodeRegistry.sol#2307) can be used in cross function reentrancies:
	- PermissionlessNodeRegistry.getAllActiveValidators(uint256,uint256) (PermissionlessNodeRegistry.sol#2751-2777)
	- PermissionlessNodeRegistry.getValidatorsByOperator(address,uint256,uint256) (PermissionlessNodeRegistry.sol#2787-2810)
	- PermissionlessNodeRegistry.isActiveValidator(uint256) (PermissionlessNodeRegistry.sol#2962-2964)
	- PermissionlessNodeRegistry.isNonTerminalValidator(uint256) (PermissionlessNodeRegistry.sol#2952-2958)
	- PermissionlessNodeRegistry.markValidatorDeposited(uint256) (PermissionlessNodeRegistry.sol#2978-2980)
	- PermissionlessNodeRegistry.updateDepositStatusAndBlock(uint256) (PermissionlessNodeRegistry.sol#2540-2545)
	- PermissionlessNodeRegistry.validatorRegistry (PermissionlessNodeRegistry.sol#2307)
	- PermissionlessNodeRegistry.withdrawnValidators(bytes[]) (PermissionlessNodeRegistry.sol#2502-2522)



    
2471             IStaderInsuranceFund(staderConfig.getStaderInsuranceFund()).depositFund{
2472                 value: frontRunValidatorsLength * FRONT_RUN_PENALTY
2473             }();



    
2489             handleInvalidSignature(validatorId);



    
2898         IOperatorRewardsCollector(staderConfig.getOperatorRewardsCollector()).depositFor{
2899             value: (COLLATERAL_ETH - staderConfig.getPreDepositSize())
2900         }(operatorAddress);



    
2489             handleInvalidSignature(validatorId);



    
2895         validatorRegistry[_validatorId].status = ValidatorStatus.INVALID_SIGNATURE;



```

```
Reentrancy in PermissionlessNodeRegistry.markValidatorReadyToDeposit(bytes[],bytes[],bytes[]) (PermissionlessNodeRegistry.sol#2444-2495):
	External calls:
	- IStaderInsuranceFund(staderConfig.getStaderInsuranceFund()).depositFund{value: frontRunValidatorsLength * FRONT_RUN_PENALTY}() (PermissionlessNodeRegistry.sol#2471-2473)
	State variables written after the call(s):
	- handleFrontRun(validatorId_scope_1) (PermissionlessNodeRegistry.sol#2479)
		- validatorRegistry[_validatorId].status = ValidatorStatus.FRONT_RUN (PermissionlessNodeRegistry.sol#2887)
	PermissionlessNodeRegistry.validatorRegistry (PermissionlessNodeRegistry.sol#2307) can be used in cross function reentrancies:
	- PermissionlessNodeRegistry.getAllActiveValidators(uint256,uint256) (PermissionlessNodeRegistry.sol#2751-2777)
	- PermissionlessNodeRegistry.getValidatorsByOperator(address,uint256,uint256) (PermissionlessNodeRegistry.sol#2787-2810)
	- PermissionlessNodeRegistry.isActiveValidator(uint256) (PermissionlessNodeRegistry.sol#2962-2964)
	- PermissionlessNodeRegistry.isNonTerminalValidator(uint256) (PermissionlessNodeRegistry.sol#2952-2958)
	- PermissionlessNodeRegistry.markValidatorDeposited(uint256) (PermissionlessNodeRegistry.sol#2978-2980)
	- PermissionlessNodeRegistry.updateDepositStatusAndBlock(uint256) (PermissionlessNodeRegistry.sol#2540-2545)
	- PermissionlessNodeRegistry.validatorRegistry (PermissionlessNodeRegistry.sol#2307)
	- PermissionlessNodeRegistry.withdrawnValidators(bytes[]) (PermissionlessNodeRegistry.sol#2502-2522)



    
2471             IStaderInsuranceFund(staderConfig.getStaderInsuranceFund()).depositFund{
2472                 value: frontRunValidatorsLength * FRONT_RUN_PENALTY
2473             }();



    
2479             handleFrontRun(validatorId);



    
2887         validatorRegistry[_validatorId].status = ValidatorStatus.FRONT_RUN;



```

### StaderStakePoolsManager.sol


```
Reentrancy in StaderStakePoolsManager.depositETHOverTargetWeight() (StaderStakePoolsManager.sol#3805-3836):
	External calls:
	- (selectedPoolCapacity,poolIdArray) = IPoolSelector(staderConfig.getPoolSelector()).poolAllocationForExcessETHDeposit(availableETHForNewDeposit) (StaderStakePoolsManager.sol#3817-3819)
	- IStaderPoolBase(poolAddress).stakeUserETHToBeaconChain{value: validatorToDeposit * poolDepositSize}() (StaderStakePoolsManager.sol#3833)
	External calls sending eth:
	- IStaderPoolBase(poolAddress).stakeUserETHToBeaconChain{value: validatorToDeposit * poolDepositSize}() (StaderStakePoolsManager.sol#3833)
	State variables written after the call(s):
	- lastExcessETHDepositBlock = block.number (StaderStakePoolsManager.sol#3831)
	StaderStakePoolsManager.lastExcessETHDepositBlock (StaderStakePoolsManager.sol#3628) can be used in cross function reentrancies:
	- StaderStakePoolsManager.initialize(address,address) (StaderStakePoolsManager.sol#3640-3650)
	- StaderStakePoolsManager.lastExcessETHDepositBlock (StaderStakePoolsManager.sol#3628)



    
3817         (uint256[] memory selectedPoolCapacity, uint8[] memory poolIdArray) = IPoolSelector(
3818             staderConfig.getPoolSelector()
3819         ).poolAllocationForExcessETHDeposit(availableETHForNewDeposit);



    
3833             IStaderPoolBase(poolAddress).stakeUserETHToBeaconChain{value: validatorToDeposit * poolDepositSize}();



    
3833             IStaderPoolBase(poolAddress).stakeUserETHToBeaconChain{value: validatorToDeposit * poolDepositSize}();



    
3831             lastExcessETHDepositBlock = block.number;



```

## arbitrary-send-eth
### Severity: High

### PermissionlessNodeRegistry.sol


```
PermissionlessNodeRegistry.handleInvalidSignature(uint256) (PermissionlessNodeRegistry.sol#2894-2901) sends eth to arbitrary user
	Dangerous calls:
	- IOperatorRewardsCollector(staderConfig.getOperatorRewardsCollector()).depositFor{value: (COLLATERAL_ETH - staderConfig.getPreDepositSize())}(operatorAddress) (PermissionlessNodeRegistry.sol#2898-2900)



    
2898         IOperatorRewardsCollector(staderConfig.getOperatorRewardsCollector()).depositFor{
2899             value: (COLLATERAL_ETH - staderConfig.getPreDepositSize())
2900         }(operatorAddress);



```

```
PermissionlessNodeRegistry.transferCollateralToPool(uint256) (PermissionlessNodeRegistry.sol#2653-2657) sends eth to arbitrary user
	Dangerous calls:
	- IPermissionlessPool(staderConfig.getPermissionlessPool()).receiveRemainingCollateralETH{value: _amount}() (PermissionlessNodeRegistry.sol#2655)



    
2655         IPermissionlessPool(staderConfig.getPermissionlessPool()).receiveRemainingCollateralETH{value: _amount}();



```

### PermissionlessPool.sol


```
PermissionlessPool.fullDepositOnBeaconChain(address,address,address,uint256,uint256) (PermissionlessPool.sol#2584-2613) sends eth to arbitrary user
	Dangerous calls:
	- IDepositContract(_ethDepositContract).deposit{value: _DEPOSIT_SIZE}(pubkey,withdrawCredential,depositSignature,depositDataRoot) (PermissionlessPool.sol#2605-2610)



    
2605         IDepositContract(_ethDepositContract).deposit{value: _DEPOSIT_SIZE}(
2606             pubkey,
2607             withdrawCredential,
2608             depositSignature,
2609             depositDataRoot
2610         );



```

### SocializingPool.sol


```
SocializingPool.handleRewards(RewardsData) (SocializingPool.sol#2572-2616) sends eth to arbitrary user
	Dangerous calls:
	- IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveExecutionLayerRewards{value: _rewardsData.userETHRewards}() (SocializingPool.sol#2598-2600)
	- (success) = address(staderConfig.getStaderTreasury()).call{value: _rewardsData.protocolETHRewards}() (SocializingPool.sol#2602)



    
2598         IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveExecutionLayerRewards{
2599             value: _rewardsData.userETHRewards
2600         }();



    
2602         (bool success, ) = payable(staderConfig.getStaderTreasury()).call{value: _rewardsData.protocolETHRewards}('');



```

```
SocializingPool.claim(uint256[],uint256[],uint256[],bytes32[][]) (SocializingPool.sol#2618-2646) sends eth to arbitrary user
	Dangerous calls:
	- (success,None) = address(operatorRewardsAddr).call{value: totalAmountETH}() (SocializingPool.sol#2632)



    
2632             (success, ) = payable(operatorRewardsAddr).call{value: totalAmountETH}('');



```

### StaderInsuranceFund.sol


```
StaderInsuranceFund.reimburseUserFund(uint256) (StaderInsuranceFund.sol#1972-1978) sends eth to arbitrary user
	Dangerous calls:
	- IPermissionedPool(staderConfig.getPermissionedPool()).receiveInsuranceFund{value: _amount}() (StaderInsuranceFund.sol#1977)



    
1977         IPermissionedPool(staderConfig.getPermissionedPool()).receiveInsuranceFund{value: _amount}();



```

## controlled-delegatecall
### Severity: High

### ValidatorWithdrawalVault.sol


```
VaultProxy.fallback(bytes) (ValidatorWithdrawalVault.sol#636-645) uses delegatecall to a input-controlled function id
	- (success,data) = vaultImplementation.delegatecall(_input) (ValidatorWithdrawalVault.sol#640)



    
640         (bool success, bytes memory data) = vaultImplementation.delegatecall(_input);



```

### VaultFactory.sol


```
VaultProxy.fallback(bytes) (VaultFactory.sol#636-645) uses delegatecall to a input-controlled function id
	- (success,data) = vaultImplementation.delegatecall(_input) (VaultFactory.sol#640)



    
640         (bool success, bytes memory data) = vaultImplementation.delegatecall(_input);



```

### VaultProxy.sol


```
VaultProxy.fallback(bytes) (VaultProxy.sol#636-645) uses delegatecall to a input-controlled function id
	- (success,data) = vaultImplementation.delegatecall(_input) (VaultProxy.sol#640)



    
640         (bool success, bytes memory data) = vaultImplementation.delegatecall(_input);



```

## divide-before-multiply
### Severity: Medium

### Auction.sol


```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (Auction.sol#1360-1440) performs a multiplication on the result of a division:
	- prod0 = prod0 / twos (Auction.sol#1410)
	- result = prod0 * inverse (Auction.sol#1437)



    
1410                 prod0 := div(prod0, twos)



    
1437             result = prod0 * inverse;



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (Auction.sol#1360-1440) performs a multiplication on the result of a division:
	- denominator = denominator / twos (Auction.sol#1407)
	- inverse *= 2 - denominator * inverse (Auction.sol#1427)



    
1407                 denominator := div(denominator, twos)



    
1427             inverse *= 2 - denominator * inverse; // inverse mod 2^16



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (Auction.sol#1360-1440) performs a multiplication on the result of a division:
	- denominator = denominator / twos (Auction.sol#1407)
	- inverse = (3 * denominator) ^ 2 (Auction.sol#1422)



    
1407                 denominator := div(denominator, twos)



    
1422             uint256 inverse = (3 * denominator) ^ 2;



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (Auction.sol#1360-1440) performs a multiplication on the result of a division:
	- denominator = denominator / twos (Auction.sol#1407)
	- inverse *= 2 - denominator * inverse (Auction.sol#1431)



    
1407                 denominator := div(denominator, twos)



    
1431             inverse *= 2 - denominator * inverse; // inverse mod 2^256



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (Auction.sol#1360-1440) performs a multiplication on the result of a division:
	- denominator = denominator / twos (Auction.sol#1407)
	- inverse *= 2 - denominator * inverse (Auction.sol#1429)



    
1407                 denominator := div(denominator, twos)



    
1429             inverse *= 2 - denominator * inverse; // inverse mod 2^64



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (Auction.sol#1360-1440) performs a multiplication on the result of a division:
	- denominator = denominator / twos (Auction.sol#1407)
	- inverse *= 2 - denominator * inverse (Auction.sol#1428)



    
1407                 denominator := div(denominator, twos)



    
1428             inverse *= 2 - denominator * inverse; // inverse mod 2^32



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (Auction.sol#1360-1440) performs a multiplication on the result of a division:
	- denominator = denominator / twos (Auction.sol#1407)
	- inverse *= 2 - denominator * inverse (Auction.sol#1426)



    
1407                 denominator := div(denominator, twos)



    
1426             inverse *= 2 - denominator * inverse; // inverse mod 2^8



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (Auction.sol#1360-1440) performs a multiplication on the result of a division:
	- denominator = denominator / twos (Auction.sol#1407)
	- inverse *= 2 - denominator * inverse (Auction.sol#1430)



    
1407                 denominator := div(denominator, twos)



    
1430             inverse *= 2 - denominator * inverse; // inverse mod 2^128



```

### ETHx.sol


```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (ETHx.sol#1653-1733) performs a multiplication on the result of a division:
	- denominator = denominator / twos (ETHx.sol#1700)
	- inverse *= 2 - denominator * inverse (ETHx.sol#1724)



    
1700                 denominator := div(denominator, twos)



    
1724             inverse *= 2 - denominator * inverse; // inverse mod 2^256



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (ETHx.sol#1653-1733) performs a multiplication on the result of a division:
	- denominator = denominator / twos (ETHx.sol#1700)
	- inverse *= 2 - denominator * inverse (ETHx.sol#1719)



    
1700                 denominator := div(denominator, twos)



    
1719             inverse *= 2 - denominator * inverse; // inverse mod 2^8



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (ETHx.sol#1653-1733) performs a multiplication on the result of a division:
	- denominator = denominator / twos (ETHx.sol#1700)
	- inverse *= 2 - denominator * inverse (ETHx.sol#1723)



    
1700                 denominator := div(denominator, twos)



    
1723             inverse *= 2 - denominator * inverse; // inverse mod 2^128



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (ETHx.sol#1653-1733) performs a multiplication on the result of a division:
	- denominator = denominator / twos (ETHx.sol#1700)
	- inverse *= 2 - denominator * inverse (ETHx.sol#1722)



    
1700                 denominator := div(denominator, twos)



    
1722             inverse *= 2 - denominator * inverse; // inverse mod 2^64



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (ETHx.sol#1653-1733) performs a multiplication on the result of a division:
	- denominator = denominator / twos (ETHx.sol#1700)
	- inverse *= 2 - denominator * inverse (ETHx.sol#1721)



    
1700                 denominator := div(denominator, twos)



    
1721             inverse *= 2 - denominator * inverse; // inverse mod 2^32



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (ETHx.sol#1653-1733) performs a multiplication on the result of a division:
	- denominator = denominator / twos (ETHx.sol#1700)
	- inverse *= 2 - denominator * inverse (ETHx.sol#1720)



    
1700                 denominator := div(denominator, twos)



    
1720             inverse *= 2 - denominator * inverse; // inverse mod 2^16



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (ETHx.sol#1653-1733) performs a multiplication on the result of a division:
	- denominator = denominator / twos (ETHx.sol#1700)
	- inverse = (3 * denominator) ^ 2 (ETHx.sol#1715)



    
1700                 denominator := div(denominator, twos)



    
1715             uint256 inverse = (3 * denominator) ^ 2;



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (ETHx.sol#1653-1733) performs a multiplication on the result of a division:
	- prod0 = prod0 / twos (ETHx.sol#1703)
	- result = prod0 * inverse (ETHx.sol#1730)



    
1703                 prod0 := div(prod0, twos)



    
1730             result = prod0 * inverse;



```

### OperatorRewardsCollector.sol


```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (OperatorRewardsCollector.sol#1168-1248) performs a multiplication on the result of a division:
	- denominator = denominator / twos (OperatorRewardsCollector.sol#1215)
	- inverse *= 2 - denominator * inverse (OperatorRewardsCollector.sol#1239)



    
1215                 denominator := div(denominator, twos)



    
1239             inverse *= 2 - denominator * inverse; // inverse mod 2^256



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (OperatorRewardsCollector.sol#1168-1248) performs a multiplication on the result of a division:
	- denominator = denominator / twos (OperatorRewardsCollector.sol#1215)
	- inverse *= 2 - denominator * inverse (OperatorRewardsCollector.sol#1235)



    
1215                 denominator := div(denominator, twos)



    
1235             inverse *= 2 - denominator * inverse; // inverse mod 2^16



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (OperatorRewardsCollector.sol#1168-1248) performs a multiplication on the result of a division:
	- prod0 = prod0 / twos (OperatorRewardsCollector.sol#1218)
	- result = prod0 * inverse (OperatorRewardsCollector.sol#1245)



    
1218                 prod0 := div(prod0, twos)



    
1245             result = prod0 * inverse;



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (OperatorRewardsCollector.sol#1168-1248) performs a multiplication on the result of a division:
	- denominator = denominator / twos (OperatorRewardsCollector.sol#1215)
	- inverse *= 2 - denominator * inverse (OperatorRewardsCollector.sol#1234)



    
1215                 denominator := div(denominator, twos)



    
1234             inverse *= 2 - denominator * inverse; // inverse mod 2^8



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (OperatorRewardsCollector.sol#1168-1248) performs a multiplication on the result of a division:
	- denominator = denominator / twos (OperatorRewardsCollector.sol#1215)
	- inverse = (3 * denominator) ^ 2 (OperatorRewardsCollector.sol#1230)



    
1215                 denominator := div(denominator, twos)



    
1230             uint256 inverse = (3 * denominator) ^ 2;



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (OperatorRewardsCollector.sol#1168-1248) performs a multiplication on the result of a division:
	- denominator = denominator / twos (OperatorRewardsCollector.sol#1215)
	- inverse *= 2 - denominator * inverse (OperatorRewardsCollector.sol#1236)



    
1215                 denominator := div(denominator, twos)



    
1236             inverse *= 2 - denominator * inverse; // inverse mod 2^32



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (OperatorRewardsCollector.sol#1168-1248) performs a multiplication on the result of a division:
	- denominator = denominator / twos (OperatorRewardsCollector.sol#1215)
	- inverse *= 2 - denominator * inverse (OperatorRewardsCollector.sol#1238)



    
1215                 denominator := div(denominator, twos)



    
1238             inverse *= 2 - denominator * inverse; // inverse mod 2^128



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (OperatorRewardsCollector.sol#1168-1248) performs a multiplication on the result of a division:
	- denominator = denominator / twos (OperatorRewardsCollector.sol#1215)
	- inverse *= 2 - denominator * inverse (OperatorRewardsCollector.sol#1237)



    
1215                 denominator := div(denominator, twos)



    
1237             inverse *= 2 - denominator * inverse; // inverse mod 2^64



```

### Penalty.sol


```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (Penalty.sol#1630-1710) performs a multiplication on the result of a division:
	- prod0 = prod0 / twos (Penalty.sol#1680)
	- result = prod0 * inverse (Penalty.sol#1707)



    
1680                 prod0 := div(prod0, twos)



    
1707             result = prod0 * inverse;



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (Penalty.sol#1630-1710) performs a multiplication on the result of a division:
	- denominator = denominator / twos (Penalty.sol#1677)
	- inverse *= 2 - denominator * inverse (Penalty.sol#1696)



    
1677                 denominator := div(denominator, twos)



    
1696             inverse *= 2 - denominator * inverse; // inverse mod 2^8



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (Penalty.sol#1630-1710) performs a multiplication on the result of a division:
	- denominator = denominator / twos (Penalty.sol#1677)
	- inverse *= 2 - denominator * inverse (Penalty.sol#1700)



    
1677                 denominator := div(denominator, twos)



    
1700             inverse *= 2 - denominator * inverse; // inverse mod 2^128



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (Penalty.sol#1630-1710) performs a multiplication on the result of a division:
	- denominator = denominator / twos (Penalty.sol#1677)
	- inverse *= 2 - denominator * inverse (Penalty.sol#1697)



    
1677                 denominator := div(denominator, twos)



    
1697             inverse *= 2 - denominator * inverse; // inverse mod 2^16



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (Penalty.sol#1630-1710) performs a multiplication on the result of a division:
	- denominator = denominator / twos (Penalty.sol#1677)
	- inverse *= 2 - denominator * inverse (Penalty.sol#1698)



    
1677                 denominator := div(denominator, twos)



    
1698             inverse *= 2 - denominator * inverse; // inverse mod 2^32



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (Penalty.sol#1630-1710) performs a multiplication on the result of a division:
	- denominator = denominator / twos (Penalty.sol#1677)
	- inverse *= 2 - denominator * inverse (Penalty.sol#1701)



    
1677                 denominator := div(denominator, twos)



    
1701             inverse *= 2 - denominator * inverse; // inverse mod 2^256



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (Penalty.sol#1630-1710) performs a multiplication on the result of a division:
	- denominator = denominator / twos (Penalty.sol#1677)
	- inverse *= 2 - denominator * inverse (Penalty.sol#1699)



    
1677                 denominator := div(denominator, twos)



    
1699             inverse *= 2 - denominator * inverse; // inverse mod 2^64



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (Penalty.sol#1630-1710) performs a multiplication on the result of a division:
	- denominator = denominator / twos (Penalty.sol#1677)
	- inverse = (3 * denominator) ^ 2 (Penalty.sol#1692)



    
1677                 denominator := div(denominator, twos)



    
1692             uint256 inverse = (3 * denominator) ^ 2;



```

### PermissionedNodeRegistry.sol


```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionedNodeRegistry.sol#1708-1788) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionedNodeRegistry.sol#1755)
	- inverse *= 2 - denominator * inverse (PermissionedNodeRegistry.sol#1777)



    
1755                 denominator := div(denominator, twos)



    
1777             inverse *= 2 - denominator * inverse; // inverse mod 2^64



```

```
Math.mulDiv(uint256,uint256,uint256) (PermissionedNodeRegistry.sol#870-950) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionedNodeRegistry.sol#917)
	- inverse *= 2 - denominator * inverse (PermissionedNodeRegistry.sol#936)



    
917                 denominator := div(denominator, twos)



    
936             inverse *= 2 - denominator * inverse; // inverse mod 2^8



```

```
Math.mulDiv(uint256,uint256,uint256) (PermissionedNodeRegistry.sol#870-950) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionedNodeRegistry.sol#917)
	- inverse *= 2 - denominator * inverse (PermissionedNodeRegistry.sol#941)



    
917                 denominator := div(denominator, twos)



    
941             inverse *= 2 - denominator * inverse; // inverse mod 2^256



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionedNodeRegistry.sol#1708-1788) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionedNodeRegistry.sol#1755)
	- inverse *= 2 - denominator * inverse (PermissionedNodeRegistry.sol#1779)



    
1755                 denominator := div(denominator, twos)



    
1779             inverse *= 2 - denominator * inverse; // inverse mod 2^256



```

```
Math.mulDiv(uint256,uint256,uint256) (PermissionedNodeRegistry.sol#870-950) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionedNodeRegistry.sol#917)
	- inverse *= 2 - denominator * inverse (PermissionedNodeRegistry.sol#940)



    
917                 denominator := div(denominator, twos)



    
940             inverse *= 2 - denominator * inverse; // inverse mod 2^128



```

```
Math.mulDiv(uint256,uint256,uint256) (PermissionedNodeRegistry.sol#870-950) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionedNodeRegistry.sol#917)
	- inverse *= 2 - denominator * inverse (PermissionedNodeRegistry.sol#938)



    
917                 denominator := div(denominator, twos)



    
938             inverse *= 2 - denominator * inverse; // inverse mod 2^32



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionedNodeRegistry.sol#1708-1788) performs a multiplication on the result of a division:
	- prod0 = prod0 / twos (PermissionedNodeRegistry.sol#1758)
	- result = prod0 * inverse (PermissionedNodeRegistry.sol#1785)



    
1758                 prod0 := div(prod0, twos)



    
1785             result = prod0 * inverse;



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionedNodeRegistry.sol#1708-1788) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionedNodeRegistry.sol#1755)
	- inverse *= 2 - denominator * inverse (PermissionedNodeRegistry.sol#1775)



    
1755                 denominator := div(denominator, twos)



    
1775             inverse *= 2 - denominator * inverse; // inverse mod 2^16



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionedNodeRegistry.sol#1708-1788) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionedNodeRegistry.sol#1755)
	- inverse *= 2 - denominator * inverse (PermissionedNodeRegistry.sol#1774)



    
1755                 denominator := div(denominator, twos)



    
1774             inverse *= 2 - denominator * inverse; // inverse mod 2^8



```

```
Math.mulDiv(uint256,uint256,uint256) (PermissionedNodeRegistry.sol#870-950) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionedNodeRegistry.sol#917)
	- inverse *= 2 - denominator * inverse (PermissionedNodeRegistry.sol#937)



    
917                 denominator := div(denominator, twos)



    
937             inverse *= 2 - denominator * inverse; // inverse mod 2^16



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionedNodeRegistry.sol#1708-1788) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionedNodeRegistry.sol#1755)
	- inverse = (3 * denominator) ^ 2 (PermissionedNodeRegistry.sol#1770)



    
1755                 denominator := div(denominator, twos)



    
1770             uint256 inverse = (3 * denominator) ^ 2;



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionedNodeRegistry.sol#1708-1788) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionedNodeRegistry.sol#1755)
	- inverse *= 2 - denominator * inverse (PermissionedNodeRegistry.sol#1778)



    
1755                 denominator := div(denominator, twos)



    
1778             inverse *= 2 - denominator * inverse; // inverse mod 2^128



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionedNodeRegistry.sol#1708-1788) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionedNodeRegistry.sol#1755)
	- inverse *= 2 - denominator * inverse (PermissionedNodeRegistry.sol#1776)



    
1755                 denominator := div(denominator, twos)



    
1776             inverse *= 2 - denominator * inverse; // inverse mod 2^32



```

```
Math.mulDiv(uint256,uint256,uint256) (PermissionedNodeRegistry.sol#870-950) performs a multiplication on the result of a division:
	- prod0 = prod0 / twos (PermissionedNodeRegistry.sol#920)
	- result = prod0 * inverse (PermissionedNodeRegistry.sol#947)



    
920                 prod0 := div(prod0, twos)



    
947             result = prod0 * inverse;



```

```
Math.mulDiv(uint256,uint256,uint256) (PermissionedNodeRegistry.sol#870-950) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionedNodeRegistry.sol#917)
	- inverse *= 2 - denominator * inverse (PermissionedNodeRegistry.sol#939)



    
917                 denominator := div(denominator, twos)



    
939             inverse *= 2 - denominator * inverse; // inverse mod 2^64



```

```
Math.mulDiv(uint256,uint256,uint256) (PermissionedNodeRegistry.sol#870-950) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionedNodeRegistry.sol#917)
	- inverse = (3 * denominator) ^ 2 (PermissionedNodeRegistry.sol#932)



    
917                 denominator := div(denominator, twos)



    
932             uint256 inverse = (3 * denominator) ^ 2;



```

### PermissionedPool.sol


```
Math.mulDiv(uint256,uint256,uint256) (PermissionedPool.sol#907-987) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionedPool.sol#954)
	- inverse *= 2 - denominator * inverse (PermissionedPool.sol#974)



    
954                 denominator := div(denominator, twos)



    
974             inverse *= 2 - denominator * inverse; // inverse mod 2^16



```

```
Math.mulDiv(uint256,uint256,uint256) (PermissionedPool.sol#907-987) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionedPool.sol#954)
	- inverse *= 2 - denominator * inverse (PermissionedPool.sol#973)



    
954                 denominator := div(denominator, twos)



    
973             inverse *= 2 - denominator * inverse; // inverse mod 2^8



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionedPool.sol#1633-1713) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionedPool.sol#1680)
	- inverse *= 2 - denominator * inverse (PermissionedPool.sol#1703)



    
1680                 denominator := div(denominator, twos)



    
1703             inverse *= 2 - denominator * inverse; // inverse mod 2^128



```

```
Math.mulDiv(uint256,uint256,uint256) (PermissionedPool.sol#907-987) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionedPool.sol#954)
	- inverse = (3 * denominator) ^ 2 (PermissionedPool.sol#969)



    
954                 denominator := div(denominator, twos)



    
969             uint256 inverse = (3 * denominator) ^ 2;



```

```
Math.mulDiv(uint256,uint256,uint256) (PermissionedPool.sol#907-987) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionedPool.sol#954)
	- inverse *= 2 - denominator * inverse (PermissionedPool.sol#977)



    
954                 denominator := div(denominator, twos)



    
977             inverse *= 2 - denominator * inverse; // inverse mod 2^128



```

```
Math.mulDiv(uint256,uint256,uint256) (PermissionedPool.sol#907-987) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionedPool.sol#954)
	- inverse *= 2 - denominator * inverse (PermissionedPool.sol#978)



    
954                 denominator := div(denominator, twos)



    
978             inverse *= 2 - denominator * inverse; // inverse mod 2^256



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionedPool.sol#1633-1713) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionedPool.sol#1680)
	- inverse *= 2 - denominator * inverse (PermissionedPool.sol#1701)



    
1680                 denominator := div(denominator, twos)



    
1701             inverse *= 2 - denominator * inverse; // inverse mod 2^32



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionedPool.sol#1633-1713) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionedPool.sol#1680)
	- inverse = (3 * denominator) ^ 2 (PermissionedPool.sol#1695)



    
1680                 denominator := div(denominator, twos)



    
1695             uint256 inverse = (3 * denominator) ^ 2;



```

```
Math.mulDiv(uint256,uint256,uint256) (PermissionedPool.sol#907-987) performs a multiplication on the result of a division:
	- prod0 = prod0 / twos (PermissionedPool.sol#957)
	- result = prod0 * inverse (PermissionedPool.sol#984)



    
957                 prod0 := div(prod0, twos)



    
984             result = prod0 * inverse;



```

```
Math.mulDiv(uint256,uint256,uint256) (PermissionedPool.sol#907-987) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionedPool.sol#954)
	- inverse *= 2 - denominator * inverse (PermissionedPool.sol#976)



    
954                 denominator := div(denominator, twos)



    
976             inverse *= 2 - denominator * inverse; // inverse mod 2^64



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionedPool.sol#1633-1713) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionedPool.sol#1680)
	- inverse *= 2 - denominator * inverse (PermissionedPool.sol#1704)



    
1680                 denominator := div(denominator, twos)



    
1704             inverse *= 2 - denominator * inverse; // inverse mod 2^256



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionedPool.sol#1633-1713) performs a multiplication on the result of a division:
	- prod0 = prod0 / twos (PermissionedPool.sol#1683)
	- result = prod0 * inverse (PermissionedPool.sol#1710)



    
1683                 prod0 := div(prod0, twos)



    
1710             result = prod0 * inverse;



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionedPool.sol#1633-1713) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionedPool.sol#1680)
	- inverse *= 2 - denominator * inverse (PermissionedPool.sol#1700)



    
1680                 denominator := div(denominator, twos)



    
1700             inverse *= 2 - denominator * inverse; // inverse mod 2^16



```

```
Math.mulDiv(uint256,uint256,uint256) (PermissionedPool.sol#907-987) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionedPool.sol#954)
	- inverse *= 2 - denominator * inverse (PermissionedPool.sol#975)



    
954                 denominator := div(denominator, twos)



    
975             inverse *= 2 - denominator * inverse; // inverse mod 2^32



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionedPool.sol#1633-1713) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionedPool.sol#1680)
	- inverse *= 2 - denominator * inverse (PermissionedPool.sol#1699)



    
1680                 denominator := div(denominator, twos)



    
1699             inverse *= 2 - denominator * inverse; // inverse mod 2^8



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionedPool.sol#1633-1713) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionedPool.sol#1680)
	- inverse *= 2 - denominator * inverse (PermissionedPool.sol#1702)



    
1680                 denominator := div(denominator, twos)



    
1702             inverse *= 2 - denominator * inverse; // inverse mod 2^64



```

### PermissionlessNodeRegistry.sol


```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionlessNodeRegistry.sol#1540-1620) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionlessNodeRegistry.sol#1587)
	- inverse *= 2 - denominator * inverse (PermissionlessNodeRegistry.sol#1607)



    
1587                 denominator := div(denominator, twos)



    
1607             inverse *= 2 - denominator * inverse; // inverse mod 2^16



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionlessNodeRegistry.sol#1540-1620) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionlessNodeRegistry.sol#1587)
	- inverse *= 2 - denominator * inverse (PermissionlessNodeRegistry.sol#1611)



    
1587                 denominator := div(denominator, twos)



    
1611             inverse *= 2 - denominator * inverse; // inverse mod 2^256



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionlessNodeRegistry.sol#1540-1620) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionlessNodeRegistry.sol#1587)
	- inverse *= 2 - denominator * inverse (PermissionlessNodeRegistry.sol#1606)



    
1587                 denominator := div(denominator, twos)



    
1606             inverse *= 2 - denominator * inverse; // inverse mod 2^8



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionlessNodeRegistry.sol#1540-1620) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionlessNodeRegistry.sol#1587)
	- inverse *= 2 - denominator * inverse (PermissionlessNodeRegistry.sol#1609)



    
1587                 denominator := div(denominator, twos)



    
1609             inverse *= 2 - denominator * inverse; // inverse mod 2^64



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionlessNodeRegistry.sol#1540-1620) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionlessNodeRegistry.sol#1587)
	- inverse *= 2 - denominator * inverse (PermissionlessNodeRegistry.sol#1610)



    
1587                 denominator := div(denominator, twos)



    
1610             inverse *= 2 - denominator * inverse; // inverse mod 2^128



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionlessNodeRegistry.sol#1540-1620) performs a multiplication on the result of a division:
	- prod0 = prod0 / twos (PermissionlessNodeRegistry.sol#1590)
	- result = prod0 * inverse (PermissionlessNodeRegistry.sol#1617)



    
1590                 prod0 := div(prod0, twos)



    
1617             result = prod0 * inverse;



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionlessNodeRegistry.sol#1540-1620) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionlessNodeRegistry.sol#1587)
	- inverse = (3 * denominator) ^ 2 (PermissionlessNodeRegistry.sol#1602)



    
1587                 denominator := div(denominator, twos)



    
1602             uint256 inverse = (3 * denominator) ^ 2;



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionlessNodeRegistry.sol#1540-1620) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionlessNodeRegistry.sol#1587)
	- inverse *= 2 - denominator * inverse (PermissionlessNodeRegistry.sol#1608)



    
1587                 denominator := div(denominator, twos)



    
1608             inverse *= 2 - denominator * inverse; // inverse mod 2^32



```

### PermissionlessPool.sol


```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionlessPool.sol#1618-1698) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionlessPool.sol#1665)
	- inverse *= 2 - denominator * inverse (PermissionlessPool.sol#1684)



    
1665                 denominator := div(denominator, twos)



    
1684             inverse *= 2 - denominator * inverse; // inverse mod 2^8



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionlessPool.sol#1618-1698) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionlessPool.sol#1665)
	- inverse *= 2 - denominator * inverse (PermissionlessPool.sol#1685)



    
1665                 denominator := div(denominator, twos)



    
1685             inverse *= 2 - denominator * inverse; // inverse mod 2^16



```

```
Math.mulDiv(uint256,uint256,uint256) (PermissionlessPool.sol#892-972) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionlessPool.sol#939)
	- inverse *= 2 - denominator * inverse (PermissionlessPool.sol#962)



    
939                 denominator := div(denominator, twos)



    
962             inverse *= 2 - denominator * inverse; // inverse mod 2^128



```

```
PermissionlessPool.stakeUserETHToBeaconChain() (PermissionlessPool.sol#2469-2497) performs a multiplication on the result of a division:
	- requiredValidators = msg.value / (staderConfig.getFullDepositSize() - DEPOSIT_NODE_BOND) (PermissionlessPool.sol#2471)
	- IPermissionlessNodeRegistry(nodeRegistryAddress).transferCollateralToPool(requiredValidators * DEPOSIT_NODE_BOND) (PermissionlessPool.sol#2473-2475)



    
2471         uint256 requiredValidators = msg.value / (staderConfig.getFullDepositSize() - DEPOSIT_NODE_BOND);



    
2473         IPermissionlessNodeRegistry(nodeRegistryAddress).transferCollateralToPool(
2474             requiredValidators * DEPOSIT_NODE_BOND
2475         );



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionlessPool.sol#1618-1698) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionlessPool.sol#1665)
	- inverse *= 2 - denominator * inverse (PermissionlessPool.sol#1686)



    
1665                 denominator := div(denominator, twos)



    
1686             inverse *= 2 - denominator * inverse; // inverse mod 2^32



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionlessPool.sol#1618-1698) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionlessPool.sol#1665)
	- inverse *= 2 - denominator * inverse (PermissionlessPool.sol#1689)



    
1665                 denominator := div(denominator, twos)



    
1689             inverse *= 2 - denominator * inverse; // inverse mod 2^256



```

```
Math.mulDiv(uint256,uint256,uint256) (PermissionlessPool.sol#892-972) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionlessPool.sol#939)
	- inverse *= 2 - denominator * inverse (PermissionlessPool.sol#961)



    
939                 denominator := div(denominator, twos)



    
961             inverse *= 2 - denominator * inverse; // inverse mod 2^64



```

```
Math.mulDiv(uint256,uint256,uint256) (PermissionlessPool.sol#892-972) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionlessPool.sol#939)
	- inverse = (3 * denominator) ^ 2 (PermissionlessPool.sol#954)



    
939                 denominator := div(denominator, twos)



    
954             uint256 inverse = (3 * denominator) ^ 2;



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionlessPool.sol#1618-1698) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionlessPool.sol#1665)
	- inverse *= 2 - denominator * inverse (PermissionlessPool.sol#1687)



    
1665                 denominator := div(denominator, twos)



    
1687             inverse *= 2 - denominator * inverse; // inverse mod 2^64



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionlessPool.sol#1618-1698) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionlessPool.sol#1665)
	- inverse = (3 * denominator) ^ 2 (PermissionlessPool.sol#1680)



    
1665                 denominator := div(denominator, twos)



    
1680             uint256 inverse = (3 * denominator) ^ 2;



```

```
Math.mulDiv(uint256,uint256,uint256) (PermissionlessPool.sol#892-972) performs a multiplication on the result of a division:
	- prod0 = prod0 / twos (PermissionlessPool.sol#942)
	- result = prod0 * inverse (PermissionlessPool.sol#969)



    
942                 prod0 := div(prod0, twos)



    
969             result = prod0 * inverse;



```

```
Math.mulDiv(uint256,uint256,uint256) (PermissionlessPool.sol#892-972) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionlessPool.sol#939)
	- inverse *= 2 - denominator * inverse (PermissionlessPool.sol#958)



    
939                 denominator := div(denominator, twos)



    
958             inverse *= 2 - denominator * inverse; // inverse mod 2^8



```

```
Math.mulDiv(uint256,uint256,uint256) (PermissionlessPool.sol#892-972) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionlessPool.sol#939)
	- inverse *= 2 - denominator * inverse (PermissionlessPool.sol#963)



    
939                 denominator := div(denominator, twos)



    
963             inverse *= 2 - denominator * inverse; // inverse mod 2^256



```

```
Math.mulDiv(uint256,uint256,uint256) (PermissionlessPool.sol#892-972) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionlessPool.sol#939)
	- inverse *= 2 - denominator * inverse (PermissionlessPool.sol#959)



    
939                 denominator := div(denominator, twos)



    
959             inverse *= 2 - denominator * inverse; // inverse mod 2^16



```

```
Math.mulDiv(uint256,uint256,uint256) (PermissionlessPool.sol#892-972) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionlessPool.sol#939)
	- inverse *= 2 - denominator * inverse (PermissionlessPool.sol#960)



    
939                 denominator := div(denominator, twos)



    
960             inverse *= 2 - denominator * inverse; // inverse mod 2^32



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionlessPool.sol#1618-1698) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PermissionlessPool.sol#1665)
	- inverse *= 2 - denominator * inverse (PermissionlessPool.sol#1688)



    
1665                 denominator := div(denominator, twos)



    
1688             inverse *= 2 - denominator * inverse; // inverse mod 2^128



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionlessPool.sol#1618-1698) performs a multiplication on the result of a division:
	- prod0 = prod0 / twos (PermissionlessPool.sol#1668)
	- result = prod0 * inverse (PermissionlessPool.sol#1695)



    
1668                 prod0 := div(prod0, twos)



    
1695             result = prod0 * inverse;



```

### PoolSelector.sol


```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PoolSelector.sol#1626-1706) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PoolSelector.sol#1673)
	- inverse *= 2 - denominator * inverse (PoolSelector.sol#1693)



    
1673                 denominator := div(denominator, twos)



    
1693             inverse *= 2 - denominator * inverse; // inverse mod 2^16



```

```
Math.mulDiv(uint256,uint256,uint256) (PoolSelector.sol#675-755) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PoolSelector.sol#722)
	- inverse *= 2 - denominator * inverse (PoolSelector.sol#742)



    
722                 denominator := div(denominator, twos)



    
742             inverse *= 2 - denominator * inverse; // inverse mod 2^16



```

```
Math.mulDiv(uint256,uint256,uint256) (PoolSelector.sol#675-755) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PoolSelector.sol#722)
	- inverse *= 2 - denominator * inverse (PoolSelector.sol#741)



    
722                 denominator := div(denominator, twos)



    
741             inverse *= 2 - denominator * inverse; // inverse mod 2^8



```

```
Math.mulDiv(uint256,uint256,uint256) (PoolSelector.sol#675-755) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PoolSelector.sol#722)
	- inverse *= 2 - denominator * inverse (PoolSelector.sol#746)



    
722                 denominator := div(denominator, twos)



    
746             inverse *= 2 - denominator * inverse; // inverse mod 2^256



```

```
Math.mulDiv(uint256,uint256,uint256) (PoolSelector.sol#675-755) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PoolSelector.sol#722)
	- inverse = (3 * denominator) ^ 2 (PoolSelector.sol#737)



    
722                 denominator := div(denominator, twos)



    
737             uint256 inverse = (3 * denominator) ^ 2;



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PoolSelector.sol#1626-1706) performs a multiplication on the result of a division:
	- prod0 = prod0 / twos (PoolSelector.sol#1676)
	- result = prod0 * inverse (PoolSelector.sol#1703)



    
1676                 prod0 := div(prod0, twos)



    
1703             result = prod0 * inverse;



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PoolSelector.sol#1626-1706) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PoolSelector.sol#1673)
	- inverse *= 2 - denominator * inverse (PoolSelector.sol#1694)



    
1673                 denominator := div(denominator, twos)



    
1694             inverse *= 2 - denominator * inverse; // inverse mod 2^32



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PoolSelector.sol#1626-1706) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PoolSelector.sol#1673)
	- inverse *= 2 - denominator * inverse (PoolSelector.sol#1696)



    
1673                 denominator := div(denominator, twos)



    
1696             inverse *= 2 - denominator * inverse; // inverse mod 2^128



```

```
Math.mulDiv(uint256,uint256,uint256) (PoolSelector.sol#675-755) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PoolSelector.sol#722)
	- inverse *= 2 - denominator * inverse (PoolSelector.sol#744)



    
722                 denominator := div(denominator, twos)



    
744             inverse *= 2 - denominator * inverse; // inverse mod 2^64



```

```
Math.mulDiv(uint256,uint256,uint256) (PoolSelector.sol#675-755) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PoolSelector.sol#722)
	- inverse *= 2 - denominator * inverse (PoolSelector.sol#745)



    
722                 denominator := div(denominator, twos)



    
745             inverse *= 2 - denominator * inverse; // inverse mod 2^128



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PoolSelector.sol#1626-1706) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PoolSelector.sol#1673)
	- inverse *= 2 - denominator * inverse (PoolSelector.sol#1695)



    
1673                 denominator := div(denominator, twos)



    
1695             inverse *= 2 - denominator * inverse; // inverse mod 2^64



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PoolSelector.sol#1626-1706) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PoolSelector.sol#1673)
	- inverse *= 2 - denominator * inverse (PoolSelector.sol#1692)



    
1673                 denominator := div(denominator, twos)



    
1692             inverse *= 2 - denominator * inverse; // inverse mod 2^8



```

```
Math.mulDiv(uint256,uint256,uint256) (PoolSelector.sol#675-755) performs a multiplication on the result of a division:
	- prod0 = prod0 / twos (PoolSelector.sol#725)
	- result = prod0 * inverse (PoolSelector.sol#752)



    
725                 prod0 := div(prod0, twos)



    
752             result = prod0 * inverse;



```

```
Math.mulDiv(uint256,uint256,uint256) (PoolSelector.sol#675-755) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PoolSelector.sol#722)
	- inverse *= 2 - denominator * inverse (PoolSelector.sol#743)



    
722                 denominator := div(denominator, twos)



    
743             inverse *= 2 - denominator * inverse; // inverse mod 2^32



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PoolSelector.sol#1626-1706) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PoolSelector.sol#1673)
	- inverse *= 2 - denominator * inverse (PoolSelector.sol#1697)



    
1673                 denominator := div(denominator, twos)



    
1697             inverse *= 2 - denominator * inverse; // inverse mod 2^256



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PoolSelector.sol#1626-1706) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PoolSelector.sol#1673)
	- inverse = (3 * denominator) ^ 2 (PoolSelector.sol#1688)



    
1673                 denominator := div(denominator, twos)



    
1688             uint256 inverse = (3 * denominator) ^ 2;



```

### PoolUtils.sol


```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PoolUtils.sol#1203-1283) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PoolUtils.sol#1250)
	- inverse *= 2 - denominator * inverse (PoolUtils.sol#1270)



    
1250                 denominator := div(denominator, twos)



    
1270             inverse *= 2 - denominator * inverse; // inverse mod 2^16



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PoolUtils.sol#1203-1283) performs a multiplication on the result of a division:
	- prod0 = prod0 / twos (PoolUtils.sol#1253)
	- result = prod0 * inverse (PoolUtils.sol#1280)



    
1253                 prod0 := div(prod0, twos)



    
1280             result = prod0 * inverse;



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PoolUtils.sol#1203-1283) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PoolUtils.sol#1250)
	- inverse = (3 * denominator) ^ 2 (PoolUtils.sol#1265)



    
1250                 denominator := div(denominator, twos)



    
1265             uint256 inverse = (3 * denominator) ^ 2;



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PoolUtils.sol#1203-1283) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PoolUtils.sol#1250)
	- inverse *= 2 - denominator * inverse (PoolUtils.sol#1271)



    
1250                 denominator := div(denominator, twos)



    
1271             inverse *= 2 - denominator * inverse; // inverse mod 2^32



```

```
PoolUtils.calculateRewardShare(uint8,uint256) (PoolUtils.sol#2102-2126) performs a multiplication on the result of a division:
	- _userShareBeforeCommision = (_totalRewards * usersETH) / TOTAL_STAKED_ETH (PoolUtils.sol#2118)
	- operatorShare += (operatorFeeBps * _userShareBeforeCommision) / staderConfig.getTotalFee() (PoolUtils.sol#2123)



    
2118         uint256 _userShareBeforeCommision = (_totalRewards * usersETH) / TOTAL_STAKED_ETH;



    
2123         operatorShare += (operatorFeeBps * _userShareBeforeCommision) / staderConfig.getTotalFee();



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PoolUtils.sol#1203-1283) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PoolUtils.sol#1250)
	- inverse *= 2 - denominator * inverse (PoolUtils.sol#1269)



    
1250                 denominator := div(denominator, twos)



    
1269             inverse *= 2 - denominator * inverse; // inverse mod 2^8



```

```
PoolUtils.calculateRewardShare(uint8,uint256) (PoolUtils.sol#2102-2126) performs a multiplication on the result of a division:
	- _userShareBeforeCommision = (_totalRewards * usersETH) / TOTAL_STAKED_ETH (PoolUtils.sol#2118)
	- protocolShare = (protocolFeeBps * _userShareBeforeCommision) / staderConfig.getTotalFee() (PoolUtils.sol#2120)



    
2118         uint256 _userShareBeforeCommision = (_totalRewards * usersETH) / TOTAL_STAKED_ETH;



    
2120         protocolShare = (protocolFeeBps * _userShareBeforeCommision) / staderConfig.getTotalFee();



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PoolUtils.sol#1203-1283) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PoolUtils.sol#1250)
	- inverse *= 2 - denominator * inverse (PoolUtils.sol#1272)



    
1250                 denominator := div(denominator, twos)



    
1272             inverse *= 2 - denominator * inverse; // inverse mod 2^64



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PoolUtils.sol#1203-1283) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PoolUtils.sol#1250)
	- inverse *= 2 - denominator * inverse (PoolUtils.sol#1274)



    
1250                 denominator := div(denominator, twos)



    
1274             inverse *= 2 - denominator * inverse; // inverse mod 2^256



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PoolUtils.sol#1203-1283) performs a multiplication on the result of a division:
	- denominator = denominator / twos (PoolUtils.sol#1250)
	- inverse *= 2 - denominator * inverse (PoolUtils.sol#1273)



    
1250                 denominator := div(denominator, twos)



    
1273             inverse *= 2 - denominator * inverse; // inverse mod 2^128



```

### SDCollateral.sol


```
Math.mulDiv(uint256,uint256,uint256) (SDCollateral.sol#1175-1255) performs a multiplication on the result of a division:
	- denominator = denominator / twos (SDCollateral.sol#1222)
	- inverse *= 2 - denominator * inverse (SDCollateral.sol#1242)



    
1222                 denominator := div(denominator, twos)



    
1242             inverse *= 2 - denominator * inverse; // inverse mod 2^16



```

```
Math.mulDiv(uint256,uint256,uint256) (SDCollateral.sol#1175-1255) performs a multiplication on the result of a division:
	- denominator = denominator / twos (SDCollateral.sol#1222)
	- inverse *= 2 - denominator * inverse (SDCollateral.sol#1246)



    
1222                 denominator := div(denominator, twos)



    
1246             inverse *= 2 - denominator * inverse; // inverse mod 2^256



```

```
Math.mulDiv(uint256,uint256,uint256) (SDCollateral.sol#1175-1255) performs a multiplication on the result of a division:
	- denominator = denominator / twos (SDCollateral.sol#1222)
	- inverse *= 2 - denominator * inverse (SDCollateral.sol#1241)



    
1222                 denominator := div(denominator, twos)



    
1241             inverse *= 2 - denominator * inverse; // inverse mod 2^8



```

```
Math.mulDiv(uint256,uint256,uint256) (SDCollateral.sol#1175-1255) performs a multiplication on the result of a division:
	- denominator = denominator / twos (SDCollateral.sol#1222)
	- inverse = (3 * denominator) ^ 2 (SDCollateral.sol#1237)



    
1222                 denominator := div(denominator, twos)



    
1237             uint256 inverse = (3 * denominator) ^ 2;



```

```
Math.mulDiv(uint256,uint256,uint256) (SDCollateral.sol#1175-1255) performs a multiplication on the result of a division:
	- denominator = denominator / twos (SDCollateral.sol#1222)
	- inverse *= 2 - denominator * inverse (SDCollateral.sol#1243)



    
1222                 denominator := div(denominator, twos)



    
1243             inverse *= 2 - denominator * inverse; // inverse mod 2^32



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (SDCollateral.sol#1901-1981) performs a multiplication on the result of a division:
	- denominator = denominator / twos (SDCollateral.sol#1948)
	- inverse *= 2 - denominator * inverse (SDCollateral.sol#1971)



    
1948                 denominator := div(denominator, twos)



    
1971             inverse *= 2 - denominator * inverse; // inverse mod 2^128



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (SDCollateral.sol#1901-1981) performs a multiplication on the result of a division:
	- prod0 = prod0 / twos (SDCollateral.sol#1951)
	- result = prod0 * inverse (SDCollateral.sol#1978)



    
1951                 prod0 := div(prod0, twos)



    
1978             result = prod0 * inverse;



```

```
Math.mulDiv(uint256,uint256,uint256) (SDCollateral.sol#1175-1255) performs a multiplication on the result of a division:
	- denominator = denominator / twos (SDCollateral.sol#1222)
	- inverse *= 2 - denominator * inverse (SDCollateral.sol#1244)



    
1222                 denominator := div(denominator, twos)



    
1244             inverse *= 2 - denominator * inverse; // inverse mod 2^64



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (SDCollateral.sol#1901-1981) performs a multiplication on the result of a division:
	- denominator = denominator / twos (SDCollateral.sol#1948)
	- inverse = (3 * denominator) ^ 2 (SDCollateral.sol#1963)



    
1948                 denominator := div(denominator, twos)



    
1963             uint256 inverse = (3 * denominator) ^ 2;



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (SDCollateral.sol#1901-1981) performs a multiplication on the result of a division:
	- denominator = denominator / twos (SDCollateral.sol#1948)
	- inverse *= 2 - denominator * inverse (SDCollateral.sol#1970)



    
1948                 denominator := div(denominator, twos)



    
1970             inverse *= 2 - denominator * inverse; // inverse mod 2^64



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (SDCollateral.sol#1901-1981) performs a multiplication on the result of a division:
	- denominator = denominator / twos (SDCollateral.sol#1948)
	- inverse *= 2 - denominator * inverse (SDCollateral.sol#1972)



    
1948                 denominator := div(denominator, twos)



    
1972             inverse *= 2 - denominator * inverse; // inverse mod 2^256



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (SDCollateral.sol#1901-1981) performs a multiplication on the result of a division:
	- denominator = denominator / twos (SDCollateral.sol#1948)
	- inverse *= 2 - denominator * inverse (SDCollateral.sol#1968)



    
1948                 denominator := div(denominator, twos)



    
1968             inverse *= 2 - denominator * inverse; // inverse mod 2^16



```

```
Math.mulDiv(uint256,uint256,uint256) (SDCollateral.sol#1175-1255) performs a multiplication on the result of a division:
	- prod0 = prod0 / twos (SDCollateral.sol#1225)
	- result = prod0 * inverse (SDCollateral.sol#1252)



    
1225                 prod0 := div(prod0, twos)



    
1252             result = prod0 * inverse;



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (SDCollateral.sol#1901-1981) performs a multiplication on the result of a division:
	- denominator = denominator / twos (SDCollateral.sol#1948)
	- inverse *= 2 - denominator * inverse (SDCollateral.sol#1969)



    
1948                 denominator := div(denominator, twos)



    
1969             inverse *= 2 - denominator * inverse; // inverse mod 2^32



```

```
Math.mulDiv(uint256,uint256,uint256) (SDCollateral.sol#1175-1255) performs a multiplication on the result of a division:
	- denominator = denominator / twos (SDCollateral.sol#1222)
	- inverse *= 2 - denominator * inverse (SDCollateral.sol#1245)



    
1222                 denominator := div(denominator, twos)



    
1245             inverse *= 2 - denominator * inverse; // inverse mod 2^128



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (SDCollateral.sol#1901-1981) performs a multiplication on the result of a division:
	- denominator = denominator / twos (SDCollateral.sol#1948)
	- inverse *= 2 - denominator * inverse (SDCollateral.sol#1967)



    
1948                 denominator := div(denominator, twos)



    
1967             inverse *= 2 - denominator * inverse; // inverse mod 2^8



```

### SocializingPool.sol


```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (SocializingPool.sol#1382-1462) performs a multiplication on the result of a division:
	- denominator = denominator / twos (SocializingPool.sol#1429)
	- inverse *= 2 - denominator * inverse (SocializingPool.sol#1449)



    
1429                 denominator := div(denominator, twos)



    
1449             inverse *= 2 - denominator * inverse; // inverse mod 2^16



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (SocializingPool.sol#1382-1462) performs a multiplication on the result of a division:
	- prod0 = prod0 / twos (SocializingPool.sol#1432)
	- result = prod0 * inverse (SocializingPool.sol#1459)



    
1432                 prod0 := div(prod0, twos)



    
1459             result = prod0 * inverse;



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (SocializingPool.sol#1382-1462) performs a multiplication on the result of a division:
	- denominator = denominator / twos (SocializingPool.sol#1429)
	- inverse = (3 * denominator) ^ 2 (SocializingPool.sol#1444)



    
1429                 denominator := div(denominator, twos)



    
1444             uint256 inverse = (3 * denominator) ^ 2;



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (SocializingPool.sol#1382-1462) performs a multiplication on the result of a division:
	- denominator = denominator / twos (SocializingPool.sol#1429)
	- inverse *= 2 - denominator * inverse (SocializingPool.sol#1453)



    
1429                 denominator := div(denominator, twos)



    
1453             inverse *= 2 - denominator * inverse; // inverse mod 2^256



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (SocializingPool.sol#1382-1462) performs a multiplication on the result of a division:
	- denominator = denominator / twos (SocializingPool.sol#1429)
	- inverse *= 2 - denominator * inverse (SocializingPool.sol#1452)



    
1429                 denominator := div(denominator, twos)



    
1452             inverse *= 2 - denominator * inverse; // inverse mod 2^128



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (SocializingPool.sol#1382-1462) performs a multiplication on the result of a division:
	- denominator = denominator / twos (SocializingPool.sol#1429)
	- inverse *= 2 - denominator * inverse (SocializingPool.sol#1448)



    
1429                 denominator := div(denominator, twos)



    
1448             inverse *= 2 - denominator * inverse; // inverse mod 2^8



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (SocializingPool.sol#1382-1462) performs a multiplication on the result of a division:
	- denominator = denominator / twos (SocializingPool.sol#1429)
	- inverse *= 2 - denominator * inverse (SocializingPool.sol#1450)



    
1429                 denominator := div(denominator, twos)



    
1450             inverse *= 2 - denominator * inverse; // inverse mod 2^32



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (SocializingPool.sol#1382-1462) performs a multiplication on the result of a division:
	- denominator = denominator / twos (SocializingPool.sol#1429)
	- inverse *= 2 - denominator * inverse (SocializingPool.sol#1451)



    
1429                 denominator := div(denominator, twos)



    
1451             inverse *= 2 - denominator * inverse; // inverse mod 2^64



```

### StaderConfig.sol


```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderConfig.sol#1155-1235) performs a multiplication on the result of a division:
	- prod0 = prod0 / twos (StaderConfig.sol#1205)
	- result = prod0 * inverse (StaderConfig.sol#1232)



    
1205                 prod0 := div(prod0, twos)



    
1232             result = prod0 * inverse;



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderConfig.sol#1155-1235) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderConfig.sol#1202)
	- inverse = (3 * denominator) ^ 2 (StaderConfig.sol#1217)



    
1202                 denominator := div(denominator, twos)



    
1217             uint256 inverse = (3 * denominator) ^ 2;



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderConfig.sol#1155-1235) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderConfig.sol#1202)
	- inverse *= 2 - denominator * inverse (StaderConfig.sol#1223)



    
1202                 denominator := div(denominator, twos)



    
1223             inverse *= 2 - denominator * inverse; // inverse mod 2^32



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderConfig.sol#1155-1235) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderConfig.sol#1202)
	- inverse *= 2 - denominator * inverse (StaderConfig.sol#1226)



    
1202                 denominator := div(denominator, twos)



    
1226             inverse *= 2 - denominator * inverse; // inverse mod 2^256



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderConfig.sol#1155-1235) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderConfig.sol#1202)
	- inverse *= 2 - denominator * inverse (StaderConfig.sol#1224)



    
1202                 denominator := div(denominator, twos)



    
1224             inverse *= 2 - denominator * inverse; // inverse mod 2^64



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderConfig.sol#1155-1235) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderConfig.sol#1202)
	- inverse *= 2 - denominator * inverse (StaderConfig.sol#1225)



    
1202                 denominator := div(denominator, twos)



    
1225             inverse *= 2 - denominator * inverse; // inverse mod 2^128



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderConfig.sol#1155-1235) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderConfig.sol#1202)
	- inverse *= 2 - denominator * inverse (StaderConfig.sol#1221)



    
1202                 denominator := div(denominator, twos)



    
1221             inverse *= 2 - denominator * inverse; // inverse mod 2^8



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderConfig.sol#1155-1235) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderConfig.sol#1202)
	- inverse *= 2 - denominator * inverse (StaderConfig.sol#1222)



    
1202                 denominator := div(denominator, twos)



    
1222             inverse *= 2 - denominator * inverse; // inverse mod 2^16



```

### StaderInsuranceFund.sol


```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderInsuranceFund.sol#1181-1261) performs a multiplication on the result of a division:
	- prod0 = prod0 / twos (StaderInsuranceFund.sol#1231)
	- result = prod0 * inverse (StaderInsuranceFund.sol#1258)



    
1231                 prod0 := div(prod0, twos)



    
1258             result = prod0 * inverse;



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderInsuranceFund.sol#1181-1261) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderInsuranceFund.sol#1228)
	- inverse *= 2 - denominator * inverse (StaderInsuranceFund.sol#1251)



    
1228                 denominator := div(denominator, twos)



    
1251             inverse *= 2 - denominator * inverse; // inverse mod 2^128



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderInsuranceFund.sol#1181-1261) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderInsuranceFund.sol#1228)
	- inverse *= 2 - denominator * inverse (StaderInsuranceFund.sol#1252)



    
1228                 denominator := div(denominator, twos)



    
1252             inverse *= 2 - denominator * inverse; // inverse mod 2^256



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderInsuranceFund.sol#1181-1261) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderInsuranceFund.sol#1228)
	- inverse *= 2 - denominator * inverse (StaderInsuranceFund.sol#1247)



    
1228                 denominator := div(denominator, twos)



    
1247             inverse *= 2 - denominator * inverse; // inverse mod 2^8



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderInsuranceFund.sol#1181-1261) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderInsuranceFund.sol#1228)
	- inverse *= 2 - denominator * inverse (StaderInsuranceFund.sol#1249)



    
1228                 denominator := div(denominator, twos)



    
1249             inverse *= 2 - denominator * inverse; // inverse mod 2^32



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderInsuranceFund.sol#1181-1261) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderInsuranceFund.sol#1228)
	- inverse *= 2 - denominator * inverse (StaderInsuranceFund.sol#1250)



    
1228                 denominator := div(denominator, twos)



    
1250             inverse *= 2 - denominator * inverse; // inverse mod 2^64



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderInsuranceFund.sol#1181-1261) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderInsuranceFund.sol#1228)
	- inverse = (3 * denominator) ^ 2 (StaderInsuranceFund.sol#1243)



    
1228                 denominator := div(denominator, twos)



    
1243             uint256 inverse = (3 * denominator) ^ 2;



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderInsuranceFund.sol#1181-1261) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderInsuranceFund.sol#1228)
	- inverse *= 2 - denominator * inverse (StaderInsuranceFund.sol#1248)



    
1228                 denominator := div(denominator, twos)



    
1248             inverse *= 2 - denominator * inverse; // inverse mod 2^16



```

### StaderOracle.sol


```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderOracle.sol#1730-1810) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderOracle.sol#1777)
	- inverse *= 2 - denominator * inverse (StaderOracle.sol#1801)



    
1777                 denominator := div(denominator, twos)



    
1801             inverse *= 2 - denominator * inverse; // inverse mod 2^256



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderOracle.sol#1730-1810) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderOracle.sol#1777)
	- inverse *= 2 - denominator * inverse (StaderOracle.sol#1799)



    
1777                 denominator := div(denominator, twos)



    
1799             inverse *= 2 - denominator * inverse; // inverse mod 2^64



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderOracle.sol#1730-1810) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderOracle.sol#1777)
	- inverse *= 2 - denominator * inverse (StaderOracle.sol#1800)



    
1777                 denominator := div(denominator, twos)



    
1800             inverse *= 2 - denominator * inverse; // inverse mod 2^128



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderOracle.sol#1730-1810) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderOracle.sol#1777)
	- inverse *= 2 - denominator * inverse (StaderOracle.sol#1796)



    
1777                 denominator := div(denominator, twos)



    
1796             inverse *= 2 - denominator * inverse; // inverse mod 2^8



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderOracle.sol#1730-1810) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderOracle.sol#1777)
	- inverse = (3 * denominator) ^ 2 (StaderOracle.sol#1792)



    
1777                 denominator := div(denominator, twos)



    
1792             uint256 inverse = (3 * denominator) ^ 2;



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderOracle.sol#1730-1810) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderOracle.sol#1777)
	- inverse *= 2 - denominator * inverse (StaderOracle.sol#1797)



    
1777                 denominator := div(denominator, twos)



    
1797             inverse *= 2 - denominator * inverse; // inverse mod 2^16



```

```
StaderOracle.getReportableBlockFor(bytes32) (StaderOracle.sol#3055-3061) performs a multiplication on the result of a division:
	- (block.number / updateFrequency) * updateFrequency (StaderOracle.sol#3060)



    
3060         return (block.number / updateFrequency) * updateFrequency;



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderOracle.sol#1730-1810) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderOracle.sol#1777)
	- inverse *= 2 - denominator * inverse (StaderOracle.sol#1798)



    
1777                 denominator := div(denominator, twos)



    
1798             inverse *= 2 - denominator * inverse; // inverse mod 2^32



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderOracle.sol#1730-1810) performs a multiplication on the result of a division:
	- prod0 = prod0 / twos (StaderOracle.sol#1780)
	- result = prod0 * inverse (StaderOracle.sol#1807)



    
1780                 prod0 := div(prod0, twos)



    
1807             result = prod0 * inverse;



```

### StaderStakePoolsManager.sol


```
Math.mulDiv(uint256,uint256,uint256) (StaderStakePoolsManager.sol#3136-3216) performs a multiplication on the result of a division:
	- prod0 = prod0 / twos (StaderStakePoolsManager.sol#3186)
	- result = prod0 * inverse (StaderStakePoolsManager.sol#3213)



    
3186                 prod0 := div(prod0, twos)



    
3213             result = prod0 * inverse;



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderStakePoolsManager.sol#1654-1734) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderStakePoolsManager.sol#1701)
	- inverse *= 2 - denominator * inverse (StaderStakePoolsManager.sol#1723)



    
1701                 denominator := div(denominator, twos)



    
1723             inverse *= 2 - denominator * inverse; // inverse mod 2^64



```

```
Math.mulDiv(uint256,uint256,uint256) (StaderStakePoolsManager.sol#3136-3216) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderStakePoolsManager.sol#3183)
	- inverse *= 2 - denominator * inverse (StaderStakePoolsManager.sol#3202)



    
3183                 denominator := div(denominator, twos)



    
3202             inverse *= 2 - denominator * inverse; // inverse mod 2^8



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderStakePoolsManager.sol#1654-1734) performs a multiplication on the result of a division:
	- prod0 = prod0 / twos (StaderStakePoolsManager.sol#1704)
	- result = prod0 * inverse (StaderStakePoolsManager.sol#1731)



    
1704                 prod0 := div(prod0, twos)



    
1731             result = prod0 * inverse;



```

```
Math.mulDiv(uint256,uint256,uint256) (StaderStakePoolsManager.sol#3136-3216) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderStakePoolsManager.sol#3183)
	- inverse *= 2 - denominator * inverse (StaderStakePoolsManager.sol#3203)



    
3183                 denominator := div(denominator, twos)



    
3203             inverse *= 2 - denominator * inverse; // inverse mod 2^16



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderStakePoolsManager.sol#1654-1734) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderStakePoolsManager.sol#1701)
	- inverse *= 2 - denominator * inverse (StaderStakePoolsManager.sol#1720)



    
1701                 denominator := div(denominator, twos)



    
1720             inverse *= 2 - denominator * inverse; // inverse mod 2^8



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderStakePoolsManager.sol#1654-1734) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderStakePoolsManager.sol#1701)
	- inverse *= 2 - denominator * inverse (StaderStakePoolsManager.sol#1721)



    
1701                 denominator := div(denominator, twos)



    
1721             inverse *= 2 - denominator * inverse; // inverse mod 2^16



```

```
Math.mulDiv(uint256,uint256,uint256) (StaderStakePoolsManager.sol#3136-3216) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderStakePoolsManager.sol#3183)
	- inverse *= 2 - denominator * inverse (StaderStakePoolsManager.sol#3207)



    
3183                 denominator := div(denominator, twos)



    
3207             inverse *= 2 - denominator * inverse; // inverse mod 2^256



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderStakePoolsManager.sol#1654-1734) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderStakePoolsManager.sol#1701)
	- inverse *= 2 - denominator * inverse (StaderStakePoolsManager.sol#1722)



    
1701                 denominator := div(denominator, twos)



    
1722             inverse *= 2 - denominator * inverse; // inverse mod 2^32



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderStakePoolsManager.sol#1654-1734) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderStakePoolsManager.sol#1701)
	- inverse *= 2 - denominator * inverse (StaderStakePoolsManager.sol#1724)



    
1701                 denominator := div(denominator, twos)



    
1724             inverse *= 2 - denominator * inverse; // inverse mod 2^128



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderStakePoolsManager.sol#1654-1734) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderStakePoolsManager.sol#1701)
	- inverse = (3 * denominator) ^ 2 (StaderStakePoolsManager.sol#1716)



    
1701                 denominator := div(denominator, twos)



    
1716             uint256 inverse = (3 * denominator) ^ 2;



```

```
Math.mulDiv(uint256,uint256,uint256) (StaderStakePoolsManager.sol#3136-3216) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderStakePoolsManager.sol#3183)
	- inverse = (3 * denominator) ^ 2 (StaderStakePoolsManager.sol#3198)



    
3183                 denominator := div(denominator, twos)



    
3198             uint256 inverse = (3 * denominator) ^ 2;



```

```
Math.mulDiv(uint256,uint256,uint256) (StaderStakePoolsManager.sol#3136-3216) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderStakePoolsManager.sol#3183)
	- inverse *= 2 - denominator * inverse (StaderStakePoolsManager.sol#3206)



    
3183                 denominator := div(denominator, twos)



    
3206             inverse *= 2 - denominator * inverse; // inverse mod 2^128



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderStakePoolsManager.sol#1654-1734) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderStakePoolsManager.sol#1701)
	- inverse *= 2 - denominator * inverse (StaderStakePoolsManager.sol#1725)



    
1701                 denominator := div(denominator, twos)



    
1725             inverse *= 2 - denominator * inverse; // inverse mod 2^256



```

```
Math.mulDiv(uint256,uint256,uint256) (StaderStakePoolsManager.sol#3136-3216) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderStakePoolsManager.sol#3183)
	- inverse *= 2 - denominator * inverse (StaderStakePoolsManager.sol#3205)



    
3183                 denominator := div(denominator, twos)



    
3205             inverse *= 2 - denominator * inverse; // inverse mod 2^64



```

```
Math.mulDiv(uint256,uint256,uint256) (StaderStakePoolsManager.sol#3136-3216) performs a multiplication on the result of a division:
	- denominator = denominator / twos (StaderStakePoolsManager.sol#3183)
	- inverse *= 2 - denominator * inverse (StaderStakePoolsManager.sol#3204)



    
3183                 denominator := div(denominator, twos)



    
3204             inverse *= 2 - denominator * inverse; // inverse mod 2^32



```

### UserWithdrawalManager.sol


```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (UserWithdrawalManager.sol#1653-1733) performs a multiplication on the result of a division:
	- denominator = denominator / twos (UserWithdrawalManager.sol#1700)
	- inverse *= 2 - denominator * inverse (UserWithdrawalManager.sol#1724)



    
1700                 denominator := div(denominator, twos)



    
1724             inverse *= 2 - denominator * inverse; // inverse mod 2^256



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (UserWithdrawalManager.sol#1653-1733) performs a multiplication on the result of a division:
	- denominator = denominator / twos (UserWithdrawalManager.sol#1700)
	- inverse *= 2 - denominator * inverse (UserWithdrawalManager.sol#1719)



    
1700                 denominator := div(denominator, twos)



    
1719             inverse *= 2 - denominator * inverse; // inverse mod 2^8



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (UserWithdrawalManager.sol#1653-1733) performs a multiplication on the result of a division:
	- denominator = denominator / twos (UserWithdrawalManager.sol#1700)
	- inverse *= 2 - denominator * inverse (UserWithdrawalManager.sol#1723)



    
1700                 denominator := div(denominator, twos)



    
1723             inverse *= 2 - denominator * inverse; // inverse mod 2^128



```

```
Math.mulDiv(uint256,uint256,uint256) (UserWithdrawalManager.sol#3065-3145) performs a multiplication on the result of a division:
	- prod0 = prod0 / twos (UserWithdrawalManager.sol#3115)
	- result = prod0 * inverse (UserWithdrawalManager.sol#3142)



    
3115                 prod0 := div(prod0, twos)



    
3142             result = prod0 * inverse;



```

```
Math.mulDiv(uint256,uint256,uint256) (UserWithdrawalManager.sol#3065-3145) performs a multiplication on the result of a division:
	- denominator = denominator / twos (UserWithdrawalManager.sol#3112)
	- inverse *= 2 - denominator * inverse (UserWithdrawalManager.sol#3132)



    
3112                 denominator := div(denominator, twos)



    
3132             inverse *= 2 - denominator * inverse; // inverse mod 2^16



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (UserWithdrawalManager.sol#1653-1733) performs a multiplication on the result of a division:
	- denominator = denominator / twos (UserWithdrawalManager.sol#1700)
	- inverse *= 2 - denominator * inverse (UserWithdrawalManager.sol#1722)



    
1700                 denominator := div(denominator, twos)



    
1722             inverse *= 2 - denominator * inverse; // inverse mod 2^64



```

```
Math.mulDiv(uint256,uint256,uint256) (UserWithdrawalManager.sol#3065-3145) performs a multiplication on the result of a division:
	- denominator = denominator / twos (UserWithdrawalManager.sol#3112)
	- inverse *= 2 - denominator * inverse (UserWithdrawalManager.sol#3133)



    
3112                 denominator := div(denominator, twos)



    
3133             inverse *= 2 - denominator * inverse; // inverse mod 2^32



```

```
Math.mulDiv(uint256,uint256,uint256) (UserWithdrawalManager.sol#3065-3145) performs a multiplication on the result of a division:
	- denominator = denominator / twos (UserWithdrawalManager.sol#3112)
	- inverse *= 2 - denominator * inverse (UserWithdrawalManager.sol#3135)



    
3112                 denominator := div(denominator, twos)



    
3135             inverse *= 2 - denominator * inverse; // inverse mod 2^128



```

```
Math.mulDiv(uint256,uint256,uint256) (UserWithdrawalManager.sol#3065-3145) performs a multiplication on the result of a division:
	- denominator = denominator / twos (UserWithdrawalManager.sol#3112)
	- inverse = (3 * denominator) ^ 2 (UserWithdrawalManager.sol#3127)



    
3112                 denominator := div(denominator, twos)



    
3127             uint256 inverse = (3 * denominator) ^ 2;



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (UserWithdrawalManager.sol#1653-1733) performs a multiplication on the result of a division:
	- denominator = denominator / twos (UserWithdrawalManager.sol#1700)
	- inverse *= 2 - denominator * inverse (UserWithdrawalManager.sol#1721)



    
1700                 denominator := div(denominator, twos)



    
1721             inverse *= 2 - denominator * inverse; // inverse mod 2^32



```

```
Math.mulDiv(uint256,uint256,uint256) (UserWithdrawalManager.sol#3065-3145) performs a multiplication on the result of a division:
	- denominator = denominator / twos (UserWithdrawalManager.sol#3112)
	- inverse *= 2 - denominator * inverse (UserWithdrawalManager.sol#3136)



    
3112                 denominator := div(denominator, twos)



    
3136             inverse *= 2 - denominator * inverse; // inverse mod 2^256



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (UserWithdrawalManager.sol#1653-1733) performs a multiplication on the result of a division:
	- denominator = denominator / twos (UserWithdrawalManager.sol#1700)
	- inverse *= 2 - denominator * inverse (UserWithdrawalManager.sol#1720)



    
1700                 denominator := div(denominator, twos)



    
1720             inverse *= 2 - denominator * inverse; // inverse mod 2^16



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (UserWithdrawalManager.sol#1653-1733) performs a multiplication on the result of a division:
	- denominator = denominator / twos (UserWithdrawalManager.sol#1700)
	- inverse = (3 * denominator) ^ 2 (UserWithdrawalManager.sol#1715)



    
1700                 denominator := div(denominator, twos)



    
1715             uint256 inverse = (3 * denominator) ^ 2;



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (UserWithdrawalManager.sol#1653-1733) performs a multiplication on the result of a division:
	- prod0 = prod0 / twos (UserWithdrawalManager.sol#1703)
	- result = prod0 * inverse (UserWithdrawalManager.sol#1730)



    
1703                 prod0 := div(prod0, twos)



    
1730             result = prod0 * inverse;



```

```
Math.mulDiv(uint256,uint256,uint256) (UserWithdrawalManager.sol#3065-3145) performs a multiplication on the result of a division:
	- denominator = denominator / twos (UserWithdrawalManager.sol#3112)
	- inverse *= 2 - denominator * inverse (UserWithdrawalManager.sol#3131)



    
3112                 denominator := div(denominator, twos)



    
3131             inverse *= 2 - denominator * inverse; // inverse mod 2^8



```

```
Math.mulDiv(uint256,uint256,uint256) (UserWithdrawalManager.sol#3065-3145) performs a multiplication on the result of a division:
	- denominator = denominator / twos (UserWithdrawalManager.sol#3112)
	- inverse *= 2 - denominator * inverse (UserWithdrawalManager.sol#3134)



    
3112                 denominator := div(denominator, twos)



    
3134             inverse *= 2 - denominator * inverse; // inverse mod 2^64



```

### ValidatorWithdrawalVault.sol


```
Math.mulDiv(uint256,uint256,uint256) (ValidatorWithdrawalVault.sol#996-1076) performs a multiplication on the result of a division:
	- denominator = denominator / twos (ValidatorWithdrawalVault.sol#1043)
	- inverse *= 2 - denominator * inverse (ValidatorWithdrawalVault.sol#1062)



    
1043                 denominator := div(denominator, twos)



    
1062             inverse *= 2 - denominator * inverse; // inverse mod 2^8



```

```
Math.mulDiv(uint256,uint256,uint256) (ValidatorWithdrawalVault.sol#996-1076) performs a multiplication on the result of a division:
	- denominator = denominator / twos (ValidatorWithdrawalVault.sol#1043)
	- inverse = (3 * denominator) ^ 2 (ValidatorWithdrawalVault.sol#1058)



    
1043                 denominator := div(denominator, twos)



    
1058             uint256 inverse = (3 * denominator) ^ 2;



```

```
Math.mulDiv(uint256,uint256,uint256) (ValidatorWithdrawalVault.sol#996-1076) performs a multiplication on the result of a division:
	- denominator = denominator / twos (ValidatorWithdrawalVault.sol#1043)
	- inverse *= 2 - denominator * inverse (ValidatorWithdrawalVault.sol#1066)



    
1043                 denominator := div(denominator, twos)



    
1066             inverse *= 2 - denominator * inverse; // inverse mod 2^128



```

```
Math.mulDiv(uint256,uint256,uint256) (ValidatorWithdrawalVault.sol#996-1076) performs a multiplication on the result of a division:
	- denominator = denominator / twos (ValidatorWithdrawalVault.sol#1043)
	- inverse *= 2 - denominator * inverse (ValidatorWithdrawalVault.sol#1063)



    
1043                 denominator := div(denominator, twos)



    
1063             inverse *= 2 - denominator * inverse; // inverse mod 2^16



```

```
Math.mulDiv(uint256,uint256,uint256) (ValidatorWithdrawalVault.sol#996-1076) performs a multiplication on the result of a division:
	- prod0 = prod0 / twos (ValidatorWithdrawalVault.sol#1046)
	- result = prod0 * inverse (ValidatorWithdrawalVault.sol#1073)



    
1046                 prod0 := div(prod0, twos)



    
1073             result = prod0 * inverse;



```

```
Math.mulDiv(uint256,uint256,uint256) (ValidatorWithdrawalVault.sol#996-1076) performs a multiplication on the result of a division:
	- denominator = denominator / twos (ValidatorWithdrawalVault.sol#1043)
	- inverse *= 2 - denominator * inverse (ValidatorWithdrawalVault.sol#1064)



    
1043                 denominator := div(denominator, twos)



    
1064             inverse *= 2 - denominator * inverse; // inverse mod 2^32



```

```
Math.mulDiv(uint256,uint256,uint256) (ValidatorWithdrawalVault.sol#996-1076) performs a multiplication on the result of a division:
	- denominator = denominator / twos (ValidatorWithdrawalVault.sol#1043)
	- inverse *= 2 - denominator * inverse (ValidatorWithdrawalVault.sol#1067)



    
1043                 denominator := div(denominator, twos)



    
1067             inverse *= 2 - denominator * inverse; // inverse mod 2^256



```

```
Math.mulDiv(uint256,uint256,uint256) (ValidatorWithdrawalVault.sol#996-1076) performs a multiplication on the result of a division:
	- denominator = denominator / twos (ValidatorWithdrawalVault.sol#1043)
	- inverse *= 2 - denominator * inverse (ValidatorWithdrawalVault.sol#1065)



    
1043                 denominator := div(denominator, twos)



    
1065             inverse *= 2 - denominator * inverse; // inverse mod 2^64



```

### VaultFactory.sol


```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (VaultFactory.sol#1350-1430) performs a multiplication on the result of a division:
	- denominator = denominator / twos (VaultFactory.sol#1397)
	- inverse = (3 * denominator) ^ 2 (VaultFactory.sol#1412)



    
1397                 denominator := div(denominator, twos)



    
1412             uint256 inverse = (3 * denominator) ^ 2;



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (VaultFactory.sol#1350-1430) performs a multiplication on the result of a division:
	- prod0 = prod0 / twos (VaultFactory.sol#1400)
	- result = prod0 * inverse (VaultFactory.sol#1427)



    
1400                 prod0 := div(prod0, twos)



    
1427             result = prod0 * inverse;



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (VaultFactory.sol#1350-1430) performs a multiplication on the result of a division:
	- denominator = denominator / twos (VaultFactory.sol#1397)
	- inverse *= 2 - denominator * inverse (VaultFactory.sol#1421)



    
1397                 denominator := div(denominator, twos)



    
1421             inverse *= 2 - denominator * inverse; // inverse mod 2^256



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (VaultFactory.sol#1350-1430) performs a multiplication on the result of a division:
	- denominator = denominator / twos (VaultFactory.sol#1397)
	- inverse *= 2 - denominator * inverse (VaultFactory.sol#1419)



    
1397                 denominator := div(denominator, twos)



    
1419             inverse *= 2 - denominator * inverse; // inverse mod 2^64



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (VaultFactory.sol#1350-1430) performs a multiplication on the result of a division:
	- denominator = denominator / twos (VaultFactory.sol#1397)
	- inverse *= 2 - denominator * inverse (VaultFactory.sol#1416)



    
1397                 denominator := div(denominator, twos)



    
1416             inverse *= 2 - denominator * inverse; // inverse mod 2^8



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (VaultFactory.sol#1350-1430) performs a multiplication on the result of a division:
	- denominator = denominator / twos (VaultFactory.sol#1397)
	- inverse *= 2 - denominator * inverse (VaultFactory.sol#1418)



    
1397                 denominator := div(denominator, twos)



    
1418             inverse *= 2 - denominator * inverse; // inverse mod 2^32



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (VaultFactory.sol#1350-1430) performs a multiplication on the result of a division:
	- denominator = denominator / twos (VaultFactory.sol#1397)
	- inverse *= 2 - denominator * inverse (VaultFactory.sol#1417)



    
1397                 denominator := div(denominator, twos)



    
1417             inverse *= 2 - denominator * inverse; // inverse mod 2^16



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (VaultFactory.sol#1350-1430) performs a multiplication on the result of a division:
	- denominator = denominator / twos (VaultFactory.sol#1397)
	- inverse *= 2 - denominator * inverse (VaultFactory.sol#1420)



    
1397                 denominator := div(denominator, twos)



    
1420             inverse *= 2 - denominator * inverse; // inverse mod 2^128



```

## reentrancy-no-eth
### Severity: Medium

### Auction.sol


```
Reentrancy in Auction.createLot(uint256) (Auction.sol#2250-2262):
	External calls:
	- ! IERC20(staderConfig.getStaderToken()).transferFrom(msg.sender,address(this),_sdAmount) (Auction.sol#2257)
	State variables written after the call(s):
	- nextLot ++ (Auction.sol#2261)
	Auction.nextLot (Auction.sol#2218) can be used in cross function reentrancies:
	- Auction.createLot(uint256) (Auction.sol#2250-2262)
	- Auction.initialize(address,address) (Auction.sol#2231-2248)
	- Auction.nextLot (Auction.sol#2218)



    
2257         if (!IERC20(staderConfig.getStaderToken()).transferFrom(msg.sender, address(this), _sdAmount)) {



    
2261         nextLot++;



```

### PermissionedNodeRegistry.sol


```
Reentrancy in PermissionedNodeRegistry.addValidatorKeys(bytes[],bytes[],bytes[]) (PermissionedNodeRegistry.sol#2570-2611):
	External calls:
	- IPoolUtils(poolUtils).onlyValidKeys(_pubkey[i],_preDepositSignature[i],_depositSignature[i]) (PermissionedNodeRegistry.sol#2586)
	- withdrawVault = IVaultFactory(vaultFactory).deployWithdrawVault(POOL_ID,operatorId,operatorTotalKeys + i,nextValidatorId) (PermissionedNodeRegistry.sol#2587-2592)
	State variables written after the call(s):
	- nextValidatorId ++ (PermissionedNodeRegistry.sol#2606)
	PermissionedNodeRegistry.nextValidatorId (PermissionedNodeRegistry.sol#2468) can be used in cross function reentrancies:
	- PermissionedNodeRegistry.addValidatorKeys(bytes[],bytes[],bytes[]) (PermissionedNodeRegistry.sol#2570-2611)
	- PermissionedNodeRegistry.getAllActiveValidators(uint256,uint256) (PermissionedNodeRegistry.sol#3012-3038)
	- PermissionedNodeRegistry.initialize(address,address) (PermissionedNodeRegistry.sol#2497-2512)
	- PermissionedNodeRegistry.nextValidatorId (PermissionedNodeRegistry.sol#2468)
	- validatorIdsByOperatorId[operatorId].push(nextValidatorId) (PermissionedNodeRegistry.sol#2604)
	PermissionedNodeRegistry.validatorIdsByOperatorId (PermissionedNodeRegistry.sol#2487) can be used in cross function reentrancies:
	- PermissionedNodeRegistry.addValidatorKeys(bytes[],bytes[],bytes[]) (PermissionedNodeRegistry.sol#2570-2611)
	- PermissionedNodeRegistry.getOperatorQueuedValidatorCount(uint256) (PermissionedNodeRegistry.sol#3108-3112)
	- PermissionedNodeRegistry.getOperatorTotalKeys(uint256) (PermissionedNodeRegistry.sol#2943-2945)
	- PermissionedNodeRegistry.getOperatorTotalNonTerminalKeys(address,uint256,uint256) (PermissionedNodeRegistry.sol#2952-2974)
	- PermissionedNodeRegistry.getValidatorsByOperator(address,uint256,uint256) (PermissionedNodeRegistry.sol#3048-3071)
	- PermissionedNodeRegistry.validatorIdsByOperatorId (PermissionedNodeRegistry.sol#2487)
	- validatorRegistry[nextValidatorId] = Validator(ValidatorStatus.INITIALIZED,_pubkey[i],_preDepositSignature[i],_depositSignature[i],withdrawVault,operatorId,0,0) (PermissionedNodeRegistry.sol#2593-2602)
	PermissionedNodeRegistry.validatorRegistry (PermissionedNodeRegistry.sol#2477) can be used in cross function reentrancies:
	- PermissionedNodeRegistry.addValidatorKeys(bytes[],bytes[],bytes[]) (PermissionedNodeRegistry.sol#2570-2611)
	- PermissionedNodeRegistry.getAllActiveValidators(uint256,uint256) (PermissionedNodeRegistry.sol#3012-3038)
	- PermissionedNodeRegistry.getValidatorsByOperator(address,uint256,uint256) (PermissionedNodeRegistry.sol#3048-3071)
	- PermissionedNodeRegistry.isActiveValidator(uint256) (PermissionedNodeRegistry.sol#3160-3163)
	- PermissionedNodeRegistry.isNonTerminalValidator(uint256) (PermissionedNodeRegistry.sol#3166-3172)
	- PermissionedNodeRegistry.markValidatorDeposited(uint256) (PermissionedNodeRegistry.sol#3186-3188)
	- PermissionedNodeRegistry.markValidatorStatusAsPreDeposit(bytes) (PermissionedNodeRegistry.sol#2818-2823)
	- PermissionedNodeRegistry.onlyPreDepositValidator(uint256) (PermissionedNodeRegistry.sol#3180-3184)
	- PermissionedNodeRegistry.updateDepositStatusAndBlock(uint256) (PermissionedNodeRegistry.sol#2806-2811)
	- PermissionedNodeRegistry.validatorRegistry (PermissionedNodeRegistry.sol#2477)
	- PermissionedNodeRegistry.withdrawnValidators(bytes[]) (PermissionedNodeRegistry.sol#2741-2761)



    
2586             IPoolUtils(poolUtils).onlyValidKeys(_pubkey[i], _preDepositSignature[i], _depositSignature[i]);



    
2587             address withdrawVault = IVaultFactory(vaultFactory).deployWithdrawVault(
2588                 POOL_ID,
2589                 operatorId,
2590                 operatorTotalKeys + i, //operator totalKeys
2591                 nextValidatorId
2592             );



    
2606             nextValidatorId++;



    
2604             validatorIdsByOperatorId[operatorId].push(nextValidatorId);



    
2593             validatorRegistry[nextValidatorId] = Validator(
2594                 ValidatorStatus.INITIALIZED,
2595                 _pubkey[i],
2596                 _preDepositSignature[i],
2597                 _depositSignature[i],
2598                 withdrawVault,
2599                 operatorId,
2600                 0,
2601                 0
2602             );



```

```
Reentrancy in PermissionedNodeRegistry.withdrawnValidators(bytes[]) (PermissionedNodeRegistry.sol#2741-2761):
	External calls:
	- IValidatorWithdrawalVault(validatorRegistry[validatorId].withdrawVaultAddress).settleFunds() (PermissionedNodeRegistry.sol#2754)
	State variables written after the call(s):
	- validatorRegistry[validatorId].status = ValidatorStatus.WITHDRAWN (PermissionedNodeRegistry.sol#2752)
	PermissionedNodeRegistry.validatorRegistry (PermissionedNodeRegistry.sol#2477) can be used in cross function reentrancies:
	- PermissionedNodeRegistry.addValidatorKeys(bytes[],bytes[],bytes[]) (PermissionedNodeRegistry.sol#2570-2611)
	- PermissionedNodeRegistry.getAllActiveValidators(uint256,uint256) (PermissionedNodeRegistry.sol#3012-3038)
	- PermissionedNodeRegistry.getValidatorsByOperator(address,uint256,uint256) (PermissionedNodeRegistry.sol#3048-3071)
	- PermissionedNodeRegistry.isActiveValidator(uint256) (PermissionedNodeRegistry.sol#3160-3163)
	- PermissionedNodeRegistry.isNonTerminalValidator(uint256) (PermissionedNodeRegistry.sol#3166-3172)
	- PermissionedNodeRegistry.markValidatorDeposited(uint256) (PermissionedNodeRegistry.sol#3186-3188)
	- PermissionedNodeRegistry.markValidatorStatusAsPreDeposit(bytes) (PermissionedNodeRegistry.sol#2818-2823)
	- PermissionedNodeRegistry.onlyPreDepositValidator(uint256) (PermissionedNodeRegistry.sol#3180-3184)
	- PermissionedNodeRegistry.updateDepositStatusAndBlock(uint256) (PermissionedNodeRegistry.sol#2806-2811)
	- PermissionedNodeRegistry.validatorRegistry (PermissionedNodeRegistry.sol#2477)
	- PermissionedNodeRegistry.withdrawnValidators(bytes[]) (PermissionedNodeRegistry.sol#2741-2761)
	- validatorRegistry[validatorId].withdrawnBlock = block.number (PermissionedNodeRegistry.sol#2753)
	PermissionedNodeRegistry.validatorRegistry (PermissionedNodeRegistry.sol#2477) can be used in cross function reentrancies:
	- PermissionedNodeRegistry.addValidatorKeys(bytes[],bytes[],bytes[]) (PermissionedNodeRegistry.sol#2570-2611)
	- PermissionedNodeRegistry.getAllActiveValidators(uint256,uint256) (PermissionedNodeRegistry.sol#3012-3038)
	- PermissionedNodeRegistry.getValidatorsByOperator(address,uint256,uint256) (PermissionedNodeRegistry.sol#3048-3071)
	- PermissionedNodeRegistry.isActiveValidator(uint256) (PermissionedNodeRegistry.sol#3160-3163)
	- PermissionedNodeRegistry.isNonTerminalValidator(uint256) (PermissionedNodeRegistry.sol#3166-3172)
	- PermissionedNodeRegistry.markValidatorDeposited(uint256) (PermissionedNodeRegistry.sol#3186-3188)
	- PermissionedNodeRegistry.markValidatorStatusAsPreDeposit(bytes) (PermissionedNodeRegistry.sol#2818-2823)
	- PermissionedNodeRegistry.onlyPreDepositValidator(uint256) (PermissionedNodeRegistry.sol#3180-3184)
	- PermissionedNodeRegistry.updateDepositStatusAndBlock(uint256) (PermissionedNodeRegistry.sol#2806-2811)
	- PermissionedNodeRegistry.validatorRegistry (PermissionedNodeRegistry.sol#2477)
	- PermissionedNodeRegistry.withdrawnValidators(bytes[]) (PermissionedNodeRegistry.sol#2741-2761)



    
2754             IValidatorWithdrawalVault(validatorRegistry[validatorId].withdrawVaultAddress).settleFunds();



    
2752             validatorRegistry[validatorId].status = ValidatorStatus.WITHDRAWN;



    
2753             validatorRegistry[validatorId].withdrawnBlock = block.number;



```

### PermissionlessNodeRegistry.sol


```
Reentrancy in PermissionlessNodeRegistry.changeSocializingPoolState(bool) (PermissionlessNodeRegistry.sol#2548-2574):
	External calls:
	- INodeELRewardVault(feeRecipientAddress).withdraw() (PermissionlessNodeRegistry.sol#2567)
	State variables written after the call(s):
	- operatorStructById[operatorId].optedForSocializingPool = _optInForSocializingPool (PermissionlessNodeRegistry.sol#2571)
	PermissionlessNodeRegistry.operatorStructById (PermissionlessNodeRegistry.sol#2313) can be used in cross function reentrancies:
	- PermissionlessNodeRegistry.changeSocializingPoolState(bool) (PermissionlessNodeRegistry.sol#2548-2574)
	- PermissionlessNodeRegistry.getNodeELVaultAddressForOptOutOperators(uint256,uint256) (PermissionlessNodeRegistry.sol#2820-2847)
	- PermissionlessNodeRegistry.getOperatorRewardAddress(uint256) (PermissionlessNodeRegistry.sol#2721-2723)
	- PermissionlessNodeRegistry.onboardOperator(bool,string,address) (PermissionlessNodeRegistry.sol#2859-2876)
	- PermissionlessNodeRegistry.onlyActiveOperator(address) (PermissionlessNodeRegistry.sol#2941-2949)
	- PermissionlessNodeRegistry.operatorStructById (PermissionlessNodeRegistry.sol#2313)
	- PermissionlessNodeRegistry.updateOperatorDetails(string,address) (PermissionlessNodeRegistry.sol#2627-2635)
	- socializingPoolStateChangeBlock[operatorId] = block.number (PermissionlessNodeRegistry.sol#2572)
	PermissionlessNodeRegistry.socializingPoolStateChangeBlock (PermissionlessNodeRegistry.sol#2318) can be used in cross function reentrancies:
	- PermissionlessNodeRegistry.changeSocializingPoolState(bool) (PermissionlessNodeRegistry.sol#2548-2574)
	- PermissionlessNodeRegistry.getSocializingPoolStateChangeBlock(uint256) (PermissionlessNodeRegistry.sol#2577-2579)
	- PermissionlessNodeRegistry.onboardOperator(bool,string,address) (PermissionlessNodeRegistry.sol#2859-2876)
	- PermissionlessNodeRegistry.socializingPoolStateChangeBlock (PermissionlessNodeRegistry.sol#2318)



    
2567                 INodeELRewardVault(feeRecipientAddress).withdraw();



    
2571         operatorStructById[operatorId].optedForSocializingPool = _optInForSocializingPool;



    
2572         socializingPoolStateChangeBlock[operatorId] = block.number;



```

```
Reentrancy in PermissionlessNodeRegistry.withdrawnValidators(bytes[]) (PermissionlessNodeRegistry.sol#2502-2522):
	External calls:
	- IValidatorWithdrawalVault(validatorRegistry[validatorId].withdrawVaultAddress).settleFunds() (PermissionlessNodeRegistry.sol#2515)
	State variables written after the call(s):
	- validatorRegistry[validatorId].status = ValidatorStatus.WITHDRAWN (PermissionlessNodeRegistry.sol#2513)
	PermissionlessNodeRegistry.validatorRegistry (PermissionlessNodeRegistry.sol#2307) can be used in cross function reentrancies:
	- PermissionlessNodeRegistry.getAllActiveValidators(uint256,uint256) (PermissionlessNodeRegistry.sol#2751-2777)
	- PermissionlessNodeRegistry.getValidatorsByOperator(address,uint256,uint256) (PermissionlessNodeRegistry.sol#2787-2810)
	- PermissionlessNodeRegistry.isActiveValidator(uint256) (PermissionlessNodeRegistry.sol#2962-2964)
	- PermissionlessNodeRegistry.isNonTerminalValidator(uint256) (PermissionlessNodeRegistry.sol#2952-2958)
	- PermissionlessNodeRegistry.markValidatorDeposited(uint256) (PermissionlessNodeRegistry.sol#2978-2980)
	- PermissionlessNodeRegistry.updateDepositStatusAndBlock(uint256) (PermissionlessNodeRegistry.sol#2540-2545)
	- PermissionlessNodeRegistry.validatorRegistry (PermissionlessNodeRegistry.sol#2307)
	- PermissionlessNodeRegistry.withdrawnValidators(bytes[]) (PermissionlessNodeRegistry.sol#2502-2522)
	- validatorRegistry[validatorId].withdrawnBlock = block.number (PermissionlessNodeRegistry.sol#2514)
	PermissionlessNodeRegistry.validatorRegistry (PermissionlessNodeRegistry.sol#2307) can be used in cross function reentrancies:
	- PermissionlessNodeRegistry.getAllActiveValidators(uint256,uint256) (PermissionlessNodeRegistry.sol#2751-2777)
	- PermissionlessNodeRegistry.getValidatorsByOperator(address,uint256,uint256) (PermissionlessNodeRegistry.sol#2787-2810)
	- PermissionlessNodeRegistry.isActiveValidator(uint256) (PermissionlessNodeRegistry.sol#2962-2964)
	- PermissionlessNodeRegistry.isNonTerminalValidator(uint256) (PermissionlessNodeRegistry.sol#2952-2958)
	- PermissionlessNodeRegistry.markValidatorDeposited(uint256) (PermissionlessNodeRegistry.sol#2978-2980)
	- PermissionlessNodeRegistry.updateDepositStatusAndBlock(uint256) (PermissionlessNodeRegistry.sol#2540-2545)
	- PermissionlessNodeRegistry.validatorRegistry (PermissionlessNodeRegistry.sol#2307)
	- PermissionlessNodeRegistry.withdrawnValidators(bytes[]) (PermissionlessNodeRegistry.sol#2502-2522)



    
2515             IValidatorWithdrawalVault(validatorRegistry[validatorId].withdrawVaultAddress).settleFunds();



    
2513             validatorRegistry[validatorId].status = ValidatorStatus.WITHDRAWN;



    
2514             validatorRegistry[validatorId].withdrawnBlock = block.number;



```

```
Reentrancy in PermissionlessNodeRegistry.onboardNodeOperator(bool,string,address) (PermissionlessNodeRegistry.sol#2350-2377):
	External calls:
	- IPoolUtils(poolUtils).onlyValidName(_operatorName) (PermissionlessNodeRegistry.sol#2359)
	- nodeELRewardVault = IVaultFactory(staderConfig.getVaultFactory()).deployNodeELRewardVault(POOL_ID,nextOperatorId) (PermissionlessNodeRegistry.sol#2367-2370)
	State variables written after the call(s):
	- onboardOperator(_optInForSocializingPool,_operatorName,_operatorRewardAddress) (PermissionlessNodeRegistry.sol#2375)
		- nextOperatorId ++ (PermissionlessNodeRegistry.sol#2873)
	PermissionlessNodeRegistry.nextOperatorId (PermissionlessNodeRegistry.sol#2298) can be used in cross function reentrancies:
	- PermissionlessNodeRegistry.getNodeELVaultAddressForOptOutOperators(uint256,uint256) (PermissionlessNodeRegistry.sol#2820-2847)
	- PermissionlessNodeRegistry.initialize(address,address) (PermissionlessNodeRegistry.sol#2327-2340)
	- PermissionlessNodeRegistry.nextOperatorId (PermissionlessNodeRegistry.sol#2298)
	- PermissionlessNodeRegistry.onboardNodeOperator(bool,string,address) (PermissionlessNodeRegistry.sol#2350-2377)
	- PermissionlessNodeRegistry.onboardOperator(bool,string,address) (PermissionlessNodeRegistry.sol#2859-2876)



    
2359         IPoolUtils(poolUtils).onlyValidName(_operatorName);



    
2367         address nodeELRewardVault = IVaultFactory(staderConfig.getVaultFactory()).deployNodeELRewardVault(
2368             POOL_ID,
2369             nextOperatorId
2370         );



    
2375         onboardOperator(_optInForSocializingPool, _operatorName, _operatorRewardAddress);



    
2873         nextOperatorId++;



```

```
Reentrancy in PermissionlessNodeRegistry.addValidatorKeys(bytes[],bytes[],bytes[]) (PermissionlessNodeRegistry.sol#2386-2433):
	External calls:
	- IPoolUtils(poolUtils).onlyValidKeys(_pubkey[i],_preDepositSignature[i],_depositSignature[i]) (PermissionlessNodeRegistry.sol#2402)
	- withdrawVault = IVaultFactory(vaultFactory).deployWithdrawVault(POOL_ID,operatorId,operatorTotalKeys + i,nextValidatorId) (PermissionlessNodeRegistry.sol#2403-2408)
	State variables written after the call(s):
	- nextValidatorId ++ (PermissionlessNodeRegistry.sol#2423)
	PermissionlessNodeRegistry.nextValidatorId (PermissionlessNodeRegistry.sol#2299) can be used in cross function reentrancies:
	- PermissionlessNodeRegistry.getAllActiveValidators(uint256,uint256) (PermissionlessNodeRegistry.sol#2751-2777)
	- PermissionlessNodeRegistry.initialize(address,address) (PermissionlessNodeRegistry.sol#2327-2340)
	- PermissionlessNodeRegistry.nextValidatorId (PermissionlessNodeRegistry.sol#2299)
	- validatorIdsByOperatorId[operatorId].push(nextValidatorId) (PermissionlessNodeRegistry.sol#2421)
	PermissionlessNodeRegistry.validatorIdsByOperatorId (PermissionlessNodeRegistry.sol#2317) can be used in cross function reentrancies:
	- PermissionlessNodeRegistry.getOperatorTotalKeys(uint256) (PermissionlessNodeRegistry.sol#2693-2695)
	- PermissionlessNodeRegistry.getOperatorTotalNonTerminalKeys(address,uint256,uint256) (PermissionlessNodeRegistry.sol#2664-2686)
	- PermissionlessNodeRegistry.getValidatorsByOperator(address,uint256,uint256) (PermissionlessNodeRegistry.sol#2787-2810)
	- PermissionlessNodeRegistry.validatorIdsByOperatorId (PermissionlessNodeRegistry.sol#2317)
	- validatorRegistry[nextValidatorId] = Validator(ValidatorStatus.INITIALIZED,_pubkey[i],_preDepositSignature[i],_depositSignature[i],withdrawVault,operatorId,0,0) (PermissionlessNodeRegistry.sol#2409-2418)
	PermissionlessNodeRegistry.validatorRegistry (PermissionlessNodeRegistry.sol#2307) can be used in cross function reentrancies:
	- PermissionlessNodeRegistry.getAllActiveValidators(uint256,uint256) (PermissionlessNodeRegistry.sol#2751-2777)
	- PermissionlessNodeRegistry.getValidatorsByOperator(address,uint256,uint256) (PermissionlessNodeRegistry.sol#2787-2810)
	- PermissionlessNodeRegistry.isActiveValidator(uint256) (PermissionlessNodeRegistry.sol#2962-2964)
	- PermissionlessNodeRegistry.isNonTerminalValidator(uint256) (PermissionlessNodeRegistry.sol#2952-2958)
	- PermissionlessNodeRegistry.markValidatorDeposited(uint256) (PermissionlessNodeRegistry.sol#2978-2980)
	- PermissionlessNodeRegistry.updateDepositStatusAndBlock(uint256) (PermissionlessNodeRegistry.sol#2540-2545)
	- PermissionlessNodeRegistry.validatorRegistry (PermissionlessNodeRegistry.sol#2307)
	- PermissionlessNodeRegistry.withdrawnValidators(bytes[]) (PermissionlessNodeRegistry.sol#2502-2522)



    
2402             IPoolUtils(poolUtils).onlyValidKeys(_pubkey[i], _preDepositSignature[i], _depositSignature[i]);



    
2403             address withdrawVault = IVaultFactory(vaultFactory).deployWithdrawVault(
2404                 POOL_ID,
2405                 operatorId,
2406                 operatorTotalKeys + i, //operator totalKeys
2407                 nextValidatorId
2408             );



    
2423             nextValidatorId++;



    
2421             validatorIdsByOperatorId[operatorId].push(nextValidatorId);



    
2409             validatorRegistry[nextValidatorId] = Validator(
2410                 ValidatorStatus.INITIALIZED,
2411                 _pubkey[i],
2412                 _preDepositSignature[i],
2413                 _depositSignature[i],
2414                 withdrawVault,
2415                 operatorId,
2416                 0,
2417                 0
2418             );



```

### UserWithdrawalManager.sol


```
Reentrancy in UserWithdrawalManager.requestWithdraw(uint256,address) (UserWithdrawalManager.sol#3561-3577):
	External calls:
	- IERC20Upgradeable(staderConfig.getETHxToken()).safeTransferFrom(msg.sender,(address(this)),_ethXAmount) (UserWithdrawalManager.sol#3570)
	State variables written after the call(s):
	- requestIdsByUserAddress[_owner].push(nextRequestId) (UserWithdrawalManager.sol#3573)
	UserWithdrawalManager.requestIdsByUserAddress (UserWithdrawalManager.sol#3504) can be used in cross function reentrancies:
	- UserWithdrawalManager.getRequestIdsByUser(address) (UserWithdrawalManager.sol#3650-3652)
	- UserWithdrawalManager.requestIdsByUserAddress (UserWithdrawalManager.sol#3504)
	- UserWithdrawalManager.requestWithdraw(uint256,address) (UserWithdrawalManager.sol#3561-3577)



    
3570         IERC20Upgradeable(staderConfig.getETHxToken()).safeTransferFrom(msg.sender, (address(this)), _ethXAmount);



    
3573         requestIdsByUserAddress[_owner].push(nextRequestId);



```

## unchecked-lowlevel
### Severity: Medium

### Auction.sol


```
Auction.withdrawUnselectedBid(uint256) (Auction.sol#2322-2337) ignores return value by (success) = address(msg.sender).call{value: withdrawalAmount}() (Auction.sol#2333)



    
2333         (bool success, ) = payable(msg.sender).call{value: withdrawalAmount}('');



```

```
AddressUpgradeable.sendValue(address,uint256) (Auction.sol#955-960) ignores return value by (success) = recipient.call{value: amount}() (Auction.sol#958)



    
958         (bool success, ) = recipient.call{value: amount}("");



```

```
UtilLib.sendValue(address,uint256) (Auction.sol#594-599) ignores return value by (success) = address(_receiver).call{value: _amount}() (Auction.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

### ETHx.sol


```
UtilLib.sendValue(address,uint256) (ETHx.sol#594-599) ignores return value by (success) = address(_receiver).call{value: _amount}() (ETHx.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

```
AddressUpgradeable.sendValue(address,uint256) (ETHx.sol#768-773) ignores return value by (success) = recipient.call{value: amount}() (ETHx.sol#771)



    
771         (bool success, ) = recipient.call{value: amount}("");



```

### NodeELRewardVault.sol


```
UtilLib.sendValue(address,uint256) (NodeELRewardVault.sol#594-599) ignores return value by (success) = address(_receiver).call{value: _amount}() (NodeELRewardVault.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

### OperatorRewardsCollector.sol


```
AddressUpgradeable.sendValue(address,uint256) (OperatorRewardsCollector.sol#763-768) ignores return value by (success) = recipient.call{value: amount}() (OperatorRewardsCollector.sol#766)



    
766         (bool success, ) = recipient.call{value: amount}("");



```

```
UtilLib.sendValue(address,uint256) (OperatorRewardsCollector.sol#594-599) ignores return value by (success) = address(_receiver).call{value: _amount}() (OperatorRewardsCollector.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

### Penalty.sol


```
AddressUpgradeable.sendValue(address,uint256) (Penalty.sol#1225-1230) ignores return value by (success) = recipient.call{value: amount}() (Penalty.sol#1228)



    
1228         (bool success, ) = recipient.call{value: amount}("");



```

```
UtilLib.sendValue(address,uint256) (Penalty.sol#594-599) ignores return value by (success) = address(_receiver).call{value: _amount}() (Penalty.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

### PermissionedNodeRegistry.sol


```
UtilLib.sendValue(address,uint256) (PermissionedNodeRegistry.sol#594-599) ignores return value by (success) = address(_receiver).call{value: _amount}() (PermissionedNodeRegistry.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

```
AddressUpgradeable.sendValue(address,uint256) (PermissionedNodeRegistry.sol#1105-1110) ignores return value by (success) = recipient.call{value: amount}() (PermissionedNodeRegistry.sol#1108)



    
1108         (bool success, ) = recipient.call{value: amount}("");



```

### PermissionedPool.sol


```
UtilLib.sendValue(address,uint256) (PermissionedPool.sol#594-599) ignores return value by (success) = address(_receiver).call{value: _amount}() (PermissionedPool.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

```
AddressUpgradeable.sendValue(address,uint256) (PermissionedPool.sol#1228-1233) ignores return value by (success) = recipient.call{value: amount}() (PermissionedPool.sol#1231)



    
1231         (bool success, ) = recipient.call{value: amount}("");



```

### PermissionlessNodeRegistry.sol


```
AddressUpgradeable.sendValue(address,uint256) (PermissionlessNodeRegistry.sol#937-942) ignores return value by (success) = recipient.call{value: amount}() (PermissionlessNodeRegistry.sol#940)



    
940         (bool success, ) = recipient.call{value: amount}("");



```

```
UtilLib.sendValue(address,uint256) (PermissionlessNodeRegistry.sol#594-599) ignores return value by (success) = address(_receiver).call{value: _amount}() (PermissionlessNodeRegistry.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

### PermissionlessPool.sol


```
AddressUpgradeable.sendValue(address,uint256) (PermissionlessPool.sol#1213-1218) ignores return value by (success) = recipient.call{value: amount}() (PermissionlessPool.sol#1216)



    
1216         (bool success, ) = recipient.call{value: amount}("");



```

```
UtilLib.sendValue(address,uint256) (PermissionlessPool.sol#594-599) ignores return value by (success) = address(_receiver).call{value: _amount}() (PermissionlessPool.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

### PoolSelector.sol


```
AddressUpgradeable.sendValue(address,uint256) (PoolSelector.sol#1221-1226) ignores return value by (success) = recipient.call{value: amount}() (PoolSelector.sol#1224)



    
1224         (bool success, ) = recipient.call{value: amount}("");



```

```
UtilLib.sendValue(address,uint256) (PoolSelector.sol#594-599) ignores return value by (success) = address(_receiver).call{value: _amount}() (PoolSelector.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

### PoolUtils.sol


```
AddressUpgradeable.sendValue(address,uint256) (PoolUtils.sol#798-803) ignores return value by (success) = recipient.call{value: amount}() (PoolUtils.sol#801)



    
801         (bool success, ) = recipient.call{value: amount}("");



```

```
UtilLib.sendValue(address,uint256) (PoolUtils.sol#594-599) ignores return value by (success) = address(_receiver).call{value: _amount}() (PoolUtils.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

### SDCollateral.sol


```
AddressUpgradeable.sendValue(address,uint256) (SDCollateral.sol#1496-1501) ignores return value by (success) = recipient.call{value: amount}() (SDCollateral.sol#1499)



    
1499         (bool success, ) = recipient.call{value: amount}("");



```

```
UtilLib.sendValue(address,uint256) (SDCollateral.sol#594-599) ignores return value by (success) = address(_receiver).call{value: _amount}() (SDCollateral.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

### SocializingPool.sol


```
UtilLib.sendValue(address,uint256) (SocializingPool.sol#595-600) ignores return value by (success) = address(_receiver).call{value: _amount}() (SocializingPool.sol#596)



    
596         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

```
AddressUpgradeable.sendValue(address,uint256) (SocializingPool.sol#977-982) ignores return value by (success) = recipient.call{value: amount}() (SocializingPool.sol#980)



    
980         (bool success, ) = recipient.call{value: amount}("");



```

```
SocializingPool.handleRewards(RewardsData) (SocializingPool.sol#2572-2616) ignores return value by (success) = address(staderConfig.getStaderTreasury()).call{value: _rewardsData.protocolETHRewards}() (SocializingPool.sol#2602)



    
2602         (bool success, ) = payable(staderConfig.getStaderTreasury()).call{value: _rewardsData.protocolETHRewards}('');



```

```
SocializingPool.claim(uint256[],uint256[],uint256[],bytes32[][]) (SocializingPool.sol#2618-2646) ignores return value by (success,None) = address(operatorRewardsAddr).call{value: totalAmountETH}() (SocializingPool.sol#2632)



    
2632             (success, ) = payable(operatorRewardsAddr).call{value: totalAmountETH}('');



```

### StaderConfig.sol


```
AddressUpgradeable.sendValue(address,uint256) (StaderConfig.sol#750-755) ignores return value by (success) = recipient.call{value: amount}() (StaderConfig.sol#753)



    
753         (bool success, ) = recipient.call{value: amount}("");



```

```
UtilLib.sendValue(address,uint256) (StaderConfig.sol#594-599) ignores return value by (success) = address(_receiver).call{value: _amount}() (StaderConfig.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

### StaderInsuranceFund.sol


```
AddressUpgradeable.sendValue(address,uint256) (StaderInsuranceFund.sol#776-781) ignores return value by (success) = recipient.call{value: amount}() (StaderInsuranceFund.sol#779)



    
779         (bool success, ) = recipient.call{value: amount}("");



```

```
UtilLib.sendValue(address,uint256) (StaderInsuranceFund.sol#594-599) ignores return value by (success) = address(_receiver).call{value: _amount}() (StaderInsuranceFund.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

```
StaderInsuranceFund.withdrawFund(uint256) (StaderInsuranceFund.sol#1953-1965) ignores return value by (success) = address(msg.sender).call{value: _amount}() (StaderInsuranceFund.sol#1960)



    
1960         (bool success, ) = payable(msg.sender).call{value: _amount}('');



```

### StaderOracle.sol


```
AddressUpgradeable.sendValue(address,uint256) (StaderOracle.sol#1127-1132) ignores return value by (success) = recipient.call{value: amount}() (StaderOracle.sol#1130)



    
1130         (bool success, ) = recipient.call{value: amount}("");



```

```
UtilLib.sendValue(address,uint256) (StaderOracle.sol#594-599) ignores return value by (success) = address(_receiver).call{value: _amount}() (StaderOracle.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

### StaderStakePoolsManager.sol


```
UtilLib.sendValue(address,uint256) (StaderStakePoolsManager.sol#595-600) ignores return value by (success) = address(_receiver).call{value: _amount}() (StaderStakePoolsManager.sol#596)



    
596         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

```
StaderStakePoolsManager.transferETHToUserWithdrawManager(uint256) (StaderStakePoolsManager.sol#3689-3697) ignores return value by (success) = address(staderConfig.getUserWithdrawManager()).call{value: _amount}() (StaderStakePoolsManager.sol#3692)



    
3692         (bool success, ) = payable(staderConfig.getUserWithdrawManager()).call{value: _amount}('');



```

```
AddressUpgradeable.sendValue(address,uint256) (StaderStakePoolsManager.sol#769-774) ignores return value by (success) = recipient.call{value: amount}() (StaderStakePoolsManager.sol#772)



    
772         (bool success, ) = recipient.call{value: amount}("");



```

### UserWithdrawalManager.sol


```
UtilLib.sendValue(address,uint256) (UserWithdrawalManager.sol#594-599) ignores return value by (success) = address(_receiver).call{value: _amount}() (UserWithdrawalManager.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

```
UserWithdrawalManager.sendValue(address,uint256) (UserWithdrawalManager.sol#3689-3699) ignores return value by (success) = _recipient.call{value: _amount}() (UserWithdrawalManager.sol#3695)



    
3695         (bool success, ) = _recipient.call{value: _amount}('');



```

```
AddressUpgradeable.sendValue(address,uint256) (UserWithdrawalManager.sol#768-773) ignores return value by (success) = recipient.call{value: amount}() (UserWithdrawalManager.sol#771)



    
771         (bool success, ) = recipient.call{value: amount}("");



```

### UtilLib.sol


```
UtilLib.sendValue(address,uint256) (UtilLib.sol#594-599) ignores return value by (success) = address(_receiver).call{value: _amount}() (UtilLib.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

### ValidatorWithdrawalVault.sol


```
UtilLib.sendValue(address,uint256) (ValidatorWithdrawalVault.sol#594-599) ignores return value by (success) = address(_receiver).call{value: _amount}() (ValidatorWithdrawalVault.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

### VaultFactory.sol


```
AddressUpgradeable.sendValue(address,uint256) (VaultFactory.sol#945-950) ignores return value by (success) = recipient.call{value: amount}() (VaultFactory.sol#948)



    
948         (bool success, ) = recipient.call{value: amount}("");



```

```
UtilLib.sendValue(address,uint256) (VaultFactory.sol#594-599) ignores return value by (success) = address(_receiver).call{value: _amount}() (VaultFactory.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

### VaultProxy.sol


```
UtilLib.sendValue(address,uint256) (VaultProxy.sol#594-599) ignores return value by (success) = address(_receiver).call{value: _amount}() (VaultProxy.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

## unused-return
### Severity: Medium

### Auction.sol


```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (Auction.sol#509-520) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (Auction.sol#516)



    
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (Auction.sol#476-490) ignores return value by (pubkey,withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (Auction.sol#483-485)



    
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (Auction.sol#522-532) ignores return value by (operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (Auction.sol#528)



    
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (Auction.sol#570-580) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId) (Auction.sol#578)



    
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (Auction.sol#534-543) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId) (Auction.sol#540)



    
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (Auction.sol#522-532) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (Auction.sol#529)



    
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (Auction.sol#492-507) ignores return value by (operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (Auction.sol#505)



    
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (Auction.sol#492-507) ignores return value by (withdrawVaultAddress,operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (Auction.sol#499-501)



    
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );



```

### ETHx.sol


```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (ETHx.sol#509-520) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (ETHx.sol#516)



    
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (ETHx.sol#476-490) ignores return value by (pubkey,withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (ETHx.sol#483-485)



    
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (ETHx.sol#522-532) ignores return value by (operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (ETHx.sol#528)



    
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (ETHx.sol#570-580) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId) (ETHx.sol#578)



    
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (ETHx.sol#534-543) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId) (ETHx.sol#540)



    
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (ETHx.sol#522-532) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (ETHx.sol#529)



    
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (ETHx.sol#492-507) ignores return value by (operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (ETHx.sol#505)



    
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (ETHx.sol#492-507) ignores return value by (withdrawVaultAddress,operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (ETHx.sol#499-501)



    
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );



```

### NodeELRewardVault.sol


```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (NodeELRewardVault.sol#509-520) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (NodeELRewardVault.sol#516)



    
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (NodeELRewardVault.sol#476-490) ignores return value by (pubkey,withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (NodeELRewardVault.sol#483-485)



    
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (NodeELRewardVault.sol#522-532) ignores return value by (operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (NodeELRewardVault.sol#528)



    
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (NodeELRewardVault.sol#570-580) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId) (NodeELRewardVault.sol#578)



    
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (NodeELRewardVault.sol#534-543) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId) (NodeELRewardVault.sol#540)



    
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (NodeELRewardVault.sol#522-532) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (NodeELRewardVault.sol#529)



    
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (NodeELRewardVault.sol#492-507) ignores return value by (operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (NodeELRewardVault.sol#505)



    
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (NodeELRewardVault.sol#492-507) ignores return value by (withdrawVaultAddress,operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (NodeELRewardVault.sol#499-501)



    
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );



```

### OperatorRewardsCollector.sol


```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (OperatorRewardsCollector.sol#509-520) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (OperatorRewardsCollector.sol#516)



    
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (OperatorRewardsCollector.sol#476-490) ignores return value by (pubkey,withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (OperatorRewardsCollector.sol#483-485)



    
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (OperatorRewardsCollector.sol#522-532) ignores return value by (operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (OperatorRewardsCollector.sol#528)



    
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (OperatorRewardsCollector.sol#570-580) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId) (OperatorRewardsCollector.sol#578)



    
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (OperatorRewardsCollector.sol#534-543) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId) (OperatorRewardsCollector.sol#540)



    
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (OperatorRewardsCollector.sol#522-532) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (OperatorRewardsCollector.sol#529)



    
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (OperatorRewardsCollector.sol#492-507) ignores return value by (operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (OperatorRewardsCollector.sol#505)



    
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (OperatorRewardsCollector.sol#492-507) ignores return value by (withdrawVaultAddress,operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (OperatorRewardsCollector.sol#499-501)



    
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );



```

### Penalty.sol


```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (Penalty.sol#509-520) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (Penalty.sol#516)



    
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (Penalty.sol#476-490) ignores return value by (pubkey,withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (Penalty.sol#483-485)



    
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (Penalty.sol#522-532) ignores return value by (operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (Penalty.sol#528)



    
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (Penalty.sol#570-580) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId) (Penalty.sol#578)



    
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (Penalty.sol#534-543) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId) (Penalty.sol#540)



    
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (Penalty.sol#522-532) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (Penalty.sol#529)



    
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (Penalty.sol#492-507) ignores return value by (operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (Penalty.sol#505)



    
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (Penalty.sol#492-507) ignores return value by (withdrawVaultAddress,operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (Penalty.sol#499-501)



    
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );



```

### PermissionedNodeRegistry.sol


```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (PermissionedNodeRegistry.sol#509-520) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (PermissionedNodeRegistry.sol#516)



    
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (PermissionedNodeRegistry.sol#476-490) ignores return value by (pubkey,withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (PermissionedNodeRegistry.sol#483-485)



    
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (PermissionedNodeRegistry.sol#522-532) ignores return value by (operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (PermissionedNodeRegistry.sol#528)



    
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (PermissionedNodeRegistry.sol#570-580) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId) (PermissionedNodeRegistry.sol#578)



    
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (PermissionedNodeRegistry.sol#534-543) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId) (PermissionedNodeRegistry.sol#540)



    
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (PermissionedNodeRegistry.sol#522-532) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (PermissionedNodeRegistry.sol#529)



    
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (PermissionedNodeRegistry.sol#492-507) ignores return value by (operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (PermissionedNodeRegistry.sol#505)



    
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (PermissionedNodeRegistry.sol#492-507) ignores return value by (withdrawVaultAddress,operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (PermissionedNodeRegistry.sol#499-501)



    
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );



```

### PermissionedPool.sol


```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (PermissionedPool.sol#509-520) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (PermissionedPool.sol#516)



    
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (PermissionedPool.sol#476-490) ignores return value by (pubkey,withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (PermissionedPool.sol#483-485)



    
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );



```

```
PermissionedPool.preDepositOnBeaconChain(address,address,address,uint256) (PermissionedPool.sol#2644-2674) ignores return value by (pubkey,preDepositSignature,withdrawVaultAddress) = INodeRegistry(_nodeRegistryAddress).validatorRegistry(_validatorId) (PermissionedPool.sol#2650-2652)



    
2650         (, bytes memory pubkey, bytes memory preDepositSignature, , address withdrawVaultAddress, , , ) = INodeRegistry(
2651             _nodeRegistryAddress
2652         ).validatorRegistry(_validatorId);



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (PermissionedPool.sol#522-532) ignores return value by (operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (PermissionedPool.sol#528)



    
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (PermissionedPool.sol#570-580) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId) (PermissionedPool.sol#578)



    
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (PermissionedPool.sol#534-543) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId) (PermissionedPool.sol#540)



    
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (PermissionedPool.sol#522-532) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (PermissionedPool.sol#529)



    
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (PermissionedPool.sol#492-507) ignores return value by (operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (PermissionedPool.sol#505)



    
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
PermissionedPool.fullDepositOnBeaconChain(bytes[]) (PermissionedPool.sol#2485-2523) ignores return value by (depositSignature,withdrawVaultAddress) = INodeRegistry(nodeRegistryAddress).validatorRegistry(validatorId) (PermissionedPool.sol#2496-2498)



    
2496             (, , , bytes memory depositSignature, address withdrawVaultAddress, , , ) = INodeRegistry(
2497                 nodeRegistryAddress
2498             ).validatorRegistry(validatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (PermissionedPool.sol#492-507) ignores return value by (withdrawVaultAddress,operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (PermissionedPool.sol#499-501)



    
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );



```

### PermissionlessNodeRegistry.sol


```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (PermissionlessNodeRegistry.sol#509-520) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (PermissionlessNodeRegistry.sol#516)



    
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (PermissionlessNodeRegistry.sol#476-490) ignores return value by (pubkey,withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (PermissionlessNodeRegistry.sol#483-485)



    
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (PermissionlessNodeRegistry.sol#522-532) ignores return value by (operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (PermissionlessNodeRegistry.sol#528)



    
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (PermissionlessNodeRegistry.sol#570-580) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId) (PermissionlessNodeRegistry.sol#578)



    
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (PermissionlessNodeRegistry.sol#534-543) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId) (PermissionlessNodeRegistry.sol#540)



    
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (PermissionlessNodeRegistry.sol#522-532) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (PermissionlessNodeRegistry.sol#529)



    
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (PermissionlessNodeRegistry.sol#492-507) ignores return value by (operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (PermissionlessNodeRegistry.sol#505)



    
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (PermissionlessNodeRegistry.sol#492-507) ignores return value by (withdrawVaultAddress,operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (PermissionlessNodeRegistry.sol#499-501)



    
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );



```

### PermissionlessPool.sol


```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (PermissionlessPool.sol#509-520) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (PermissionlessPool.sol#516)



    
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (PermissionlessPool.sol#476-490) ignores return value by (pubkey,withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (PermissionlessPool.sol#483-485)



    
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (PermissionlessPool.sol#522-532) ignores return value by (operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (PermissionlessPool.sol#528)



    
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (PermissionlessPool.sol#570-580) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId) (PermissionlessPool.sol#578)



    
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (PermissionlessPool.sol#534-543) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId) (PermissionlessPool.sol#540)



    
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (PermissionlessPool.sol#522-532) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (PermissionlessPool.sol#529)



    
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (PermissionlessPool.sol#492-507) ignores return value by (operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (PermissionlessPool.sol#505)



    
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
PermissionlessPool.fullDepositOnBeaconChain(address,address,address,uint256,uint256) (PermissionlessPool.sol#2584-2613) ignores return value by (pubkey,depositSignature,withdrawVaultAddress) = INodeRegistry(_nodeRegistryAddress).validatorRegistry(_validatorId) (PermissionlessPool.sol#2591-2593)



    
2591         (, bytes memory pubkey, , bytes memory depositSignature, address withdrawVaultAddress, , , ) = INodeRegistry(
2592             _nodeRegistryAddress
2593         ).validatorRegistry(_validatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (PermissionlessPool.sol#492-507) ignores return value by (withdrawVaultAddress,operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (PermissionlessPool.sol#499-501)



    
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );



```

### PoolSelector.sol


```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (PoolSelector.sol#509-520) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (PoolSelector.sol#516)



    
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (PoolSelector.sol#476-490) ignores return value by (pubkey,withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (PoolSelector.sol#483-485)



    
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (PoolSelector.sol#522-532) ignores return value by (operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (PoolSelector.sol#528)



    
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (PoolSelector.sol#570-580) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId) (PoolSelector.sol#578)



    
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (PoolSelector.sol#534-543) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId) (PoolSelector.sol#540)



    
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (PoolSelector.sol#522-532) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (PoolSelector.sol#529)



    
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (PoolSelector.sol#492-507) ignores return value by (operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (PoolSelector.sol#505)



    
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (PoolSelector.sol#492-507) ignores return value by (withdrawVaultAddress,operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (PoolSelector.sol#499-501)



    
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );



```

```
PoolSelector.computePoolAllocationForDeposit(uint8,uint256) (PoolSelector.sol#2328-2345) ignores return value by (remainingPoolTarget) = SafeMath.trySub(poolTotalTarget,currentActiveValidators) (PoolSelector.sol#2340)



    
2340         (, uint256 remainingPoolTarget) = SafeMath.trySub(poolTotalTarget, currentActiveValidators);



```

### PoolUtils.sol


```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (PoolUtils.sol#509-520) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (PoolUtils.sol#516)



    
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (PoolUtils.sol#476-490) ignores return value by (pubkey,withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (PoolUtils.sol#483-485)



    
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (PoolUtils.sol#522-532) ignores return value by (operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (PoolUtils.sol#528)



    
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (PoolUtils.sol#570-580) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId) (PoolUtils.sol#578)



    
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (PoolUtils.sol#534-543) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId) (PoolUtils.sol#540)



    
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (PoolUtils.sol#522-532) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (PoolUtils.sol#529)



    
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (PoolUtils.sol#492-507) ignores return value by (operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (PoolUtils.sol#505)



    
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (PoolUtils.sol#492-507) ignores return value by (withdrawVaultAddress,operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (PoolUtils.sol#499-501)



    
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );



```

### SDCollateral.sol


```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (SDCollateral.sol#509-520) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (SDCollateral.sol#516)



    
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (SDCollateral.sol#476-490) ignores return value by (pubkey,withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (SDCollateral.sol#483-485)



    
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (SDCollateral.sol#522-532) ignores return value by (operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (SDCollateral.sol#528)



    
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (SDCollateral.sol#570-580) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId) (SDCollateral.sol#578)



    
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (SDCollateral.sol#534-543) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId) (SDCollateral.sol#540)



    
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);



```

```
SDCollateral.maxApproveSD() (SDCollateral.sol#2807-2812) ignores return value by IERC20(staderConfig.getStaderToken()).approve(auctionContract,type()(uint256).max) (SDCollateral.sol#2811)



    
2811         IERC20(staderConfig.getStaderToken()).approve(auctionContract, type(uint256).max);



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (SDCollateral.sol#522-532) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (SDCollateral.sol#529)



    
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (SDCollateral.sol#492-507) ignores return value by (operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (SDCollateral.sol#505)



    
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (SDCollateral.sol#492-507) ignores return value by (withdrawVaultAddress,operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (SDCollateral.sol#499-501)



    
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );



```

### SocializingPool.sol


```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (SocializingPool.sol#535-544) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId) (SocializingPool.sol#541)



    
541         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);



```

```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (SocializingPool.sol#510-521) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (SocializingPool.sol#517)



    
517         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (SocializingPool.sol#477-491) ignores return value by (pubkey,withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (SocializingPool.sol#484-486)



    
484         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
485             _validatorId
486         );



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (SocializingPool.sol#493-508) ignores return value by (operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (SocializingPool.sol#506)



    
506         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (SocializingPool.sol#523-533) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (SocializingPool.sol#530)



    
530         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (SocializingPool.sol#571-581) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId) (SocializingPool.sol#579)



    
579         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (SocializingPool.sol#523-533) ignores return value by (operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (SocializingPool.sol#529)



    
529         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (SocializingPool.sol#493-508) ignores return value by (withdrawVaultAddress,operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (SocializingPool.sol#500-502)



    
500         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
501             _validatorId
502         );



```

### StaderConfig.sol


```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (StaderConfig.sol#509-520) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (StaderConfig.sol#516)



    
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (StaderConfig.sol#476-490) ignores return value by (pubkey,withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (StaderConfig.sol#483-485)



    
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (StaderConfig.sol#522-532) ignores return value by (operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (StaderConfig.sol#528)



    
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (StaderConfig.sol#570-580) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId) (StaderConfig.sol#578)



    
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (StaderConfig.sol#534-543) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId) (StaderConfig.sol#540)



    
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (StaderConfig.sol#522-532) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (StaderConfig.sol#529)



    
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (StaderConfig.sol#492-507) ignores return value by (operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (StaderConfig.sol#505)



    
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (StaderConfig.sol#492-507) ignores return value by (withdrawVaultAddress,operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (StaderConfig.sol#499-501)



    
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );



```

### StaderInsuranceFund.sol


```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (StaderInsuranceFund.sol#509-520) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (StaderInsuranceFund.sol#516)



    
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (StaderInsuranceFund.sol#476-490) ignores return value by (pubkey,withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (StaderInsuranceFund.sol#483-485)



    
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (StaderInsuranceFund.sol#522-532) ignores return value by (operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (StaderInsuranceFund.sol#528)



    
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (StaderInsuranceFund.sol#570-580) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId) (StaderInsuranceFund.sol#578)



    
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (StaderInsuranceFund.sol#534-543) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId) (StaderInsuranceFund.sol#540)



    
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (StaderInsuranceFund.sol#522-532) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (StaderInsuranceFund.sol#529)



    
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (StaderInsuranceFund.sol#492-507) ignores return value by (operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (StaderInsuranceFund.sol#505)



    
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (StaderInsuranceFund.sol#492-507) ignores return value by (withdrawVaultAddress,operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (StaderInsuranceFund.sol#499-501)



    
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );



```

### StaderOracle.sol


```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (StaderOracle.sol#509-520) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (StaderOracle.sol#516)



    
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
StaderOracle.getPORFeedData() (StaderOracle.sol#3094-3108) ignores return value by (totalETHXSupplyInInt) = AggregatorV3Interface(staderConfig.getETHXSupplyPORFeedProxy()).latestRoundData() (StaderOracle.sol#3105-3106)



    
3105         (, int256 totalETHXSupplyInInt, , , ) = AggregatorV3Interface(staderConfig.getETHXSupplyPORFeedProxy())
3106             .latestRoundData();



```

```
StaderOracle.getMerkleRootReportableBlockByPoolId(uint8) (StaderOracle.sol#3032-3037) ignores return value by (currentEndBlock) = ISocializingPool(IPoolUtils(staderConfig.getPoolUtils()).getSocializingPoolAddress(_poolId)).getRewardDetails() (StaderOracle.sol#3033-3035)



    
3033         (, , uint256 currentEndBlock) = ISocializingPool(
3034             IPoolUtils(staderConfig.getPoolUtils()).getSocializingPoolAddress(_poolId)
3035         ).getRewardDetails();



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (StaderOracle.sol#476-490) ignores return value by (pubkey,withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (StaderOracle.sol#483-485)



    
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (StaderOracle.sol#522-532) ignores return value by (operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (StaderOracle.sol#528)



    
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (StaderOracle.sol#570-580) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId) (StaderOracle.sol#578)



    
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (StaderOracle.sol#534-543) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId) (StaderOracle.sol#540)



    
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (StaderOracle.sol#522-532) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (StaderOracle.sol#529)



    
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (StaderOracle.sol#492-507) ignores return value by (operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (StaderOracle.sol#505)



    
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (StaderOracle.sol#492-507) ignores return value by (withdrawVaultAddress,operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (StaderOracle.sol#499-501)



    
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );



```

```
StaderOracle.getPORFeedData() (StaderOracle.sol#3094-3108) ignores return value by (totalETHBalanceInInt) = AggregatorV3Interface(staderConfig.getETHBalancePORFeedProxy()).latestRoundData() (StaderOracle.sol#3103-3104)



    
3103         (, int256 totalETHBalanceInInt, , , ) = AggregatorV3Interface(staderConfig.getETHBalancePORFeedProxy())
3104             .latestRoundData();



```

### StaderStakePoolsManager.sol


```
StaderStakePoolsManager.validatorBatchDeposit(uint8) (StaderStakePoolsManager.sol#3773-3799) ignores return value by (availableETHForNewDeposit) = SafeMath.trySub(address(this).balance,IUserWithdrawalManager(staderConfig.getUserWithdrawManager()).ethRequestedForWithdraw()) (StaderStakePoolsManager.sol#3778-3781)



    
3778         (, uint256 availableETHForNewDeposit) = SafeMath.trySub(
3779             address(this).balance,
3780             IUserWithdrawalManager(staderConfig.getUserWithdrawManager()).ethRequestedForWithdraw()
3781         );



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (StaderStakePoolsManager.sol#535-544) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId) (StaderStakePoolsManager.sol#541)



    
541         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);



```

```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (StaderStakePoolsManager.sol#510-521) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (StaderStakePoolsManager.sol#517)



    
517         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (StaderStakePoolsManager.sol#477-491) ignores return value by (pubkey,withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (StaderStakePoolsManager.sol#484-486)



    
484         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
485             _validatorId
486         );



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (StaderStakePoolsManager.sol#493-508) ignores return value by (operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (StaderStakePoolsManager.sol#506)



    
506         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
StaderStakePoolsManager.depositETHOverTargetWeight() (StaderStakePoolsManager.sol#3805-3836) ignores return value by (availableETHForNewDeposit) = SafeMath.trySub(address(this).balance,IUserWithdrawalManager(staderConfig.getUserWithdrawManager()).ethRequestedForWithdraw()) (StaderStakePoolsManager.sol#3810-3813)



    
3810         (, uint256 availableETHForNewDeposit) = SafeMath.trySub(
3811             address(this).balance,
3812             IUserWithdrawalManager(staderConfig.getUserWithdrawManager()).ethRequestedForWithdraw()
3813         );



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (StaderStakePoolsManager.sol#523-533) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (StaderStakePoolsManager.sol#530)



    
530         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (StaderStakePoolsManager.sol#571-581) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId) (StaderStakePoolsManager.sol#579)



    
579         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (StaderStakePoolsManager.sol#523-533) ignores return value by (operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (StaderStakePoolsManager.sol#529)



    
529         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (StaderStakePoolsManager.sol#493-508) ignores return value by (withdrawVaultAddress,operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (StaderStakePoolsManager.sol#500-502)



    
500         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
501             _validatorId
502         );



```

### UserWithdrawalManager.sol


```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (UserWithdrawalManager.sol#509-520) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (UserWithdrawalManager.sol#516)



    
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (UserWithdrawalManager.sol#476-490) ignores return value by (pubkey,withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (UserWithdrawalManager.sol#483-485)



    
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (UserWithdrawalManager.sol#522-532) ignores return value by (operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (UserWithdrawalManager.sol#528)



    
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (UserWithdrawalManager.sol#570-580) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId) (UserWithdrawalManager.sol#578)



    
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (UserWithdrawalManager.sol#534-543) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId) (UserWithdrawalManager.sol#540)



    
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (UserWithdrawalManager.sol#522-532) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (UserWithdrawalManager.sol#529)



    
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (UserWithdrawalManager.sol#492-507) ignores return value by (operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (UserWithdrawalManager.sol#505)



    
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (UserWithdrawalManager.sol#492-507) ignores return value by (withdrawVaultAddress,operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (UserWithdrawalManager.sol#499-501)



    
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );



```

### UtilLib.sol


```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (UtilLib.sol#509-520) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (UtilLib.sol#516)



    
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (UtilLib.sol#476-490) ignores return value by (pubkey,withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (UtilLib.sol#483-485)



    
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (UtilLib.sol#522-532) ignores return value by (operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (UtilLib.sol#528)



    
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (UtilLib.sol#570-580) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId) (UtilLib.sol#578)



    
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (UtilLib.sol#534-543) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId) (UtilLib.sol#540)



    
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (UtilLib.sol#522-532) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (UtilLib.sol#529)



    
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (UtilLib.sol#492-507) ignores return value by (operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (UtilLib.sol#505)



    
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (UtilLib.sol#492-507) ignores return value by (withdrawVaultAddress,operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (UtilLib.sol#499-501)



    
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );



```

### ValidatorWithdrawalVault.sol


```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (ValidatorWithdrawalVault.sol#509-520) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (ValidatorWithdrawalVault.sol#516)



    
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (ValidatorWithdrawalVault.sol#476-490) ignores return value by (pubkey,withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (ValidatorWithdrawalVault.sol#483-485)



    
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );



```

```
ValidatorWithdrawalVault.getUpdatedPenaltyAmount(uint8,uint256,IStaderConfig) (ValidatorWithdrawalVault.sol#1290-1301) ignores return value by (pubkey) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (ValidatorWithdrawalVault.sol#1296)



    
1296         (, bytes memory pubkey, , , , , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (ValidatorWithdrawalVault.sol#522-532) ignores return value by (operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (ValidatorWithdrawalVault.sol#528)



    
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (ValidatorWithdrawalVault.sol#570-580) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId) (ValidatorWithdrawalVault.sol#578)



    
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (ValidatorWithdrawalVault.sol#534-543) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId) (ValidatorWithdrawalVault.sol#540)



    
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (ValidatorWithdrawalVault.sol#522-532) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (ValidatorWithdrawalVault.sol#529)



    
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (ValidatorWithdrawalVault.sol#492-507) ignores return value by (operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (ValidatorWithdrawalVault.sol#505)



    
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (ValidatorWithdrawalVault.sol#492-507) ignores return value by (withdrawVaultAddress,operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (ValidatorWithdrawalVault.sol#499-501)



    
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );



```

### VaultFactory.sol


```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (VaultFactory.sol#509-520) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (VaultFactory.sol#516)



    
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (VaultFactory.sol#476-490) ignores return value by (pubkey,withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (VaultFactory.sol#483-485)



    
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (VaultFactory.sol#522-532) ignores return value by (operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (VaultFactory.sol#528)



    
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (VaultFactory.sol#570-580) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId) (VaultFactory.sol#578)



    
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (VaultFactory.sol#534-543) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId) (VaultFactory.sol#540)



    
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (VaultFactory.sol#522-532) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (VaultFactory.sol#529)



    
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (VaultFactory.sol#492-507) ignores return value by (operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (VaultFactory.sol#505)



    
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (VaultFactory.sol#492-507) ignores return value by (withdrawVaultAddress,operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (VaultFactory.sol#499-501)



    
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );



```

### VaultProxy.sol


```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (VaultProxy.sol#509-520) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (VaultProxy.sol#516)



    
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (VaultProxy.sol#476-490) ignores return value by (pubkey,withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (VaultProxy.sol#483-485)



    
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (VaultProxy.sol#522-532) ignores return value by (operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (VaultProxy.sol#528)



    
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (VaultProxy.sol#570-580) ignores return value by (withdrawVaultAddress) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId) (VaultProxy.sol#578)



    
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (VaultProxy.sol#534-543) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId) (VaultProxy.sol#540)



    
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (VaultProxy.sol#522-532) ignores return value by (operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (VaultProxy.sol#529)



    
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (VaultProxy.sol#492-507) ignores return value by (operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId) (VaultProxy.sol#505)



    
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (VaultProxy.sol#492-507) ignores return value by (withdrawVaultAddress,operatorId) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId) (VaultProxy.sol#499-501)



    
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );



```

## incorrect-equality
### Severity: Medium

### NodeELRewardVault.sol


```
NodeELRewardVault.withdraw() (NodeELRewardVault.sol#696-715) uses a dangerous strict equality:
	- totalRewards == 0 (NodeELRewardVault.sol#700)



    
700         if (totalRewards == 0) {



```

### PermissionedPool.sol


```
PermissionedPool.transferExcessETHToSSPM() (PermissionedPool.sol#2529-2536) uses a dangerous strict equality:
	- preDepositValidatorCount != 0 || address(this).balance == 0 (PermissionedPool.sol#2530)



    
2530         if (preDepositValidatorCount != 0 || address(this).balance == 0) {



```

### StaderStakePoolsManager.sol


```
StaderStakePoolsManager.validatorBatchDeposit(uint8) (StaderStakePoolsManager.sol#3773-3799) uses a dangerous strict equality:
	- selectedPoolCapacity == 0 (StaderStakePoolsManager.sol#3792)



    
3792         if (selectedPoolCapacity == 0) {



```

```
StaderStakePoolsManager.depositETHOverTargetWeight() (StaderStakePoolsManager.sol#3805-3836) uses a dangerous strict equality:
	- availableETHForNewDeposit == 0 (StaderStakePoolsManager.sol#3814)



    
3814         if (availableETHForNewDeposit == 0) {



```

```
StaderStakePoolsManager.depositETHOverTargetWeight() (StaderStakePoolsManager.sol#3805-3836) uses a dangerous strict equality:
	- validatorToDeposit == 0 (StaderStakePoolsManager.sol#3824)



    
3824             if (validatorToDeposit == 0) {



```

### ValidatorWithdrawalVault.sol


```
ValidatorWithdrawalVault.distributeRewards() (ValidatorWithdrawalVault.sol#1181-1203) uses a dangerous strict equality:
	- totalRewards == 0 (ValidatorWithdrawalVault.sol#1190)



    
1190         if (totalRewards == 0) {



```

## uninitialized-local
### Severity: Medium

### PermissionedNodeRegistry.sol


```
PermissionedNodeRegistry.getOperatorTotalNonTerminalKeys(address,uint256,uint256).totalNonWithdrawnKeyCount (PermissionedNodeRegistry.sol#2963) is a local variable never initialized



    
2963         uint64 totalNonWithdrawnKeyCount;



```

```
PermissionedNodeRegistry.allocateValidatorsAndUpdateOperatorId(uint256).totalValidatorToDeposit (PermissionedNodeRegistry.sol#2633) is a local variable never initialized



    
2633         uint256 totalValidatorToDeposit;



```

```
PermissionedNodeRegistry.getTotalQueuedValidatorCount().totalQueuedValidators (PermissionedNodeRegistry.sol#2917) is a local variable never initialized



    
2917         uint256 totalQueuedValidators;



```

### PermissionlessNodeRegistry.sol


```
PermissionlessNodeRegistry.getOperatorTotalNonTerminalKeys(address,uint256,uint256).totalNonWithdrawnKeyCount (PermissionlessNodeRegistry.sol#2675) is a local variable never initialized



    
2675         uint64 totalNonWithdrawnKeyCount;



```

## reentrancy-events
### Severity: Low

### Auction.sol


```
Reentrancy in Auction.extractNonBidSD(uint256) (Auction.sol#2308-2320):
	External calls:
	- ! IERC20(staderConfig.getStaderToken()).transfer(staderConfig.getStaderTreasury(),_sdAmount) (Auction.sol#2316)
	Event emitted after the call(s):
	- UnsuccessfulSDAuctionExtracted(lotId,_sdAmount,staderConfig.getStaderTreasury()) (Auction.sol#2319)



    
2316         if (!IERC20(staderConfig.getStaderToken()).transfer(staderConfig.getStaderTreasury(), _sdAmount)) {



    
2319         emit UnsuccessfulSDAuctionExtracted(lotId, _sdAmount, staderConfig.getStaderTreasury());



```

```
Reentrancy in Auction.createLot(uint256) (Auction.sol#2250-2262):
	External calls:
	- ! IERC20(staderConfig.getStaderToken()).transferFrom(msg.sender,address(this),_sdAmount) (Auction.sol#2257)
	Event emitted after the call(s):
	- LotCreated(nextLot,lotItem.sdAmount,lotItem.startBlock,lotItem.endBlock,bidIncrement) (Auction.sol#2260)



    
2257         if (!IERC20(staderConfig.getStaderToken()).transferFrom(msg.sender, address(this), _sdAmount)) {



    
2260         emit LotCreated(nextLot, lotItem.sdAmount, lotItem.startBlock, lotItem.endBlock, bidIncrement);



```

```
Reentrancy in Auction.claimSD(uint256) (Auction.sol#2282-2293):
	External calls:
	- ! IERC20(staderConfig.getStaderToken()).transfer(lotItem.highestBidder,lotItem.sdAmount) (Auction.sol#2289)
	Event emitted after the call(s):
	- SDClaimed(lotId,lotItem.highestBidder,lotItem.sdAmount) (Auction.sol#2292)



    
2289         if (!IERC20(staderConfig.getStaderToken()).transfer(lotItem.highestBidder, lotItem.sdAmount)) {



    
2292         emit SDClaimed(lotId, lotItem.highestBidder, lotItem.sdAmount);



```

### NodeELRewardVault.sol


```
Reentrancy in NodeELRewardVault.withdraw() (NodeELRewardVault.sol#696-715):
	External calls:
	- IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveExecutionLayerRewards{value: userShare}() (NodeELRewardVault.sol#707)
	- UtilLib.sendValue(address(staderConfig.getStaderTreasury()),protocolShare) (NodeELRewardVault.sol#709)
	- IOperatorRewardsCollector(staderConfig.getOperatorRewardsCollector()).depositFor{value: operatorShare}(UtilLib.getOperatorAddressByOperatorId(poolId,IVaultProxy(address(this)).id(),staderConfig)) (NodeELRewardVault.sol#710-712)
	External calls sending eth:
	- IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveExecutionLayerRewards{value: userShare}() (NodeELRewardVault.sol#707)
	- IOperatorRewardsCollector(staderConfig.getOperatorRewardsCollector()).depositFor{value: operatorShare}(UtilLib.getOperatorAddressByOperatorId(poolId,IVaultProxy(address(this)).id(),staderConfig)) (NodeELRewardVault.sol#710-712)
	Event emitted after the call(s):
	- Withdrawal(protocolShare,operatorShare,userShare) (NodeELRewardVault.sol#714)



    
707         IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveExecutionLayerRewards{value: userShare}();



    
709         UtilLib.sendValue(payable(staderConfig.getStaderTreasury()), protocolShare);



    
710         IOperatorRewardsCollector(staderConfig.getOperatorRewardsCollector()).depositFor{value: operatorShare}(
711             UtilLib.getOperatorAddressByOperatorId(poolId, IVaultProxy(address(this)).id(), staderConfig)
712         );



    
707         IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveExecutionLayerRewards{value: userShare}();



    
710         IOperatorRewardsCollector(staderConfig.getOperatorRewardsCollector()).depositFor{value: operatorShare}(
711             UtilLib.getOperatorAddressByOperatorId(poolId, IVaultProxy(address(this)).id(), staderConfig)
712         );



    
714         emit Withdrawal(protocolShare, operatorShare, userShare);



```

### OperatorRewardsCollector.sol


```
Reentrancy in OperatorRewardsCollector.claim() (OperatorRewardsCollector.sol#1980-1988):
	External calls:
	- UtilLib.sendValue(operatorRewardsAddr,amount) (OperatorRewardsCollector.sol#1986)
	Event emitted after the call(s):
	- Claimed(operatorRewardsAddr,amount) (OperatorRewardsCollector.sol#1987)



    
1986         UtilLib.sendValue(operatorRewardsAddr, amount);



    
1987         emit Claimed(operatorRewardsAddr, amount);



```

### PermissionedNodeRegistry.sol


```
Reentrancy in PermissionedNodeRegistry.withdrawnValidators(bytes[]) (PermissionedNodeRegistry.sol#2741-2761):
	External calls:
	- IValidatorWithdrawalVault(validatorRegistry[validatorId].withdrawVaultAddress).settleFunds() (PermissionedNodeRegistry.sol#2754)
	Event emitted after the call(s):
	- DecreasedTotalActiveValidatorCount(totalActiveValidatorCount) (PermissionedNodeRegistry.sol#3177)
		- decreaseTotalActiveValidatorCount(withdrawnValidatorCount) (PermissionedNodeRegistry.sol#2760)
	- ValidatorWithdrawn(_pubkeys[i],validatorId) (PermissionedNodeRegistry.sol#2755)



    
2754             IValidatorWithdrawalVault(validatorRegistry[validatorId].withdrawVaultAddress).settleFunds();



    
3177         emit DecreasedTotalActiveValidatorCount(totalActiveValidatorCount);



    
2760         decreaseTotalActiveValidatorCount(withdrawnValidatorCount);



    
2755             emit ValidatorWithdrawn(_pubkeys[i], validatorId);



```

```
Reentrancy in PermissionedNodeRegistry.addValidatorKeys(bytes[],bytes[],bytes[]) (PermissionedNodeRegistry.sol#2570-2611):
	External calls:
	- IPoolUtils(poolUtils).onlyValidKeys(_pubkey[i],_preDepositSignature[i],_depositSignature[i]) (PermissionedNodeRegistry.sol#2586)
	- withdrawVault = IVaultFactory(vaultFactory).deployWithdrawVault(POOL_ID,operatorId,operatorTotalKeys + i,nextValidatorId) (PermissionedNodeRegistry.sol#2587-2592)
	Event emitted after the call(s):
	- AddedValidatorKey(msg.sender,_pubkey[i],nextValidatorId) (PermissionedNodeRegistry.sol#2605)



    
2586             IPoolUtils(poolUtils).onlyValidKeys(_pubkey[i], _preDepositSignature[i], _depositSignature[i]);



    
2587             address withdrawVault = IVaultFactory(vaultFactory).deployWithdrawVault(
2588                 POOL_ID,
2589                 operatorId,
2590                 operatorTotalKeys + i, //operator totalKeys
2591                 nextValidatorId
2592             );



    
2605             emit AddedValidatorKey(msg.sender, _pubkey[i], nextValidatorId);



```

```
Reentrancy in PermissionedNodeRegistry.updateOperatorDetails(string,address) (PermissionedNodeRegistry.sol#2831-2839):
	External calls:
	- IPoolUtils(staderConfig.getPoolUtils()).onlyValidName(_operatorName) (PermissionedNodeRegistry.sol#2832)
	Event emitted after the call(s):
	- UpdatedOperatorDetails(msg.sender,_operatorName,_rewardAddress) (PermissionedNodeRegistry.sol#2838)



    
2832         IPoolUtils(staderConfig.getPoolUtils()).onlyValidName(_operatorName);



    
2838         emit UpdatedOperatorDetails(msg.sender, _operatorName, _rewardAddress);



```

```
Reentrancy in PermissionedNodeRegistry.onboardNodeOperator(string,address) (PermissionedNodeRegistry.sol#2537-2561):
	External calls:
	- IPoolUtils(poolUtils).onlyValidName(_operatorName) (PermissionedNodeRegistry.sol#2547)
	Event emitted after the call(s):
	- OnboardedOperator(msg.sender,_operatorRewardAddress,nextOperatorId - 1) (PermissionedNodeRegistry.sol#3095)
		- onboardOperator(_operatorName,_operatorRewardAddress) (PermissionedNodeRegistry.sol#2559)



    
2547         IPoolUtils(poolUtils).onlyValidName(_operatorName);



    
3095         emit OnboardedOperator(msg.sender, _operatorRewardAddress, nextOperatorId - 1);



    
2559         onboardOperator(_operatorName, _operatorRewardAddress);



```

### PermissionlessNodeRegistry.sol


```
Reentrancy in PermissionlessNodeRegistry.onboardNodeOperator(bool,string,address) (PermissionlessNodeRegistry.sol#2350-2377):
	External calls:
	- IPoolUtils(poolUtils).onlyValidName(_operatorName) (PermissionlessNodeRegistry.sol#2359)
	- nodeELRewardVault = IVaultFactory(staderConfig.getVaultFactory()).deployNodeELRewardVault(POOL_ID,nextOperatorId) (PermissionlessNodeRegistry.sol#2367-2370)
	Event emitted after the call(s):
	- OnboardedOperator(msg.sender,_operatorRewardAddress,nextOperatorId - 1,_optInForSocializingPool) (PermissionlessNodeRegistry.sol#2875)
		- onboardOperator(_optInForSocializingPool,_operatorName,_operatorRewardAddress) (PermissionlessNodeRegistry.sol#2375)



    
2359         IPoolUtils(poolUtils).onlyValidName(_operatorName);



    
2367         address nodeELRewardVault = IVaultFactory(staderConfig.getVaultFactory()).deployNodeELRewardVault(
2368             POOL_ID,
2369             nextOperatorId
2370         );



    
2875         emit OnboardedOperator(msg.sender, _operatorRewardAddress, nextOperatorId - 1, _optInForSocializingPool);



    
2375         onboardOperator(_optInForSocializingPool, _operatorName, _operatorRewardAddress);



```

```
Reentrancy in PermissionlessNodeRegistry.changeSocializingPoolState(bool) (PermissionlessNodeRegistry.sol#2548-2574):
	External calls:
	- INodeELRewardVault(feeRecipientAddress).withdraw() (PermissionlessNodeRegistry.sol#2567)
	Event emitted after the call(s):
	- UpdatedSocializingPoolState(operatorId,_optInForSocializingPool,block.number) (PermissionlessNodeRegistry.sol#2573)



    
2567                 INodeELRewardVault(feeRecipientAddress).withdraw();



    
2573         emit UpdatedSocializingPoolState(operatorId, _optInForSocializingPool, block.number);



```

```
Reentrancy in PermissionlessNodeRegistry.withdrawnValidators(bytes[]) (PermissionlessNodeRegistry.sol#2502-2522):
	External calls:
	- IValidatorWithdrawalVault(validatorRegistry[validatorId].withdrawVaultAddress).settleFunds() (PermissionlessNodeRegistry.sol#2515)
	Event emitted after the call(s):
	- DecreasedTotalActiveValidatorCount(totalActiveValidatorCount) (PermissionlessNodeRegistry.sol#2969)
		- decreaseTotalActiveValidatorCount(withdrawnValidatorCount) (PermissionlessNodeRegistry.sol#2521)
	- ValidatorWithdrawn(_pubkeys[i],validatorId) (PermissionlessNodeRegistry.sol#2516)



    
2515             IValidatorWithdrawalVault(validatorRegistry[validatorId].withdrawVaultAddress).settleFunds();



    
2969         emit DecreasedTotalActiveValidatorCount(totalActiveValidatorCount);



    
2521         decreaseTotalActiveValidatorCount(withdrawnValidatorCount);



    
2516             emit ValidatorWithdrawn(_pubkeys[i], validatorId);



```

```
Reentrancy in PermissionlessNodeRegistry.updateOperatorDetails(string,address) (PermissionlessNodeRegistry.sol#2627-2635):
	External calls:
	- IPoolUtils(staderConfig.getPoolUtils()).onlyValidName(_operatorName) (PermissionlessNodeRegistry.sol#2628)
	Event emitted after the call(s):
	- UpdatedOperatorDetails(msg.sender,_operatorName,_rewardAddress) (PermissionlessNodeRegistry.sol#2634)



    
2628         IPoolUtils(staderConfig.getPoolUtils()).onlyValidName(_operatorName);



    
2634         emit UpdatedOperatorDetails(msg.sender, _operatorName, _rewardAddress);



```

### SDCollateral.sol


```
Reentrancy in SDCollateral.depositSDAsCollateral(uint256) (SDCollateral.sol#2752-2760):
	External calls:
	- ! IERC20(staderConfig.getStaderToken()).transferFrom(msg.sender,address(this),_sdAmount) (SDCollateral.sol#2755)
	Event emitted after the call(s):
	- SDDeposited(msg.sender,_sdAmount) (SDCollateral.sol#2759)



    
2755         if (!IERC20(staderConfig.getStaderToken()).transferFrom(msg.sender, address(this), _sdAmount)) {



    
2759         emit SDDeposited(msg.sender, _sdAmount);



```

```
Reentrancy in SDCollateral.withdraw(uint256) (SDCollateral.sol#2766-2780):
	External calls:
	- ! IERC20(staderConfig.getStaderToken()).transfer(address(msg.sender),_requestedSD) (SDCollateral.sol#2775)
	Event emitted after the call(s):
	- SDWithdrawn(msg.sender,_requestedSD) (SDCollateral.sol#2779)



    
2775         if (!IERC20(staderConfig.getStaderToken()).transfer(payable(msg.sender), _requestedSD)) {



    
2779         emit SDWithdrawn(msg.sender, _requestedSD);



```

### StaderStakePoolsManager.sol


```
Reentrancy in StaderStakePoolsManager._deposit(address,address,uint256,uint256) (StaderStakePoolsManager.sol#3905-3913):
	External calls:
	- ETHx(staderConfig.getETHxToken()).mint(_receiver,_shares) (StaderStakePoolsManager.sol#3911)
	Event emitted after the call(s):
	- Deposited(_caller,_receiver,_assets,_shares) (StaderStakePoolsManager.sol#3912)



    
3911         ETHx(staderConfig.getETHxToken()).mint(_receiver, _shares);



    
3912         emit Deposited(_caller, _receiver, _assets, _shares);



```

### UserWithdrawalManager.sol


```
Reentrancy in UserWithdrawalManager.requestWithdraw(uint256,address) (UserWithdrawalManager.sol#3561-3577):
	External calls:
	- IERC20Upgradeable(staderConfig.getETHxToken()).safeTransferFrom(msg.sender,(address(this)),_ethXAmount) (UserWithdrawalManager.sol#3570)
	Event emitted after the call(s):
	- WithdrawRequestReceived(msg.sender,_owner,nextRequestId,_ethXAmount,assets) (UserWithdrawalManager.sol#3574)



    
3570         IERC20Upgradeable(staderConfig.getETHxToken()).safeTransferFrom(msg.sender, (address(this)), _ethXAmount);



    
3574         emit WithdrawRequestReceived(msg.sender, _owner, nextRequestId, _ethXAmount, assets);



```

### ValidatorWithdrawalVault.sol


```
Reentrancy in ValidatorWithdrawalVault.distributeRewards() (ValidatorWithdrawalVault.sol#1181-1203):
	External calls:
	- IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveWithdrawVaultUserShare{value: userShare}() (ValidatorWithdrawalVault.sol#1197)
	- UtilLib.sendValue(address(staderConfig.getStaderTreasury()),protocolShare) (ValidatorWithdrawalVault.sol#1198)
	- IOperatorRewardsCollector(staderConfig.getOperatorRewardsCollector()).depositFor{value: operatorShare}(getOperatorAddress(poolId,validatorId,staderConfig)) (ValidatorWithdrawalVault.sol#1199-1201)
	External calls sending eth:
	- IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveWithdrawVaultUserShare{value: userShare}() (ValidatorWithdrawalVault.sol#1197)
	- IOperatorRewardsCollector(staderConfig.getOperatorRewardsCollector()).depositFor{value: operatorShare}(getOperatorAddress(poolId,validatorId,staderConfig)) (ValidatorWithdrawalVault.sol#1199-1201)
	Event emitted after the call(s):
	- DistributedRewards(userShare,operatorShare,protocolShare) (ValidatorWithdrawalVault.sol#1202)



    
1197         IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveWithdrawVaultUserShare{value: userShare}();



    
1198         UtilLib.sendValue(payable(staderConfig.getStaderTreasury()), protocolShare);



    
1199         IOperatorRewardsCollector(staderConfig.getOperatorRewardsCollector()).depositFor{value: operatorShare}(
1200             getOperatorAddress(poolId, validatorId, staderConfig)
1201         );



    
1197         IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveWithdrawVaultUserShare{value: userShare}();



    
1199         IOperatorRewardsCollector(staderConfig.getOperatorRewardsCollector()).depositFor{value: operatorShare}(
1200             getOperatorAddress(poolId, validatorId, staderConfig)
1201         );



    
1202         emit DistributedRewards(userShare, operatorShare, protocolShare);



```

```
Reentrancy in ValidatorWithdrawalVault.settleFunds() (ValidatorWithdrawalVault.sol#1205-1234):
	External calls:
	- penaltyAmount = getUpdatedPenaltyAmount(poolId,validatorId,staderConfig) (ValidatorWithdrawalVault.sol#1215)
		- IPenalty(_staderConfig.getPenaltyContract()).updateTotalPenaltyAmount(pubkeyArray) (ValidatorWithdrawalVault.sol#1299)
	- ISDCollateral(staderConfig.getSDCollateral()).slashValidatorSD(validatorId,poolId) (ValidatorWithdrawalVault.sol#1218)
	- IPenalty(staderConfig.getPenaltyContract()).markValidatorSettled(poolId,validatorId) (ValidatorWithdrawalVault.sol#1227)
	- IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveWithdrawVaultUserShare{value: userShare}() (ValidatorWithdrawalVault.sol#1228)
	- UtilLib.sendValue(address(staderConfig.getStaderTreasury()),protocolShare) (ValidatorWithdrawalVault.sol#1229)
	- IOperatorRewardsCollector(staderConfig.getOperatorRewardsCollector()).depositFor{value: operatorShare}(getOperatorAddress(poolId,validatorId,staderConfig)) (ValidatorWithdrawalVault.sol#1230-1232)
	External calls sending eth:
	- IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveWithdrawVaultUserShare{value: userShare}() (ValidatorWithdrawalVault.sol#1228)
	- IOperatorRewardsCollector(staderConfig.getOperatorRewardsCollector()).depositFor{value: operatorShare}(getOperatorAddress(poolId,validatorId,staderConfig)) (ValidatorWithdrawalVault.sol#1230-1232)
	Event emitted after the call(s):
	- SettledFunds(userShare,operatorShare,protocolShare) (ValidatorWithdrawalVault.sol#1233)



    
1215         uint256 penaltyAmount = getUpdatedPenaltyAmount(poolId, validatorId, staderConfig);



    
1299         IPenalty(_staderConfig.getPenaltyContract()).updateTotalPenaltyAmount(pubkeyArray);



    
1218             ISDCollateral(staderConfig.getSDCollateral()).slashValidatorSD(validatorId, poolId);



    
1227         IPenalty(staderConfig.getPenaltyContract()).markValidatorSettled(poolId, validatorId);



    
1228         IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveWithdrawVaultUserShare{value: userShare}();



    
1229         UtilLib.sendValue(payable(staderConfig.getStaderTreasury()), protocolShare);



    
1230         IOperatorRewardsCollector(staderConfig.getOperatorRewardsCollector()).depositFor{value: operatorShare}(
1231             getOperatorAddress(poolId, validatorId, staderConfig)
1232         );



    
1228         IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveWithdrawVaultUserShare{value: userShare}();



    
1230         IOperatorRewardsCollector(staderConfig.getOperatorRewardsCollector()).depositFor{value: operatorShare}(
1231             getOperatorAddress(poolId, validatorId, staderConfig)
1232         );



    
1233         emit SettledFunds(userShare, operatorShare, protocolShare);



```

### VaultFactory.sol


```
Reentrancy in VaultFactory.deployNodeELRewardVault(uint8,uint256) (VaultFactory.sol#2052-2064):
	External calls:
	- VaultProxy(address(nodeELRewardVaultAddress)).initialise(false,_poolId,_operatorId,address(staderConfig)) (VaultFactory.sol#2060)
	Event emitted after the call(s):
	- NodeELRewardVaultCreated(nodeELRewardVaultAddress) (VaultFactory.sol#2062)



    
2060         VaultProxy(payable(nodeELRewardVaultAddress)).initialise(false, _poolId, _operatorId, address(staderConfig));



    
2062         emit NodeELRewardVaultCreated(nodeELRewardVaultAddress);



```

```
Reentrancy in VaultFactory.deployWithdrawVault(uint8,uint256,uint256,uint256) (VaultFactory.sol#2038-2050):
	External calls:
	- VaultProxy(address(withdrawVaultAddress)).initialise(true,_poolId,_validatorId,address(staderConfig)) (VaultFactory.sol#2046)
	Event emitted after the call(s):
	- WithdrawVaultCreated(withdrawVaultAddress) (VaultFactory.sol#2048)



    
2046         VaultProxy(payable(withdrawVaultAddress)).initialise(true, _poolId, _validatorId, address(staderConfig));



    
2048         emit WithdrawVaultCreated(withdrawVaultAddress);



```

## missing-zero-check
### Severity: Low

### Penalty.sol


```
Penalty.updateRatedOracleAddress(address)._ratedOracleAddress (Penalty.sol#2442) lacks a zero-check on :
		- ratedOracleAddress = _ratedOracleAddress (Penalty.sol#2445)



    
2445         ratedOracleAddress = _ratedOracleAddress;



```

```
Penalty.initialize(address,address,address)._ratedOracleAddress (Penalty.sol#2394) lacks a zero-check on :
		- ratedOracleAddress = _ratedOracleAddress (Penalty.sol#2403)



    
2403         ratedOracleAddress = _ratedOracleAddress;



```

### SocializingPool.sol


```
SocializingPool.claim(uint256[],uint256[],uint256[],bytes32[][]).operatorRewardsAddr (SocializingPool.sol#2627) lacks a zero-check on :
		- (success,None) = address(operatorRewardsAddr).call{value: totalAmountETH}() (SocializingPool.sol#2632)



    
2632             (success, ) = payable(operatorRewardsAddr).call{value: totalAmountETH}('');



```

### ValidatorWithdrawalVault.sol


```
VaultProxy.updateOwner(address)._owner (ValidatorWithdrawalVault.sol#663) lacks a zero-check on :
		- owner = _owner (ValidatorWithdrawalVault.sol#665)



    
665         owner = _owner;



```

### VaultFactory.sol


```
VaultFactory.updateVaultProxyAddress(address)._vaultProxyImpl (VaultFactory.sol#2097) lacks a zero-check on :
		- vaultProxyImplementation = _vaultProxyImpl (VaultFactory.sol#2099)



    
2099         vaultProxyImplementation = _vaultProxyImpl;



```

```
VaultProxy.updateOwner(address)._owner (VaultFactory.sol#663) lacks a zero-check on :
		- owner = _owner (VaultFactory.sol#665)



    
665         owner = _owner;



```

### VaultProxy.sol


```
VaultProxy.updateOwner(address)._owner (VaultProxy.sol#663) lacks a zero-check on :
		- owner = _owner (VaultProxy.sol#665)



    
665         owner = _owner;



```

## calls-loop
### Severity: Low

### Penalty.sol


```
Penalty.calculateMEVTheftPenalty(bytes32) (Penalty.sol#2480-2485) has external calls inside a loop: IRatedV1(ratedOracleAddress).getViolationsForValidator(_pubkeyRoot).length * mevTheftPenaltyPerStrike (Penalty.sol#2484)



    
2484         return IRatedV1(ratedOracleAddress).getViolationsForValidator(_pubkeyRoot).length * mevTheftPenaltyPerStrike;



```

```
Penalty.calculateMissedAttestationPenalty(bytes32) (Penalty.sol#2488-2492) has external calls inside a loop: IStaderOracle(staderConfig.getStaderOracle()).missedAttestationPenalty(_pubkeyRoot) * missedAttestationPenaltyPerStrike (Penalty.sol#2489-2491)



    
2489         return
2490             IStaderOracle(staderConfig.getStaderOracle()).missedAttestationPenalty(_pubkeyRoot) *
2491             missedAttestationPenaltyPerStrike;



```

### PermissionedNodeRegistry.sol


```
PermissionedNodeRegistry.addValidatorKeys(bytes[],bytes[],bytes[]) (PermissionedNodeRegistry.sol#2570-2611) has external calls inside a loop: IPoolUtils(poolUtils).onlyValidKeys(_pubkey[i],_preDepositSignature[i],_depositSignature[i]) (PermissionedNodeRegistry.sol#2586)



    
2586             IPoolUtils(poolUtils).onlyValidKeys(_pubkey[i], _preDepositSignature[i], _depositSignature[i]);



```

```
PermissionedNodeRegistry.withdrawnValidators(bytes[]) (PermissionedNodeRegistry.sol#2741-2761) has external calls inside a loop: IValidatorWithdrawalVault(validatorRegistry[validatorId].withdrawVaultAddress).settleFunds() (PermissionedNodeRegistry.sol#2754)



    
2754             IValidatorWithdrawalVault(validatorRegistry[validatorId].withdrawVaultAddress).settleFunds();



```

```
PermissionedNodeRegistry.addValidatorKeys(bytes[],bytes[],bytes[]) (PermissionedNodeRegistry.sol#2570-2611) has external calls inside a loop: withdrawVault = IVaultFactory(vaultFactory).deployWithdrawVault(POOL_ID,operatorId,operatorTotalKeys + i,nextValidatorId) (PermissionedNodeRegistry.sol#2587-2592)



    
2587             address withdrawVault = IVaultFactory(vaultFactory).deployWithdrawVault(
2588                 POOL_ID,
2589                 operatorId,
2590                 operatorTotalKeys + i, //operator totalKeys
2591                 nextValidatorId
2592             );



```

### PermissionedPool.sol


```
PermissionedPool.stakeUserETHToBeaconChain() (PermissionedPool.sol#2445-2482) has external calls inside a loop: validatorId = INodeRegistry(nodeRegistryAddress).validatorIdsByOperatorId(i,index) (PermissionedPool.sol#2470)



    
2470                 uint256 validatorId = INodeRegistry(nodeRegistryAddress).validatorIdsByOperatorId(i, index);



```

```
PermissionedPool.fullDepositOnBeaconChain(bytes[]) (PermissionedPool.sol#2485-2523) has external calls inside a loop: withdrawCredential = IVaultFactory(vaultFactory).getValidatorWithdrawCredential(withdrawVaultAddress) (PermissionedPool.sol#2499-2501)



    
2499             bytes memory withdrawCredential = IVaultFactory(vaultFactory).getValidatorWithdrawCredential(
2500                 withdrawVaultAddress
2501             );



```

```
PermissionedPool.fullDepositOnBeaconChain(bytes[]) (PermissionedPool.sol#2485-2523) has external calls inside a loop: IPermissionedNodeRegistry(nodeRegistryAddress).onlyPreDepositValidator(_pubkey[i]) (PermissionedPool.sol#2494)



    
2494             IPermissionedNodeRegistry(nodeRegistryAddress).onlyPreDepositValidator(_pubkey[i]);



```

```
PermissionedPool.preDepositOnBeaconChain(address,address,address,uint256) (PermissionedPool.sol#2644-2674) has external calls inside a loop: preDepositSize = staderConfig.getPreDepositSize() (PermissionedPool.sol#2657)



    
2657         uint256 preDepositSize = staderConfig.getPreDepositSize();



```

```
PermissionedPool.fullDepositOnBeaconChain(bytes[]) (PermissionedPool.sol#2485-2523) has external calls inside a loop: (depositSignature,withdrawVaultAddress) = INodeRegistry(nodeRegistryAddress).validatorRegistry(validatorId) (PermissionedPool.sol#2496-2498)



    
2496             (, , , bytes memory depositSignature, address withdrawVaultAddress, , , ) = INodeRegistry(
2497                 nodeRegistryAddress
2498             ).validatorRegistry(validatorId);



```

```
PermissionedPool.fullDepositOnBeaconChain(bytes[]) (PermissionedPool.sol#2485-2523) has external calls inside a loop: validatorId = INodeRegistry(nodeRegistryAddress).validatorIdByPubkey(_pubkey[i]) (PermissionedPool.sol#2495)



    
2495             uint256 validatorId = INodeRegistry(nodeRegistryAddress).validatorIdByPubkey(_pubkey[i]);



```

```
PermissionedPool.preDepositOnBeaconChain(address,address,address,uint256) (PermissionedPool.sol#2644-2674) has external calls inside a loop: depositDataRoot = this.computeDepositDataRoot(pubkey,preDepositSignature,withdrawCredential,preDepositSize) (PermissionedPool.sol#2658-2663)



    
2658         bytes32 depositDataRoot = this.computeDepositDataRoot(
2659             pubkey,
2660             preDepositSignature,
2661             withdrawCredential,
2662             preDepositSize
2663         );



```

```
PermissionedPool.fullDepositOnBeaconChain(bytes[]) (PermissionedPool.sol#2485-2523) has external calls inside a loop: fullDepositSize = staderConfig.getFullDepositSize() (PermissionedPool.sol#2502)



    
2502             uint256 fullDepositSize = staderConfig.getFullDepositSize();



```

```
PermissionedPool.preDepositOnBeaconChain(address,address,address,uint256) (PermissionedPool.sol#2644-2674) has external calls inside a loop: IPermissionedNodeRegistry(_nodeRegistryAddress).markValidatorStatusAsPreDeposit(pubkey) (PermissionedPool.sol#2672)



    
2672         IPermissionedNodeRegistry(_nodeRegistryAddress).markValidatorStatusAsPreDeposit(pubkey);



```

```
PermissionedPool.fullDepositOnBeaconChain(bytes[]) (PermissionedPool.sol#2485-2523) has external calls inside a loop: depositDataRoot = this.computeDepositDataRoot(_pubkey[i],depositSignature,withdrawCredential,fullDepositSize) (PermissionedPool.sol#2503-2508)



    
2503             bytes32 depositDataRoot = this.computeDepositDataRoot(
2504                 _pubkey[i],
2505                 depositSignature,
2506                 withdrawCredential,
2507                 fullDepositSize
2508             );



```

```
PermissionedPool.fullDepositOnBeaconChain(bytes[]) (PermissionedPool.sol#2485-2523) has external calls inside a loop: IPermissionedNodeRegistry(nodeRegistryAddress).updateDepositStatusAndBlock(validatorId) (PermissionedPool.sol#2517)



    
2517             IPermissionedNodeRegistry(nodeRegistryAddress).updateDepositStatusAndBlock(validatorId);



```

```
PermissionedPool.preDepositOnBeaconChain(address,address,address,uint256) (PermissionedPool.sol#2644-2674) has external calls inside a loop: IDepositContract(_ethDepositContract).deposit{value: preDepositSize}(pubkey,withdrawCredential,preDepositSignature,depositDataRoot) (PermissionedPool.sol#2666-2671)



    
2666         IDepositContract(_ethDepositContract).deposit{value: preDepositSize}(
2667             pubkey,
2668             withdrawCredential,
2669             preDepositSignature,
2670             depositDataRoot
2671         );



```

```
PermissionedPool.stakeUserETHToBeaconChain() (PermissionedPool.sol#2445-2482) has external calls inside a loop: nextQueuedValidatorIndex = IPermissionedNodeRegistry(nodeRegistryAddress).nextQueuedValidatorIndexByOperatorId(i) (PermissionedPool.sol#2462-2463)



    
2462             uint256 nextQueuedValidatorIndex = IPermissionedNodeRegistry(nodeRegistryAddress)
2463                 .nextQueuedValidatorIndexByOperatorId(i);



```

```
PermissionedPool.fullDepositOnBeaconChain(bytes[]) (PermissionedPool.sol#2485-2523) has external calls inside a loop: IDepositContract(ethDepositContract).deposit{value: fullDepositSize}(_pubkey[i],withdrawCredential,depositSignature,depositDataRoot) (PermissionedPool.sol#2511-2516)



    
2511             IDepositContract(ethDepositContract).deposit{value: fullDepositSize}(
2512                 _pubkey[i],
2513                 withdrawCredential,
2514                 depositSignature,
2515                 depositDataRoot
2516             );



```

```
PermissionedPool.preDepositOnBeaconChain(address,address,address,uint256) (PermissionedPool.sol#2644-2674) has external calls inside a loop: (pubkey,preDepositSignature,withdrawVaultAddress) = INodeRegistry(_nodeRegistryAddress).validatorRegistry(_validatorId) (PermissionedPool.sol#2650-2652)



    
2650         (, bytes memory pubkey, bytes memory preDepositSignature, , address withdrawVaultAddress, , , ) = INodeRegistry(
2651             _nodeRegistryAddress
2652         ).validatorRegistry(_validatorId);



```

```
PermissionedPool.stakeUserETHToBeaconChain() (PermissionedPool.sol#2445-2482) has external calls inside a loop: IPermissionedNodeRegistry(nodeRegistryAddress).updateQueuedValidatorIndex(i,nextQueuedValidatorIndex + validatorToDeposit) (PermissionedPool.sol#2473-2476)



    
2473             IPermissionedNodeRegistry(nodeRegistryAddress).updateQueuedValidatorIndex(
2474                 i,
2475                 nextQueuedValidatorIndex + validatorToDeposit
2476             );



```

```
PermissionedPool.preDepositOnBeaconChain(address,address,address,uint256) (PermissionedPool.sol#2644-2674) has external calls inside a loop: withdrawCredential = IVaultFactory(_vaultFactory).getValidatorWithdrawCredential(withdrawVaultAddress) (PermissionedPool.sol#2654-2656)



    
2654         bytes memory withdrawCredential = IVaultFactory(_vaultFactory).getValidatorWithdrawCredential(
2655             withdrawVaultAddress
2656         );



```

### PermissionlessNodeRegistry.sol


```
PermissionlessNodeRegistry.handleInvalidSignature(uint256) (PermissionlessNodeRegistry.sol#2894-2901) has external calls inside a loop: IOperatorRewardsCollector(staderConfig.getOperatorRewardsCollector()).depositFor{value: (COLLATERAL_ETH - staderConfig.getPreDepositSize())}(operatorAddress) (PermissionlessNodeRegistry.sol#2898-2900)



    
2898         IOperatorRewardsCollector(staderConfig.getOperatorRewardsCollector()).depositFor{
2899             value: (COLLATERAL_ETH - staderConfig.getPreDepositSize())
2900         }(operatorAddress);



```

```
PermissionlessNodeRegistry.addValidatorKeys(bytes[],bytes[],bytes[]) (PermissionlessNodeRegistry.sol#2386-2433) has external calls inside a loop: IPoolUtils(poolUtils).onlyValidKeys(_pubkey[i],_preDepositSignature[i],_depositSignature[i]) (PermissionlessNodeRegistry.sol#2402)



    
2402             IPoolUtils(poolUtils).onlyValidKeys(_pubkey[i], _preDepositSignature[i], _depositSignature[i]);



```

```
PermissionlessNodeRegistry.addValidatorKeys(bytes[],bytes[],bytes[]) (PermissionlessNodeRegistry.sol#2386-2433) has external calls inside a loop: withdrawVault = IVaultFactory(vaultFactory).deployWithdrawVault(POOL_ID,operatorId,operatorTotalKeys + i,nextValidatorId) (PermissionlessNodeRegistry.sol#2403-2408)



    
2403             address withdrawVault = IVaultFactory(vaultFactory).deployWithdrawVault(
2404                 POOL_ID,
2405                 operatorId,
2406                 operatorTotalKeys + i, //operator totalKeys
2407                 nextValidatorId
2408             );



```

```
PermissionlessNodeRegistry.withdrawnValidators(bytes[]) (PermissionlessNodeRegistry.sol#2502-2522) has external calls inside a loop: IValidatorWithdrawalVault(validatorRegistry[validatorId].withdrawVaultAddress).settleFunds() (PermissionlessNodeRegistry.sol#2515)



    
2515             IValidatorWithdrawalVault(validatorRegistry[validatorId].withdrawVaultAddress).settleFunds();



```

### PermissionlessPool.sol


```
PermissionlessPool.stakeUserETHToBeaconChain() (PermissionlessPool.sol#2469-2497) has external calls inside a loop: fullDepositOnBeaconChain(nodeRegistryAddress,vaultFactoryAddress,ethDepositContract,validatorId,staderConfig.getFullDepositSize()) (PermissionlessPool.sol#2482-2488)



    
2482             fullDepositOnBeaconChain(
2483                 nodeRegistryAddress,
2484                 vaultFactoryAddress,
2485                 ethDepositContract,
2486                 validatorId,
2487                 staderConfig.getFullDepositSize()
2488             );



```

```
PermissionlessPool.stakeUserETHToBeaconChain() (PermissionlessPool.sol#2469-2497) has external calls inside a loop: validatorId = IPermissionlessNodeRegistry(nodeRegistryAddress).queuedValidators(i) (PermissionlessPool.sol#2481)



    
2481             uint256 validatorId = IPermissionlessNodeRegistry(nodeRegistryAddress).queuedValidators(i);



```

```
PermissionlessPool.fullDepositOnBeaconChain(address,address,address,uint256,uint256) (PermissionlessPool.sol#2584-2613) has external calls inside a loop: (pubkey,depositSignature,withdrawVaultAddress) = INodeRegistry(_nodeRegistryAddress).validatorRegistry(_validatorId) (PermissionlessPool.sol#2591-2593)



    
2591         (, bytes memory pubkey, , bytes memory depositSignature, address withdrawVaultAddress, , , ) = INodeRegistry(
2592             _nodeRegistryAddress
2593         ).validatorRegistry(_validatorId);



```

```
PermissionlessPool.fullDepositOnBeaconChain(address,address,address,uint256,uint256) (PermissionlessPool.sol#2584-2613) has external calls inside a loop: depositDataRoot = this.computeDepositDataRoot(pubkey,depositSignature,withdrawCredential,_DEPOSIT_SIZE) (PermissionlessPool.sol#2599-2604)



    
2599         bytes32 depositDataRoot = this.computeDepositDataRoot(
2600             pubkey,
2601             depositSignature,
2602             withdrawCredential,
2603             _DEPOSIT_SIZE
2604         );



```

```
PermissionlessPool.preDepositOnBeaconChain(bytes[],bytes[],uint256,uint256) (PermissionlessPool.sol#2428-2463) has external calls inside a loop: depositDataRoot = this.computeDepositDataRoot(_pubkey[i],_preDepositSignature[i],withdrawCredential,staderConfig.getPreDepositSize()) (PermissionlessPool.sol#2445-2450)



    
2445             bytes32 depositDataRoot = this.computeDepositDataRoot(
2446                 _pubkey[i],
2447                 _preDepositSignature[i],
2448                 withdrawCredential,
2449                 staderConfig.getPreDepositSize()
2450             );



```

```
PermissionlessPool.fullDepositOnBeaconChain(address,address,address,uint256,uint256) (PermissionlessPool.sol#2584-2613) has external calls inside a loop: IDepositContract(_ethDepositContract).deposit{value: _DEPOSIT_SIZE}(pubkey,withdrawCredential,depositSignature,depositDataRoot) (PermissionlessPool.sol#2605-2610)



    
2605         IDepositContract(_ethDepositContract).deposit{value: _DEPOSIT_SIZE}(
2606             pubkey,
2607             withdrawCredential,
2608             depositSignature,
2609             depositDataRoot
2610         );



```

```
PermissionlessPool.fullDepositOnBeaconChain(address,address,address,uint256,uint256) (PermissionlessPool.sol#2584-2613) has external calls inside a loop: withdrawCredential = IVaultFactory(_vaultFactoryAddress).getValidatorWithdrawCredential(withdrawVaultAddress) (PermissionlessPool.sol#2595-2597)



    
2595         bytes memory withdrawCredential = IVaultFactory(_vaultFactoryAddress).getValidatorWithdrawCredential(
2596             withdrawVaultAddress
2597         );



```

```
PermissionlessPool.preDepositOnBeaconChain(bytes[],bytes[],uint256,uint256) (PermissionlessPool.sol#2428-2463) has external calls inside a loop: withdrawCredential = IVaultFactory(vaultFactory).getValidatorWithdrawCredential(withdrawVault) (PermissionlessPool.sol#2443)



    
2443             bytes memory withdrawCredential = IVaultFactory(vaultFactory).getValidatorWithdrawCredential(withdrawVault);



```

```
PermissionlessPool.fullDepositOnBeaconChain(address,address,address,uint256,uint256) (PermissionlessPool.sol#2584-2613) has external calls inside a loop: IPermissionlessNodeRegistry(_nodeRegistryAddress).updateDepositStatusAndBlock(_validatorId) (PermissionlessPool.sol#2611)



    
2611         IPermissionlessNodeRegistry(_nodeRegistryAddress).updateDepositStatusAndBlock(_validatorId);



```

```
PermissionlessPool.preDepositOnBeaconChain(bytes[],bytes[],uint256,uint256) (PermissionlessPool.sol#2428-2463) has external calls inside a loop: withdrawVault = IVaultFactory(vaultFactory).computeWithdrawVaultAddress(INodeRegistry((staderConfig).getPermissionlessNodeRegistry()).POOL_ID(),_operatorId,_operatorTotalKeys + i) (PermissionlessPool.sol#2438-2442)



    
2438             address withdrawVault = IVaultFactory(vaultFactory).computeWithdrawVaultAddress(
2439                 INodeRegistry((staderConfig).getPermissionlessNodeRegistry()).POOL_ID(),
2440                 _operatorId,
2441                 _operatorTotalKeys + i
2442             );



```

```
PermissionlessPool.preDepositOnBeaconChain(bytes[],bytes[],uint256,uint256) (PermissionlessPool.sol#2428-2463) has external calls inside a loop: IDepositContract(staderConfig.getETHDepositContract()).deposit{value: staderConfig.getPreDepositSize()}(_pubkey[i],withdrawCredential,_preDepositSignature[i],depositDataRoot) (PermissionlessPool.sol#2452-2457)



    
2452             IDepositContract(staderConfig.getETHDepositContract()).deposit{value: staderConfig.getPreDepositSize()}(
2453                 _pubkey[i],
2454                 withdrawCredential,
2455                 _preDepositSignature[i],
2456                 depositDataRoot
2457             );



```

### PoolSelector.sol


```
PoolSelector.poolAllocationForExcessETHDeposit(uint256) (PoolSelector.sol#2354-2389) has external calls inside a loop: poolCapacity = poolUtils.getQueuedValidatorCountByPool(poolIdArray[i]) (PoolSelector.sol#2369)



    
2369             uint256 poolCapacity = poolUtils.getQueuedValidatorCountByPool(poolIdArray[i]);



```

```
PoolSelector.poolAllocationForExcessETHDeposit(uint256) (PoolSelector.sol#2354-2389) has external calls inside a loop: poolDepositSize = ETH_PER_NODE - poolUtils.getCollateralETH(poolIdArray[i]) (PoolSelector.sol#2370)



    
2370             uint256 poolDepositSize = ETH_PER_NODE - poolUtils.getCollateralETH(poolIdArray[i]);



```

### PoolUtils.sol


```
PoolUtils.isExistingOperator(address) (PoolUtils.sol#2034-2043) has external calls inside a loop: INodeRegistry(nodeRegistry).isExistingOperator(_operAddr) (PoolUtils.sol#2038)



    
2038             if (INodeRegistry(nodeRegistry).isExistingOperator(_operAddr)) {



```

```
PoolUtils.getNodeRegistry(uint8) (PoolUtils.sol#2019-2021) has external calls inside a loop: IStaderPoolBase(poolAddressById[_poolId]).getNodeRegistry() (PoolUtils.sol#2020)



    
2020         return IStaderPoolBase(poolAddressById[_poolId]).getNodeRegistry();



```

```
PoolUtils.getOperatorPoolId(address) (PoolUtils.sol#2045-2054) has external calls inside a loop: INodeRegistry(nodeRegistry).isExistingOperator(_operAddr) (PoolUtils.sol#2049)



    
2049             if (INodeRegistry(nodeRegistry).isExistingOperator(_operAddr)) {



```

```
PoolUtils.getActiveValidatorCountByPool(uint8) (PoolUtils.sol#1981-1990) has external calls inside a loop: INodeRegistry(nodeRegistry).getTotalActiveValidatorCount() (PoolUtils.sol#1989)



    
1989         return INodeRegistry(nodeRegistry).getTotalActiveValidatorCount();



```

```
PoolUtils.getValidatorPoolId(bytes) (PoolUtils.sol#2056-2065) has external calls inside a loop: INodeRegistry(nodeRegistry).isExistingPubkey(_pubkey) (PoolUtils.sol#2060)



    
2060             if (INodeRegistry(nodeRegistry).isExistingPubkey(_pubkey)) {



```

```
PoolUtils.isExistingPubkey(bytes) (PoolUtils.sol#2023-2032) has external calls inside a loop: INodeRegistry(nodeRegistry).isExistingPubkey(_pubkey) (PoolUtils.sol#2027)



    
2027             if (INodeRegistry(nodeRegistry).isExistingPubkey(_pubkey)) {



```

### StaderStakePoolsManager.sol


```
StaderStakePoolsManager.depositETHOverTargetWeight() (StaderStakePoolsManager.sol#3805-3836) has external calls inside a loop: poolDepositSize = staderConfig.getStakedEthPerNode() - IPoolUtils(poolUtils).getCollateralETH(poolIdArray[i]) (StaderStakePoolsManager.sol#3828-3829)



    
3828             uint256 poolDepositSize = staderConfig.getStakedEthPerNode() -
3829                 IPoolUtils(poolUtils).getCollateralETH(poolIdArray[i]);



```

```
StaderStakePoolsManager.depositETHOverTargetWeight() (StaderStakePoolsManager.sol#3805-3836) has external calls inside a loop: poolAddress = IPoolUtils(poolUtils).poolAddressById(poolIdArray[i]) (StaderStakePoolsManager.sol#3827)



    
3827             address poolAddress = IPoolUtils(poolUtils).poolAddressById(poolIdArray[i]);



```

```
StaderStakePoolsManager.depositETHOverTargetWeight() (StaderStakePoolsManager.sol#3805-3836) has external calls inside a loop: IStaderPoolBase(poolAddress).stakeUserETHToBeaconChain{value: validatorToDeposit * poolDepositSize}() (StaderStakePoolsManager.sol#3833)



    
3833             IStaderPoolBase(poolAddress).stakeUserETHToBeaconChain{value: validatorToDeposit * poolDepositSize}();



```

### UserWithdrawalManager.sol


```
UserWithdrawalManager.finalizeUserWithdrawalRequest() (UserWithdrawalManager.sol#3583-3625) has external calls inside a loop: (ethToSendToFinalizeRequest + minEThRequiredToFinalizeRequest > pooledETH) || (userWithdrawInfo.requestBlock + staderConfig.getMinBlockDelayToFinalizeWithdrawRequest() > block.number) (UserWithdrawalManager.sol#3604-3606)



    
3604                 (ethToSendToFinalizeRequest + minEThRequiredToFinalizeRequest > pooledETH) ||
3605                 (userWithdrawInfo.requestBlock + staderConfig.getMinBlockDelayToFinalizeWithdrawRequest() >
3606                     block.number)



```

## reentrancy-benign
### Severity: Low

### Penalty.sol


```
Reentrancy in Penalty.updateTotalPenaltyAmount(bytes[]) (Penalty.sol#2457-2477):
	External calls:
	- totalPenalty = calculateMEVTheftPenalty(pubkeyRoot) + calculateMissedAttestationPenalty(pubkeyRoot) + additionalPenaltyAmount[pubkeyRoot] (Penalty.sol#2468)
		- IRatedV1(ratedOracleAddress).getViolationsForValidator(_pubkeyRoot).length * mevTheftPenaltyPerStrike (Penalty.sol#2484)
	State variables written after the call(s):
	- totalPenaltyAmount[_pubkey[i]] = totalPenalty (Penalty.sol#2469)



    
2468             uint256 totalPenalty = calculateMEVTheftPenalty(pubkeyRoot) + calculateMissedAttestationPenalty(pubkeyRoot) + additionalPenaltyAmount[pubkeyRoot];



    
2484         return IRatedV1(ratedOracleAddress).getViolationsForValidator(_pubkeyRoot).length * mevTheftPenaltyPerStrike;



    
2468             uint256 totalPenalty = calculateMEVTheftPenalty(pubkeyRoot) + calculateMissedAttestationPenalty(pubkeyRoot) + additionalPenaltyAmount[pubkeyRoot];



    
2484         return IRatedV1(ratedOracleAddress).getViolationsForValidator(_pubkeyRoot).length * mevTheftPenaltyPerStrike;



    
2469             totalPenaltyAmount[_pubkey[i]] = totalPenalty;



```

### PermissionedNodeRegistry.sol


```
Reentrancy in PermissionedNodeRegistry.onboardNodeOperator(string,address) (PermissionedNodeRegistry.sol#2537-2561):
	External calls:
	- IPoolUtils(poolUtils).onlyValidName(_operatorName) (PermissionedNodeRegistry.sol#2547)
	State variables written after the call(s):
	- onboardOperator(_operatorName,_operatorRewardAddress) (PermissionedNodeRegistry.sol#2559)
		- nextOperatorId ++ (PermissionedNodeRegistry.sol#3093)
	- onboardOperator(_operatorName,_operatorRewardAddress) (PermissionedNodeRegistry.sol#2559)
		- operatorIDByAddress[msg.sender] = nextOperatorId (PermissionedNodeRegistry.sol#3091)
	- onboardOperator(_operatorName,_operatorRewardAddress) (PermissionedNodeRegistry.sol#2559)
		- operatorStructById[nextOperatorId] = Operator(true,true,_operatorName,_operatorRewardAddress,msg.sender) (PermissionedNodeRegistry.sol#3090)
	- onboardOperator(_operatorName,_operatorRewardAddress) (PermissionedNodeRegistry.sol#2559)
		- socializingPoolStateChangeBlock[nextOperatorId] = block.number (PermissionedNodeRegistry.sol#3092)
	- onboardOperator(_operatorName,_operatorRewardAddress) (PermissionedNodeRegistry.sol#2559)
		- totalActiveOperatorCount ++ (PermissionedNodeRegistry.sol#3094)



    
2547         IPoolUtils(poolUtils).onlyValidName(_operatorName);



    
2547         IPoolUtils(poolUtils).onlyValidName(_operatorName);



    
2559         onboardOperator(_operatorName, _operatorRewardAddress);



    
3093         nextOperatorId++;



    
2559         onboardOperator(_operatorName, _operatorRewardAddress);



    
3091         operatorIDByAddress[msg.sender] = nextOperatorId;



    
2559         onboardOperator(_operatorName, _operatorRewardAddress);



    
3090         operatorStructById[nextOperatorId] = Operator(true, true, _operatorName, _operatorRewardAddress, msg.sender);



    
2559         onboardOperator(_operatorName, _operatorRewardAddress);



    
3092         socializingPoolStateChangeBlock[nextOperatorId] = block.number;



    
2559         onboardOperator(_operatorName, _operatorRewardAddress);



    
3094         totalActiveOperatorCount++;



```

```
Reentrancy in PermissionedNodeRegistry.addValidatorKeys(bytes[],bytes[],bytes[]) (PermissionedNodeRegistry.sol#2570-2611):
	External calls:
	- IPoolUtils(poolUtils).onlyValidKeys(_pubkey[i],_preDepositSignature[i],_depositSignature[i]) (PermissionedNodeRegistry.sol#2586)
	- withdrawVault = IVaultFactory(vaultFactory).deployWithdrawVault(POOL_ID,operatorId,operatorTotalKeys + i,nextValidatorId) (PermissionedNodeRegistry.sol#2587-2592)
	State variables written after the call(s):
	- validatorIdByPubkey[_pubkey[i]] = nextValidatorId (PermissionedNodeRegistry.sol#2603)



    
2586             IPoolUtils(poolUtils).onlyValidKeys(_pubkey[i], _preDepositSignature[i], _depositSignature[i]);



    
2587             address withdrawVault = IVaultFactory(vaultFactory).deployWithdrawVault(
2588                 POOL_ID,
2589                 operatorId,
2590                 operatorTotalKeys + i, //operator totalKeys
2591                 nextValidatorId
2592             );



    
2586             IPoolUtils(poolUtils).onlyValidKeys(_pubkey[i], _preDepositSignature[i], _depositSignature[i]);



    
2587             address withdrawVault = IVaultFactory(vaultFactory).deployWithdrawVault(
2588                 POOL_ID,
2589                 operatorId,
2590                 operatorTotalKeys + i, //operator totalKeys
2591                 nextValidatorId
2592             );



    
2603             validatorIdByPubkey[_pubkey[i]] = nextValidatorId;



```

```
Reentrancy in PermissionedNodeRegistry.withdrawnValidators(bytes[]) (PermissionedNodeRegistry.sol#2741-2761):
	External calls:
	- IValidatorWithdrawalVault(validatorRegistry[validatorId].withdrawVaultAddress).settleFunds() (PermissionedNodeRegistry.sol#2754)
	State variables written after the call(s):
	- decreaseTotalActiveValidatorCount(withdrawnValidatorCount) (PermissionedNodeRegistry.sol#2760)
		- totalActiveValidatorCount -= _count (PermissionedNodeRegistry.sol#3176)



    
2754             IValidatorWithdrawalVault(validatorRegistry[validatorId].withdrawVaultAddress).settleFunds();



    
2754             IValidatorWithdrawalVault(validatorRegistry[validatorId].withdrawVaultAddress).settleFunds();



    
2760         decreaseTotalActiveValidatorCount(withdrawnValidatorCount);



    
3176         totalActiveValidatorCount -= _count;



```

```
Reentrancy in PermissionedNodeRegistry.updateOperatorDetails(string,address) (PermissionedNodeRegistry.sol#2831-2839):
	External calls:
	- IPoolUtils(staderConfig.getPoolUtils()).onlyValidName(_operatorName) (PermissionedNodeRegistry.sol#2832)
	State variables written after the call(s):
	- operatorStructById[operatorId].operatorName = _operatorName (PermissionedNodeRegistry.sol#2836)
	- operatorStructById[operatorId].operatorRewardAddress = _rewardAddress (PermissionedNodeRegistry.sol#2837)



    
2832         IPoolUtils(staderConfig.getPoolUtils()).onlyValidName(_operatorName);



    
2832         IPoolUtils(staderConfig.getPoolUtils()).onlyValidName(_operatorName);



    
2836         operatorStructById[operatorId].operatorName = _operatorName;



    
2837         operatorStructById[operatorId].operatorRewardAddress = _rewardAddress;



```

### PermissionlessNodeRegistry.sol


```
Reentrancy in PermissionlessNodeRegistry.markValidatorReadyToDeposit(bytes[],bytes[],bytes[]) (PermissionlessNodeRegistry.sol#2444-2495):
	External calls:
	- IStaderInsuranceFund(staderConfig.getStaderInsuranceFund()).depositFund{value: frontRunValidatorsLength * FRONT_RUN_PENALTY}() (PermissionlessNodeRegistry.sol#2471-2473)
	State variables written after the call(s):
	- handleFrontRun(validatorId_scope_1) (PermissionlessNodeRegistry.sol#2479)
		- operatorStructById[validatorRegistry[_validatorId].operatorId].active = false (PermissionlessNodeRegistry.sol#2889)



    
2471             IStaderInsuranceFund(staderConfig.getStaderInsuranceFund()).depositFund{
2472                 value: frontRunValidatorsLength * FRONT_RUN_PENALTY
2473             }();



    
2479             handleFrontRun(validatorId);



    
2889         operatorStructById[validatorRegistry[_validatorId].operatorId].active = false;



```

```
Reentrancy in PermissionlessNodeRegistry.updateOperatorDetails(string,address) (PermissionlessNodeRegistry.sol#2627-2635):
	External calls:
	- IPoolUtils(staderConfig.getPoolUtils()).onlyValidName(_operatorName) (PermissionlessNodeRegistry.sol#2628)
	State variables written after the call(s):
	- operatorStructById[operatorId].operatorName = _operatorName (PermissionlessNodeRegistry.sol#2632)
	- operatorStructById[operatorId].operatorRewardAddress = _rewardAddress (PermissionlessNodeRegistry.sol#2633)



    
2628         IPoolUtils(staderConfig.getPoolUtils()).onlyValidName(_operatorName);



    
2628         IPoolUtils(staderConfig.getPoolUtils()).onlyValidName(_operatorName);



    
2632         operatorStructById[operatorId].operatorName = _operatorName;



    
2633         operatorStructById[operatorId].operatorRewardAddress = _rewardAddress;



```

```
Reentrancy in PermissionlessNodeRegistry.onboardNodeOperator(bool,string,address) (PermissionlessNodeRegistry.sol#2350-2377):
	External calls:
	- IPoolUtils(poolUtils).onlyValidName(_operatorName) (PermissionlessNodeRegistry.sol#2359)
	- nodeELRewardVault = IVaultFactory(staderConfig.getVaultFactory()).deployNodeELRewardVault(POOL_ID,nextOperatorId) (PermissionlessNodeRegistry.sol#2367-2370)
	State variables written after the call(s):
	- nodeELRewardVaultByOperatorId[nextOperatorId] = nodeELRewardVault (PermissionlessNodeRegistry.sol#2371)
	- onboardOperator(_optInForSocializingPool,_operatorName,_operatorRewardAddress) (PermissionlessNodeRegistry.sol#2375)
		- operatorIDByAddress[msg.sender] = nextOperatorId (PermissionlessNodeRegistry.sol#2871)
	- onboardOperator(_optInForSocializingPool,_operatorName,_operatorRewardAddress) (PermissionlessNodeRegistry.sol#2375)
		- operatorStructById[nextOperatorId] = Operator(true,_optInForSocializingPool,_operatorName,_operatorRewardAddress,msg.sender) (PermissionlessNodeRegistry.sol#2864-2870)
	- onboardOperator(_optInForSocializingPool,_operatorName,_operatorRewardAddress) (PermissionlessNodeRegistry.sol#2375)
		- socializingPoolStateChangeBlock[nextOperatorId] = block.number (PermissionlessNodeRegistry.sol#2872)



    
2359         IPoolUtils(poolUtils).onlyValidName(_operatorName);



    
2367         address nodeELRewardVault = IVaultFactory(staderConfig.getVaultFactory()).deployNodeELRewardVault(
2368             POOL_ID,
2369             nextOperatorId
2370         );



    
2359         IPoolUtils(poolUtils).onlyValidName(_operatorName);



    
2367         address nodeELRewardVault = IVaultFactory(staderConfig.getVaultFactory()).deployNodeELRewardVault(
2368             POOL_ID,
2369             nextOperatorId
2370         );



    
2371         nodeELRewardVaultByOperatorId[nextOperatorId] = nodeELRewardVault;



    
2375         onboardOperator(_optInForSocializingPool, _operatorName, _operatorRewardAddress);



    
2871         operatorIDByAddress[msg.sender] = nextOperatorId;



    
2375         onboardOperator(_optInForSocializingPool, _operatorName, _operatorRewardAddress);



    
2864         operatorStructById[nextOperatorId] = Operator(
2865             true,
2866             _optInForSocializingPool,
2867             _operatorName,
2868             _operatorRewardAddress,
2869             msg.sender
2870         );



    
2375         onboardOperator(_optInForSocializingPool, _operatorName, _operatorRewardAddress);



    
2872         socializingPoolStateChangeBlock[nextOperatorId] = block.number;



```

```
Reentrancy in PermissionlessNodeRegistry.withdrawnValidators(bytes[]) (PermissionlessNodeRegistry.sol#2502-2522):
	External calls:
	- IValidatorWithdrawalVault(validatorRegistry[validatorId].withdrawVaultAddress).settleFunds() (PermissionlessNodeRegistry.sol#2515)
	State variables written after the call(s):
	- decreaseTotalActiveValidatorCount(withdrawnValidatorCount) (PermissionlessNodeRegistry.sol#2521)
		- totalActiveValidatorCount -= _count (PermissionlessNodeRegistry.sol#2968)



    
2515             IValidatorWithdrawalVault(validatorRegistry[validatorId].withdrawVaultAddress).settleFunds();



    
2515             IValidatorWithdrawalVault(validatorRegistry[validatorId].withdrawVaultAddress).settleFunds();



    
2521         decreaseTotalActiveValidatorCount(withdrawnValidatorCount);



    
2968         totalActiveValidatorCount -= _count;



```

```
Reentrancy in PermissionlessNodeRegistry.addValidatorKeys(bytes[],bytes[],bytes[]) (PermissionlessNodeRegistry.sol#2386-2433):
	External calls:
	- IPoolUtils(poolUtils).onlyValidKeys(_pubkey[i],_preDepositSignature[i],_depositSignature[i]) (PermissionlessNodeRegistry.sol#2402)
	- withdrawVault = IVaultFactory(vaultFactory).deployWithdrawVault(POOL_ID,operatorId,operatorTotalKeys + i,nextValidatorId) (PermissionlessNodeRegistry.sol#2403-2408)
	State variables written after the call(s):
	- validatorIdByPubkey[_pubkey[i]] = nextValidatorId (PermissionlessNodeRegistry.sol#2420)



    
2402             IPoolUtils(poolUtils).onlyValidKeys(_pubkey[i], _preDepositSignature[i], _depositSignature[i]);



    
2403             address withdrawVault = IVaultFactory(vaultFactory).deployWithdrawVault(
2404                 POOL_ID,
2405                 operatorId,
2406                 operatorTotalKeys + i, //operator totalKeys
2407                 nextValidatorId
2408             );



    
2402             IPoolUtils(poolUtils).onlyValidKeys(_pubkey[i], _preDepositSignature[i], _depositSignature[i]);



    
2403             address withdrawVault = IVaultFactory(vaultFactory).deployWithdrawVault(
2404                 POOL_ID,
2405                 operatorId,
2406                 operatorTotalKeys + i, //operator totalKeys
2407                 nextValidatorId
2408             );



    
2420             validatorIdByPubkey[_pubkey[i]] = nextValidatorId;



```

### SocializingPool.sol


```
Reentrancy in SocializingPool.claim(uint256[],uint256[],uint256[],bytes32[][]) (SocializingPool.sol#2618-2646):
	External calls:
	- (success,None) = address(operatorRewardsAddr).call{value: totalAmountETH}() (SocializingPool.sol#2632)
	State variables written after the call(s):
	- totalOperatorSDRewardsRemaining -= totalAmountSD (SocializingPool.sol#2639)



    
2632             (success, ) = payable(operatorRewardsAddr).call{value: totalAmountETH}('');



    
2639             totalOperatorSDRewardsRemaining -= totalAmountSD;



```

### UserWithdrawalManager.sol


```
Reentrancy in UserWithdrawalManager.requestWithdraw(uint256,address) (UserWithdrawalManager.sol#3561-3577):
	External calls:
	- IERC20Upgradeable(staderConfig.getETHxToken()).safeTransferFrom(msg.sender,(address(this)),_ethXAmount) (UserWithdrawalManager.sol#3570)
	State variables written after the call(s):
	- ethRequestedForWithdraw += assets (UserWithdrawalManager.sol#3571)
	- nextRequestId ++ (UserWithdrawalManager.sol#3575)
	- userWithdrawRequests[nextRequestId] = UserWithdrawInfo(address(_owner),_ethXAmount,assets,0,block.number) (UserWithdrawalManager.sol#3572)



    
3570         IERC20Upgradeable(staderConfig.getETHxToken()).safeTransferFrom(msg.sender, (address(this)), _ethXAmount);



    
3570         IERC20Upgradeable(staderConfig.getETHxToken()).safeTransferFrom(msg.sender, (address(this)), _ethXAmount);



    
3571         ethRequestedForWithdraw += assets;



    
3575         nextRequestId++;



    
3572         userWithdrawRequests[nextRequestId] = UserWithdrawInfo(payable(_owner), _ethXAmount, assets, 0, block.number);



```

### ValidatorWithdrawalVault.sol


```
Reentrancy in ValidatorWithdrawalVault.settleFunds() (ValidatorWithdrawalVault.sol#1205-1234):
	External calls:
	- penaltyAmount = getUpdatedPenaltyAmount(poolId,validatorId,staderConfig) (ValidatorWithdrawalVault.sol#1215)
		- IPenalty(_staderConfig.getPenaltyContract()).updateTotalPenaltyAmount(pubkeyArray) (ValidatorWithdrawalVault.sol#1299)
	- ISDCollateral(staderConfig.getSDCollateral()).slashValidatorSD(validatorId,poolId) (ValidatorWithdrawalVault.sol#1218)
	State variables written after the call(s):
	- vaultSettleStatus = true (ValidatorWithdrawalVault.sol#1226)



    
1215         uint256 penaltyAmount = getUpdatedPenaltyAmount(poolId, validatorId, staderConfig);



    
1299         IPenalty(_staderConfig.getPenaltyContract()).updateTotalPenaltyAmount(pubkeyArray);



    
1218             ISDCollateral(staderConfig.getSDCollateral()).slashValidatorSD(validatorId, poolId);



    
1215         uint256 penaltyAmount = getUpdatedPenaltyAmount(poolId, validatorId, staderConfig);



    
1299         IPenalty(_staderConfig.getPenaltyContract()).updateTotalPenaltyAmount(pubkeyArray);



    
1218             ISDCollateral(staderConfig.getSDCollateral()).slashValidatorSD(validatorId, poolId);



    
1226         vaultSettleStatus = true;



```

## assembly
### Severity: Informational

### Auction.sol


```
StringsUpgradeable.toString(uint256) (Auction.sol#1662-1682) uses assembly
	- INLINE ASM (Auction.sol#1668-1670)
	- INLINE ASM (Auction.sol#1674-1676)



    
1668             assembly {
1669                 ptr := add(buffer, add(32, length))
1670             }



    
1674                 assembly {
1675                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
1676                 }



```

```
AddressUpgradeable._revert(bytes,string) (Auction.sol#1101-1113) uses assembly
	- INLINE ASM (Auction.sol#1106-1109)



    
1106             assembly {
1107                 let returndata_size := mload(returndata)
1108                 revert(add(32, returndata), returndata_size)
1109             }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (Auction.sol#1360-1440) uses assembly
	- INLINE ASM (Auction.sol#1371-1375)
	- INLINE ASM (Auction.sol#1391-1398)
	- INLINE ASM (Auction.sol#1405-1414)



    
1371             assembly {
1372                 let mm := mulmod(x, y, not(0))
1373                 prod0 := mul(x, y)
1374                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1375             }



    
1391             assembly {
1392                 // Compute remainder using mulmod.
1393                 remainder := mulmod(x, y, denominator)
1394 
1395                 // Subtract 256 bit number from 512 bit number.
1396                 prod1 := sub(prod1, gt(remainder, prod0))
1397                 prod0 := sub(prod0, remainder)
1398             }



    
1405             assembly {
1406                 // Divide denominator by twos.
1407                 denominator := div(denominator, twos)
1408 
1409                 // Divide [prod1 prod0] by twos.
1410                 prod0 := div(prod0, twos)
1411 
1412                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1413                 twos := add(div(sub(0, twos), twos), 1)
1414             }



```

### ETHx.sol


```
StringsUpgradeable.toString(uint256) (ETHx.sol#1955-1975) uses assembly
	- INLINE ASM (ETHx.sol#1961-1963)
	- INLINE ASM (ETHx.sol#1967-1969)



    
1961             assembly {
1962                 ptr := add(buffer, add(32, length))
1963             }



    
1967                 assembly {
1968                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
1969                 }



```

```
AddressUpgradeable._revert(bytes,string) (ETHx.sol#914-926) uses assembly
	- INLINE ASM (ETHx.sol#919-922)



    
919             assembly {
920                 let returndata_size := mload(returndata)
921                 revert(add(32, returndata), returndata_size)
922             }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (ETHx.sol#1653-1733) uses assembly
	- INLINE ASM (ETHx.sol#1664-1668)
	- INLINE ASM (ETHx.sol#1684-1691)
	- INLINE ASM (ETHx.sol#1698-1707)



    
1664             assembly {
1665                 let mm := mulmod(x, y, not(0))
1666                 prod0 := mul(x, y)
1667                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1668             }



    
1684             assembly {
1685                 // Compute remainder using mulmod.
1686                 remainder := mulmod(x, y, denominator)
1687 
1688                 // Subtract 256 bit number from 512 bit number.
1689                 prod1 := sub(prod1, gt(remainder, prod0))
1690                 prod0 := sub(prod0, remainder)
1691             }



    
1698             assembly {
1699                 // Divide denominator by twos.
1700                 denominator := div(denominator, twos)
1701 
1702                 // Divide [prod1 prod0] by twos.
1703                 prod0 := div(prod0, twos)
1704 
1705                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1706                 twos := add(div(sub(0, twos), twos), 1)
1707             }



```

### OperatorRewardsCollector.sol


```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (OperatorRewardsCollector.sol#1168-1248) uses assembly
	- INLINE ASM (OperatorRewardsCollector.sol#1179-1183)
	- INLINE ASM (OperatorRewardsCollector.sol#1199-1206)
	- INLINE ASM (OperatorRewardsCollector.sol#1213-1222)



    
1179             assembly {
1180                 let mm := mulmod(x, y, not(0))
1181                 prod0 := mul(x, y)
1182                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1183             }



    
1199             assembly {
1200                 // Compute remainder using mulmod.
1201                 remainder := mulmod(x, y, denominator)
1202 
1203                 // Subtract 256 bit number from 512 bit number.
1204                 prod1 := sub(prod1, gt(remainder, prod0))
1205                 prod0 := sub(prod0, remainder)
1206             }



    
1213             assembly {
1214                 // Divide denominator by twos.
1215                 denominator := div(denominator, twos)
1216 
1217                 // Divide [prod1 prod0] by twos.
1218                 prod0 := div(prod0, twos)
1219 
1220                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1221                 twos := add(div(sub(0, twos), twos), 1)
1222             }



```

```
StringsUpgradeable.toString(uint256) (OperatorRewardsCollector.sol#1470-1490) uses assembly
	- INLINE ASM (OperatorRewardsCollector.sol#1476-1478)
	- INLINE ASM (OperatorRewardsCollector.sol#1482-1484)



    
1476             assembly {
1477                 ptr := add(buffer, add(32, length))
1478             }



    
1482                 assembly {
1483                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
1484                 }



```

```
AddressUpgradeable._revert(bytes,string) (OperatorRewardsCollector.sol#909-921) uses assembly
	- INLINE ASM (OperatorRewardsCollector.sol#914-917)



    
914             assembly {
915                 let returndata_size := mload(returndata)
916                 revert(add(32, returndata), returndata_size)
917             }



```

### Penalty.sol


```
AddressUpgradeable._revert(bytes,string) (Penalty.sol#1371-1383) uses assembly
	- INLINE ASM (Penalty.sol#1376-1379)



    
1376             assembly {
1377                 let returndata_size := mload(returndata)
1378                 revert(add(32, returndata), returndata_size)
1379             }



```

```
StringsUpgradeable.toString(uint256) (Penalty.sol#1932-1952) uses assembly
	- INLINE ASM (Penalty.sol#1938-1940)
	- INLINE ASM (Penalty.sol#1944-1946)



    
1938             assembly {
1939                 ptr := add(buffer, add(32, length))
1940             }



    
1944                 assembly {
1945                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
1946                 }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (Penalty.sol#1630-1710) uses assembly
	- INLINE ASM (Penalty.sol#1641-1645)
	- INLINE ASM (Penalty.sol#1661-1668)
	- INLINE ASM (Penalty.sol#1675-1684)



    
1641             assembly {
1642                 let mm := mulmod(x, y, not(0))
1643                 prod0 := mul(x, y)
1644                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1645             }



    
1661             assembly {
1662                 // Compute remainder using mulmod.
1663                 remainder := mulmod(x, y, denominator)
1664 
1665                 // Subtract 256 bit number from 512 bit number.
1666                 prod1 := sub(prod1, gt(remainder, prod0))
1667                 prod0 := sub(prod0, remainder)
1668             }



    
1675             assembly {
1676                 // Divide denominator by twos.
1677                 denominator := div(denominator, twos)
1678 
1679                 // Divide [prod1 prod0] by twos.
1680                 prod0 := div(prod0, twos)
1681 
1682                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1683                 twos := add(div(sub(0, twos), twos), 1)
1684             }



```

### PermissionedNodeRegistry.sol


```
StringsUpgradeable.toString(uint256) (PermissionedNodeRegistry.sol#2010-2030) uses assembly
	- INLINE ASM (PermissionedNodeRegistry.sol#2016-2018)
	- INLINE ASM (PermissionedNodeRegistry.sol#2022-2024)



    
2016             assembly {
2017                 ptr := add(buffer, add(32, length))
2018             }



    
2022                 assembly {
2023                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
2024                 }



```

```
AddressUpgradeable._revert(bytes,string) (PermissionedNodeRegistry.sol#1251-1263) uses assembly
	- INLINE ASM (PermissionedNodeRegistry.sol#1256-1259)



    
1256             assembly {
1257                 let returndata_size := mload(returndata)
1258                 revert(add(32, returndata), returndata_size)
1259             }



```

```
PermissionedNodeRegistry.getAllActiveValidators(uint256,uint256) (PermissionedNodeRegistry.sol#3012-3038) uses assembly
	- INLINE ASM (PermissionedNodeRegistry.sol#3033-3035)



    
3033         assembly {
3034             mstore(validators, validatorCount)
3035         }



```

```
Math.mulDiv(uint256,uint256,uint256) (PermissionedNodeRegistry.sol#870-950) uses assembly
	- INLINE ASM (PermissionedNodeRegistry.sol#881-885)
	- INLINE ASM (PermissionedNodeRegistry.sol#901-908)
	- INLINE ASM (PermissionedNodeRegistry.sol#915-924)



    
881             assembly {
882                 let mm := mulmod(x, y, not(0))
883                 prod0 := mul(x, y)
884                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
885             }



    
901             assembly {
902                 // Compute remainder using mulmod.
903                 remainder := mulmod(x, y, denominator)
904 
905                 // Subtract 256 bit number from 512 bit number.
906                 prod1 := sub(prod1, gt(remainder, prod0))
907                 prod0 := sub(prod0, remainder)
908             }



    
915             assembly {
916                 // Divide denominator by twos.
917                 denominator := div(denominator, twos)
918 
919                 // Divide [prod1 prod0] by twos.
920                 prod0 := div(prod0, twos)
921 
922                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
923                 twos := add(div(sub(0, twos), twos), 1)
924             }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionedNodeRegistry.sol#1708-1788) uses assembly
	- INLINE ASM (PermissionedNodeRegistry.sol#1719-1723)
	- INLINE ASM (PermissionedNodeRegistry.sol#1739-1746)
	- INLINE ASM (PermissionedNodeRegistry.sol#1753-1762)



    
1719             assembly {
1720                 let mm := mulmod(x, y, not(0))
1721                 prod0 := mul(x, y)
1722                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1723             }



    
1739             assembly {
1740                 // Compute remainder using mulmod.
1741                 remainder := mulmod(x, y, denominator)
1742 
1743                 // Subtract 256 bit number from 512 bit number.
1744                 prod1 := sub(prod1, gt(remainder, prod0))
1745                 prod0 := sub(prod0, remainder)
1746             }



    
1753             assembly {
1754                 // Divide denominator by twos.
1755                 denominator := div(denominator, twos)
1756 
1757                 // Divide [prod1 prod0] by twos.
1758                 prod0 := div(prod0, twos)
1759 
1760                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1761                 twos := add(div(sub(0, twos), twos), 1)
1762             }



```

### PermissionedPool.sol


```
AddressUpgradeable._revert(bytes,string) (PermissionedPool.sol#1374-1386) uses assembly
	- INLINE ASM (PermissionedPool.sol#1379-1382)



    
1379             assembly {
1380                 let returndata_size := mload(returndata)
1381                 revert(add(32, returndata), returndata_size)
1382             }



```

```
Math.mulDiv(uint256,uint256,uint256) (PermissionedPool.sol#907-987) uses assembly
	- INLINE ASM (PermissionedPool.sol#918-922)
	- INLINE ASM (PermissionedPool.sol#938-945)
	- INLINE ASM (PermissionedPool.sol#952-961)



    
918             assembly {
919                 let mm := mulmod(x, y, not(0))
920                 prod0 := mul(x, y)
921                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
922             }



    
938             assembly {
939                 // Compute remainder using mulmod.
940                 remainder := mulmod(x, y, denominator)
941 
942                 // Subtract 256 bit number from 512 bit number.
943                 prod1 := sub(prod1, gt(remainder, prod0))
944                 prod0 := sub(prod0, remainder)
945             }



    
952             assembly {
953                 // Divide denominator by twos.
954                 denominator := div(denominator, twos)
955 
956                 // Divide [prod1 prod0] by twos.
957                 prod0 := div(prod0, twos)
958 
959                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
960                 twos := add(div(sub(0, twos), twos), 1)
961             }



```

```
StringsUpgradeable.toString(uint256) (PermissionedPool.sol#1935-1955) uses assembly
	- INLINE ASM (PermissionedPool.sol#1941-1943)
	- INLINE ASM (PermissionedPool.sol#1947-1949)



    
1941             assembly {
1942                 ptr := add(buffer, add(32, length))
1943             }



    
1947                 assembly {
1948                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
1949                 }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionedPool.sol#1633-1713) uses assembly
	- INLINE ASM (PermissionedPool.sol#1644-1648)
	- INLINE ASM (PermissionedPool.sol#1664-1671)
	- INLINE ASM (PermissionedPool.sol#1678-1687)



    
1644             assembly {
1645                 let mm := mulmod(x, y, not(0))
1646                 prod0 := mul(x, y)
1647                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1648             }



    
1664             assembly {
1665                 // Compute remainder using mulmod.
1666                 remainder := mulmod(x, y, denominator)
1667 
1668                 // Subtract 256 bit number from 512 bit number.
1669                 prod1 := sub(prod1, gt(remainder, prod0))
1670                 prod0 := sub(prod0, remainder)
1671             }



    
1678             assembly {
1679                 // Divide denominator by twos.
1680                 denominator := div(denominator, twos)
1681 
1682                 // Divide [prod1 prod0] by twos.
1683                 prod0 := div(prod0, twos)
1684 
1685                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1686                 twos := add(div(sub(0, twos), twos), 1)
1687             }



```

### PermissionlessNodeRegistry.sol


```
PermissionlessNodeRegistry.getAllActiveValidators(uint256,uint256) (PermissionlessNodeRegistry.sol#2751-2777) uses assembly
	- INLINE ASM (PermissionlessNodeRegistry.sol#2772-2774)



    
2772         assembly {
2773             mstore(validators, validatorCount)
2774         }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionlessNodeRegistry.sol#1540-1620) uses assembly
	- INLINE ASM (PermissionlessNodeRegistry.sol#1551-1555)
	- INLINE ASM (PermissionlessNodeRegistry.sol#1571-1578)
	- INLINE ASM (PermissionlessNodeRegistry.sol#1585-1594)



    
1551             assembly {
1552                 let mm := mulmod(x, y, not(0))
1553                 prod0 := mul(x, y)
1554                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1555             }



    
1571             assembly {
1572                 // Compute remainder using mulmod.
1573                 remainder := mulmod(x, y, denominator)
1574 
1575                 // Subtract 256 bit number from 512 bit number.
1576                 prod1 := sub(prod1, gt(remainder, prod0))
1577                 prod0 := sub(prod0, remainder)
1578             }



    
1585             assembly {
1586                 // Divide denominator by twos.
1587                 denominator := div(denominator, twos)
1588 
1589                 // Divide [prod1 prod0] by twos.
1590                 prod0 := div(prod0, twos)
1591 
1592                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1593                 twos := add(div(sub(0, twos), twos), 1)
1594             }



```

```
PermissionlessNodeRegistry.getNodeELVaultAddressForOptOutOperators(uint256,uint256) (PermissionlessNodeRegistry.sol#2820-2847) uses assembly
	- INLINE ASM (PermissionlessNodeRegistry.sol#2842-2844)



    
2842         assembly {
2843             mstore(nodeELRewardVault, optOutOperatorCount)
2844         }



```

```
AddressUpgradeable._revert(bytes,string) (PermissionlessNodeRegistry.sol#1083-1095) uses assembly
	- INLINE ASM (PermissionlessNodeRegistry.sol#1088-1091)



    
1088             assembly {
1089                 let returndata_size := mload(returndata)
1090                 revert(add(32, returndata), returndata_size)
1091             }



```

```
StringsUpgradeable.toString(uint256) (PermissionlessNodeRegistry.sol#1842-1862) uses assembly
	- INLINE ASM (PermissionlessNodeRegistry.sol#1848-1850)
	- INLINE ASM (PermissionlessNodeRegistry.sol#1854-1856)



    
1848             assembly {
1849                 ptr := add(buffer, add(32, length))
1850             }



    
1854                 assembly {
1855                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
1856                 }



```

### PermissionlessPool.sol


```
AddressUpgradeable._revert(bytes,string) (PermissionlessPool.sol#1359-1371) uses assembly
	- INLINE ASM (PermissionlessPool.sol#1364-1367)



    
1364             assembly {
1365                 let returndata_size := mload(returndata)
1366                 revert(add(32, returndata), returndata_size)
1367             }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionlessPool.sol#1618-1698) uses assembly
	- INLINE ASM (PermissionlessPool.sol#1629-1633)
	- INLINE ASM (PermissionlessPool.sol#1649-1656)
	- INLINE ASM (PermissionlessPool.sol#1663-1672)



    
1629             assembly {
1630                 let mm := mulmod(x, y, not(0))
1631                 prod0 := mul(x, y)
1632                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1633             }



    
1649             assembly {
1650                 // Compute remainder using mulmod.
1651                 remainder := mulmod(x, y, denominator)
1652 
1653                 // Subtract 256 bit number from 512 bit number.
1654                 prod1 := sub(prod1, gt(remainder, prod0))
1655                 prod0 := sub(prod0, remainder)
1656             }



    
1663             assembly {
1664                 // Divide denominator by twos.
1665                 denominator := div(denominator, twos)
1666 
1667                 // Divide [prod1 prod0] by twos.
1668                 prod0 := div(prod0, twos)
1669 
1670                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1671                 twos := add(div(sub(0, twos), twos), 1)
1672             }



```

```
StringsUpgradeable.toString(uint256) (PermissionlessPool.sol#1920-1940) uses assembly
	- INLINE ASM (PermissionlessPool.sol#1926-1928)
	- INLINE ASM (PermissionlessPool.sol#1932-1934)



    
1926             assembly {
1927                 ptr := add(buffer, add(32, length))
1928             }



    
1932                 assembly {
1933                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
1934                 }



```

```
Math.mulDiv(uint256,uint256,uint256) (PermissionlessPool.sol#892-972) uses assembly
	- INLINE ASM (PermissionlessPool.sol#903-907)
	- INLINE ASM (PermissionlessPool.sol#923-930)
	- INLINE ASM (PermissionlessPool.sol#937-946)



    
903             assembly {
904                 let mm := mulmod(x, y, not(0))
905                 prod0 := mul(x, y)
906                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
907             }



    
923             assembly {
924                 // Compute remainder using mulmod.
925                 remainder := mulmod(x, y, denominator)
926 
927                 // Subtract 256 bit number from 512 bit number.
928                 prod1 := sub(prod1, gt(remainder, prod0))
929                 prod0 := sub(prod0, remainder)
930             }



    
937             assembly {
938                 // Divide denominator by twos.
939                 denominator := div(denominator, twos)
940 
941                 // Divide [prod1 prod0] by twos.
942                 prod0 := div(prod0, twos)
943 
944                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
945                 twos := add(div(sub(0, twos), twos), 1)
946             }



```

### PoolSelector.sol


```
AddressUpgradeable._revert(bytes,string) (PoolSelector.sol#1367-1379) uses assembly
	- INLINE ASM (PoolSelector.sol#1372-1375)



    
1372             assembly {
1373                 let returndata_size := mload(returndata)
1374                 revert(add(32, returndata), returndata_size)
1375             }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PoolSelector.sol#1626-1706) uses assembly
	- INLINE ASM (PoolSelector.sol#1637-1641)
	- INLINE ASM (PoolSelector.sol#1657-1664)
	- INLINE ASM (PoolSelector.sol#1671-1680)



    
1637             assembly {
1638                 let mm := mulmod(x, y, not(0))
1639                 prod0 := mul(x, y)
1640                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1641             }



    
1657             assembly {
1658                 // Compute remainder using mulmod.
1659                 remainder := mulmod(x, y, denominator)
1660 
1661                 // Subtract 256 bit number from 512 bit number.
1662                 prod1 := sub(prod1, gt(remainder, prod0))
1663                 prod0 := sub(prod0, remainder)
1664             }



    
1671             assembly {
1672                 // Divide denominator by twos.
1673                 denominator := div(denominator, twos)
1674 
1675                 // Divide [prod1 prod0] by twos.
1676                 prod0 := div(prod0, twos)
1677 
1678                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1679                 twos := add(div(sub(0, twos), twos), 1)
1680             }



```

```
Math.mulDiv(uint256,uint256,uint256) (PoolSelector.sol#675-755) uses assembly
	- INLINE ASM (PoolSelector.sol#686-690)
	- INLINE ASM (PoolSelector.sol#706-713)
	- INLINE ASM (PoolSelector.sol#720-729)



    
686             assembly {
687                 let mm := mulmod(x, y, not(0))
688                 prod0 := mul(x, y)
689                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
690             }



    
706             assembly {
707                 // Compute remainder using mulmod.
708                 remainder := mulmod(x, y, denominator)
709 
710                 // Subtract 256 bit number from 512 bit number.
711                 prod1 := sub(prod1, gt(remainder, prod0))
712                 prod0 := sub(prod0, remainder)
713             }



    
720             assembly {
721                 // Divide denominator by twos.
722                 denominator := div(denominator, twos)
723 
724                 // Divide [prod1 prod0] by twos.
725                 prod0 := div(prod0, twos)
726 
727                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
728                 twos := add(div(sub(0, twos), twos), 1)
729             }



```

```
StringsUpgradeable.toString(uint256) (PoolSelector.sol#1928-1948) uses assembly
	- INLINE ASM (PoolSelector.sol#1934-1936)
	- INLINE ASM (PoolSelector.sol#1940-1942)



    
1934             assembly {
1935                 ptr := add(buffer, add(32, length))
1936             }



    
1940                 assembly {
1941                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
1942                 }



```

### PoolUtils.sol


```
StringsUpgradeable.toString(uint256) (PoolUtils.sol#1505-1525) uses assembly
	- INLINE ASM (PoolUtils.sol#1511-1513)
	- INLINE ASM (PoolUtils.sol#1517-1519)



    
1511             assembly {
1512                 ptr := add(buffer, add(32, length))
1513             }



    
1517                 assembly {
1518                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
1519                 }



```

```
AddressUpgradeable._revert(bytes,string) (PoolUtils.sol#944-956) uses assembly
	- INLINE ASM (PoolUtils.sol#949-952)



    
949             assembly {
950                 let returndata_size := mload(returndata)
951                 revert(add(32, returndata), returndata_size)
952             }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PoolUtils.sol#1203-1283) uses assembly
	- INLINE ASM (PoolUtils.sol#1214-1218)
	- INLINE ASM (PoolUtils.sol#1234-1241)
	- INLINE ASM (PoolUtils.sol#1248-1257)



    
1214             assembly {
1215                 let mm := mulmod(x, y, not(0))
1216                 prod0 := mul(x, y)
1217                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1218             }



    
1234             assembly {
1235                 // Compute remainder using mulmod.
1236                 remainder := mulmod(x, y, denominator)
1237 
1238                 // Subtract 256 bit number from 512 bit number.
1239                 prod1 := sub(prod1, gt(remainder, prod0))
1240                 prod0 := sub(prod0, remainder)
1241             }



    
1248             assembly {
1249                 // Divide denominator by twos.
1250                 denominator := div(denominator, twos)
1251 
1252                 // Divide [prod1 prod0] by twos.
1253                 prod0 := div(prod0, twos)
1254 
1255                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1256                 twos := add(div(sub(0, twos), twos), 1)
1257             }



```

### SDCollateral.sol


```
StringsUpgradeable.toString(uint256) (SDCollateral.sol#2203-2223) uses assembly
	- INLINE ASM (SDCollateral.sol#2209-2211)
	- INLINE ASM (SDCollateral.sol#2215-2217)



    
2209             assembly {
2210                 ptr := add(buffer, add(32, length))
2211             }



    
2215                 assembly {
2216                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
2217                 }



```

```
AddressUpgradeable._revert(bytes,string) (SDCollateral.sol#1642-1654) uses assembly
	- INLINE ASM (SDCollateral.sol#1647-1650)



    
1647             assembly {
1648                 let returndata_size := mload(returndata)
1649                 revert(add(32, returndata), returndata_size)
1650             }



```

```
Math.mulDiv(uint256,uint256,uint256) (SDCollateral.sol#1175-1255) uses assembly
	- INLINE ASM (SDCollateral.sol#1186-1190)
	- INLINE ASM (SDCollateral.sol#1206-1213)
	- INLINE ASM (SDCollateral.sol#1220-1229)



    
1186             assembly {
1187                 let mm := mulmod(x, y, not(0))
1188                 prod0 := mul(x, y)
1189                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1190             }



    
1206             assembly {
1207                 // Compute remainder using mulmod.
1208                 remainder := mulmod(x, y, denominator)
1209 
1210                 // Subtract 256 bit number from 512 bit number.
1211                 prod1 := sub(prod1, gt(remainder, prod0))
1212                 prod0 := sub(prod0, remainder)
1213             }



    
1220             assembly {
1221                 // Divide denominator by twos.
1222                 denominator := div(denominator, twos)
1223 
1224                 // Divide [prod1 prod0] by twos.
1225                 prod0 := div(prod0, twos)
1226 
1227                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1228                 twos := add(div(sub(0, twos), twos), 1)
1229             }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (SDCollateral.sol#1901-1981) uses assembly
	- INLINE ASM (SDCollateral.sol#1912-1916)
	- INLINE ASM (SDCollateral.sol#1932-1939)
	- INLINE ASM (SDCollateral.sol#1946-1955)



    
1912             assembly {
1913                 let mm := mulmod(x, y, not(0))
1914                 prod0 := mul(x, y)
1915                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1916             }



    
1932             assembly {
1933                 // Compute remainder using mulmod.
1934                 remainder := mulmod(x, y, denominator)
1935 
1936                 // Subtract 256 bit number from 512 bit number.
1937                 prod1 := sub(prod1, gt(remainder, prod0))
1938                 prod0 := sub(prod0, remainder)
1939             }



    
1946             assembly {
1947                 // Divide denominator by twos.
1948                 denominator := div(denominator, twos)
1949 
1950                 // Divide [prod1 prod0] by twos.
1951                 prod0 := div(prod0, twos)
1952 
1953                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1954                 twos := add(div(sub(0, twos), twos), 1)
1955             }



```

### SocializingPool.sol


```
AddressUpgradeable._revert(bytes,string) (SocializingPool.sol#1123-1135) uses assembly
	- INLINE ASM (SocializingPool.sol#1128-1131)



    
1128             assembly {
1129                 let returndata_size := mload(returndata)
1130                 revert(add(32, returndata), returndata_size)
1131             }



```

```
MerkleProofUpgradeable._efficientHash(bytes32,bytes32) (SocializingPool.sol#2438-2445) uses assembly
	- INLINE ASM (SocializingPool.sol#2440-2444)



    
2440         assembly {
2441             mstore(0x00, a)
2442             mstore(0x20, b)
2443             value := keccak256(0x00, 0x40)
2444         }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (SocializingPool.sol#1382-1462) uses assembly
	- INLINE ASM (SocializingPool.sol#1393-1397)
	- INLINE ASM (SocializingPool.sol#1413-1420)
	- INLINE ASM (SocializingPool.sol#1427-1436)



    
1393             assembly {
1394                 let mm := mulmod(x, y, not(0))
1395                 prod0 := mul(x, y)
1396                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1397             }



    
1413             assembly {
1414                 // Compute remainder using mulmod.
1415                 remainder := mulmod(x, y, denominator)
1416 
1417                 // Subtract 256 bit number from 512 bit number.
1418                 prod1 := sub(prod1, gt(remainder, prod0))
1419                 prod0 := sub(prod0, remainder)
1420             }



    
1427             assembly {
1428                 // Divide denominator by twos.
1429                 denominator := div(denominator, twos)
1430 
1431                 // Divide [prod1 prod0] by twos.
1432                 prod0 := div(prod0, twos)
1433 
1434                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1435                 twos := add(div(sub(0, twos), twos), 1)
1436             }



```

```
StringsUpgradeable.toString(uint256) (SocializingPool.sol#1684-1704) uses assembly
	- INLINE ASM (SocializingPool.sol#1690-1692)
	- INLINE ASM (SocializingPool.sol#1696-1698)



    
1690             assembly {
1691                 ptr := add(buffer, add(32, length))
1692             }



    
1696                 assembly {
1697                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
1698                 }



```

### StaderConfig.sol


```
StringsUpgradeable.toString(uint256) (StaderConfig.sol#1457-1477) uses assembly
	- INLINE ASM (StaderConfig.sol#1463-1465)
	- INLINE ASM (StaderConfig.sol#1469-1471)



    
1463             assembly {
1464                 ptr := add(buffer, add(32, length))
1465             }



    
1469                 assembly {
1470                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
1471                 }



```

```
AddressUpgradeable._revert(bytes,string) (StaderConfig.sol#896-908) uses assembly
	- INLINE ASM (StaderConfig.sol#901-904)



    
901             assembly {
902                 let returndata_size := mload(returndata)
903                 revert(add(32, returndata), returndata_size)
904             }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderConfig.sol#1155-1235) uses assembly
	- INLINE ASM (StaderConfig.sol#1166-1170)
	- INLINE ASM (StaderConfig.sol#1186-1193)
	- INLINE ASM (StaderConfig.sol#1200-1209)



    
1166             assembly {
1167                 let mm := mulmod(x, y, not(0))
1168                 prod0 := mul(x, y)
1169                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1170             }



    
1186             assembly {
1187                 // Compute remainder using mulmod.
1188                 remainder := mulmod(x, y, denominator)
1189 
1190                 // Subtract 256 bit number from 512 bit number.
1191                 prod1 := sub(prod1, gt(remainder, prod0))
1192                 prod0 := sub(prod0, remainder)
1193             }



    
1200             assembly {
1201                 // Divide denominator by twos.
1202                 denominator := div(denominator, twos)
1203 
1204                 // Divide [prod1 prod0] by twos.
1205                 prod0 := div(prod0, twos)
1206 
1207                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1208                 twos := add(div(sub(0, twos), twos), 1)
1209             }



```

### StaderInsuranceFund.sol


```
AddressUpgradeable._revert(bytes,string) (StaderInsuranceFund.sol#922-934) uses assembly
	- INLINE ASM (StaderInsuranceFund.sol#927-930)



    
927             assembly {
928                 let returndata_size := mload(returndata)
929                 revert(add(32, returndata), returndata_size)
930             }



```

```
StringsUpgradeable.toString(uint256) (StaderInsuranceFund.sol#1483-1503) uses assembly
	- INLINE ASM (StaderInsuranceFund.sol#1489-1491)
	- INLINE ASM (StaderInsuranceFund.sol#1495-1497)



    
1489             assembly {
1490                 ptr := add(buffer, add(32, length))
1491             }



    
1495                 assembly {
1496                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
1497                 }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderInsuranceFund.sol#1181-1261) uses assembly
	- INLINE ASM (StaderInsuranceFund.sol#1192-1196)
	- INLINE ASM (StaderInsuranceFund.sol#1212-1219)
	- INLINE ASM (StaderInsuranceFund.sol#1226-1235)



    
1192             assembly {
1193                 let mm := mulmod(x, y, not(0))
1194                 prod0 := mul(x, y)
1195                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1196             }



    
1212             assembly {
1213                 // Compute remainder using mulmod.
1214                 remainder := mulmod(x, y, denominator)
1215 
1216                 // Subtract 256 bit number from 512 bit number.
1217                 prod1 := sub(prod1, gt(remainder, prod0))
1218                 prod0 := sub(prod0, remainder)
1219             }



    
1226             assembly {
1227                 // Divide denominator by twos.
1228                 denominator := div(denominator, twos)
1229 
1230                 // Divide [prod1 prod0] by twos.
1231                 prod0 := div(prod0, twos)
1232 
1233                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1234                 twos := add(div(sub(0, twos), twos), 1)
1235             }



```

### StaderOracle.sol


```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderOracle.sol#1730-1810) uses assembly
	- INLINE ASM (StaderOracle.sol#1741-1745)
	- INLINE ASM (StaderOracle.sol#1761-1768)
	- INLINE ASM (StaderOracle.sol#1775-1784)



    
1741             assembly {
1742                 let mm := mulmod(x, y, not(0))
1743                 prod0 := mul(x, y)
1744                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1745             }



    
1761             assembly {
1762                 // Compute remainder using mulmod.
1763                 remainder := mulmod(x, y, denominator)
1764 
1765                 // Subtract 256 bit number from 512 bit number.
1766                 prod1 := sub(prod1, gt(remainder, prod0))
1767                 prod0 := sub(prod0, remainder)
1768             }



    
1775             assembly {
1776                 // Divide denominator by twos.
1777                 denominator := div(denominator, twos)
1778 
1779                 // Divide [prod1 prod0] by twos.
1780                 prod0 := div(prod0, twos)
1781 
1782                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1783                 twos := add(div(sub(0, twos), twos), 1)
1784             }



```

```
StringsUpgradeable.toString(uint256) (StaderOracle.sol#2032-2052) uses assembly
	- INLINE ASM (StaderOracle.sol#2038-2040)
	- INLINE ASM (StaderOracle.sol#2044-2046)



    
2038             assembly {
2039                 ptr := add(buffer, add(32, length))
2040             }



    
2044                 assembly {
2045                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
2046                 }



```

```
AddressUpgradeable._revert(bytes,string) (StaderOracle.sol#1273-1285) uses assembly
	- INLINE ASM (StaderOracle.sol#1278-1281)



    
1278             assembly {
1279                 let returndata_size := mload(returndata)
1280                 revert(add(32, returndata), returndata_size)
1281             }



```

### StaderStakePoolsManager.sol


```
AddressUpgradeable._revert(bytes,string) (StaderStakePoolsManager.sol#915-927) uses assembly
	- INLINE ASM (StaderStakePoolsManager.sol#920-923)



    
920             assembly {
921                 let returndata_size := mload(returndata)
922                 revert(add(32, returndata), returndata_size)
923             }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderStakePoolsManager.sol#1654-1734) uses assembly
	- INLINE ASM (StaderStakePoolsManager.sol#1665-1669)
	- INLINE ASM (StaderStakePoolsManager.sol#1685-1692)
	- INLINE ASM (StaderStakePoolsManager.sol#1699-1708)



    
1665             assembly {
1666                 let mm := mulmod(x, y, not(0))
1667                 prod0 := mul(x, y)
1668                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1669             }



    
1685             assembly {
1686                 // Compute remainder using mulmod.
1687                 remainder := mulmod(x, y, denominator)
1688 
1689                 // Subtract 256 bit number from 512 bit number.
1690                 prod1 := sub(prod1, gt(remainder, prod0))
1691                 prod0 := sub(prod0, remainder)
1692             }



    
1699             assembly {
1700                 // Divide denominator by twos.
1701                 denominator := div(denominator, twos)
1702 
1703                 // Divide [prod1 prod0] by twos.
1704                 prod0 := div(prod0, twos)
1705 
1706                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1707                 twos := add(div(sub(0, twos), twos), 1)
1708             }



```

```
StringsUpgradeable.toString(uint256) (StaderStakePoolsManager.sol#1956-1976) uses assembly
	- INLINE ASM (StaderStakePoolsManager.sol#1962-1964)
	- INLINE ASM (StaderStakePoolsManager.sol#1968-1970)



    
1962             assembly {
1963                 ptr := add(buffer, add(32, length))
1964             }



    
1968                 assembly {
1969                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
1970                 }



```

```
Math.mulDiv(uint256,uint256,uint256) (StaderStakePoolsManager.sol#3136-3216) uses assembly
	- INLINE ASM (StaderStakePoolsManager.sol#3147-3151)
	- INLINE ASM (StaderStakePoolsManager.sol#3167-3174)
	- INLINE ASM (StaderStakePoolsManager.sol#3181-3190)



    
3147             assembly {
3148                 let mm := mulmod(x, y, not(0))
3149                 prod0 := mul(x, y)
3150                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
3151             }



    
3167             assembly {
3168                 // Compute remainder using mulmod.
3169                 remainder := mulmod(x, y, denominator)
3170 
3171                 // Subtract 256 bit number from 512 bit number.
3172                 prod1 := sub(prod1, gt(remainder, prod0))
3173                 prod0 := sub(prod0, remainder)
3174             }



    
3181             assembly {
3182                 // Divide denominator by twos.
3183                 denominator := div(denominator, twos)
3184 
3185                 // Divide [prod1 prod0] by twos.
3186                 prod0 := div(prod0, twos)
3187 
3188                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
3189                 twos := add(div(sub(0, twos), twos), 1)
3190             }



```

### UserWithdrawalManager.sol


```
StringsUpgradeable.toString(uint256) (UserWithdrawalManager.sol#1955-1975) uses assembly
	- INLINE ASM (UserWithdrawalManager.sol#1961-1963)
	- INLINE ASM (UserWithdrawalManager.sol#1967-1969)



    
1961             assembly {
1962                 ptr := add(buffer, add(32, length))
1963             }



    
1967                 assembly {
1968                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
1969                 }



```

```
Math.mulDiv(uint256,uint256,uint256) (UserWithdrawalManager.sol#3065-3145) uses assembly
	- INLINE ASM (UserWithdrawalManager.sol#3076-3080)
	- INLINE ASM (UserWithdrawalManager.sol#3096-3103)
	- INLINE ASM (UserWithdrawalManager.sol#3110-3119)



    
3076             assembly {
3077                 let mm := mulmod(x, y, not(0))
3078                 prod0 := mul(x, y)
3079                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
3080             }



    
3096             assembly {
3097                 // Compute remainder using mulmod.
3098                 remainder := mulmod(x, y, denominator)
3099 
3100                 // Subtract 256 bit number from 512 bit number.
3101                 prod1 := sub(prod1, gt(remainder, prod0))
3102                 prod0 := sub(prod0, remainder)
3103             }



    
3110             assembly {
3111                 // Divide denominator by twos.
3112                 denominator := div(denominator, twos)
3113 
3114                 // Divide [prod1 prod0] by twos.
3115                 prod0 := div(prod0, twos)
3116 
3117                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
3118                 twos := add(div(sub(0, twos), twos), 1)
3119             }



```

```
AddressUpgradeable._revert(bytes,string) (UserWithdrawalManager.sol#914-926) uses assembly
	- INLINE ASM (UserWithdrawalManager.sol#919-922)



    
919             assembly {
920                 let returndata_size := mload(returndata)
921                 revert(add(32, returndata), returndata_size)
922             }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (UserWithdrawalManager.sol#1653-1733) uses assembly
	- INLINE ASM (UserWithdrawalManager.sol#1664-1668)
	- INLINE ASM (UserWithdrawalManager.sol#1684-1691)
	- INLINE ASM (UserWithdrawalManager.sol#1698-1707)



    
1664             assembly {
1665                 let mm := mulmod(x, y, not(0))
1666                 prod0 := mul(x, y)
1667                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1668             }



    
1684             assembly {
1685                 // Compute remainder using mulmod.
1686                 remainder := mulmod(x, y, denominator)
1687 
1688                 // Subtract 256 bit number from 512 bit number.
1689                 prod1 := sub(prod1, gt(remainder, prod0))
1690                 prod0 := sub(prod0, remainder)
1691             }



    
1698             assembly {
1699                 // Divide denominator by twos.
1700                 denominator := div(denominator, twos)
1701 
1702                 // Divide [prod1 prod0] by twos.
1703                 prod0 := div(prod0, twos)
1704 
1705                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1706                 twos := add(div(sub(0, twos), twos), 1)
1707             }



```

### ValidatorWithdrawalVault.sol


```
Math.mulDiv(uint256,uint256,uint256) (ValidatorWithdrawalVault.sol#996-1076) uses assembly
	- INLINE ASM (ValidatorWithdrawalVault.sol#1007-1011)
	- INLINE ASM (ValidatorWithdrawalVault.sol#1027-1034)
	- INLINE ASM (ValidatorWithdrawalVault.sol#1041-1050)



    
1007             assembly {
1008                 let mm := mulmod(x, y, not(0))
1009                 prod0 := mul(x, y)
1010                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1011             }



    
1027             assembly {
1028                 // Compute remainder using mulmod.
1029                 remainder := mulmod(x, y, denominator)
1030 
1031                 // Subtract 256 bit number from 512 bit number.
1032                 prod1 := sub(prod1, gt(remainder, prod0))
1033                 prod0 := sub(prod0, remainder)
1034             }



    
1041             assembly {
1042                 // Divide denominator by twos.
1043                 denominator := div(denominator, twos)
1044 
1045                 // Divide [prod1 prod0] by twos.
1046                 prod0 := div(prod0, twos)
1047 
1048                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1049                 twos := add(div(sub(0, twos), twos), 1)
1050             }



```

### VaultFactory.sol


```
ClonesUpgradeable.predictDeterministicAddress(address,bytes32,address) (VaultFactory.sol#767-783) uses assembly
	- INLINE ASM (VaultFactory.sol#773-782)



    
773         assembly {
774             let ptr := mload(0x40)
775             mstore(add(ptr, 0x38), deployer)
776             mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)
777             mstore(add(ptr, 0x14), implementation)
778             mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)
779             mstore(add(ptr, 0x58), salt)
780             mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))
781             predicted := keccak256(add(ptr, 0x43), 0x55)
782         }



```

```
ClonesUpgradeable.cloneDeterministic(address,bytes32) (VaultFactory.sol#751-762) uses assembly
	- INLINE ASM (VaultFactory.sol#753-760)



    
753         assembly {
754             // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
755             // of the `implementation` address with the bytecode before the address.
756             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
757             // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
758             mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
759             instance := create2(0, 0x09, 0x37, salt)
760         }



```

```
AddressUpgradeable._revert(bytes,string) (VaultFactory.sol#1091-1103) uses assembly
	- INLINE ASM (VaultFactory.sol#1096-1099)



    
1096             assembly {
1097                 let returndata_size := mload(returndata)
1098                 revert(add(32, returndata), returndata_size)
1099             }



```

```
ClonesUpgradeable.clone(address) (VaultFactory.sol#731-742) uses assembly
	- INLINE ASM (VaultFactory.sol#733-740)



    
733         assembly {
734             // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
735             // of the `implementation` address with the bytecode before the address.
736             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
737             // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
738             mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
739             instance := create(0, 0x09, 0x37)
740         }



```

```
StringsUpgradeable.toString(uint256) (VaultFactory.sol#1652-1672) uses assembly
	- INLINE ASM (VaultFactory.sol#1658-1660)
	- INLINE ASM (VaultFactory.sol#1664-1666)



    
1658             assembly {
1659                 ptr := add(buffer, add(32, length))
1660             }



    
1664                 assembly {
1665                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
1666                 }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (VaultFactory.sol#1350-1430) uses assembly
	- INLINE ASM (VaultFactory.sol#1361-1365)
	- INLINE ASM (VaultFactory.sol#1381-1388)
	- INLINE ASM (VaultFactory.sol#1395-1404)



    
1361             assembly {
1362                 let mm := mulmod(x, y, not(0))
1363                 prod0 := mul(x, y)
1364                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1365             }



    
1381             assembly {
1382                 // Compute remainder using mulmod.
1383                 remainder := mulmod(x, y, denominator)
1384 
1385                 // Subtract 256 bit number from 512 bit number.
1386                 prod1 := sub(prod1, gt(remainder, prod0))
1387                 prod0 := sub(prod0, remainder)
1388             }



    
1395             assembly {
1396                 // Divide denominator by twos.
1397                 denominator := div(denominator, twos)
1398 
1399                 // Divide [prod1 prod0] by twos.
1400                 prod0 := div(prod0, twos)
1401 
1402                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1403                 twos := add(div(sub(0, twos), twos), 1)
1404             }



```

## dead-code
### Severity: Informational

### Auction.sol


```
StringsUpgradeable.toString(uint256) (Auction.sol#1662-1682) is never used and should be removed



    
1662     function toString(uint256 value) internal pure returns (string memory) {
1663         unchecked {
1664             uint256 length = MathUpgradeable.log10(value) + 1;
1665             string memory buffer = new string(length);
1666             uint256 ptr;
1667             /// @solidity memory-safe-assembly
1668             assembly {
1669                 ptr := add(buffer, add(32, length))
1670             }
1671             while (true) {
1672                 ptr--;
1673                 /// @solidity memory-safe-assembly
1674                 assembly {
1675                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
1676                 }
1677                 value /= 10;
1678                 if (value == 0) break;
1679             }
1680             return buffer;
1681         }
1682     }



```

```
ContextUpgradeable._msgData() (Auction.sol#1295-1297) is never used and should be removed



    
1295     function _msgData() internal view virtual returns (bytes calldata) {
1296         return msg.data;
1297     }



```

```
MathUpgradeable.log2(uint256,MathUpgradeable.Rounding) (Auction.sol#1552-1557) is never used and should be removed



    
1552     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
1553         unchecked {
1554             uint256 result = log2(value);
1555             return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
1556         }
1557     }



```

```
Initializable._isInitializing() (Auction.sol#1270-1272) is never used and should be removed



    
1270     function _isInitializing() internal view returns (bool) {
1271         return _initializing;
1272     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256) (Auction.sol#1009-1015) is never used and should be removed



    
1009     function functionCallWithValue(
1010         address target,
1011         bytes memory data,
1012         uint256 value
1013     ) internal returns (bytes memory) {
1014         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
1015     }



```

```
MathUpgradeable.ceilDiv(uint256,uint256) (Auction.sol#1350-1353) is never used and should be removed



    
1350     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
1351         // (a + b - 1) / b can overflow on addition, so we distribute.
1352         return a == 0 ? 0 : (a - 1) / b + 1;
1353     }



```

```
MathUpgradeable.min(uint256,uint256) (Auction.sol#1331-1333) is never used and should be removed



    
1331     function min(uint256 a, uint256 b) internal pure returns (uint256) {
1332         return a < b ? a : b;
1333     }



```

```
PausableUpgradeable._unpause() (Auction.sol#2125-2128) is never used and should be removed



    
2125     function _unpause() internal virtual whenPaused {
2126         _paused = false;
2127         emit Unpaused(_msgSender());
2128     }



```

```
MathUpgradeable.sqrt(uint256) (Auction.sol#1463-1494) is never used and should be removed



    
1463     function sqrt(uint256 a) internal pure returns (uint256) {
1464         if (a == 0) {
1465             return 0;
1466         }
1467 
1468         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
1469         //
1470         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
1471         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
1472         //
1473         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
1474         // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
1475         // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
1476         //
1477         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
1478         uint256 result = 1 << (log2(a) >> 1);
1479 
1480         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
1481         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
1482         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
1483         // into the expected uint128 result.
1484         unchecked {
1485             result = (result + a / result) >> 1;
1486             result = (result + a / result) >> 1;
1487             result = (result + a / result) >> 1;
1488             result = (result + a / result) >> 1;
1489             result = (result + a / result) >> 1;
1490             result = (result + a / result) >> 1;
1491             result = (result + a / result) >> 1;
1492             return min(result, a / result);
1493         }
1494     }



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (Auction.sol#522-532) is never used and should be removed



    
522     function getOperatorAddressByValidatorId(
523         uint8 _poolId,
524         uint256 _validatorId,
525         IStaderConfig _staderConfig
526     ) internal view returns (address) {
527         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
530 
531         return operatorAddress;
532     }



```

```
PausableUpgradeable._requirePaused() (Auction.sol#2102-2104) is never used and should be removed



    
2102     function _requirePaused() internal view virtual {
2103         require(paused(), "Pausable: not paused");
2104     }



```

```
UtilLib.getPubkeyRoot(bytes) (Auction.sol#561-568) is never used and should be removed



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {
562         if (_pubkey.length != VALIDATOR_PUBKEY_LENGTH) {
563             revert InvalidPubkeyLength();
564         }
565 
566         // Append 16 bytes of zero padding to the pubkey and compute its hash to get the pubkey root.
567         return sha256(abi.encodePacked(_pubkey, bytes16(0)));
568     }



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (Auction.sol#492-507) is never used and should be removed



    
492     function getOperatorForValidSender(
493         uint8 _poolId,
494         uint256 _validatorId,
495         address _addr,
496         IStaderConfig _staderConfig
497     ) internal view returns (address) {
498         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );
502         if (_addr != withdrawVaultAddress) {
503             revert CallerNotWithdrawVault();
504         }
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
506         return operator;
507     }



```

```
MathUpgradeable.log10(uint256,MathUpgradeable.Rounding) (Auction.sol#1601-1606) is never used and should be removed



    
1601     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
1602         unchecked {
1603             uint256 result = log10(value);
1604             return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);
1605         }
1606     }



```

```
AddressUpgradeable.functionCall(address,bytes) (Auction.sol#980-982) is never used and should be removed



    
980     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
981         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
982     }



```

```
ContextUpgradeable.__Context_init_unchained() (Auction.sol#1289-1290) is never used and should be removed



    
1289     function __Context_init_unchained() internal onlyInitializing {
1290     }



```

```
ERC165Upgradeable.__ERC165_init_unchained() (Auction.sol#1759-1760) is never used and should be removed



    
1759     function __ERC165_init_unchained() internal onlyInitializing {
1760     }



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (Auction.sol#570-580) is never used and should be removed



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)
571         internal
572         view
573         returns (bool)
574     {
575         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getValidatorPoolId(_pubkey);
576         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
577         uint256 validatorId = INodeRegistry(nodeRegistry).validatorIdByPubkey(_pubkey);
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);
579         return IVaultProxy(withdrawVaultAddress).vaultSettleStatus();
580     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (Auction.sol#1360-1440) is never used and should be removed



    
1360     function mulDiv(
1361         uint256 x,
1362         uint256 y,
1363         uint256 denominator
1364     ) internal pure returns (uint256 result) {
1365         unchecked {
1366             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
1367             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
1368             // variables such that product = prod1 * 2^256 + prod0.
1369             uint256 prod0; // Least significant 256 bits of the product
1370             uint256 prod1; // Most significant 256 bits of the product
1371             assembly {
1372                 let mm := mulmod(x, y, not(0))
1373                 prod0 := mul(x, y)
1374                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1375             }
1376 
1377             // Handle non-overflow cases, 256 by 256 division.
1378             if (prod1 == 0) {
1379                 return prod0 / denominator;
1380             }
1381 
1382             // Make sure the result is less than 2^256. Also prevents denominator == 0.
1383             require(denominator > prod1);
1384 
1385             ///////////////////////////////////////////////
1386             // 512 by 256 division.
1387             ///////////////////////////////////////////////
1388 
1389             // Make division exact by subtracting the remainder from [prod1 prod0].
1390             uint256 remainder;
1391             assembly {
1392                 // Compute remainder using mulmod.
1393                 remainder := mulmod(x, y, denominator)
1394 
1395                 // Subtract 256 bit number from 512 bit number.
1396                 prod1 := sub(prod1, gt(remainder, prod0))
1397                 prod0 := sub(prod0, remainder)
1398             }
1399 
1400             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
1401             // See https://cs.stackexchange.com/q/138556/92363.
1402 
1403             // Does not overflow because the denominator cannot be zero at this stage in the function.
1404             uint256 twos = denominator & (~denominator + 1);
1405             assembly {
1406                 // Divide denominator by twos.
1407                 denominator := div(denominator, twos)
1408 
1409                 // Divide [prod1 prod0] by twos.
1410                 prod0 := div(prod0, twos)
1411 
1412                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1413                 twos := add(div(sub(0, twos), twos), 1)
1414             }
1415 
1416             // Shift in bits from prod1 into prod0.
1417             prod0 |= prod1 * twos;
1418 
1419             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
1420             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
1421             // four bits. That is, denominator * inv = 1 mod 2^4.
1422             uint256 inverse = (3 * denominator) ^ 2;
1423 
1424             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
1425             // in modular arithmetic, doubling the correct bits in each step.
1426             inverse *= 2 - denominator * inverse; // inverse mod 2^8
1427             inverse *= 2 - denominator * inverse; // inverse mod 2^16
1428             inverse *= 2 - denominator * inverse; // inverse mod 2^32
1429             inverse *= 2 - denominator * inverse; // inverse mod 2^64
1430             inverse *= 2 - denominator * inverse; // inverse mod 2^128
1431             inverse *= 2 - denominator * inverse; // inverse mod 2^256
1432 
1433             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
1434             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
1435             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
1436             // is no longer required.
1437             result = prod0 * inverse;
1438             return result;
1439         }
1440     }



```

```
AddressUpgradeable.functionCall(address,bytes,string) (Auction.sol#990-996) is never used and should be removed



    
990     function functionCall(
991         address target,
992         bytes memory data,
993         string memory errorMessage
994     ) internal returns (bytes memory) {
995         return functionCallWithValue(target, data, 0, errorMessage);
996     }



```

```
AddressUpgradeable.sendValue(address,uint256) (Auction.sol#955-960) is never used and should be removed



    
955     function sendValue(address payable recipient, uint256 amount) internal {
956         require(address(this).balance >= amount, "Address: insufficient balance");
957 
958         (bool success, ) = recipient.call{value: amount}("");
959         require(success, "Address: unable to send value, recipient may have reverted");
960     }



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (Auction.sol#534-543) is never used and should be removed



    
534     function getOperatorAddressByOperatorId(
535         uint8 _poolId,
536         uint256 _operatorId,
537         IStaderConfig _staderConfig
538     ) internal view returns (address) {
539         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);
541 
542         return operatorAddress;
543     }



```

```
UtilLib.onlyStaderContract(address,IStaderConfig,bytes32) (Auction.sol#466-474) is never used and should be removed



    
466     function onlyStaderContract(
467         address _addr,
468         IStaderConfig _staderConfig,
469         bytes32 _contractName
470     ) internal view {
471         if (!_staderConfig.onlyStaderContract(_addr, _contractName)) {
472             revert CallerNotStaderContract();
473         }
474     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes) (Auction.sol#1040-1042) is never used and should be removed



    
1040     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
1041         return functionStaticCall(target, data, "Address: low-level static call failed");
1042     }



```

```
MathUpgradeable.sqrt(uint256,MathUpgradeable.Rounding) (Auction.sol#1499-1504) is never used and should be removed



    
1499     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
1500         unchecked {
1501             uint256 result = sqrt(a);
1502             return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
1503         }
1504     }



```

```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (Auction.sol#509-520) is never used and should be removed



    
509     function onlyValidatorWithdrawVault(
510         uint8 _poolId,
511         uint256 _validatorId,
512         address _addr,
513         IStaderConfig _staderConfig
514     ) internal view {
515         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
517         if (_addr != withdrawVaultAddress) {
518             revert CallerNotWithdrawVault();
519         }
520     }



```

```
MathUpgradeable.log2(uint256) (Auction.sol#1510-1546) is never used and should be removed



    
1510     function log2(uint256 value) internal pure returns (uint256) {
1511         uint256 result = 0;
1512         unchecked {
1513             if (value >> 128 > 0) {
1514                 value >>= 128;
1515                 result += 128;
1516             }
1517             if (value >> 64 > 0) {
1518                 value >>= 64;
1519                 result += 64;
1520             }
1521             if (value >> 32 > 0) {
1522                 value >>= 32;
1523                 result += 32;
1524             }
1525             if (value >> 16 > 0) {
1526                 value >>= 16;
1527                 result += 16;
1528             }
1529             if (value >> 8 > 0) {
1530                 value >>= 8;
1531                 result += 8;
1532             }
1533             if (value >> 4 > 0) {
1534                 value >>= 4;
1535                 result += 4;
1536             }
1537             if (value >> 2 > 0) {
1538                 value >>= 2;
1539                 result += 2;
1540             }
1541             if (value >> 1 > 0) {
1542                 result += 1;
1543             }
1544         }
1545         return result;
1546     }



```

```
UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig) (Auction.sol#582-592) is never used and should be removed



    
582     function computeExchangeRate(
583         uint256 totalETHBalance,
584         uint256 totalETHXSupply,
585         IStaderConfig _staderConfig
586     ) internal view returns (uint256) {
587         uint256 DECIMALS = _staderConfig.getDecimals();
588         uint256 newExchangeRate = (totalETHBalance == 0 || totalETHXSupply == 0)
589             ? DECIMALS
590             : (totalETHBalance * DECIMALS) / totalETHXSupply;
591         return newExchangeRate;
592     }



```

```
AccessControlUpgradeable._setRoleAdmin(bytes32,bytes32) (Auction.sol#1984-1988) is never used and should be removed



    
1984     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
1985         bytes32 previousAdminRole = getRoleAdmin(role);
1986         _roles[role].adminRole = adminRole;
1987         emit RoleAdminChanged(role, previousAdminRole, adminRole);
1988     }



```

```
MathUpgradeable.average(uint256,uint256) (Auction.sol#1339-1342) is never used and should be removed



    
1339     function average(uint256 a, uint256 b) internal pure returns (uint256) {
1340         // (a + b) / 2 can overflow.
1341         return (a & b) + (a ^ b) / 2;
1342     }



```

```
StringsUpgradeable.toHexString(uint256) (Auction.sol#1687-1691) is never used and should be removed



    
1687     function toHexString(uint256 value) internal pure returns (string memory) {
1688         unchecked {
1689             return toHexString(value, MathUpgradeable.log256(value) + 1);
1690         }
1691     }



```

```
MathUpgradeable.log10(uint256) (Auction.sol#1563-1595) is never used and should be removed



    
1563     function log10(uint256 value) internal pure returns (uint256) {
1564         uint256 result = 0;
1565         unchecked {
1566             if (value >= 10**64) {
1567                 value /= 10**64;
1568                 result += 64;
1569             }
1570             if (value >= 10**32) {
1571                 value /= 10**32;
1572                 result += 32;
1573             }
1574             if (value >= 10**16) {
1575                 value /= 10**16;
1576                 result += 16;
1577             }
1578             if (value >= 10**8) {
1579                 value /= 10**8;
1580                 result += 8;
1581             }
1582             if (value >= 10**4) {
1583                 value /= 10**4;
1584                 result += 4;
1585             }
1586             if (value >= 10**2) {
1587                 value /= 10**2;
1588                 result += 2;
1589             }
1590             if (value >= 10**1) {
1591                 result += 1;
1592             }
1593         }
1594         return result;
1595     }



```

```
ERC165Upgradeable.__ERC165_init() (Auction.sol#1756-1757) is never used and should be removed



    
1756     function __ERC165_init() internal onlyInitializing {
1757     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256,MathUpgradeable.Rounding) (Auction.sol#1445-1456) is never used and should be removed



    
1445     function mulDiv(
1446         uint256 x,
1447         uint256 y,
1448         uint256 denominator,
1449         Rounding rounding
1450     ) internal pure returns (uint256) {
1451         uint256 result = mulDiv(x, y, denominator);
1452         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
1453             result += 1;
1454         }
1455         return result;
1456     }



```

```
PausableUpgradeable._pause() (Auction.sol#2113-2116) is never used and should be removed



    
2113     function _pause() internal virtual whenNotPaused {
2114         _paused = true;
2115         emit Paused(_msgSender());
2116     }



```

```
AddressUpgradeable.verifyCallResult(bool,bytes,string) (Auction.sol#1089-1099) is never used and should be removed



    
1089     function verifyCallResult(
1090         bool success,
1091         bytes memory returndata,
1092         string memory errorMessage
1093     ) internal pure returns (bytes memory) {
1094         if (success) {
1095             return returndata;
1096         } else {
1097             _revert(returndata, errorMessage);
1098         }
1099     }



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (Auction.sol#476-490) is never used and should be removed



    
476     function getPubkeyForValidSender(
477         uint8 _poolId,
478         uint256 _validatorId,
479         address _addr,
480         IStaderConfig _staderConfig
481     ) internal view returns (bytes memory) {
482         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );
486         if (_addr != withdrawVaultAddress) {
487             revert CallerNotWithdrawVault();
488         }
489         return pubkey;
490     }



```

```
AccessControlUpgradeable.__AccessControl_init_unchained() (Auction.sol#1818-1819) is never used and should be removed



    
1818     function __AccessControl_init_unchained() internal onlyInitializing {
1819     }



```

```
AddressUpgradeable._revert(bytes,string) (Auction.sol#1101-1113) is never used and should be removed



    
1101     function _revert(bytes memory returndata, string memory errorMessage) private pure {
1102         // Look for revert reason and bubble it up if present
1103         if (returndata.length > 0) {
1104             // The easiest way to bubble the revert reason is using memory via assembly
1105             /// @solidity memory-safe-assembly
1106             assembly {
1107                 let returndata_size := mload(returndata)
1108                 revert(add(32, returndata), returndata_size)
1109             }
1110         } else {
1111             revert(errorMessage);
1112         }
1113     }



```

```
Initializable._getInitializedVersion() (Auction.sol#1263-1265) is never used and should be removed



    
1263     function _getInitializedVersion() internal view returns (uint8) {
1264         return _initialized;
1265     }



```

```
AccessControlUpgradeable._setupRole(bytes32,address) (Auction.sol#1975-1977) is never used and should be removed



    
1975     function _setupRole(bytes32 role, address account) internal virtual {
1976         _grantRole(role, account);
1977     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes,string) (Auction.sol#1050-1057) is never used and should be removed



    
1050     function functionStaticCall(
1051         address target,
1052         bytes memory data,
1053         string memory errorMessage
1054     ) internal view returns (bytes memory) {
1055         (bool success, bytes memory returndata) = target.staticcall(data);
1056         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
1057     }



```

```
MathUpgradeable.log256(uint256,MathUpgradeable.Rounding) (Auction.sol#1644-1649) is never used and should be removed



    
1644     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
1645         unchecked {
1646             uint256 result = log256(value);
1647             return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);
1648         }
1649     }



```

```
UtilLib.onlyOperatorRole(address,IStaderConfig) (Auction.sol#459-463) is never used and should be removed



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {
460         if (!_staderConfig.onlyOperatorRole(_addr)) {
461             revert CallerNotOperator();
462         }
463     }



```

```
UtilLib.sendValue(address,uint256) (Auction.sol#594-599) is never used and should be removed



    
594     function sendValue(address _receiver, uint256 _amount) internal {
595         (bool success, ) = payable(_receiver).call{value: _amount}('');
596         if (!success) {
597             revert TransferFailed();
598         }
599     }



```

```
MathUpgradeable.max(uint256,uint256) (Auction.sol#1324-1326) is never used and should be removed



    
1324     function max(uint256 a, uint256 b) internal pure returns (uint256) {
1325         return a > b ? a : b;
1326     }



```

```
ContextUpgradeable.__Context_init() (Auction.sol#1286-1287) is never used and should be removed



    
1286     function __Context_init() internal onlyInitializing {
1287     }



```

```
UtilLib.getOperatorRewardAddress(address,IStaderConfig) (Auction.sol#545-554) is never used and should be removed



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)
546         internal
547         view
548         returns (address payable)
549     {
550         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getOperatorPoolId(_operator);
551         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
552         uint256 operatorId = INodeRegistry(nodeRegistry).operatorIDByAddress(_operator);
553         return INodeRegistry(nodeRegistry).getOperatorRewardAddress(operatorId);
554     }



```

```
AddressUpgradeable.verifyCallResultFromTarget(address,bool,bytes,string) (Auction.sol#1065-1081) is never used and should be removed



    
1065     function verifyCallResultFromTarget(
1066         address target,
1067         bool success,
1068         bytes memory returndata,
1069         string memory errorMessage
1070     ) internal view returns (bytes memory) {
1071         if (success) {
1072             if (returndata.length == 0) {
1073                 // only check isContract if the call was successful and the return data is empty
1074                 // otherwise we already know that it was a contract
1075                 require(isContract(target), "Address: call to non-contract");
1076             }
1077             return returndata;
1078         } else {
1079             _revert(returndata, errorMessage);
1080         }
1081     }



```

```
MathUpgradeable.log256(uint256) (Auction.sol#1614-1638) is never used and should be removed



    
1614     function log256(uint256 value) internal pure returns (uint256) {
1615         uint256 result = 0;
1616         unchecked {
1617             if (value >> 128 > 0) {
1618                 value >>= 128;
1619                 result += 16;
1620             }
1621             if (value >> 64 > 0) {
1622                 value >>= 64;
1623                 result += 8;
1624             }
1625             if (value >> 32 > 0) {
1626                 value >>= 32;
1627                 result += 4;
1628             }
1629             if (value >> 16 > 0) {
1630                 value >>= 16;
1631                 result += 2;
1632             }
1633             if (value >> 8 > 0) {
1634                 result += 1;
1635             }
1636         }
1637         return result;
1638     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (Auction.sol#1023-1032) is never used and should be removed



    
1023     function functionCallWithValue(
1024         address target,
1025         bytes memory data,
1026         uint256 value,
1027         string memory errorMessage
1028     ) internal returns (bytes memory) {
1029         require(address(this).balance >= value, "Address: insufficient balance for call");
1030         (bool success, bytes memory returndata) = target.call{value: value}(data);
1031         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
1032     }



```

### ETHx.sol


```
StringsUpgradeable.toString(uint256) (ETHx.sol#1955-1975) is never used and should be removed



    
1955     function toString(uint256 value) internal pure returns (string memory) {
1956         unchecked {
1957             uint256 length = MathUpgradeable.log10(value) + 1;
1958             string memory buffer = new string(length);
1959             uint256 ptr;
1960             /// @solidity memory-safe-assembly
1961             assembly {
1962                 ptr := add(buffer, add(32, length))
1963             }
1964             while (true) {
1965                 ptr--;
1966                 /// @solidity memory-safe-assembly
1967                 assembly {
1968                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
1969                 }
1970                 value /= 10;
1971                 if (value == 0) break;
1972             }
1973             return buffer;
1974         }
1975     }



```

```
ContextUpgradeable._msgData() (ETHx.sol#1108-1110) is never used and should be removed



    
1108     function _msgData() internal view virtual returns (bytes calldata) {
1109         return msg.data;
1110     }



```

```
MathUpgradeable.log2(uint256,MathUpgradeable.Rounding) (ETHx.sol#1845-1850) is never used and should be removed



    
1845     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
1846         unchecked {
1847             uint256 result = log2(value);
1848             return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
1849         }
1850     }



```

```
Initializable._isInitializing() (ETHx.sol#1083-1085) is never used and should be removed



    
1083     function _isInitializing() internal view returns (bool) {
1084         return _initializing;
1085     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256) (ETHx.sol#822-828) is never used and should be removed



    
822     function functionCallWithValue(
823         address target,
824         bytes memory data,
825         uint256 value
826     ) internal returns (bytes memory) {
827         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
828     }



```

```
MathUpgradeable.ceilDiv(uint256,uint256) (ETHx.sol#1643-1646) is never used and should be removed



    
1643     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
1644         // (a + b - 1) / b can overflow on addition, so we distribute.
1645         return a == 0 ? 0 : (a - 1) / b + 1;
1646     }



```

```
MathUpgradeable.min(uint256,uint256) (ETHx.sol#1624-1626) is never used and should be removed



    
1624     function min(uint256 a, uint256 b) internal pure returns (uint256) {
1625         return a < b ? a : b;
1626     }



```

```
MathUpgradeable.sqrt(uint256) (ETHx.sol#1756-1787) is never used and should be removed



    
1756     function sqrt(uint256 a) internal pure returns (uint256) {
1757         if (a == 0) {
1758             return 0;
1759         }
1760 
1761         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
1762         //
1763         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
1764         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
1765         //
1766         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
1767         // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
1768         // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
1769         //
1770         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
1771         uint256 result = 1 << (log2(a) >> 1);
1772 
1773         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
1774         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
1775         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
1776         // into the expected uint128 result.
1777         unchecked {
1778             result = (result + a / result) >> 1;
1779             result = (result + a / result) >> 1;
1780             result = (result + a / result) >> 1;
1781             result = (result + a / result) >> 1;
1782             result = (result + a / result) >> 1;
1783             result = (result + a / result) >> 1;
1784             result = (result + a / result) >> 1;
1785             return min(result, a / result);
1786         }
1787     }



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (ETHx.sol#522-532) is never used and should be removed



    
522     function getOperatorAddressByValidatorId(
523         uint8 _poolId,
524         uint256 _validatorId,
525         IStaderConfig _staderConfig
526     ) internal view returns (address) {
527         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
530 
531         return operatorAddress;
532     }



```

```
UtilLib.getPubkeyRoot(bytes) (ETHx.sol#561-568) is never used and should be removed



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {
562         if (_pubkey.length != VALIDATOR_PUBKEY_LENGTH) {
563             revert InvalidPubkeyLength();
564         }
565 
566         // Append 16 bytes of zero padding to the pubkey and compute its hash to get the pubkey root.
567         return sha256(abi.encodePacked(_pubkey, bytes16(0)));
568     }



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (ETHx.sol#492-507) is never used and should be removed



    
492     function getOperatorForValidSender(
493         uint8 _poolId,
494         uint256 _validatorId,
495         address _addr,
496         IStaderConfig _staderConfig
497     ) internal view returns (address) {
498         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );
502         if (_addr != withdrawVaultAddress) {
503             revert CallerNotWithdrawVault();
504         }
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
506         return operator;
507     }



```

```
MathUpgradeable.log10(uint256,MathUpgradeable.Rounding) (ETHx.sol#1894-1899) is never used and should be removed



    
1894     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
1895         unchecked {
1896             uint256 result = log10(value);
1897             return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);
1898         }
1899     }



```

```
AddressUpgradeable.functionCall(address,bytes) (ETHx.sol#793-795) is never used and should be removed



    
793     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
794         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
795     }



```

```
ContextUpgradeable.__Context_init_unchained() (ETHx.sol#1102-1103) is never used and should be removed



    
1102     function __Context_init_unchained() internal onlyInitializing {
1103     }



```

```
ERC165Upgradeable.__ERC165_init_unchained() (ETHx.sol#2052-2053) is never used and should be removed



    
2052     function __ERC165_init_unchained() internal onlyInitializing {
2053     }



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (ETHx.sol#570-580) is never used and should be removed



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)
571         internal
572         view
573         returns (bool)
574     {
575         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getValidatorPoolId(_pubkey);
576         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
577         uint256 validatorId = INodeRegistry(nodeRegistry).validatorIdByPubkey(_pubkey);
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);
579         return IVaultProxy(withdrawVaultAddress).vaultSettleStatus();
580     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (ETHx.sol#1653-1733) is never used and should be removed



    
1653     function mulDiv(
1654         uint256 x,
1655         uint256 y,
1656         uint256 denominator
1657     ) internal pure returns (uint256 result) {
1658         unchecked {
1659             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
1660             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
1661             // variables such that product = prod1 * 2^256 + prod0.
1662             uint256 prod0; // Least significant 256 bits of the product
1663             uint256 prod1; // Most significant 256 bits of the product
1664             assembly {
1665                 let mm := mulmod(x, y, not(0))
1666                 prod0 := mul(x, y)
1667                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1668             }
1669 
1670             // Handle non-overflow cases, 256 by 256 division.
1671             if (prod1 == 0) {
1672                 return prod0 / denominator;
1673             }
1674 
1675             // Make sure the result is less than 2^256. Also prevents denominator == 0.
1676             require(denominator > prod1);
1677 
1678             ///////////////////////////////////////////////
1679             // 512 by 256 division.
1680             ///////////////////////////////////////////////
1681 
1682             // Make division exact by subtracting the remainder from [prod1 prod0].
1683             uint256 remainder;
1684             assembly {
1685                 // Compute remainder using mulmod.
1686                 remainder := mulmod(x, y, denominator)
1687 
1688                 // Subtract 256 bit number from 512 bit number.
1689                 prod1 := sub(prod1, gt(remainder, prod0))
1690                 prod0 := sub(prod0, remainder)
1691             }
1692 
1693             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
1694             // See https://cs.stackexchange.com/q/138556/92363.
1695 
1696             // Does not overflow because the denominator cannot be zero at this stage in the function.
1697             uint256 twos = denominator & (~denominator + 1);
1698             assembly {
1699                 // Divide denominator by twos.
1700                 denominator := div(denominator, twos)
1701 
1702                 // Divide [prod1 prod0] by twos.
1703                 prod0 := div(prod0, twos)
1704 
1705                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1706                 twos := add(div(sub(0, twos), twos), 1)
1707             }
1708 
1709             // Shift in bits from prod1 into prod0.
1710             prod0 |= prod1 * twos;
1711 
1712             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
1713             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
1714             // four bits. That is, denominator * inv = 1 mod 2^4.
1715             uint256 inverse = (3 * denominator) ^ 2;
1716 
1717             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
1718             // in modular arithmetic, doubling the correct bits in each step.
1719             inverse *= 2 - denominator * inverse; // inverse mod 2^8
1720             inverse *= 2 - denominator * inverse; // inverse mod 2^16
1721             inverse *= 2 - denominator * inverse; // inverse mod 2^32
1722             inverse *= 2 - denominator * inverse; // inverse mod 2^64
1723             inverse *= 2 - denominator * inverse; // inverse mod 2^128
1724             inverse *= 2 - denominator * inverse; // inverse mod 2^256
1725 
1726             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
1727             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
1728             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
1729             // is no longer required.
1730             result = prod0 * inverse;
1731             return result;
1732         }
1733     }



```

```
AddressUpgradeable.functionCall(address,bytes,string) (ETHx.sol#803-809) is never used and should be removed



    
803     function functionCall(
804         address target,
805         bytes memory data,
806         string memory errorMessage
807     ) internal returns (bytes memory) {
808         return functionCallWithValue(target, data, 0, errorMessage);
809     }



```

```
AddressUpgradeable.sendValue(address,uint256) (ETHx.sol#768-773) is never used and should be removed



    
768     function sendValue(address payable recipient, uint256 amount) internal {
769         require(address(this).balance >= amount, "Address: insufficient balance");
770 
771         (bool success, ) = recipient.call{value: amount}("");
772         require(success, "Address: unable to send value, recipient may have reverted");
773     }



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (ETHx.sol#534-543) is never used and should be removed



    
534     function getOperatorAddressByOperatorId(
535         uint8 _poolId,
536         uint256 _operatorId,
537         IStaderConfig _staderConfig
538     ) internal view returns (address) {
539         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);
541 
542         return operatorAddress;
543     }



```

```
UtilLib.onlyStaderContract(address,IStaderConfig,bytes32) (ETHx.sol#466-474) is never used and should be removed



    
466     function onlyStaderContract(
467         address _addr,
468         IStaderConfig _staderConfig,
469         bytes32 _contractName
470     ) internal view {
471         if (!_staderConfig.onlyStaderContract(_addr, _contractName)) {
472             revert CallerNotStaderContract();
473         }
474     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes) (ETHx.sol#853-855) is never used and should be removed



    
853     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
854         return functionStaticCall(target, data, "Address: low-level static call failed");
855     }



```

```
MathUpgradeable.sqrt(uint256,MathUpgradeable.Rounding) (ETHx.sol#1792-1797) is never used and should be removed



    
1792     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
1793         unchecked {
1794             uint256 result = sqrt(a);
1795             return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
1796         }
1797     }



```

```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (ETHx.sol#509-520) is never used and should be removed



    
509     function onlyValidatorWithdrawVault(
510         uint8 _poolId,
511         uint256 _validatorId,
512         address _addr,
513         IStaderConfig _staderConfig
514     ) internal view {
515         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
517         if (_addr != withdrawVaultAddress) {
518             revert CallerNotWithdrawVault();
519         }
520     }



```

```
MathUpgradeable.log2(uint256) (ETHx.sol#1803-1839) is never used and should be removed



    
1803     function log2(uint256 value) internal pure returns (uint256) {
1804         uint256 result = 0;
1805         unchecked {
1806             if (value >> 128 > 0) {
1807                 value >>= 128;
1808                 result += 128;
1809             }
1810             if (value >> 64 > 0) {
1811                 value >>= 64;
1812                 result += 64;
1813             }
1814             if (value >> 32 > 0) {
1815                 value >>= 32;
1816                 result += 32;
1817             }
1818             if (value >> 16 > 0) {
1819                 value >>= 16;
1820                 result += 16;
1821             }
1822             if (value >> 8 > 0) {
1823                 value >>= 8;
1824                 result += 8;
1825             }
1826             if (value >> 4 > 0) {
1827                 value >>= 4;
1828                 result += 4;
1829             }
1830             if (value >> 2 > 0) {
1831                 value >>= 2;
1832                 result += 2;
1833             }
1834             if (value >> 1 > 0) {
1835                 result += 1;
1836             }
1837         }
1838         return result;
1839     }



```

```
UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig) (ETHx.sol#582-592) is never used and should be removed



    
582     function computeExchangeRate(
583         uint256 totalETHBalance,
584         uint256 totalETHXSupply,
585         IStaderConfig _staderConfig
586     ) internal view returns (uint256) {
587         uint256 DECIMALS = _staderConfig.getDecimals();
588         uint256 newExchangeRate = (totalETHBalance == 0 || totalETHXSupply == 0)
589             ? DECIMALS
590             : (totalETHBalance * DECIMALS) / totalETHXSupply;
591         return newExchangeRate;
592     }



```

```
AccessControlUpgradeable._setRoleAdmin(bytes32,bytes32) (ETHx.sol#2277-2281) is never used and should be removed



    
2277     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
2278         bytes32 previousAdminRole = getRoleAdmin(role);
2279         _roles[role].adminRole = adminRole;
2280         emit RoleAdminChanged(role, previousAdminRole, adminRole);
2281     }



```

```
MathUpgradeable.average(uint256,uint256) (ETHx.sol#1632-1635) is never used and should be removed



    
1632     function average(uint256 a, uint256 b) internal pure returns (uint256) {
1633         // (a + b) / 2 can overflow.
1634         return (a & b) + (a ^ b) / 2;
1635     }



```

```
StringsUpgradeable.toHexString(uint256) (ETHx.sol#1980-1984) is never used and should be removed



    
1980     function toHexString(uint256 value) internal pure returns (string memory) {
1981         unchecked {
1982             return toHexString(value, MathUpgradeable.log256(value) + 1);
1983         }
1984     }



```

```
MathUpgradeable.log10(uint256) (ETHx.sol#1856-1888) is never used and should be removed



    
1856     function log10(uint256 value) internal pure returns (uint256) {
1857         uint256 result = 0;
1858         unchecked {
1859             if (value >= 10**64) {
1860                 value /= 10**64;
1861                 result += 64;
1862             }
1863             if (value >= 10**32) {
1864                 value /= 10**32;
1865                 result += 32;
1866             }
1867             if (value >= 10**16) {
1868                 value /= 10**16;
1869                 result += 16;
1870             }
1871             if (value >= 10**8) {
1872                 value /= 10**8;
1873                 result += 8;
1874             }
1875             if (value >= 10**4) {
1876                 value /= 10**4;
1877                 result += 4;
1878             }
1879             if (value >= 10**2) {
1880                 value /= 10**2;
1881                 result += 2;
1882             }
1883             if (value >= 10**1) {
1884                 result += 1;
1885             }
1886         }
1887         return result;
1888     }



```

```
ERC165Upgradeable.__ERC165_init() (ETHx.sol#2049-2050) is never used and should be removed



    
2049     function __ERC165_init() internal onlyInitializing {
2050     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256,MathUpgradeable.Rounding) (ETHx.sol#1738-1749) is never used and should be removed



    
1738     function mulDiv(
1739         uint256 x,
1740         uint256 y,
1741         uint256 denominator,
1742         Rounding rounding
1743     ) internal pure returns (uint256) {
1744         uint256 result = mulDiv(x, y, denominator);
1745         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
1746             result += 1;
1747         }
1748         return result;
1749     }



```

```
AddressUpgradeable.verifyCallResult(bool,bytes,string) (ETHx.sol#902-912) is never used and should be removed



    
902     function verifyCallResult(
903         bool success,
904         bytes memory returndata,
905         string memory errorMessage
906     ) internal pure returns (bytes memory) {
907         if (success) {
908             return returndata;
909         } else {
910             _revert(returndata, errorMessage);
911         }
912     }



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (ETHx.sol#476-490) is never used and should be removed



    
476     function getPubkeyForValidSender(
477         uint8 _poolId,
478         uint256 _validatorId,
479         address _addr,
480         IStaderConfig _staderConfig
481     ) internal view returns (bytes memory) {
482         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );
486         if (_addr != withdrawVaultAddress) {
487             revert CallerNotWithdrawVault();
488         }
489         return pubkey;
490     }



```

```
AccessControlUpgradeable.__AccessControl_init_unchained() (ETHx.sol#2111-2112) is never used and should be removed



    
2111     function __AccessControl_init_unchained() internal onlyInitializing {
2112     }



```

```
AddressUpgradeable._revert(bytes,string) (ETHx.sol#914-926) is never used and should be removed



    
914     function _revert(bytes memory returndata, string memory errorMessage) private pure {
915         // Look for revert reason and bubble it up if present
916         if (returndata.length > 0) {
917             // The easiest way to bubble the revert reason is using memory via assembly
918             /// @solidity memory-safe-assembly
919             assembly {
920                 let returndata_size := mload(returndata)
921                 revert(add(32, returndata), returndata_size)
922             }
923         } else {
924             revert(errorMessage);
925         }
926     }



```

```
Initializable._getInitializedVersion() (ETHx.sol#1076-1078) is never used and should be removed



    
1076     function _getInitializedVersion() internal view returns (uint8) {
1077         return _initialized;
1078     }



```

```
AccessControlUpgradeable._setupRole(bytes32,address) (ETHx.sol#2268-2270) is never used and should be removed



    
2268     function _setupRole(bytes32 role, address account) internal virtual {
2269         _grantRole(role, account);
2270     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes,string) (ETHx.sol#863-870) is never used and should be removed



    
863     function functionStaticCall(
864         address target,
865         bytes memory data,
866         string memory errorMessage
867     ) internal view returns (bytes memory) {
868         (bool success, bytes memory returndata) = target.staticcall(data);
869         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
870     }



```

```
MathUpgradeable.log256(uint256,MathUpgradeable.Rounding) (ETHx.sol#1937-1942) is never used and should be removed



    
1937     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
1938         unchecked {
1939             uint256 result = log256(value);
1940             return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);
1941         }
1942     }



```

```
UtilLib.onlyOperatorRole(address,IStaderConfig) (ETHx.sol#459-463) is never used and should be removed



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {
460         if (!_staderConfig.onlyOperatorRole(_addr)) {
461             revert CallerNotOperator();
462         }
463     }



```

```
UtilLib.sendValue(address,uint256) (ETHx.sol#594-599) is never used and should be removed



    
594     function sendValue(address _receiver, uint256 _amount) internal {
595         (bool success, ) = payable(_receiver).call{value: _amount}('');
596         if (!success) {
597             revert TransferFailed();
598         }
599     }



```

```
MathUpgradeable.max(uint256,uint256) (ETHx.sol#1617-1619) is never used and should be removed



    
1617     function max(uint256 a, uint256 b) internal pure returns (uint256) {
1618         return a > b ? a : b;
1619     }



```

```
ContextUpgradeable.__Context_init() (ETHx.sol#1099-1100) is never used and should be removed



    
1099     function __Context_init() internal onlyInitializing {
1100     }



```

```
UtilLib.getOperatorRewardAddress(address,IStaderConfig) (ETHx.sol#545-554) is never used and should be removed



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)
546         internal
547         view
548         returns (address payable)
549     {
550         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getOperatorPoolId(_operator);
551         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
552         uint256 operatorId = INodeRegistry(nodeRegistry).operatorIDByAddress(_operator);
553         return INodeRegistry(nodeRegistry).getOperatorRewardAddress(operatorId);
554     }



```

```
AddressUpgradeable.verifyCallResultFromTarget(address,bool,bytes,string) (ETHx.sol#878-894) is never used and should be removed



    
878     function verifyCallResultFromTarget(
879         address target,
880         bool success,
881         bytes memory returndata,
882         string memory errorMessage
883     ) internal view returns (bytes memory) {
884         if (success) {
885             if (returndata.length == 0) {
886                 // only check isContract if the call was successful and the return data is empty
887                 // otherwise we already know that it was a contract
888                 require(isContract(target), "Address: call to non-contract");
889             }
890             return returndata;
891         } else {
892             _revert(returndata, errorMessage);
893         }
894     }



```

```
MathUpgradeable.log256(uint256) (ETHx.sol#1907-1931) is never used and should be removed



    
1907     function log256(uint256 value) internal pure returns (uint256) {
1908         uint256 result = 0;
1909         unchecked {
1910             if (value >> 128 > 0) {
1911                 value >>= 128;
1912                 result += 16;
1913             }
1914             if (value >> 64 > 0) {
1915                 value >>= 64;
1916                 result += 8;
1917             }
1918             if (value >> 32 > 0) {
1919                 value >>= 32;
1920                 result += 4;
1921             }
1922             if (value >> 16 > 0) {
1923                 value >>= 16;
1924                 result += 2;
1925             }
1926             if (value >> 8 > 0) {
1927                 result += 1;
1928             }
1929         }
1930         return result;
1931     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (ETHx.sol#836-845) is never used and should be removed



    
836     function functionCallWithValue(
837         address target,
838         bytes memory data,
839         uint256 value,
840         string memory errorMessage
841     ) internal returns (bytes memory) {
842         require(address(this).balance >= value, "Address: insufficient balance for call");
843         (bool success, bytes memory returndata) = target.call{value: value}(data);
844         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
845     }



```

### NodeELRewardVault.sol


```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (NodeELRewardVault.sol#522-532) is never used and should be removed



    
522     function getOperatorAddressByValidatorId(
523         uint8 _poolId,
524         uint256 _validatorId,
525         IStaderConfig _staderConfig
526     ) internal view returns (address) {
527         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
530 
531         return operatorAddress;
532     }



```

```
UtilLib.getPubkeyRoot(bytes) (NodeELRewardVault.sol#561-568) is never used and should be removed



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {
562         if (_pubkey.length != VALIDATOR_PUBKEY_LENGTH) {
563             revert InvalidPubkeyLength();
564         }
565 
566         // Append 16 bytes of zero padding to the pubkey and compute its hash to get the pubkey root.
567         return sha256(abi.encodePacked(_pubkey, bytes16(0)));
568     }



```

```
UtilLib.checkNonZeroAddress(address) (NodeELRewardVault.sol#448-450) is never used and should be removed



    
448     function checkNonZeroAddress(address _address) internal pure {
449         if (_address == address(0)) revert ZeroAddress();
450     }



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (NodeELRewardVault.sol#492-507) is never used and should be removed



    
492     function getOperatorForValidSender(
493         uint8 _poolId,
494         uint256 _validatorId,
495         address _addr,
496         IStaderConfig _staderConfig
497     ) internal view returns (address) {
498         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );
502         if (_addr != withdrawVaultAddress) {
503             revert CallerNotWithdrawVault();
504         }
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
506         return operator;
507     }



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (NodeELRewardVault.sol#570-580) is never used and should be removed



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)
571         internal
572         view
573         returns (bool)
574     {
575         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getValidatorPoolId(_pubkey);
576         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
577         uint256 validatorId = INodeRegistry(nodeRegistry).validatorIdByPubkey(_pubkey);
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);
579         return IVaultProxy(withdrawVaultAddress).vaultSettleStatus();
580     }



```

```
UtilLib.onlyStaderContract(address,IStaderConfig,bytes32) (NodeELRewardVault.sol#466-474) is never used and should be removed



    
466     function onlyStaderContract(
467         address _addr,
468         IStaderConfig _staderConfig,
469         bytes32 _contractName
470     ) internal view {
471         if (!_staderConfig.onlyStaderContract(_addr, _contractName)) {
472             revert CallerNotStaderContract();
473         }
474     }



```

```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (NodeELRewardVault.sol#509-520) is never used and should be removed



    
509     function onlyValidatorWithdrawVault(
510         uint8 _poolId,
511         uint256 _validatorId,
512         address _addr,
513         IStaderConfig _staderConfig
514     ) internal view {
515         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
517         if (_addr != withdrawVaultAddress) {
518             revert CallerNotWithdrawVault();
519         }
520     }



```

```
UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig) (NodeELRewardVault.sol#582-592) is never used and should be removed



    
582     function computeExchangeRate(
583         uint256 totalETHBalance,
584         uint256 totalETHXSupply,
585         IStaderConfig _staderConfig
586     ) internal view returns (uint256) {
587         uint256 DECIMALS = _staderConfig.getDecimals();
588         uint256 newExchangeRate = (totalETHBalance == 0 || totalETHXSupply == 0)
589             ? DECIMALS
590             : (totalETHBalance * DECIMALS) / totalETHXSupply;
591         return newExchangeRate;
592     }



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (NodeELRewardVault.sol#476-490) is never used and should be removed



    
476     function getPubkeyForValidSender(
477         uint8 _poolId,
478         uint256 _validatorId,
479         address _addr,
480         IStaderConfig _staderConfig
481     ) internal view returns (bytes memory) {
482         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );
486         if (_addr != withdrawVaultAddress) {
487             revert CallerNotWithdrawVault();
488         }
489         return pubkey;
490     }



```

```
UtilLib.onlyOperatorRole(address,IStaderConfig) (NodeELRewardVault.sol#459-463) is never used and should be removed



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {
460         if (!_staderConfig.onlyOperatorRole(_addr)) {
461             revert CallerNotOperator();
462         }
463     }



```

```
UtilLib.onlyManagerRole(address,IStaderConfig) (NodeELRewardVault.sol#453-457) is never used and should be removed



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {
454         if (!_staderConfig.onlyManagerRole(_addr)) {
455             revert CallerNotManager();
456         }
457     }



```

```
UtilLib.getOperatorRewardAddress(address,IStaderConfig) (NodeELRewardVault.sol#545-554) is never used and should be removed



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)
546         internal
547         view
548         returns (address payable)
549     {
550         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getOperatorPoolId(_operator);
551         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
552         uint256 operatorId = INodeRegistry(nodeRegistry).operatorIDByAddress(_operator);
553         return INodeRegistry(nodeRegistry).getOperatorRewardAddress(operatorId);
554     }



```

### OperatorRewardsCollector.sol


```
StringsUpgradeable.toString(uint256) (OperatorRewardsCollector.sol#1470-1490) is never used and should be removed



    
1470     function toString(uint256 value) internal pure returns (string memory) {
1471         unchecked {
1472             uint256 length = MathUpgradeable.log10(value) + 1;
1473             string memory buffer = new string(length);
1474             uint256 ptr;
1475             /// @solidity memory-safe-assembly
1476             assembly {
1477                 ptr := add(buffer, add(32, length))
1478             }
1479             while (true) {
1480                 ptr--;
1481                 /// @solidity memory-safe-assembly
1482                 assembly {
1483                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
1484                 }
1485                 value /= 10;
1486                 if (value == 0) break;
1487             }
1488             return buffer;
1489         }
1490     }



```

```
ContextUpgradeable._msgData() (OperatorRewardsCollector.sol#1103-1105) is never used and should be removed



    
1103     function _msgData() internal view virtual returns (bytes calldata) {
1104         return msg.data;
1105     }



```

```
MathUpgradeable.log2(uint256,MathUpgradeable.Rounding) (OperatorRewardsCollector.sol#1360-1365) is never used and should be removed



    
1360     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
1361         unchecked {
1362             uint256 result = log2(value);
1363             return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
1364         }
1365     }



```

```
Initializable._isInitializing() (OperatorRewardsCollector.sol#1078-1080) is never used and should be removed



    
1078     function _isInitializing() internal view returns (bool) {
1079         return _initializing;
1080     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256) (OperatorRewardsCollector.sol#817-823) is never used and should be removed



    
817     function functionCallWithValue(
818         address target,
819         bytes memory data,
820         uint256 value
821     ) internal returns (bytes memory) {
822         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
823     }



```

```
MathUpgradeable.ceilDiv(uint256,uint256) (OperatorRewardsCollector.sol#1158-1161) is never used and should be removed



    
1158     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
1159         // (a + b - 1) / b can overflow on addition, so we distribute.
1160         return a == 0 ? 0 : (a - 1) / b + 1;
1161     }



```

```
MathUpgradeable.min(uint256,uint256) (OperatorRewardsCollector.sol#1139-1141) is never used and should be removed



    
1139     function min(uint256 a, uint256 b) internal pure returns (uint256) {
1140         return a < b ? a : b;
1141     }



```

```
PausableUpgradeable._unpause() (OperatorRewardsCollector.sol#1933-1936) is never used and should be removed



    
1933     function _unpause() internal virtual whenPaused {
1934         _paused = false;
1935         emit Unpaused(_msgSender());
1936     }



```

```
MathUpgradeable.sqrt(uint256) (OperatorRewardsCollector.sol#1271-1302) is never used and should be removed



    
1271     function sqrt(uint256 a) internal pure returns (uint256) {
1272         if (a == 0) {
1273             return 0;
1274         }
1275 
1276         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
1277         //
1278         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
1279         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
1280         //
1281         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
1282         // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
1283         // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
1284         //
1285         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
1286         uint256 result = 1 << (log2(a) >> 1);
1287 
1288         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
1289         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
1290         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
1291         // into the expected uint128 result.
1292         unchecked {
1293             result = (result + a / result) >> 1;
1294             result = (result + a / result) >> 1;
1295             result = (result + a / result) >> 1;
1296             result = (result + a / result) >> 1;
1297             result = (result + a / result) >> 1;
1298             result = (result + a / result) >> 1;
1299             result = (result + a / result) >> 1;
1300             return min(result, a / result);
1301         }
1302     }



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (OperatorRewardsCollector.sol#522-532) is never used and should be removed



    
522     function getOperatorAddressByValidatorId(
523         uint8 _poolId,
524         uint256 _validatorId,
525         IStaderConfig _staderConfig
526     ) internal view returns (address) {
527         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
530 
531         return operatorAddress;
532     }



```

```
PausableUpgradeable._requirePaused() (OperatorRewardsCollector.sol#1910-1912) is never used and should be removed



    
1910     function _requirePaused() internal view virtual {
1911         require(paused(), "Pausable: not paused");
1912     }



```

```
UtilLib.getPubkeyRoot(bytes) (OperatorRewardsCollector.sol#561-568) is never used and should be removed



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {
562         if (_pubkey.length != VALIDATOR_PUBKEY_LENGTH) {
563             revert InvalidPubkeyLength();
564         }
565 
566         // Append 16 bytes of zero padding to the pubkey and compute its hash to get the pubkey root.
567         return sha256(abi.encodePacked(_pubkey, bytes16(0)));
568     }



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (OperatorRewardsCollector.sol#492-507) is never used and should be removed



    
492     function getOperatorForValidSender(
493         uint8 _poolId,
494         uint256 _validatorId,
495         address _addr,
496         IStaderConfig _staderConfig
497     ) internal view returns (address) {
498         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );
502         if (_addr != withdrawVaultAddress) {
503             revert CallerNotWithdrawVault();
504         }
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
506         return operator;
507     }



```

```
MathUpgradeable.log10(uint256,MathUpgradeable.Rounding) (OperatorRewardsCollector.sol#1409-1414) is never used and should be removed



    
1409     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
1410         unchecked {
1411             uint256 result = log10(value);
1412             return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);
1413         }
1414     }



```

```
AddressUpgradeable.functionCall(address,bytes) (OperatorRewardsCollector.sol#788-790) is never used and should be removed



    
788     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
789         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
790     }



```

```
ContextUpgradeable.__Context_init_unchained() (OperatorRewardsCollector.sol#1097-1098) is never used and should be removed



    
1097     function __Context_init_unchained() internal onlyInitializing {
1098     }



```

```
ERC165Upgradeable.__ERC165_init_unchained() (OperatorRewardsCollector.sol#1567-1568) is never used and should be removed



    
1567     function __ERC165_init_unchained() internal onlyInitializing {
1568     }



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (OperatorRewardsCollector.sol#570-580) is never used and should be removed



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)
571         internal
572         view
573         returns (bool)
574     {
575         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getValidatorPoolId(_pubkey);
576         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
577         uint256 validatorId = INodeRegistry(nodeRegistry).validatorIdByPubkey(_pubkey);
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);
579         return IVaultProxy(withdrawVaultAddress).vaultSettleStatus();
580     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (OperatorRewardsCollector.sol#1168-1248) is never used and should be removed



    
1168     function mulDiv(
1169         uint256 x,
1170         uint256 y,
1171         uint256 denominator
1172     ) internal pure returns (uint256 result) {
1173         unchecked {
1174             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
1175             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
1176             // variables such that product = prod1 * 2^256 + prod0.
1177             uint256 prod0; // Least significant 256 bits of the product
1178             uint256 prod1; // Most significant 256 bits of the product
1179             assembly {
1180                 let mm := mulmod(x, y, not(0))
1181                 prod0 := mul(x, y)
1182                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1183             }
1184 
1185             // Handle non-overflow cases, 256 by 256 division.
1186             if (prod1 == 0) {
1187                 return prod0 / denominator;
1188             }
1189 
1190             // Make sure the result is less than 2^256. Also prevents denominator == 0.
1191             require(denominator > prod1);
1192 
1193             ///////////////////////////////////////////////
1194             // 512 by 256 division.
1195             ///////////////////////////////////////////////
1196 
1197             // Make division exact by subtracting the remainder from [prod1 prod0].
1198             uint256 remainder;
1199             assembly {
1200                 // Compute remainder using mulmod.
1201                 remainder := mulmod(x, y, denominator)
1202 
1203                 // Subtract 256 bit number from 512 bit number.
1204                 prod1 := sub(prod1, gt(remainder, prod0))
1205                 prod0 := sub(prod0, remainder)
1206             }
1207 
1208             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
1209             // See https://cs.stackexchange.com/q/138556/92363.
1210 
1211             // Does not overflow because the denominator cannot be zero at this stage in the function.
1212             uint256 twos = denominator & (~denominator + 1);
1213             assembly {
1214                 // Divide denominator by twos.
1215                 denominator := div(denominator, twos)
1216 
1217                 // Divide [prod1 prod0] by twos.
1218                 prod0 := div(prod0, twos)
1219 
1220                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1221                 twos := add(div(sub(0, twos), twos), 1)
1222             }
1223 
1224             // Shift in bits from prod1 into prod0.
1225             prod0 |= prod1 * twos;
1226 
1227             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
1228             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
1229             // four bits. That is, denominator * inv = 1 mod 2^4.
1230             uint256 inverse = (3 * denominator) ^ 2;
1231 
1232             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
1233             // in modular arithmetic, doubling the correct bits in each step.
1234             inverse *= 2 - denominator * inverse; // inverse mod 2^8
1235             inverse *= 2 - denominator * inverse; // inverse mod 2^16
1236             inverse *= 2 - denominator * inverse; // inverse mod 2^32
1237             inverse *= 2 - denominator * inverse; // inverse mod 2^64
1238             inverse *= 2 - denominator * inverse; // inverse mod 2^128
1239             inverse *= 2 - denominator * inverse; // inverse mod 2^256
1240 
1241             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
1242             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
1243             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
1244             // is no longer required.
1245             result = prod0 * inverse;
1246             return result;
1247         }
1248     }



```

```
AddressUpgradeable.functionCall(address,bytes,string) (OperatorRewardsCollector.sol#798-804) is never used and should be removed



    
798     function functionCall(
799         address target,
800         bytes memory data,
801         string memory errorMessage
802     ) internal returns (bytes memory) {
803         return functionCallWithValue(target, data, 0, errorMessage);
804     }



```

```
AddressUpgradeable.sendValue(address,uint256) (OperatorRewardsCollector.sol#763-768) is never used and should be removed



    
763     function sendValue(address payable recipient, uint256 amount) internal {
764         require(address(this).balance >= amount, "Address: insufficient balance");
765 
766         (bool success, ) = recipient.call{value: amount}("");
767         require(success, "Address: unable to send value, recipient may have reverted");
768     }



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (OperatorRewardsCollector.sol#534-543) is never used and should be removed



    
534     function getOperatorAddressByOperatorId(
535         uint8 _poolId,
536         uint256 _operatorId,
537         IStaderConfig _staderConfig
538     ) internal view returns (address) {
539         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);
541 
542         return operatorAddress;
543     }



```

```
UtilLib.onlyStaderContract(address,IStaderConfig,bytes32) (OperatorRewardsCollector.sol#466-474) is never used and should be removed



    
466     function onlyStaderContract(
467         address _addr,
468         IStaderConfig _staderConfig,
469         bytes32 _contractName
470     ) internal view {
471         if (!_staderConfig.onlyStaderContract(_addr, _contractName)) {
472             revert CallerNotStaderContract();
473         }
474     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes) (OperatorRewardsCollector.sol#848-850) is never used and should be removed



    
848     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
849         return functionStaticCall(target, data, "Address: low-level static call failed");
850     }



```

```
MathUpgradeable.sqrt(uint256,MathUpgradeable.Rounding) (OperatorRewardsCollector.sol#1307-1312) is never used and should be removed



    
1307     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
1308         unchecked {
1309             uint256 result = sqrt(a);
1310             return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
1311         }
1312     }



```

```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (OperatorRewardsCollector.sol#509-520) is never used and should be removed



    
509     function onlyValidatorWithdrawVault(
510         uint8 _poolId,
511         uint256 _validatorId,
512         address _addr,
513         IStaderConfig _staderConfig
514     ) internal view {
515         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
517         if (_addr != withdrawVaultAddress) {
518             revert CallerNotWithdrawVault();
519         }
520     }



```

```
MathUpgradeable.log2(uint256) (OperatorRewardsCollector.sol#1318-1354) is never used and should be removed



    
1318     function log2(uint256 value) internal pure returns (uint256) {
1319         uint256 result = 0;
1320         unchecked {
1321             if (value >> 128 > 0) {
1322                 value >>= 128;
1323                 result += 128;
1324             }
1325             if (value >> 64 > 0) {
1326                 value >>= 64;
1327                 result += 64;
1328             }
1329             if (value >> 32 > 0) {
1330                 value >>= 32;
1331                 result += 32;
1332             }
1333             if (value >> 16 > 0) {
1334                 value >>= 16;
1335                 result += 16;
1336             }
1337             if (value >> 8 > 0) {
1338                 value >>= 8;
1339                 result += 8;
1340             }
1341             if (value >> 4 > 0) {
1342                 value >>= 4;
1343                 result += 4;
1344             }
1345             if (value >> 2 > 0) {
1346                 value >>= 2;
1347                 result += 2;
1348             }
1349             if (value >> 1 > 0) {
1350                 result += 1;
1351             }
1352         }
1353         return result;
1354     }



```

```
UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig) (OperatorRewardsCollector.sol#582-592) is never used and should be removed



    
582     function computeExchangeRate(
583         uint256 totalETHBalance,
584         uint256 totalETHXSupply,
585         IStaderConfig _staderConfig
586     ) internal view returns (uint256) {
587         uint256 DECIMALS = _staderConfig.getDecimals();
588         uint256 newExchangeRate = (totalETHBalance == 0 || totalETHXSupply == 0)
589             ? DECIMALS
590             : (totalETHBalance * DECIMALS) / totalETHXSupply;
591         return newExchangeRate;
592     }



```

```
AccessControlUpgradeable._setRoleAdmin(bytes32,bytes32) (OperatorRewardsCollector.sol#1792-1796) is never used and should be removed



    
1792     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
1793         bytes32 previousAdminRole = getRoleAdmin(role);
1794         _roles[role].adminRole = adminRole;
1795         emit RoleAdminChanged(role, previousAdminRole, adminRole);
1796     }



```

```
MathUpgradeable.average(uint256,uint256) (OperatorRewardsCollector.sol#1147-1150) is never used and should be removed



    
1147     function average(uint256 a, uint256 b) internal pure returns (uint256) {
1148         // (a + b) / 2 can overflow.
1149         return (a & b) + (a ^ b) / 2;
1150     }



```

```
StringsUpgradeable.toHexString(uint256) (OperatorRewardsCollector.sol#1495-1499) is never used and should be removed



    
1495     function toHexString(uint256 value) internal pure returns (string memory) {
1496         unchecked {
1497             return toHexString(value, MathUpgradeable.log256(value) + 1);
1498         }
1499     }



```

```
MathUpgradeable.log10(uint256) (OperatorRewardsCollector.sol#1371-1403) is never used and should be removed



    
1371     function log10(uint256 value) internal pure returns (uint256) {
1372         uint256 result = 0;
1373         unchecked {
1374             if (value >= 10**64) {
1375                 value /= 10**64;
1376                 result += 64;
1377             }
1378             if (value >= 10**32) {
1379                 value /= 10**32;
1380                 result += 32;
1381             }
1382             if (value >= 10**16) {
1383                 value /= 10**16;
1384                 result += 16;
1385             }
1386             if (value >= 10**8) {
1387                 value /= 10**8;
1388                 result += 8;
1389             }
1390             if (value >= 10**4) {
1391                 value /= 10**4;
1392                 result += 4;
1393             }
1394             if (value >= 10**2) {
1395                 value /= 10**2;
1396                 result += 2;
1397             }
1398             if (value >= 10**1) {
1399                 result += 1;
1400             }
1401         }
1402         return result;
1403     }



```

```
ERC165Upgradeable.__ERC165_init() (OperatorRewardsCollector.sol#1564-1565) is never used and should be removed



    
1564     function __ERC165_init() internal onlyInitializing {
1565     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256,MathUpgradeable.Rounding) (OperatorRewardsCollector.sol#1253-1264) is never used and should be removed



    
1253     function mulDiv(
1254         uint256 x,
1255         uint256 y,
1256         uint256 denominator,
1257         Rounding rounding
1258     ) internal pure returns (uint256) {
1259         uint256 result = mulDiv(x, y, denominator);
1260         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
1261             result += 1;
1262         }
1263         return result;
1264     }



```

```
PausableUpgradeable._pause() (OperatorRewardsCollector.sol#1921-1924) is never used and should be removed



    
1921     function _pause() internal virtual whenNotPaused {
1922         _paused = true;
1923         emit Paused(_msgSender());
1924     }



```

```
AddressUpgradeable.verifyCallResult(bool,bytes,string) (OperatorRewardsCollector.sol#897-907) is never used and should be removed



    
897     function verifyCallResult(
898         bool success,
899         bytes memory returndata,
900         string memory errorMessage
901     ) internal pure returns (bytes memory) {
902         if (success) {
903             return returndata;
904         } else {
905             _revert(returndata, errorMessage);
906         }
907     }



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (OperatorRewardsCollector.sol#476-490) is never used and should be removed



    
476     function getPubkeyForValidSender(
477         uint8 _poolId,
478         uint256 _validatorId,
479         address _addr,
480         IStaderConfig _staderConfig
481     ) internal view returns (bytes memory) {
482         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );
486         if (_addr != withdrawVaultAddress) {
487             revert CallerNotWithdrawVault();
488         }
489         return pubkey;
490     }



```

```
AccessControlUpgradeable.__AccessControl_init_unchained() (OperatorRewardsCollector.sol#1626-1627) is never used and should be removed



    
1626     function __AccessControl_init_unchained() internal onlyInitializing {
1627     }



```

```
AddressUpgradeable._revert(bytes,string) (OperatorRewardsCollector.sol#909-921) is never used and should be removed



    
909     function _revert(bytes memory returndata, string memory errorMessage) private pure {
910         // Look for revert reason and bubble it up if present
911         if (returndata.length > 0) {
912             // The easiest way to bubble the revert reason is using memory via assembly
913             /// @solidity memory-safe-assembly
914             assembly {
915                 let returndata_size := mload(returndata)
916                 revert(add(32, returndata), returndata_size)
917             }
918         } else {
919             revert(errorMessage);
920         }
921     }



```

```
Initializable._getInitializedVersion() (OperatorRewardsCollector.sol#1071-1073) is never used and should be removed



    
1071     function _getInitializedVersion() internal view returns (uint8) {
1072         return _initialized;
1073     }



```

```
AccessControlUpgradeable._setupRole(bytes32,address) (OperatorRewardsCollector.sol#1783-1785) is never used and should be removed



    
1783     function _setupRole(bytes32 role, address account) internal virtual {
1784         _grantRole(role, account);
1785     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes,string) (OperatorRewardsCollector.sol#858-865) is never used and should be removed



    
858     function functionStaticCall(
859         address target,
860         bytes memory data,
861         string memory errorMessage
862     ) internal view returns (bytes memory) {
863         (bool success, bytes memory returndata) = target.staticcall(data);
864         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
865     }



```

```
MathUpgradeable.log256(uint256,MathUpgradeable.Rounding) (OperatorRewardsCollector.sol#1452-1457) is never used and should be removed



    
1452     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
1453         unchecked {
1454             uint256 result = log256(value);
1455             return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);
1456         }
1457     }



```

```
UtilLib.onlyOperatorRole(address,IStaderConfig) (OperatorRewardsCollector.sol#459-463) is never used and should be removed



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {
460         if (!_staderConfig.onlyOperatorRole(_addr)) {
461             revert CallerNotOperator();
462         }
463     }



```

```
MathUpgradeable.max(uint256,uint256) (OperatorRewardsCollector.sol#1132-1134) is never used and should be removed



    
1132     function max(uint256 a, uint256 b) internal pure returns (uint256) {
1133         return a > b ? a : b;
1134     }



```

```
ContextUpgradeable.__Context_init() (OperatorRewardsCollector.sol#1094-1095) is never used and should be removed



    
1094     function __Context_init() internal onlyInitializing {
1095     }



```

```
UtilLib.onlyManagerRole(address,IStaderConfig) (OperatorRewardsCollector.sol#453-457) is never used and should be removed



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {
454         if (!_staderConfig.onlyManagerRole(_addr)) {
455             revert CallerNotManager();
456         }
457     }



```

```
AddressUpgradeable.verifyCallResultFromTarget(address,bool,bytes,string) (OperatorRewardsCollector.sol#873-889) is never used and should be removed



    
873     function verifyCallResultFromTarget(
874         address target,
875         bool success,
876         bytes memory returndata,
877         string memory errorMessage
878     ) internal view returns (bytes memory) {
879         if (success) {
880             if (returndata.length == 0) {
881                 // only check isContract if the call was successful and the return data is empty
882                 // otherwise we already know that it was a contract
883                 require(isContract(target), "Address: call to non-contract");
884             }
885             return returndata;
886         } else {
887             _revert(returndata, errorMessage);
888         }
889     }



```

```
MathUpgradeable.log256(uint256) (OperatorRewardsCollector.sol#1422-1446) is never used and should be removed



    
1422     function log256(uint256 value) internal pure returns (uint256) {
1423         uint256 result = 0;
1424         unchecked {
1425             if (value >> 128 > 0) {
1426                 value >>= 128;
1427                 result += 16;
1428             }
1429             if (value >> 64 > 0) {
1430                 value >>= 64;
1431                 result += 8;
1432             }
1433             if (value >> 32 > 0) {
1434                 value >>= 32;
1435                 result += 4;
1436             }
1437             if (value >> 16 > 0) {
1438                 value >>= 16;
1439                 result += 2;
1440             }
1441             if (value >> 8 > 0) {
1442                 result += 1;
1443             }
1444         }
1445         return result;
1446     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (OperatorRewardsCollector.sol#831-840) is never used and should be removed



    
831     function functionCallWithValue(
832         address target,
833         bytes memory data,
834         uint256 value,
835         string memory errorMessage
836     ) internal returns (bytes memory) {
837         require(address(this).balance >= value, "Address: insufficient balance for call");
838         (bool success, bytes memory returndata) = target.call{value: value}(data);
839         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
840     }



```

### Penalty.sol


```
StringsUpgradeable.toString(uint256) (Penalty.sol#1932-1952) is never used and should be removed



    
1932     function toString(uint256 value) internal pure returns (string memory) {
1933         unchecked {
1934             uint256 length = MathUpgradeable.log10(value) + 1;
1935             string memory buffer = new string(length);
1936             uint256 ptr;
1937             /// @solidity memory-safe-assembly
1938             assembly {
1939                 ptr := add(buffer, add(32, length))
1940             }
1941             while (true) {
1942                 ptr--;
1943                 /// @solidity memory-safe-assembly
1944                 assembly {
1945                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
1946                 }
1947                 value /= 10;
1948                 if (value == 0) break;
1949             }
1950             return buffer;
1951         }
1952     }



```

```
ContextUpgradeable._msgData() (Penalty.sol#1565-1567) is never used and should be removed



    
1565     function _msgData() internal view virtual returns (bytes calldata) {
1566         return msg.data;
1567     }



```

```
MathUpgradeable.log2(uint256,MathUpgradeable.Rounding) (Penalty.sol#1822-1827) is never used and should be removed



    
1822     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
1823         unchecked {
1824             uint256 result = log2(value);
1825             return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
1826         }
1827     }



```

```
Initializable._isInitializing() (Penalty.sol#1540-1542) is never used and should be removed



    
1540     function _isInitializing() internal view returns (bool) {
1541         return _initializing;
1542     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256) (Penalty.sol#1279-1285) is never used and should be removed



    
1279     function functionCallWithValue(
1280         address target,
1281         bytes memory data,
1282         uint256 value
1283     ) internal returns (bytes memory) {
1284         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
1285     }



```

```
MathUpgradeable.ceilDiv(uint256,uint256) (Penalty.sol#1620-1623) is never used and should be removed



    
1620     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
1621         // (a + b - 1) / b can overflow on addition, so we distribute.
1622         return a == 0 ? 0 : (a - 1) / b + 1;
1623     }



```

```
MathUpgradeable.min(uint256,uint256) (Penalty.sol#1601-1603) is never used and should be removed



    
1601     function min(uint256 a, uint256 b) internal pure returns (uint256) {
1602         return a < b ? a : b;
1603     }



```

```
MathUpgradeable.sqrt(uint256) (Penalty.sol#1733-1764) is never used and should be removed



    
1733     function sqrt(uint256 a) internal pure returns (uint256) {
1734         if (a == 0) {
1735             return 0;
1736         }
1737 
1738         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
1739         //
1740         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
1741         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
1742         //
1743         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
1744         // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
1745         // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
1746         //
1747         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
1748         uint256 result = 1 << (log2(a) >> 1);
1749 
1750         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
1751         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
1752         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
1753         // into the expected uint128 result.
1754         unchecked {
1755             result = (result + a / result) >> 1;
1756             result = (result + a / result) >> 1;
1757             result = (result + a / result) >> 1;
1758             result = (result + a / result) >> 1;
1759             result = (result + a / result) >> 1;
1760             result = (result + a / result) >> 1;
1761             result = (result + a / result) >> 1;
1762             return min(result, a / result);
1763         }
1764     }



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (Penalty.sol#522-532) is never used and should be removed



    
522     function getOperatorAddressByValidatorId(
523         uint8 _poolId,
524         uint256 _validatorId,
525         IStaderConfig _staderConfig
526     ) internal view returns (address) {
527         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
530 
531         return operatorAddress;
532     }



```

```
AccessControlUpgradeable.__AccessControl_init() (Penalty.sol#2085-2086) is never used and should be removed



    
2085     function __AccessControl_init() internal onlyInitializing {
2086     }



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (Penalty.sol#492-507) is never used and should be removed



    
492     function getOperatorForValidSender(
493         uint8 _poolId,
494         uint256 _validatorId,
495         address _addr,
496         IStaderConfig _staderConfig
497     ) internal view returns (address) {
498         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );
502         if (_addr != withdrawVaultAddress) {
503             revert CallerNotWithdrawVault();
504         }
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
506         return operator;
507     }



```

```
MathUpgradeable.log10(uint256,MathUpgradeable.Rounding) (Penalty.sol#1871-1876) is never used and should be removed



    
1871     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
1872         unchecked {
1873             uint256 result = log10(value);
1874             return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);
1875         }
1876     }



```

```
AddressUpgradeable.functionCall(address,bytes) (Penalty.sol#1250-1252) is never used and should be removed



    
1250     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
1251         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
1252     }



```

```
ContextUpgradeable.__Context_init_unchained() (Penalty.sol#1559-1560) is never used and should be removed



    
1559     function __Context_init_unchained() internal onlyInitializing {
1560     }



```

```
ERC165Upgradeable.__ERC165_init_unchained() (Penalty.sol#2029-2030) is never used and should be removed



    
2029     function __ERC165_init_unchained() internal onlyInitializing {
2030     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (Penalty.sol#1630-1710) is never used and should be removed



    
1630     function mulDiv(
1631         uint256 x,
1632         uint256 y,
1633         uint256 denominator
1634     ) internal pure returns (uint256 result) {
1635         unchecked {
1636             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
1637             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
1638             // variables such that product = prod1 * 2^256 + prod0.
1639             uint256 prod0; // Least significant 256 bits of the product
1640             uint256 prod1; // Most significant 256 bits of the product
1641             assembly {
1642                 let mm := mulmod(x, y, not(0))
1643                 prod0 := mul(x, y)
1644                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1645             }
1646 
1647             // Handle non-overflow cases, 256 by 256 division.
1648             if (prod1 == 0) {
1649                 return prod0 / denominator;
1650             }
1651 
1652             // Make sure the result is less than 2^256. Also prevents denominator == 0.
1653             require(denominator > prod1);
1654 
1655             ///////////////////////////////////////////////
1656             // 512 by 256 division.
1657             ///////////////////////////////////////////////
1658 
1659             // Make division exact by subtracting the remainder from [prod1 prod0].
1660             uint256 remainder;
1661             assembly {
1662                 // Compute remainder using mulmod.
1663                 remainder := mulmod(x, y, denominator)
1664 
1665                 // Subtract 256 bit number from 512 bit number.
1666                 prod1 := sub(prod1, gt(remainder, prod0))
1667                 prod0 := sub(prod0, remainder)
1668             }
1669 
1670             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
1671             // See https://cs.stackexchange.com/q/138556/92363.
1672 
1673             // Does not overflow because the denominator cannot be zero at this stage in the function.
1674             uint256 twos = denominator & (~denominator + 1);
1675             assembly {
1676                 // Divide denominator by twos.
1677                 denominator := div(denominator, twos)
1678 
1679                 // Divide [prod1 prod0] by twos.
1680                 prod0 := div(prod0, twos)
1681 
1682                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1683                 twos := add(div(sub(0, twos), twos), 1)
1684             }
1685 
1686             // Shift in bits from prod1 into prod0.
1687             prod0 |= prod1 * twos;
1688 
1689             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
1690             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
1691             // four bits. That is, denominator * inv = 1 mod 2^4.
1692             uint256 inverse = (3 * denominator) ^ 2;
1693 
1694             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
1695             // in modular arithmetic, doubling the correct bits in each step.
1696             inverse *= 2 - denominator * inverse; // inverse mod 2^8
1697             inverse *= 2 - denominator * inverse; // inverse mod 2^16
1698             inverse *= 2 - denominator * inverse; // inverse mod 2^32
1699             inverse *= 2 - denominator * inverse; // inverse mod 2^64
1700             inverse *= 2 - denominator * inverse; // inverse mod 2^128
1701             inverse *= 2 - denominator * inverse; // inverse mod 2^256
1702 
1703             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
1704             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
1705             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
1706             // is no longer required.
1707             result = prod0 * inverse;
1708             return result;
1709         }
1710     }



```

```
AddressUpgradeable.functionCall(address,bytes,string) (Penalty.sol#1260-1266) is never used and should be removed



    
1260     function functionCall(
1261         address target,
1262         bytes memory data,
1263         string memory errorMessage
1264     ) internal returns (bytes memory) {
1265         return functionCallWithValue(target, data, 0, errorMessage);
1266     }



```

```
AddressUpgradeable.sendValue(address,uint256) (Penalty.sol#1225-1230) is never used and should be removed



    
1225     function sendValue(address payable recipient, uint256 amount) internal {
1226         require(address(this).balance >= amount, "Address: insufficient balance");
1227 
1228         (bool success, ) = recipient.call{value: amount}("");
1229         require(success, "Address: unable to send value, recipient may have reverted");
1230     }



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (Penalty.sol#534-543) is never used and should be removed



    
534     function getOperatorAddressByOperatorId(
535         uint8 _poolId,
536         uint256 _operatorId,
537         IStaderConfig _staderConfig
538     ) internal view returns (address) {
539         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);
541 
542         return operatorAddress;
543     }



```

```
UtilLib.onlyStaderContract(address,IStaderConfig,bytes32) (Penalty.sol#466-474) is never used and should be removed



    
466     function onlyStaderContract(
467         address _addr,
468         IStaderConfig _staderConfig,
469         bytes32 _contractName
470     ) internal view {
471         if (!_staderConfig.onlyStaderContract(_addr, _contractName)) {
472             revert CallerNotStaderContract();
473         }
474     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes) (Penalty.sol#1310-1312) is never used and should be removed



    
1310     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
1311         return functionStaticCall(target, data, "Address: low-level static call failed");
1312     }



```

```
MathUpgradeable.sqrt(uint256,MathUpgradeable.Rounding) (Penalty.sol#1769-1774) is never used and should be removed



    
1769     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
1770         unchecked {
1771             uint256 result = sqrt(a);
1772             return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
1773         }
1774     }



```

```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (Penalty.sol#509-520) is never used and should be removed



    
509     function onlyValidatorWithdrawVault(
510         uint8 _poolId,
511         uint256 _validatorId,
512         address _addr,
513         IStaderConfig _staderConfig
514     ) internal view {
515         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
517         if (_addr != withdrawVaultAddress) {
518             revert CallerNotWithdrawVault();
519         }
520     }



```

```
MathUpgradeable.log2(uint256) (Penalty.sol#1780-1816) is never used and should be removed



    
1780     function log2(uint256 value) internal pure returns (uint256) {
1781         uint256 result = 0;
1782         unchecked {
1783             if (value >> 128 > 0) {
1784                 value >>= 128;
1785                 result += 128;
1786             }
1787             if (value >> 64 > 0) {
1788                 value >>= 64;
1789                 result += 64;
1790             }
1791             if (value >> 32 > 0) {
1792                 value >>= 32;
1793                 result += 32;
1794             }
1795             if (value >> 16 > 0) {
1796                 value >>= 16;
1797                 result += 16;
1798             }
1799             if (value >> 8 > 0) {
1800                 value >>= 8;
1801                 result += 8;
1802             }
1803             if (value >> 4 > 0) {
1804                 value >>= 4;
1805                 result += 4;
1806             }
1807             if (value >> 2 > 0) {
1808                 value >>= 2;
1809                 result += 2;
1810             }
1811             if (value >> 1 > 0) {
1812                 result += 1;
1813             }
1814         }
1815         return result;
1816     }



```

```
UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig) (Penalty.sol#582-592) is never used and should be removed



    
582     function computeExchangeRate(
583         uint256 totalETHBalance,
584         uint256 totalETHXSupply,
585         IStaderConfig _staderConfig
586     ) internal view returns (uint256) {
587         uint256 DECIMALS = _staderConfig.getDecimals();
588         uint256 newExchangeRate = (totalETHBalance == 0 || totalETHXSupply == 0)
589             ? DECIMALS
590             : (totalETHBalance * DECIMALS) / totalETHXSupply;
591         return newExchangeRate;
592     }



```

```
AccessControlUpgradeable._setRoleAdmin(bytes32,bytes32) (Penalty.sol#2254-2258) is never used and should be removed



    
2254     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
2255         bytes32 previousAdminRole = getRoleAdmin(role);
2256         _roles[role].adminRole = adminRole;
2257         emit RoleAdminChanged(role, previousAdminRole, adminRole);
2258     }



```

```
MathUpgradeable.average(uint256,uint256) (Penalty.sol#1609-1612) is never used and should be removed



    
1609     function average(uint256 a, uint256 b) internal pure returns (uint256) {
1610         // (a + b) / 2 can overflow.
1611         return (a & b) + (a ^ b) / 2;
1612     }



```

```
StringsUpgradeable.toHexString(uint256) (Penalty.sol#1957-1961) is never used and should be removed



    
1957     function toHexString(uint256 value) internal pure returns (string memory) {
1958         unchecked {
1959             return toHexString(value, MathUpgradeable.log256(value) + 1);
1960         }
1961     }



```

```
MathUpgradeable.log10(uint256) (Penalty.sol#1833-1865) is never used and should be removed



    
1833     function log10(uint256 value) internal pure returns (uint256) {
1834         uint256 result = 0;
1835         unchecked {
1836             if (value >= 10**64) {
1837                 value /= 10**64;
1838                 result += 64;
1839             }
1840             if (value >= 10**32) {
1841                 value /= 10**32;
1842                 result += 32;
1843             }
1844             if (value >= 10**16) {
1845                 value /= 10**16;
1846                 result += 16;
1847             }
1848             if (value >= 10**8) {
1849                 value /= 10**8;
1850                 result += 8;
1851             }
1852             if (value >= 10**4) {
1853                 value /= 10**4;
1854                 result += 4;
1855             }
1856             if (value >= 10**2) {
1857                 value /= 10**2;
1858                 result += 2;
1859             }
1860             if (value >= 10**1) {
1861                 result += 1;
1862             }
1863         }
1864         return result;
1865     }



```

```
ERC165Upgradeable.__ERC165_init() (Penalty.sol#2026-2027) is never used and should be removed



    
2026     function __ERC165_init() internal onlyInitializing {
2027     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256,MathUpgradeable.Rounding) (Penalty.sol#1715-1726) is never used and should be removed



    
1715     function mulDiv(
1716         uint256 x,
1717         uint256 y,
1718         uint256 denominator,
1719         Rounding rounding
1720     ) internal pure returns (uint256) {
1721         uint256 result = mulDiv(x, y, denominator);
1722         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
1723             result += 1;
1724         }
1725         return result;
1726     }



```

```
AddressUpgradeable.verifyCallResult(bool,bytes,string) (Penalty.sol#1359-1369) is never used and should be removed



    
1359     function verifyCallResult(
1360         bool success,
1361         bytes memory returndata,
1362         string memory errorMessage
1363     ) internal pure returns (bytes memory) {
1364         if (success) {
1365             return returndata;
1366         } else {
1367             _revert(returndata, errorMessage);
1368         }
1369     }



```

```
AddressUpgradeable._revert(bytes,string) (Penalty.sol#1371-1383) is never used and should be removed



    
1371     function _revert(bytes memory returndata, string memory errorMessage) private pure {
1372         // Look for revert reason and bubble it up if present
1373         if (returndata.length > 0) {
1374             // The easiest way to bubble the revert reason is using memory via assembly
1375             /// @solidity memory-safe-assembly
1376             assembly {
1377                 let returndata_size := mload(returndata)
1378                 revert(add(32, returndata), returndata_size)
1379             }
1380         } else {
1381             revert(errorMessage);
1382         }
1383     }



```

```
Initializable._getInitializedVersion() (Penalty.sol#1533-1535) is never used and should be removed



    
1533     function _getInitializedVersion() internal view returns (uint8) {
1534         return _initialized;
1535     }



```

```
AccessControlUpgradeable._setupRole(bytes32,address) (Penalty.sol#2245-2247) is never used and should be removed



    
2245     function _setupRole(bytes32 role, address account) internal virtual {
2246         _grantRole(role, account);
2247     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes,string) (Penalty.sol#1320-1327) is never used and should be removed



    
1320     function functionStaticCall(
1321         address target,
1322         bytes memory data,
1323         string memory errorMessage
1324     ) internal view returns (bytes memory) {
1325         (bool success, bytes memory returndata) = target.staticcall(data);
1326         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
1327     }



```

```
MathUpgradeable.log256(uint256,MathUpgradeable.Rounding) (Penalty.sol#1914-1919) is never used and should be removed



    
1914     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
1915         unchecked {
1916             uint256 result = log256(value);
1917             return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);
1918         }
1919     }



```

```
UtilLib.onlyOperatorRole(address,IStaderConfig) (Penalty.sol#459-463) is never used and should be removed



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {
460         if (!_staderConfig.onlyOperatorRole(_addr)) {
461             revert CallerNotOperator();
462         }
463     }



```

```
UtilLib.sendValue(address,uint256) (Penalty.sol#594-599) is never used and should be removed



    
594     function sendValue(address _receiver, uint256 _amount) internal {
595         (bool success, ) = payable(_receiver).call{value: _amount}('');
596         if (!success) {
597             revert TransferFailed();
598         }
599     }



```

```
MathUpgradeable.max(uint256,uint256) (Penalty.sol#1594-1596) is never used and should be removed



    
1594     function max(uint256 a, uint256 b) internal pure returns (uint256) {
1595         return a > b ? a : b;
1596     }



```

```
ContextUpgradeable.__Context_init() (Penalty.sol#1556-1557) is never used and should be removed



    
1556     function __Context_init() internal onlyInitializing {
1557     }



```

```
UtilLib.getOperatorRewardAddress(address,IStaderConfig) (Penalty.sol#545-554) is never used and should be removed



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)
546         internal
547         view
548         returns (address payable)
549     {
550         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getOperatorPoolId(_operator);
551         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
552         uint256 operatorId = INodeRegistry(nodeRegistry).operatorIDByAddress(_operator);
553         return INodeRegistry(nodeRegistry).getOperatorRewardAddress(operatorId);
554     }



```

```
AddressUpgradeable.verifyCallResultFromTarget(address,bool,bytes,string) (Penalty.sol#1335-1351) is never used and should be removed



    
1335     function verifyCallResultFromTarget(
1336         address target,
1337         bool success,
1338         bytes memory returndata,
1339         string memory errorMessage
1340     ) internal view returns (bytes memory) {
1341         if (success) {
1342             if (returndata.length == 0) {
1343                 // only check isContract if the call was successful and the return data is empty
1344                 // otherwise we already know that it was a contract
1345                 require(isContract(target), "Address: call to non-contract");
1346             }
1347             return returndata;
1348         } else {
1349             _revert(returndata, errorMessage);
1350         }
1351     }



```

```
MathUpgradeable.log256(uint256) (Penalty.sol#1884-1908) is never used and should be removed



    
1884     function log256(uint256 value) internal pure returns (uint256) {
1885         uint256 result = 0;
1886         unchecked {
1887             if (value >> 128 > 0) {
1888                 value >>= 128;
1889                 result += 16;
1890             }
1891             if (value >> 64 > 0) {
1892                 value >>= 64;
1893                 result += 8;
1894             }
1895             if (value >> 32 > 0) {
1896                 value >>= 32;
1897                 result += 4;
1898             }
1899             if (value >> 16 > 0) {
1900                 value >>= 16;
1901                 result += 2;
1902             }
1903             if (value >> 8 > 0) {
1904                 result += 1;
1905             }
1906         }
1907         return result;
1908     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (Penalty.sol#1293-1302) is never used and should be removed



    
1293     function functionCallWithValue(
1294         address target,
1295         bytes memory data,
1296         uint256 value,
1297         string memory errorMessage
1298     ) internal returns (bytes memory) {
1299         require(address(this).balance >= value, "Address: insufficient balance for call");
1300         (bool success, bytes memory returndata) = target.call{value: value}(data);
1301         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
1302     }



```

### PermissionedNodeRegistry.sol


```
StringsUpgradeable.toString(uint256) (PermissionedNodeRegistry.sol#2010-2030) is never used and should be removed



    
2010     function toString(uint256 value) internal pure returns (string memory) {
2011         unchecked {
2012             uint256 length = MathUpgradeable.log10(value) + 1;
2013             string memory buffer = new string(length);
2014             uint256 ptr;
2015             /// @solidity memory-safe-assembly
2016             assembly {
2017                 ptr := add(buffer, add(32, length))
2018             }
2019             while (true) {
2020                 ptr--;
2021                 /// @solidity memory-safe-assembly
2022                 assembly {
2023                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
2024                 }
2025                 value /= 10;
2026                 if (value == 0) break;
2027             }
2028             return buffer;
2029         }
2030     }



```

```
ContextUpgradeable._msgData() (PermissionedNodeRegistry.sol#1445-1447) is never used and should be removed



    
1445     function _msgData() internal view virtual returns (bytes calldata) {
1446         return msg.data;
1447     }



```

```
MathUpgradeable.log2(uint256,MathUpgradeable.Rounding) (PermissionedNodeRegistry.sol#1900-1905) is never used and should be removed



    
1900     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
1901         unchecked {
1902             uint256 result = log2(value);
1903             return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
1904         }
1905     }



```

```
Initializable._isInitializing() (PermissionedNodeRegistry.sol#1420-1422) is never used and should be removed



    
1420     function _isInitializing() internal view returns (bool) {
1421         return _initializing;
1422     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256) (PermissionedNodeRegistry.sol#1159-1165) is never used and should be removed



    
1159     function functionCallWithValue(
1160         address target,
1161         bytes memory data,
1162         uint256 value
1163     ) internal returns (bytes memory) {
1164         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
1165     }



```

```
MathUpgradeable.ceilDiv(uint256,uint256) (PermissionedNodeRegistry.sol#1698-1701) is never used and should be removed



    
1698     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
1699         // (a + b - 1) / b can overflow on addition, so we distribute.
1700         return a == 0 ? 0 : (a - 1) / b + 1;
1701     }



```

```
MathUpgradeable.min(uint256,uint256) (PermissionedNodeRegistry.sol#1679-1681) is never used and should be removed



    
1679     function min(uint256 a, uint256 b) internal pure returns (uint256) {
1680         return a < b ? a : b;
1681     }



```

```
MathUpgradeable.sqrt(uint256) (PermissionedNodeRegistry.sol#1811-1842) is never used and should be removed



    
1811     function sqrt(uint256 a) internal pure returns (uint256) {
1812         if (a == 0) {
1813             return 0;
1814         }
1815 
1816         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
1817         //
1818         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
1819         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
1820         //
1821         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
1822         // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
1823         // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
1824         //
1825         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
1826         uint256 result = 1 << (log2(a) >> 1);
1827 
1828         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
1829         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
1830         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
1831         // into the expected uint128 result.
1832         unchecked {
1833             result = (result + a / result) >> 1;
1834             result = (result + a / result) >> 1;
1835             result = (result + a / result) >> 1;
1836             result = (result + a / result) >> 1;
1837             result = (result + a / result) >> 1;
1838             result = (result + a / result) >> 1;
1839             result = (result + a / result) >> 1;
1840             return min(result, a / result);
1841         }
1842     }



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (PermissionedNodeRegistry.sol#522-532) is never used and should be removed



    
522     function getOperatorAddressByValidatorId(
523         uint8 _poolId,
524         uint256 _validatorId,
525         IStaderConfig _staderConfig
526     ) internal view returns (address) {
527         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
530 
531         return operatorAddress;
532     }



```

```
Math.ceilDiv(uint256,uint256) (PermissionedNodeRegistry.sol#860-863) is never used and should be removed



    
860     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
861         // (a + b - 1) / b can overflow on addition, so we distribute.
862         return a == 0 ? 0 : (a - 1) / b + 1;
863     }



```

```
UtilLib.getPubkeyRoot(bytes) (PermissionedNodeRegistry.sol#561-568) is never used and should be removed



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {
562         if (_pubkey.length != VALIDATOR_PUBKEY_LENGTH) {
563             revert InvalidPubkeyLength();
564         }
565 
566         // Append 16 bytes of zero padding to the pubkey and compute its hash to get the pubkey root.
567         return sha256(abi.encodePacked(_pubkey, bytes16(0)));
568     }



```

```
AccessControlUpgradeable.__AccessControl_init() (PermissionedNodeRegistry.sol#2163-2164) is never used and should be removed



    
2163     function __AccessControl_init() internal onlyInitializing {
2164     }



```

```
Math.mulDiv(uint256,uint256,uint256) (PermissionedNodeRegistry.sol#870-950) is never used and should be removed



    
870     function mulDiv(
871         uint256 x,
872         uint256 y,
873         uint256 denominator
874     ) internal pure returns (uint256 result) {
875         unchecked {
876             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
877             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
878             // variables such that product = prod1 * 2^256 + prod0.
879             uint256 prod0; // Least significant 256 bits of the product
880             uint256 prod1; // Most significant 256 bits of the product
881             assembly {
882                 let mm := mulmod(x, y, not(0))
883                 prod0 := mul(x, y)
884                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
885             }
886 
887             // Handle non-overflow cases, 256 by 256 division.
888             if (prod1 == 0) {
889                 return prod0 / denominator;
890             }
891 
892             // Make sure the result is less than 2^256. Also prevents denominator == 0.
893             require(denominator > prod1);
894 
895             ///////////////////////////////////////////////
896             // 512 by 256 division.
897             ///////////////////////////////////////////////
898 
899             // Make division exact by subtracting the remainder from [prod1 prod0].
900             uint256 remainder;
901             assembly {
902                 // Compute remainder using mulmod.
903                 remainder := mulmod(x, y, denominator)
904 
905                 // Subtract 256 bit number from 512 bit number.
906                 prod1 := sub(prod1, gt(remainder, prod0))
907                 prod0 := sub(prod0, remainder)
908             }
909 
910             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
911             // See https://cs.stackexchange.com/q/138556/92363.
912 
913             // Does not overflow because the denominator cannot be zero at this stage in the function.
914             uint256 twos = denominator & (~denominator + 1);
915             assembly {
916                 // Divide denominator by twos.
917                 denominator := div(denominator, twos)
918 
919                 // Divide [prod1 prod0] by twos.
920                 prod0 := div(prod0, twos)
921 
922                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
923                 twos := add(div(sub(0, twos), twos), 1)
924             }
925 
926             // Shift in bits from prod1 into prod0.
927             prod0 |= prod1 * twos;
928 
929             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
930             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
931             // four bits. That is, denominator * inv = 1 mod 2^4.
932             uint256 inverse = (3 * denominator) ^ 2;
933 
934             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
935             // in modular arithmetic, doubling the correct bits in each step.
936             inverse *= 2 - denominator * inverse; // inverse mod 2^8
937             inverse *= 2 - denominator * inverse; // inverse mod 2^16
938             inverse *= 2 - denominator * inverse; // inverse mod 2^32
939             inverse *= 2 - denominator * inverse; // inverse mod 2^64
940             inverse *= 2 - denominator * inverse; // inverse mod 2^128
941             inverse *= 2 - denominator * inverse; // inverse mod 2^256
942 
943             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
944             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
945             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
946             // is no longer required.
947             result = prod0 * inverse;
948             return result;
949         }
950     }



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (PermissionedNodeRegistry.sol#492-507) is never used and should be removed



    
492     function getOperatorForValidSender(
493         uint8 _poolId,
494         uint256 _validatorId,
495         address _addr,
496         IStaderConfig _staderConfig
497     ) internal view returns (address) {
498         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );
502         if (_addr != withdrawVaultAddress) {
503             revert CallerNotWithdrawVault();
504         }
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
506         return operator;
507     }



```

```
MathUpgradeable.log10(uint256,MathUpgradeable.Rounding) (PermissionedNodeRegistry.sol#1949-1954) is never used and should be removed



    
1949     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
1950         unchecked {
1951             uint256 result = log10(value);
1952             return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);
1953         }
1954     }



```

```
AddressUpgradeable.functionCall(address,bytes) (PermissionedNodeRegistry.sol#1130-1132) is never used and should be removed



    
1130     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
1131         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
1132     }



```

```
Math.sqrt(uint256,Math.Rounding) (PermissionedNodeRegistry.sol#1034-1040) is never used and should be removed



    
1034     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
1035         uint256 result = sqrt(a);
1036         if (rounding == Rounding.Up && result * result < a) {
1037             result += 1;
1038         }
1039         return result;
1040     }



```

```
ContextUpgradeable.__Context_init_unchained() (PermissionedNodeRegistry.sol#1439-1440) is never used and should be removed



    
1439     function __Context_init_unchained() internal onlyInitializing {
1440     }



```

```
Math.max(uint256,uint256) (PermissionedNodeRegistry.sol#834-836) is never used and should be removed



    
834     function max(uint256 a, uint256 b) internal pure returns (uint256) {
835         return a >= b ? a : b;
836     }



```

```
ERC165Upgradeable.__ERC165_init_unchained() (PermissionedNodeRegistry.sol#2107-2108) is never used and should be removed



    
2107     function __ERC165_init_unchained() internal onlyInitializing {
2108     }



```

```
Math.average(uint256,uint256) (PermissionedNodeRegistry.sol#849-852) is never used and should be removed



    
849     function average(uint256 a, uint256 b) internal pure returns (uint256) {
850         // (a + b) / 2 can overflow.
851         return (a & b) + (a ^ b) / 2;
852     }



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (PermissionedNodeRegistry.sol#570-580) is never used and should be removed



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)
571         internal
572         view
573         returns (bool)
574     {
575         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getValidatorPoolId(_pubkey);
576         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
577         uint256 validatorId = INodeRegistry(nodeRegistry).validatorIdByPubkey(_pubkey);
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);
579         return IVaultProxy(withdrawVaultAddress).vaultSettleStatus();
580     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionedNodeRegistry.sol#1708-1788) is never used and should be removed



    
1708     function mulDiv(
1709         uint256 x,
1710         uint256 y,
1711         uint256 denominator
1712     ) internal pure returns (uint256 result) {
1713         unchecked {
1714             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
1715             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
1716             // variables such that product = prod1 * 2^256 + prod0.
1717             uint256 prod0; // Least significant 256 bits of the product
1718             uint256 prod1; // Most significant 256 bits of the product
1719             assembly {
1720                 let mm := mulmod(x, y, not(0))
1721                 prod0 := mul(x, y)
1722                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1723             }
1724 
1725             // Handle non-overflow cases, 256 by 256 division.
1726             if (prod1 == 0) {
1727                 return prod0 / denominator;
1728             }
1729 
1730             // Make sure the result is less than 2^256. Also prevents denominator == 0.
1731             require(denominator > prod1);
1732 
1733             ///////////////////////////////////////////////
1734             // 512 by 256 division.
1735             ///////////////////////////////////////////////
1736 
1737             // Make division exact by subtracting the remainder from [prod1 prod0].
1738             uint256 remainder;
1739             assembly {
1740                 // Compute remainder using mulmod.
1741                 remainder := mulmod(x, y, denominator)
1742 
1743                 // Subtract 256 bit number from 512 bit number.
1744                 prod1 := sub(prod1, gt(remainder, prod0))
1745                 prod0 := sub(prod0, remainder)
1746             }
1747 
1748             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
1749             // See https://cs.stackexchange.com/q/138556/92363.
1750 
1751             // Does not overflow because the denominator cannot be zero at this stage in the function.
1752             uint256 twos = denominator & (~denominator + 1);
1753             assembly {
1754                 // Divide denominator by twos.
1755                 denominator := div(denominator, twos)
1756 
1757                 // Divide [prod1 prod0] by twos.
1758                 prod0 := div(prod0, twos)
1759 
1760                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1761                 twos := add(div(sub(0, twos), twos), 1)
1762             }
1763 
1764             // Shift in bits from prod1 into prod0.
1765             prod0 |= prod1 * twos;
1766 
1767             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
1768             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
1769             // four bits. That is, denominator * inv = 1 mod 2^4.
1770             uint256 inverse = (3 * denominator) ^ 2;
1771 
1772             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
1773             // in modular arithmetic, doubling the correct bits in each step.
1774             inverse *= 2 - denominator * inverse; // inverse mod 2^8
1775             inverse *= 2 - denominator * inverse; // inverse mod 2^16
1776             inverse *= 2 - denominator * inverse; // inverse mod 2^32
1777             inverse *= 2 - denominator * inverse; // inverse mod 2^64
1778             inverse *= 2 - denominator * inverse; // inverse mod 2^128
1779             inverse *= 2 - denominator * inverse; // inverse mod 2^256
1780 
1781             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
1782             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
1783             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
1784             // is no longer required.
1785             result = prod0 * inverse;
1786             return result;
1787         }
1788     }



```

```
AddressUpgradeable.functionCall(address,bytes,string) (PermissionedNodeRegistry.sol#1140-1146) is never used and should be removed



    
1140     function functionCall(
1141         address target,
1142         bytes memory data,
1143         string memory errorMessage
1144     ) internal returns (bytes memory) {
1145         return functionCallWithValue(target, data, 0, errorMessage);
1146     }



```

```
AddressUpgradeable.sendValue(address,uint256) (PermissionedNodeRegistry.sol#1105-1110) is never used and should be removed



    
1105     function sendValue(address payable recipient, uint256 amount) internal {
1106         require(address(this).balance >= amount, "Address: insufficient balance");
1107 
1108         (bool success, ) = recipient.call{value: amount}("");
1109         require(success, "Address: unable to send value, recipient may have reverted");
1110     }



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (PermissionedNodeRegistry.sol#534-543) is never used and should be removed



    
534     function getOperatorAddressByOperatorId(
535         uint8 _poolId,
536         uint256 _operatorId,
537         IStaderConfig _staderConfig
538     ) internal view returns (address) {
539         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);
541 
542         return operatorAddress;
543     }



```

```
Math.sqrt(uint256) (PermissionedNodeRegistry.sol#973-1029) is never used and should be removed



    
973     function sqrt(uint256 a) internal pure returns (uint256) {
974         if (a == 0) {
975             return 0;
976         }
977 
978         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
979         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
980         // `msb(a) <= a < 2*msb(a)`.
981         // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.
982         // This gives `2**k < a <= 2**(k+1)` → `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.
983         // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a
984         // good first aproximation of `sqrt(a)` with at least 1 correct bit.
985         uint256 result = 1;
986         uint256 x = a;
987         if (x >> 128 > 0) {
988             x >>= 128;
989             result <<= 64;
990         }
991         if (x >> 64 > 0) {
992             x >>= 64;
993             result <<= 32;
994         }
995         if (x >> 32 > 0) {
996             x >>= 32;
997             result <<= 16;
998         }
999         if (x >> 16 > 0) {
1000             x >>= 16;
1001             result <<= 8;
1002         }
1003         if (x >> 8 > 0) {
1004             x >>= 8;
1005             result <<= 4;
1006         }
1007         if (x >> 4 > 0) {
1008             x >>= 4;
1009             result <<= 2;
1010         }
1011         if (x >> 2 > 0) {
1012             result <<= 1;
1013         }
1014 
1015         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
1016         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
1017         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
1018         // into the expected uint128 result.
1019         unchecked {
1020             result = (result + a / result) >> 1;
1021             result = (result + a / result) >> 1;
1022             result = (result + a / result) >> 1;
1023             result = (result + a / result) >> 1;
1024             result = (result + a / result) >> 1;
1025             result = (result + a / result) >> 1;
1026             result = (result + a / result) >> 1;
1027             return min(result, a / result);
1028         }
1029     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes) (PermissionedNodeRegistry.sol#1190-1192) is never used and should be removed



    
1190     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
1191         return functionStaticCall(target, data, "Address: low-level static call failed");
1192     }



```

```
MathUpgradeable.sqrt(uint256,MathUpgradeable.Rounding) (PermissionedNodeRegistry.sol#1847-1852) is never used and should be removed



    
1847     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
1848         unchecked {
1849             uint256 result = sqrt(a);
1850             return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
1851         }
1852     }



```

```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (PermissionedNodeRegistry.sol#509-520) is never used and should be removed



    
509     function onlyValidatorWithdrawVault(
510         uint8 _poolId,
511         uint256 _validatorId,
512         address _addr,
513         IStaderConfig _staderConfig
514     ) internal view {
515         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
517         if (_addr != withdrawVaultAddress) {
518             revert CallerNotWithdrawVault();
519         }
520     }



```

```
MathUpgradeable.log2(uint256) (PermissionedNodeRegistry.sol#1858-1894) is never used and should be removed



    
1858     function log2(uint256 value) internal pure returns (uint256) {
1859         uint256 result = 0;
1860         unchecked {
1861             if (value >> 128 > 0) {
1862                 value >>= 128;
1863                 result += 128;
1864             }
1865             if (value >> 64 > 0) {
1866                 value >>= 64;
1867                 result += 64;
1868             }
1869             if (value >> 32 > 0) {
1870                 value >>= 32;
1871                 result += 32;
1872             }
1873             if (value >> 16 > 0) {
1874                 value >>= 16;
1875                 result += 16;
1876             }
1877             if (value >> 8 > 0) {
1878                 value >>= 8;
1879                 result += 8;
1880             }
1881             if (value >> 4 > 0) {
1882                 value >>= 4;
1883                 result += 4;
1884             }
1885             if (value >> 2 > 0) {
1886                 value >>= 2;
1887                 result += 2;
1888             }
1889             if (value >> 1 > 0) {
1890                 result += 1;
1891             }
1892         }
1893         return result;
1894     }



```

```
UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig) (PermissionedNodeRegistry.sol#582-592) is never used and should be removed



    
582     function computeExchangeRate(
583         uint256 totalETHBalance,
584         uint256 totalETHXSupply,
585         IStaderConfig _staderConfig
586     ) internal view returns (uint256) {
587         uint256 DECIMALS = _staderConfig.getDecimals();
588         uint256 newExchangeRate = (totalETHBalance == 0 || totalETHXSupply == 0)
589             ? DECIMALS
590             : (totalETHBalance * DECIMALS) / totalETHXSupply;
591         return newExchangeRate;
592     }



```

```
AccessControlUpgradeable._setRoleAdmin(bytes32,bytes32) (PermissionedNodeRegistry.sol#2332-2336) is never used and should be removed



    
2332     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
2333         bytes32 previousAdminRole = getRoleAdmin(role);
2334         _roles[role].adminRole = adminRole;
2335         emit RoleAdminChanged(role, previousAdminRole, adminRole);
2336     }



```

```
MathUpgradeable.average(uint256,uint256) (PermissionedNodeRegistry.sol#1687-1690) is never used and should be removed



    
1687     function average(uint256 a, uint256 b) internal pure returns (uint256) {
1688         // (a + b) / 2 can overflow.
1689         return (a & b) + (a ^ b) / 2;
1690     }



```

```
StringsUpgradeable.toHexString(uint256) (PermissionedNodeRegistry.sol#2035-2039) is never used and should be removed



    
2035     function toHexString(uint256 value) internal pure returns (string memory) {
2036         unchecked {
2037             return toHexString(value, MathUpgradeable.log256(value) + 1);
2038         }
2039     }



```

```
MathUpgradeable.log10(uint256) (PermissionedNodeRegistry.sol#1911-1943) is never used and should be removed



    
1911     function log10(uint256 value) internal pure returns (uint256) {
1912         uint256 result = 0;
1913         unchecked {
1914             if (value >= 10**64) {
1915                 value /= 10**64;
1916                 result += 64;
1917             }
1918             if (value >= 10**32) {
1919                 value /= 10**32;
1920                 result += 32;
1921             }
1922             if (value >= 10**16) {
1923                 value /= 10**16;
1924                 result += 16;
1925             }
1926             if (value >= 10**8) {
1927                 value /= 10**8;
1928                 result += 8;
1929             }
1930             if (value >= 10**4) {
1931                 value /= 10**4;
1932                 result += 4;
1933             }
1934             if (value >= 10**2) {
1935                 value /= 10**2;
1936                 result += 2;
1937             }
1938             if (value >= 10**1) {
1939                 result += 1;
1940             }
1941         }
1942         return result;
1943     }



```

```
ERC165Upgradeable.__ERC165_init() (PermissionedNodeRegistry.sol#2104-2105) is never used and should be removed



    
2104     function __ERC165_init() internal onlyInitializing {
2105     }



```

```
Math.mulDiv(uint256,uint256,uint256,Math.Rounding) (PermissionedNodeRegistry.sol#955-966) is never used and should be removed



    
955     function mulDiv(
956         uint256 x,
957         uint256 y,
958         uint256 denominator,
959         Rounding rounding
960     ) internal pure returns (uint256) {
961         uint256 result = mulDiv(x, y, denominator);
962         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
963             result += 1;
964         }
965         return result;
966     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256,MathUpgradeable.Rounding) (PermissionedNodeRegistry.sol#1793-1804) is never used and should be removed



    
1793     function mulDiv(
1794         uint256 x,
1795         uint256 y,
1796         uint256 denominator,
1797         Rounding rounding
1798     ) internal pure returns (uint256) {
1799         uint256 result = mulDiv(x, y, denominator);
1800         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
1801             result += 1;
1802         }
1803         return result;
1804     }



```

```
AddressUpgradeable.verifyCallResult(bool,bytes,string) (PermissionedNodeRegistry.sol#1239-1249) is never used and should be removed



    
1239     function verifyCallResult(
1240         bool success,
1241         bytes memory returndata,
1242         string memory errorMessage
1243     ) internal pure returns (bytes memory) {
1244         if (success) {
1245             return returndata;
1246         } else {
1247             _revert(returndata, errorMessage);
1248         }
1249     }



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (PermissionedNodeRegistry.sol#476-490) is never used and should be removed



    
476     function getPubkeyForValidSender(
477         uint8 _poolId,
478         uint256 _validatorId,
479         address _addr,
480         IStaderConfig _staderConfig
481     ) internal view returns (bytes memory) {
482         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );
486         if (_addr != withdrawVaultAddress) {
487             revert CallerNotWithdrawVault();
488         }
489         return pubkey;
490     }



```

```
AddressUpgradeable._revert(bytes,string) (PermissionedNodeRegistry.sol#1251-1263) is never used and should be removed



    
1251     function _revert(bytes memory returndata, string memory errorMessage) private pure {
1252         // Look for revert reason and bubble it up if present
1253         if (returndata.length > 0) {
1254             // The easiest way to bubble the revert reason is using memory via assembly
1255             /// @solidity memory-safe-assembly
1256             assembly {
1257                 let returndata_size := mload(returndata)
1258                 revert(add(32, returndata), returndata_size)
1259             }
1260         } else {
1261             revert(errorMessage);
1262         }
1263     }



```

```
Initializable._getInitializedVersion() (PermissionedNodeRegistry.sol#1413-1415) is never used and should be removed



    
1413     function _getInitializedVersion() internal view returns (uint8) {
1414         return _initialized;
1415     }



```

```
AccessControlUpgradeable._setupRole(bytes32,address) (PermissionedNodeRegistry.sol#2323-2325) is never used and should be removed



    
2323     function _setupRole(bytes32 role, address account) internal virtual {
2324         _grantRole(role, account);
2325     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes,string) (PermissionedNodeRegistry.sol#1200-1207) is never used and should be removed



    
1200     function functionStaticCall(
1201         address target,
1202         bytes memory data,
1203         string memory errorMessage
1204     ) internal view returns (bytes memory) {
1205         (bool success, bytes memory returndata) = target.staticcall(data);
1206         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
1207     }



```

```
MathUpgradeable.log256(uint256,MathUpgradeable.Rounding) (PermissionedNodeRegistry.sol#1992-1997) is never used and should be removed



    
1992     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
1993         unchecked {
1994             uint256 result = log256(value);
1995             return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);
1996         }
1997     }



```

```
UtilLib.sendValue(address,uint256) (PermissionedNodeRegistry.sol#594-599) is never used and should be removed



    
594     function sendValue(address _receiver, uint256 _amount) internal {
595         (bool success, ) = payable(_receiver).call{value: _amount}('');
596         if (!success) {
597             revert TransferFailed();
598         }
599     }



```

```
MathUpgradeable.max(uint256,uint256) (PermissionedNodeRegistry.sol#1672-1674) is never used and should be removed



    
1672     function max(uint256 a, uint256 b) internal pure returns (uint256) {
1673         return a > b ? a : b;
1674     }



```

```
ContextUpgradeable.__Context_init() (PermissionedNodeRegistry.sol#1436-1437) is never used and should be removed



    
1436     function __Context_init() internal onlyInitializing {
1437     }



```

```
UtilLib.getOperatorRewardAddress(address,IStaderConfig) (PermissionedNodeRegistry.sol#545-554) is never used and should be removed



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)
546         internal
547         view
548         returns (address payable)
549     {
550         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getOperatorPoolId(_operator);
551         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
552         uint256 operatorId = INodeRegistry(nodeRegistry).operatorIDByAddress(_operator);
553         return INodeRegistry(nodeRegistry).getOperatorRewardAddress(operatorId);
554     }



```

```
AddressUpgradeable.verifyCallResultFromTarget(address,bool,bytes,string) (PermissionedNodeRegistry.sol#1215-1231) is never used and should be removed



    
1215     function verifyCallResultFromTarget(
1216         address target,
1217         bool success,
1218         bytes memory returndata,
1219         string memory errorMessage
1220     ) internal view returns (bytes memory) {
1221         if (success) {
1222             if (returndata.length == 0) {
1223                 // only check isContract if the call was successful and the return data is empty
1224                 // otherwise we already know that it was a contract
1225                 require(isContract(target), "Address: call to non-contract");
1226             }
1227             return returndata;
1228         } else {
1229             _revert(returndata, errorMessage);
1230         }
1231     }



```

```
MathUpgradeable.log256(uint256) (PermissionedNodeRegistry.sol#1962-1986) is never used and should be removed



    
1962     function log256(uint256 value) internal pure returns (uint256) {
1963         uint256 result = 0;
1964         unchecked {
1965             if (value >> 128 > 0) {
1966                 value >>= 128;
1967                 result += 16;
1968             }
1969             if (value >> 64 > 0) {
1970                 value >>= 64;
1971                 result += 8;
1972             }
1973             if (value >> 32 > 0) {
1974                 value >>= 32;
1975                 result += 4;
1976             }
1977             if (value >> 16 > 0) {
1978                 value >>= 16;
1979                 result += 2;
1980             }
1981             if (value >> 8 > 0) {
1982                 result += 1;
1983             }
1984         }
1985         return result;
1986     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (PermissionedNodeRegistry.sol#1173-1182) is never used and should be removed



    
1173     function functionCallWithValue(
1174         address target,
1175         bytes memory data,
1176         uint256 value,
1177         string memory errorMessage
1178     ) internal returns (bytes memory) {
1179         require(address(this).balance >= value, "Address: insufficient balance for call");
1180         (bool success, bytes memory returndata) = target.call{value: value}(data);
1181         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
1182     }



```

### PermissionedPool.sol


```
StringsUpgradeable.toString(uint256) (PermissionedPool.sol#1935-1955) is never used and should be removed



    
1935     function toString(uint256 value) internal pure returns (string memory) {
1936         unchecked {
1937             uint256 length = MathUpgradeable.log10(value) + 1;
1938             string memory buffer = new string(length);
1939             uint256 ptr;
1940             /// @solidity memory-safe-assembly
1941             assembly {
1942                 ptr := add(buffer, add(32, length))
1943             }
1944             while (true) {
1945                 ptr--;
1946                 /// @solidity memory-safe-assembly
1947                 assembly {
1948                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
1949                 }
1950                 value /= 10;
1951                 if (value == 0) break;
1952             }
1953             return buffer;
1954         }
1955     }



```

```
ContextUpgradeable._msgData() (PermissionedPool.sol#1568-1570) is never used and should be removed



    
1568     function _msgData() internal view virtual returns (bytes calldata) {
1569         return msg.data;
1570     }



```

```
MathUpgradeable.log2(uint256,MathUpgradeable.Rounding) (PermissionedPool.sol#1825-1830) is never used and should be removed



    
1825     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
1826         unchecked {
1827             uint256 result = log2(value);
1828             return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
1829         }
1830     }



```

```
Initializable._isInitializing() (PermissionedPool.sol#1543-1545) is never used and should be removed



    
1543     function _isInitializing() internal view returns (bool) {
1544         return _initializing;
1545     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256) (PermissionedPool.sol#1282-1288) is never used and should be removed



    
1282     function functionCallWithValue(
1283         address target,
1284         bytes memory data,
1285         uint256 value
1286     ) internal returns (bytes memory) {
1287         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
1288     }



```

```
MathUpgradeable.ceilDiv(uint256,uint256) (PermissionedPool.sol#1623-1626) is never used and should be removed



    
1623     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
1624         // (a + b - 1) / b can overflow on addition, so we distribute.
1625         return a == 0 ? 0 : (a - 1) / b + 1;
1626     }



```

```
MathUpgradeable.min(uint256,uint256) (PermissionedPool.sol#1604-1606) is never used and should be removed



    
1604     function min(uint256 a, uint256 b) internal pure returns (uint256) {
1605         return a < b ? a : b;
1606     }



```

```
MathUpgradeable.sqrt(uint256) (PermissionedPool.sol#1736-1767) is never used and should be removed



    
1736     function sqrt(uint256 a) internal pure returns (uint256) {
1737         if (a == 0) {
1738             return 0;
1739         }
1740 
1741         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
1742         //
1743         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
1744         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
1745         //
1746         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
1747         // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
1748         // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
1749         //
1750         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
1751         uint256 result = 1 << (log2(a) >> 1);
1752 
1753         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
1754         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
1755         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
1756         // into the expected uint128 result.
1757         unchecked {
1758             result = (result + a / result) >> 1;
1759             result = (result + a / result) >> 1;
1760             result = (result + a / result) >> 1;
1761             result = (result + a / result) >> 1;
1762             result = (result + a / result) >> 1;
1763             result = (result + a / result) >> 1;
1764             result = (result + a / result) >> 1;
1765             return min(result, a / result);
1766         }
1767     }



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (PermissionedPool.sol#522-532) is never used and should be removed



    
522     function getOperatorAddressByValidatorId(
523         uint8 _poolId,
524         uint256 _validatorId,
525         IStaderConfig _staderConfig
526     ) internal view returns (address) {
527         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
530 
531         return operatorAddress;
532     }



```

```
Math.ceilDiv(uint256,uint256) (PermissionedPool.sol#897-900) is never used and should be removed



    
897     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
898         // (a + b - 1) / b can overflow on addition, so we distribute.
899         return a == 0 ? 0 : (a - 1) / b + 1;
900     }



```

```
UtilLib.getPubkeyRoot(bytes) (PermissionedPool.sol#561-568) is never used and should be removed



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {
562         if (_pubkey.length != VALIDATOR_PUBKEY_LENGTH) {
563             revert InvalidPubkeyLength();
564         }
565 
566         // Append 16 bytes of zero padding to the pubkey and compute its hash to get the pubkey root.
567         return sha256(abi.encodePacked(_pubkey, bytes16(0)));
568     }



```

```
AccessControlUpgradeable.__AccessControl_init() (PermissionedPool.sol#2088-2089) is never used and should be removed



    
2088     function __AccessControl_init() internal onlyInitializing {
2089     }



```

```
Math.mulDiv(uint256,uint256,uint256) (PermissionedPool.sol#907-987) is never used and should be removed



    
907     function mulDiv(
908         uint256 x,
909         uint256 y,
910         uint256 denominator
911     ) internal pure returns (uint256 result) {
912         unchecked {
913             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
914             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
915             // variables such that product = prod1 * 2^256 + prod0.
916             uint256 prod0; // Least significant 256 bits of the product
917             uint256 prod1; // Most significant 256 bits of the product
918             assembly {
919                 let mm := mulmod(x, y, not(0))
920                 prod0 := mul(x, y)
921                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
922             }
923 
924             // Handle non-overflow cases, 256 by 256 division.
925             if (prod1 == 0) {
926                 return prod0 / denominator;
927             }
928 
929             // Make sure the result is less than 2^256. Also prevents denominator == 0.
930             require(denominator > prod1);
931 
932             ///////////////////////////////////////////////
933             // 512 by 256 division.
934             ///////////////////////////////////////////////
935 
936             // Make division exact by subtracting the remainder from [prod1 prod0].
937             uint256 remainder;
938             assembly {
939                 // Compute remainder using mulmod.
940                 remainder := mulmod(x, y, denominator)
941 
942                 // Subtract 256 bit number from 512 bit number.
943                 prod1 := sub(prod1, gt(remainder, prod0))
944                 prod0 := sub(prod0, remainder)
945             }
946 
947             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
948             // See https://cs.stackexchange.com/q/138556/92363.
949 
950             // Does not overflow because the denominator cannot be zero at this stage in the function.
951             uint256 twos = denominator & (~denominator + 1);
952             assembly {
953                 // Divide denominator by twos.
954                 denominator := div(denominator, twos)
955 
956                 // Divide [prod1 prod0] by twos.
957                 prod0 := div(prod0, twos)
958 
959                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
960                 twos := add(div(sub(0, twos), twos), 1)
961             }
962 
963             // Shift in bits from prod1 into prod0.
964             prod0 |= prod1 * twos;
965 
966             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
967             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
968             // four bits. That is, denominator * inv = 1 mod 2^4.
969             uint256 inverse = (3 * denominator) ^ 2;
970 
971             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
972             // in modular arithmetic, doubling the correct bits in each step.
973             inverse *= 2 - denominator * inverse; // inverse mod 2^8
974             inverse *= 2 - denominator * inverse; // inverse mod 2^16
975             inverse *= 2 - denominator * inverse; // inverse mod 2^32
976             inverse *= 2 - denominator * inverse; // inverse mod 2^64
977             inverse *= 2 - denominator * inverse; // inverse mod 2^128
978             inverse *= 2 - denominator * inverse; // inverse mod 2^256
979 
980             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
981             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
982             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
983             // is no longer required.
984             result = prod0 * inverse;
985             return result;
986         }
987     }



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (PermissionedPool.sol#492-507) is never used and should be removed



    
492     function getOperatorForValidSender(
493         uint8 _poolId,
494         uint256 _validatorId,
495         address _addr,
496         IStaderConfig _staderConfig
497     ) internal view returns (address) {
498         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );
502         if (_addr != withdrawVaultAddress) {
503             revert CallerNotWithdrawVault();
504         }
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
506         return operator;
507     }



```

```
MathUpgradeable.log10(uint256,MathUpgradeable.Rounding) (PermissionedPool.sol#1874-1879) is never used and should be removed



    
1874     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
1875         unchecked {
1876             uint256 result = log10(value);
1877             return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);
1878         }
1879     }



```

```
AddressUpgradeable.functionCall(address,bytes) (PermissionedPool.sol#1253-1255) is never used and should be removed



    
1253     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
1254         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
1255     }



```

```
Math.sqrt(uint256,Math.Rounding) (PermissionedPool.sol#1071-1077) is never used and should be removed



    
1071     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
1072         uint256 result = sqrt(a);
1073         if (rounding == Rounding.Up && result * result < a) {
1074             result += 1;
1075         }
1076         return result;
1077     }



```

```
ContextUpgradeable.__Context_init_unchained() (PermissionedPool.sol#1562-1563) is never used and should be removed



    
1562     function __Context_init_unchained() internal onlyInitializing {
1563     }



```

```
Math.max(uint256,uint256) (PermissionedPool.sol#871-873) is never used and should be removed



    
871     function max(uint256 a, uint256 b) internal pure returns (uint256) {
872         return a >= b ? a : b;
873     }



```

```
ERC165Upgradeable.__ERC165_init_unchained() (PermissionedPool.sol#2032-2033) is never used and should be removed



    
2032     function __ERC165_init_unchained() internal onlyInitializing {
2033     }



```

```
Math.average(uint256,uint256) (PermissionedPool.sol#886-889) is never used and should be removed



    
886     function average(uint256 a, uint256 b) internal pure returns (uint256) {
887         // (a + b) / 2 can overflow.
888         return (a & b) + (a ^ b) / 2;
889     }



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (PermissionedPool.sol#570-580) is never used and should be removed



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)
571         internal
572         view
573         returns (bool)
574     {
575         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getValidatorPoolId(_pubkey);
576         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
577         uint256 validatorId = INodeRegistry(nodeRegistry).validatorIdByPubkey(_pubkey);
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);
579         return IVaultProxy(withdrawVaultAddress).vaultSettleStatus();
580     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionedPool.sol#1633-1713) is never used and should be removed



    
1633     function mulDiv(
1634         uint256 x,
1635         uint256 y,
1636         uint256 denominator
1637     ) internal pure returns (uint256 result) {
1638         unchecked {
1639             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
1640             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
1641             // variables such that product = prod1 * 2^256 + prod0.
1642             uint256 prod0; // Least significant 256 bits of the product
1643             uint256 prod1; // Most significant 256 bits of the product
1644             assembly {
1645                 let mm := mulmod(x, y, not(0))
1646                 prod0 := mul(x, y)
1647                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1648             }
1649 
1650             // Handle non-overflow cases, 256 by 256 division.
1651             if (prod1 == 0) {
1652                 return prod0 / denominator;
1653             }
1654 
1655             // Make sure the result is less than 2^256. Also prevents denominator == 0.
1656             require(denominator > prod1);
1657 
1658             ///////////////////////////////////////////////
1659             // 512 by 256 division.
1660             ///////////////////////////////////////////////
1661 
1662             // Make division exact by subtracting the remainder from [prod1 prod0].
1663             uint256 remainder;
1664             assembly {
1665                 // Compute remainder using mulmod.
1666                 remainder := mulmod(x, y, denominator)
1667 
1668                 // Subtract 256 bit number from 512 bit number.
1669                 prod1 := sub(prod1, gt(remainder, prod0))
1670                 prod0 := sub(prod0, remainder)
1671             }
1672 
1673             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
1674             // See https://cs.stackexchange.com/q/138556/92363.
1675 
1676             // Does not overflow because the denominator cannot be zero at this stage in the function.
1677             uint256 twos = denominator & (~denominator + 1);
1678             assembly {
1679                 // Divide denominator by twos.
1680                 denominator := div(denominator, twos)
1681 
1682                 // Divide [prod1 prod0] by twos.
1683                 prod0 := div(prod0, twos)
1684 
1685                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1686                 twos := add(div(sub(0, twos), twos), 1)
1687             }
1688 
1689             // Shift in bits from prod1 into prod0.
1690             prod0 |= prod1 * twos;
1691 
1692             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
1693             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
1694             // four bits. That is, denominator * inv = 1 mod 2^4.
1695             uint256 inverse = (3 * denominator) ^ 2;
1696 
1697             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
1698             // in modular arithmetic, doubling the correct bits in each step.
1699             inverse *= 2 - denominator * inverse; // inverse mod 2^8
1700             inverse *= 2 - denominator * inverse; // inverse mod 2^16
1701             inverse *= 2 - denominator * inverse; // inverse mod 2^32
1702             inverse *= 2 - denominator * inverse; // inverse mod 2^64
1703             inverse *= 2 - denominator * inverse; // inverse mod 2^128
1704             inverse *= 2 - denominator * inverse; // inverse mod 2^256
1705 
1706             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
1707             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
1708             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
1709             // is no longer required.
1710             result = prod0 * inverse;
1711             return result;
1712         }
1713     }



```

```
AddressUpgradeable.functionCall(address,bytes,string) (PermissionedPool.sol#1263-1269) is never used and should be removed



    
1263     function functionCall(
1264         address target,
1265         bytes memory data,
1266         string memory errorMessage
1267     ) internal returns (bytes memory) {
1268         return functionCallWithValue(target, data, 0, errorMessage);
1269     }



```

```
AddressUpgradeable.sendValue(address,uint256) (PermissionedPool.sol#1228-1233) is never used and should be removed



    
1228     function sendValue(address payable recipient, uint256 amount) internal {
1229         require(address(this).balance >= amount, "Address: insufficient balance");
1230 
1231         (bool success, ) = recipient.call{value: amount}("");
1232         require(success, "Address: unable to send value, recipient may have reverted");
1233     }



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (PermissionedPool.sol#534-543) is never used and should be removed



    
534     function getOperatorAddressByOperatorId(
535         uint8 _poolId,
536         uint256 _operatorId,
537         IStaderConfig _staderConfig
538     ) internal view returns (address) {
539         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);
541 
542         return operatorAddress;
543     }



```

```
Math.sqrt(uint256) (PermissionedPool.sol#1010-1066) is never used and should be removed



    
1010     function sqrt(uint256 a) internal pure returns (uint256) {
1011         if (a == 0) {
1012             return 0;
1013         }
1014 
1015         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
1016         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
1017         // `msb(a) <= a < 2*msb(a)`.
1018         // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.
1019         // This gives `2**k < a <= 2**(k+1)` → `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.
1020         // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a
1021         // good first aproximation of `sqrt(a)` with at least 1 correct bit.
1022         uint256 result = 1;
1023         uint256 x = a;
1024         if (x >> 128 > 0) {
1025             x >>= 128;
1026             result <<= 64;
1027         }
1028         if (x >> 64 > 0) {
1029             x >>= 64;
1030             result <<= 32;
1031         }
1032         if (x >> 32 > 0) {
1033             x >>= 32;
1034             result <<= 16;
1035         }
1036         if (x >> 16 > 0) {
1037             x >>= 16;
1038             result <<= 8;
1039         }
1040         if (x >> 8 > 0) {
1041             x >>= 8;
1042             result <<= 4;
1043         }
1044         if (x >> 4 > 0) {
1045             x >>= 4;
1046             result <<= 2;
1047         }
1048         if (x >> 2 > 0) {
1049             result <<= 1;
1050         }
1051 
1052         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
1053         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
1054         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
1055         // into the expected uint128 result.
1056         unchecked {
1057             result = (result + a / result) >> 1;
1058             result = (result + a / result) >> 1;
1059             result = (result + a / result) >> 1;
1060             result = (result + a / result) >> 1;
1061             result = (result + a / result) >> 1;
1062             result = (result + a / result) >> 1;
1063             result = (result + a / result) >> 1;
1064             return min(result, a / result);
1065         }
1066     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes) (PermissionedPool.sol#1313-1315) is never used and should be removed



    
1313     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
1314         return functionStaticCall(target, data, "Address: low-level static call failed");
1315     }



```

```
MathUpgradeable.sqrt(uint256,MathUpgradeable.Rounding) (PermissionedPool.sol#1772-1777) is never used and should be removed



    
1772     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
1773         unchecked {
1774             uint256 result = sqrt(a);
1775             return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
1776         }
1777     }



```

```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (PermissionedPool.sol#509-520) is never used and should be removed



    
509     function onlyValidatorWithdrawVault(
510         uint8 _poolId,
511         uint256 _validatorId,
512         address _addr,
513         IStaderConfig _staderConfig
514     ) internal view {
515         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
517         if (_addr != withdrawVaultAddress) {
518             revert CallerNotWithdrawVault();
519         }
520     }



```

```
MathUpgradeable.log2(uint256) (PermissionedPool.sol#1783-1819) is never used and should be removed



    
1783     function log2(uint256 value) internal pure returns (uint256) {
1784         uint256 result = 0;
1785         unchecked {
1786             if (value >> 128 > 0) {
1787                 value >>= 128;
1788                 result += 128;
1789             }
1790             if (value >> 64 > 0) {
1791                 value >>= 64;
1792                 result += 64;
1793             }
1794             if (value >> 32 > 0) {
1795                 value >>= 32;
1796                 result += 32;
1797             }
1798             if (value >> 16 > 0) {
1799                 value >>= 16;
1800                 result += 16;
1801             }
1802             if (value >> 8 > 0) {
1803                 value >>= 8;
1804                 result += 8;
1805             }
1806             if (value >> 4 > 0) {
1807                 value >>= 4;
1808                 result += 4;
1809             }
1810             if (value >> 2 > 0) {
1811                 value >>= 2;
1812                 result += 2;
1813             }
1814             if (value >> 1 > 0) {
1815                 result += 1;
1816             }
1817         }
1818         return result;
1819     }



```

```
UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig) (PermissionedPool.sol#582-592) is never used and should be removed



    
582     function computeExchangeRate(
583         uint256 totalETHBalance,
584         uint256 totalETHXSupply,
585         IStaderConfig _staderConfig
586     ) internal view returns (uint256) {
587         uint256 DECIMALS = _staderConfig.getDecimals();
588         uint256 newExchangeRate = (totalETHBalance == 0 || totalETHXSupply == 0)
589             ? DECIMALS
590             : (totalETHBalance * DECIMALS) / totalETHXSupply;
591         return newExchangeRate;
592     }



```

```
AccessControlUpgradeable._setRoleAdmin(bytes32,bytes32) (PermissionedPool.sol#2257-2261) is never used and should be removed



    
2257     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
2258         bytes32 previousAdminRole = getRoleAdmin(role);
2259         _roles[role].adminRole = adminRole;
2260         emit RoleAdminChanged(role, previousAdminRole, adminRole);
2261     }



```

```
MathUpgradeable.average(uint256,uint256) (PermissionedPool.sol#1612-1615) is never used and should be removed



    
1612     function average(uint256 a, uint256 b) internal pure returns (uint256) {
1613         // (a + b) / 2 can overflow.
1614         return (a & b) + (a ^ b) / 2;
1615     }



```

```
StringsUpgradeable.toHexString(uint256) (PermissionedPool.sol#1960-1964) is never used and should be removed



    
1960     function toHexString(uint256 value) internal pure returns (string memory) {
1961         unchecked {
1962             return toHexString(value, MathUpgradeable.log256(value) + 1);
1963         }
1964     }



```

```
MathUpgradeable.log10(uint256) (PermissionedPool.sol#1836-1868) is never used and should be removed



    
1836     function log10(uint256 value) internal pure returns (uint256) {
1837         uint256 result = 0;
1838         unchecked {
1839             if (value >= 10**64) {
1840                 value /= 10**64;
1841                 result += 64;
1842             }
1843             if (value >= 10**32) {
1844                 value /= 10**32;
1845                 result += 32;
1846             }
1847             if (value >= 10**16) {
1848                 value /= 10**16;
1849                 result += 16;
1850             }
1851             if (value >= 10**8) {
1852                 value /= 10**8;
1853                 result += 8;
1854             }
1855             if (value >= 10**4) {
1856                 value /= 10**4;
1857                 result += 4;
1858             }
1859             if (value >= 10**2) {
1860                 value /= 10**2;
1861                 result += 2;
1862             }
1863             if (value >= 10**1) {
1864                 result += 1;
1865             }
1866         }
1867         return result;
1868     }



```

```
ERC165Upgradeable.__ERC165_init() (PermissionedPool.sol#2029-2030) is never used and should be removed



    
2029     function __ERC165_init() internal onlyInitializing {
2030     }



```

```
Math.mulDiv(uint256,uint256,uint256,Math.Rounding) (PermissionedPool.sol#992-1003) is never used and should be removed



    
992     function mulDiv(
993         uint256 x,
994         uint256 y,
995         uint256 denominator,
996         Rounding rounding
997     ) internal pure returns (uint256) {
998         uint256 result = mulDiv(x, y, denominator);
999         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
1000             result += 1;
1001         }
1002         return result;
1003     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256,MathUpgradeable.Rounding) (PermissionedPool.sol#1718-1729) is never used and should be removed



    
1718     function mulDiv(
1719         uint256 x,
1720         uint256 y,
1721         uint256 denominator,
1722         Rounding rounding
1723     ) internal pure returns (uint256) {
1724         uint256 result = mulDiv(x, y, denominator);
1725         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
1726             result += 1;
1727         }
1728         return result;
1729     }



```

```
AddressUpgradeable.verifyCallResult(bool,bytes,string) (PermissionedPool.sol#1362-1372) is never used and should be removed



    
1362     function verifyCallResult(
1363         bool success,
1364         bytes memory returndata,
1365         string memory errorMessage
1366     ) internal pure returns (bytes memory) {
1367         if (success) {
1368             return returndata;
1369         } else {
1370             _revert(returndata, errorMessage);
1371         }
1372     }



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (PermissionedPool.sol#476-490) is never used and should be removed



    
476     function getPubkeyForValidSender(
477         uint8 _poolId,
478         uint256 _validatorId,
479         address _addr,
480         IStaderConfig _staderConfig
481     ) internal view returns (bytes memory) {
482         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );
486         if (_addr != withdrawVaultAddress) {
487             revert CallerNotWithdrawVault();
488         }
489         return pubkey;
490     }



```

```
AddressUpgradeable._revert(bytes,string) (PermissionedPool.sol#1374-1386) is never used and should be removed



    
1374     function _revert(bytes memory returndata, string memory errorMessage) private pure {
1375         // Look for revert reason and bubble it up if present
1376         if (returndata.length > 0) {
1377             // The easiest way to bubble the revert reason is using memory via assembly
1378             /// @solidity memory-safe-assembly
1379             assembly {
1380                 let returndata_size := mload(returndata)
1381                 revert(add(32, returndata), returndata_size)
1382             }
1383         } else {
1384             revert(errorMessage);
1385         }
1386     }



```

```
Initializable._getInitializedVersion() (PermissionedPool.sol#1536-1538) is never used and should be removed



    
1536     function _getInitializedVersion() internal view returns (uint8) {
1537         return _initialized;
1538     }



```

```
AccessControlUpgradeable._setupRole(bytes32,address) (PermissionedPool.sol#2248-2250) is never used and should be removed



    
2248     function _setupRole(bytes32 role, address account) internal virtual {
2249         _grantRole(role, account);
2250     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes,string) (PermissionedPool.sol#1323-1330) is never used and should be removed



    
1323     function functionStaticCall(
1324         address target,
1325         bytes memory data,
1326         string memory errorMessage
1327     ) internal view returns (bytes memory) {
1328         (bool success, bytes memory returndata) = target.staticcall(data);
1329         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
1330     }



```

```
Math.min(uint256,uint256) (PermissionedPool.sol#878-880) is never used and should be removed



    
878     function min(uint256 a, uint256 b) internal pure returns (uint256) {
879         return a < b ? a : b;
880     }



```

```
MathUpgradeable.log256(uint256,MathUpgradeable.Rounding) (PermissionedPool.sol#1917-1922) is never used and should be removed



    
1917     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
1918         unchecked {
1919             uint256 result = log256(value);
1920             return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);
1921         }
1922     }



```

```
UtilLib.onlyOperatorRole(address,IStaderConfig) (PermissionedPool.sol#459-463) is never used and should be removed



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {
460         if (!_staderConfig.onlyOperatorRole(_addr)) {
461             revert CallerNotOperator();
462         }
463     }



```

```
UtilLib.sendValue(address,uint256) (PermissionedPool.sol#594-599) is never used and should be removed



    
594     function sendValue(address _receiver, uint256 _amount) internal {
595         (bool success, ) = payable(_receiver).call{value: _amount}('');
596         if (!success) {
597             revert TransferFailed();
598         }
599     }



```

```
MathUpgradeable.max(uint256,uint256) (PermissionedPool.sol#1597-1599) is never used and should be removed



    
1597     function max(uint256 a, uint256 b) internal pure returns (uint256) {
1598         return a > b ? a : b;
1599     }



```

```
ContextUpgradeable.__Context_init() (PermissionedPool.sol#1559-1560) is never used and should be removed



    
1559     function __Context_init() internal onlyInitializing {
1560     }



```

```
UtilLib.getOperatorRewardAddress(address,IStaderConfig) (PermissionedPool.sol#545-554) is never used and should be removed



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)
546         internal
547         view
548         returns (address payable)
549     {
550         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getOperatorPoolId(_operator);
551         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
552         uint256 operatorId = INodeRegistry(nodeRegistry).operatorIDByAddress(_operator);
553         return INodeRegistry(nodeRegistry).getOperatorRewardAddress(operatorId);
554     }



```

```
AddressUpgradeable.verifyCallResultFromTarget(address,bool,bytes,string) (PermissionedPool.sol#1338-1354) is never used and should be removed



    
1338     function verifyCallResultFromTarget(
1339         address target,
1340         bool success,
1341         bytes memory returndata,
1342         string memory errorMessage
1343     ) internal view returns (bytes memory) {
1344         if (success) {
1345             if (returndata.length == 0) {
1346                 // only check isContract if the call was successful and the return data is empty
1347                 // otherwise we already know that it was a contract
1348                 require(isContract(target), "Address: call to non-contract");
1349             }
1350             return returndata;
1351         } else {
1352             _revert(returndata, errorMessage);
1353         }
1354     }



```

```
MathUpgradeable.log256(uint256) (PermissionedPool.sol#1887-1911) is never used and should be removed



    
1887     function log256(uint256 value) internal pure returns (uint256) {
1888         uint256 result = 0;
1889         unchecked {
1890             if (value >> 128 > 0) {
1891                 value >>= 128;
1892                 result += 16;
1893             }
1894             if (value >> 64 > 0) {
1895                 value >>= 64;
1896                 result += 8;
1897             }
1898             if (value >> 32 > 0) {
1899                 value >>= 32;
1900                 result += 4;
1901             }
1902             if (value >> 16 > 0) {
1903                 value >>= 16;
1904                 result += 2;
1905             }
1906             if (value >> 8 > 0) {
1907                 result += 1;
1908             }
1909         }
1910         return result;
1911     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (PermissionedPool.sol#1296-1305) is never used and should be removed



    
1296     function functionCallWithValue(
1297         address target,
1298         bytes memory data,
1299         uint256 value,
1300         string memory errorMessage
1301     ) internal returns (bytes memory) {
1302         require(address(this).balance >= value, "Address: insufficient balance for call");
1303         (bool success, bytes memory returndata) = target.call{value: value}(data);
1304         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
1305     }



```

### PermissionlessNodeRegistry.sol


```
StringsUpgradeable.toString(uint256) (PermissionlessNodeRegistry.sol#1842-1862) is never used and should be removed



    
1842     function toString(uint256 value) internal pure returns (string memory) {
1843         unchecked {
1844             uint256 length = MathUpgradeable.log10(value) + 1;
1845             string memory buffer = new string(length);
1846             uint256 ptr;
1847             /// @solidity memory-safe-assembly
1848             assembly {
1849                 ptr := add(buffer, add(32, length))
1850             }
1851             while (true) {
1852                 ptr--;
1853                 /// @solidity memory-safe-assembly
1854                 assembly {
1855                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
1856                 }
1857                 value /= 10;
1858                 if (value == 0) break;
1859             }
1860             return buffer;
1861         }
1862     }



```

```
ContextUpgradeable._msgData() (PermissionlessNodeRegistry.sol#1277-1279) is never used and should be removed



    
1277     function _msgData() internal view virtual returns (bytes calldata) {
1278         return msg.data;
1279     }



```

```
MathUpgradeable.log2(uint256,MathUpgradeable.Rounding) (PermissionlessNodeRegistry.sol#1732-1737) is never used and should be removed



    
1732     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
1733         unchecked {
1734             uint256 result = log2(value);
1735             return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
1736         }
1737     }



```

```
Initializable._isInitializing() (PermissionlessNodeRegistry.sol#1252-1254) is never used and should be removed



    
1252     function _isInitializing() internal view returns (bool) {
1253         return _initializing;
1254     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256) (PermissionlessNodeRegistry.sol#991-997) is never used and should be removed



    
991     function functionCallWithValue(
992         address target,
993         bytes memory data,
994         uint256 value
995     ) internal returns (bytes memory) {
996         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
997     }



```

```
MathUpgradeable.ceilDiv(uint256,uint256) (PermissionlessNodeRegistry.sol#1530-1533) is never used and should be removed



    
1530     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
1531         // (a + b - 1) / b can overflow on addition, so we distribute.
1532         return a == 0 ? 0 : (a - 1) / b + 1;
1533     }



```

```
MathUpgradeable.min(uint256,uint256) (PermissionlessNodeRegistry.sol#1511-1513) is never used and should be removed



    
1511     function min(uint256 a, uint256 b) internal pure returns (uint256) {
1512         return a < b ? a : b;
1513     }



```

```
MathUpgradeable.sqrt(uint256) (PermissionlessNodeRegistry.sol#1643-1674) is never used and should be removed



    
1643     function sqrt(uint256 a) internal pure returns (uint256) {
1644         if (a == 0) {
1645             return 0;
1646         }
1647 
1648         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
1649         //
1650         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
1651         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
1652         //
1653         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
1654         // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
1655         // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
1656         //
1657         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
1658         uint256 result = 1 << (log2(a) >> 1);
1659 
1660         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
1661         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
1662         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
1663         // into the expected uint128 result.
1664         unchecked {
1665             result = (result + a / result) >> 1;
1666             result = (result + a / result) >> 1;
1667             result = (result + a / result) >> 1;
1668             result = (result + a / result) >> 1;
1669             result = (result + a / result) >> 1;
1670             result = (result + a / result) >> 1;
1671             result = (result + a / result) >> 1;
1672             return min(result, a / result);
1673         }
1674     }



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (PermissionlessNodeRegistry.sol#522-532) is never used and should be removed



    
522     function getOperatorAddressByValidatorId(
523         uint8 _poolId,
524         uint256 _validatorId,
525         IStaderConfig _staderConfig
526     ) internal view returns (address) {
527         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
530 
531         return operatorAddress;
532     }



```

```
UtilLib.getPubkeyRoot(bytes) (PermissionlessNodeRegistry.sol#561-568) is never used and should be removed



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {
562         if (_pubkey.length != VALIDATOR_PUBKEY_LENGTH) {
563             revert InvalidPubkeyLength();
564         }
565 
566         // Append 16 bytes of zero padding to the pubkey and compute its hash to get the pubkey root.
567         return sha256(abi.encodePacked(_pubkey, bytes16(0)));
568     }



```

```
AccessControlUpgradeable.__AccessControl_init() (PermissionlessNodeRegistry.sol#1995-1996) is never used and should be removed



    
1995     function __AccessControl_init() internal onlyInitializing {
1996     }



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (PermissionlessNodeRegistry.sol#492-507) is never used and should be removed



    
492     function getOperatorForValidSender(
493         uint8 _poolId,
494         uint256 _validatorId,
495         address _addr,
496         IStaderConfig _staderConfig
497     ) internal view returns (address) {
498         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );
502         if (_addr != withdrawVaultAddress) {
503             revert CallerNotWithdrawVault();
504         }
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
506         return operator;
507     }



```

```
MathUpgradeable.log10(uint256,MathUpgradeable.Rounding) (PermissionlessNodeRegistry.sol#1781-1786) is never used and should be removed



    
1781     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
1782         unchecked {
1783             uint256 result = log10(value);
1784             return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);
1785         }
1786     }



```

```
AddressUpgradeable.functionCall(address,bytes) (PermissionlessNodeRegistry.sol#962-964) is never used and should be removed



    
962     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
963         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
964     }



```

```
ContextUpgradeable.__Context_init_unchained() (PermissionlessNodeRegistry.sol#1271-1272) is never used and should be removed



    
1271     function __Context_init_unchained() internal onlyInitializing {
1272     }



```

```
ERC165Upgradeable.__ERC165_init_unchained() (PermissionlessNodeRegistry.sol#1939-1940) is never used and should be removed



    
1939     function __ERC165_init_unchained() internal onlyInitializing {
1940     }



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (PermissionlessNodeRegistry.sol#570-580) is never used and should be removed



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)
571         internal
572         view
573         returns (bool)
574     {
575         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getValidatorPoolId(_pubkey);
576         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
577         uint256 validatorId = INodeRegistry(nodeRegistry).validatorIdByPubkey(_pubkey);
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);
579         return IVaultProxy(withdrawVaultAddress).vaultSettleStatus();
580     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionlessNodeRegistry.sol#1540-1620) is never used and should be removed



    
1540     function mulDiv(
1541         uint256 x,
1542         uint256 y,
1543         uint256 denominator
1544     ) internal pure returns (uint256 result) {
1545         unchecked {
1546             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
1547             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
1548             // variables such that product = prod1 * 2^256 + prod0.
1549             uint256 prod0; // Least significant 256 bits of the product
1550             uint256 prod1; // Most significant 256 bits of the product
1551             assembly {
1552                 let mm := mulmod(x, y, not(0))
1553                 prod0 := mul(x, y)
1554                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1555             }
1556 
1557             // Handle non-overflow cases, 256 by 256 division.
1558             if (prod1 == 0) {
1559                 return prod0 / denominator;
1560             }
1561 
1562             // Make sure the result is less than 2^256. Also prevents denominator == 0.
1563             require(denominator > prod1);
1564 
1565             ///////////////////////////////////////////////
1566             // 512 by 256 division.
1567             ///////////////////////////////////////////////
1568 
1569             // Make division exact by subtracting the remainder from [prod1 prod0].
1570             uint256 remainder;
1571             assembly {
1572                 // Compute remainder using mulmod.
1573                 remainder := mulmod(x, y, denominator)
1574 
1575                 // Subtract 256 bit number from 512 bit number.
1576                 prod1 := sub(prod1, gt(remainder, prod0))
1577                 prod0 := sub(prod0, remainder)
1578             }
1579 
1580             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
1581             // See https://cs.stackexchange.com/q/138556/92363.
1582 
1583             // Does not overflow because the denominator cannot be zero at this stage in the function.
1584             uint256 twos = denominator & (~denominator + 1);
1585             assembly {
1586                 // Divide denominator by twos.
1587                 denominator := div(denominator, twos)
1588 
1589                 // Divide [prod1 prod0] by twos.
1590                 prod0 := div(prod0, twos)
1591 
1592                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1593                 twos := add(div(sub(0, twos), twos), 1)
1594             }
1595 
1596             // Shift in bits from prod1 into prod0.
1597             prod0 |= prod1 * twos;
1598 
1599             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
1600             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
1601             // four bits. That is, denominator * inv = 1 mod 2^4.
1602             uint256 inverse = (3 * denominator) ^ 2;
1603 
1604             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
1605             // in modular arithmetic, doubling the correct bits in each step.
1606             inverse *= 2 - denominator * inverse; // inverse mod 2^8
1607             inverse *= 2 - denominator * inverse; // inverse mod 2^16
1608             inverse *= 2 - denominator * inverse; // inverse mod 2^32
1609             inverse *= 2 - denominator * inverse; // inverse mod 2^64
1610             inverse *= 2 - denominator * inverse; // inverse mod 2^128
1611             inverse *= 2 - denominator * inverse; // inverse mod 2^256
1612 
1613             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
1614             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
1615             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
1616             // is no longer required.
1617             result = prod0 * inverse;
1618             return result;
1619         }
1620     }



```

```
AddressUpgradeable.functionCall(address,bytes,string) (PermissionlessNodeRegistry.sol#972-978) is never used and should be removed



    
972     function functionCall(
973         address target,
974         bytes memory data,
975         string memory errorMessage
976     ) internal returns (bytes memory) {
977         return functionCallWithValue(target, data, 0, errorMessage);
978     }



```

```
AddressUpgradeable.sendValue(address,uint256) (PermissionlessNodeRegistry.sol#937-942) is never used and should be removed



    
937     function sendValue(address payable recipient, uint256 amount) internal {
938         require(address(this).balance >= amount, "Address: insufficient balance");
939 
940         (bool success, ) = recipient.call{value: amount}("");
941         require(success, "Address: unable to send value, recipient may have reverted");
942     }



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (PermissionlessNodeRegistry.sol#534-543) is never used and should be removed



    
534     function getOperatorAddressByOperatorId(
535         uint8 _poolId,
536         uint256 _operatorId,
537         IStaderConfig _staderConfig
538     ) internal view returns (address) {
539         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);
541 
542         return operatorAddress;
543     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes) (PermissionlessNodeRegistry.sol#1022-1024) is never used and should be removed



    
1022     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
1023         return functionStaticCall(target, data, "Address: low-level static call failed");
1024     }



```

```
MathUpgradeable.sqrt(uint256,MathUpgradeable.Rounding) (PermissionlessNodeRegistry.sol#1679-1684) is never used and should be removed



    
1679     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
1680         unchecked {
1681             uint256 result = sqrt(a);
1682             return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
1683         }
1684     }



```

```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (PermissionlessNodeRegistry.sol#509-520) is never used and should be removed



    
509     function onlyValidatorWithdrawVault(
510         uint8 _poolId,
511         uint256 _validatorId,
512         address _addr,
513         IStaderConfig _staderConfig
514     ) internal view {
515         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
517         if (_addr != withdrawVaultAddress) {
518             revert CallerNotWithdrawVault();
519         }
520     }



```

```
MathUpgradeable.log2(uint256) (PermissionlessNodeRegistry.sol#1690-1726) is never used and should be removed



    
1690     function log2(uint256 value) internal pure returns (uint256) {
1691         uint256 result = 0;
1692         unchecked {
1693             if (value >> 128 > 0) {
1694                 value >>= 128;
1695                 result += 128;
1696             }
1697             if (value >> 64 > 0) {
1698                 value >>= 64;
1699                 result += 64;
1700             }
1701             if (value >> 32 > 0) {
1702                 value >>= 32;
1703                 result += 32;
1704             }
1705             if (value >> 16 > 0) {
1706                 value >>= 16;
1707                 result += 16;
1708             }
1709             if (value >> 8 > 0) {
1710                 value >>= 8;
1711                 result += 8;
1712             }
1713             if (value >> 4 > 0) {
1714                 value >>= 4;
1715                 result += 4;
1716             }
1717             if (value >> 2 > 0) {
1718                 value >>= 2;
1719                 result += 2;
1720             }
1721             if (value >> 1 > 0) {
1722                 result += 1;
1723             }
1724         }
1725         return result;
1726     }



```

```
UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig) (PermissionlessNodeRegistry.sol#582-592) is never used and should be removed



    
582     function computeExchangeRate(
583         uint256 totalETHBalance,
584         uint256 totalETHXSupply,
585         IStaderConfig _staderConfig
586     ) internal view returns (uint256) {
587         uint256 DECIMALS = _staderConfig.getDecimals();
588         uint256 newExchangeRate = (totalETHBalance == 0 || totalETHXSupply == 0)
589             ? DECIMALS
590             : (totalETHBalance * DECIMALS) / totalETHXSupply;
591         return newExchangeRate;
592     }



```

```
AccessControlUpgradeable._setRoleAdmin(bytes32,bytes32) (PermissionlessNodeRegistry.sol#2164-2168) is never used and should be removed



    
2164     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
2165         bytes32 previousAdminRole = getRoleAdmin(role);
2166         _roles[role].adminRole = adminRole;
2167         emit RoleAdminChanged(role, previousAdminRole, adminRole);
2168     }



```

```
MathUpgradeable.average(uint256,uint256) (PermissionlessNodeRegistry.sol#1519-1522) is never used and should be removed



    
1519     function average(uint256 a, uint256 b) internal pure returns (uint256) {
1520         // (a + b) / 2 can overflow.
1521         return (a & b) + (a ^ b) / 2;
1522     }



```

```
StringsUpgradeable.toHexString(uint256) (PermissionlessNodeRegistry.sol#1867-1871) is never used and should be removed



    
1867     function toHexString(uint256 value) internal pure returns (string memory) {
1868         unchecked {
1869             return toHexString(value, MathUpgradeable.log256(value) + 1);
1870         }
1871     }



```

```
MathUpgradeable.log10(uint256) (PermissionlessNodeRegistry.sol#1743-1775) is never used and should be removed



    
1743     function log10(uint256 value) internal pure returns (uint256) {
1744         uint256 result = 0;
1745         unchecked {
1746             if (value >= 10**64) {
1747                 value /= 10**64;
1748                 result += 64;
1749             }
1750             if (value >= 10**32) {
1751                 value /= 10**32;
1752                 result += 32;
1753             }
1754             if (value >= 10**16) {
1755                 value /= 10**16;
1756                 result += 16;
1757             }
1758             if (value >= 10**8) {
1759                 value /= 10**8;
1760                 result += 8;
1761             }
1762             if (value >= 10**4) {
1763                 value /= 10**4;
1764                 result += 4;
1765             }
1766             if (value >= 10**2) {
1767                 value /= 10**2;
1768                 result += 2;
1769             }
1770             if (value >= 10**1) {
1771                 result += 1;
1772             }
1773         }
1774         return result;
1775     }



```

```
ERC165Upgradeable.__ERC165_init() (PermissionlessNodeRegistry.sol#1936-1937) is never used and should be removed



    
1936     function __ERC165_init() internal onlyInitializing {
1937     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256,MathUpgradeable.Rounding) (PermissionlessNodeRegistry.sol#1625-1636) is never used and should be removed



    
1625     function mulDiv(
1626         uint256 x,
1627         uint256 y,
1628         uint256 denominator,
1629         Rounding rounding
1630     ) internal pure returns (uint256) {
1631         uint256 result = mulDiv(x, y, denominator);
1632         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
1633             result += 1;
1634         }
1635         return result;
1636     }



```

```
AddressUpgradeable.verifyCallResult(bool,bytes,string) (PermissionlessNodeRegistry.sol#1071-1081) is never used and should be removed



    
1071     function verifyCallResult(
1072         bool success,
1073         bytes memory returndata,
1074         string memory errorMessage
1075     ) internal pure returns (bytes memory) {
1076         if (success) {
1077             return returndata;
1078         } else {
1079             _revert(returndata, errorMessage);
1080         }
1081     }



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (PermissionlessNodeRegistry.sol#476-490) is never used and should be removed



    
476     function getPubkeyForValidSender(
477         uint8 _poolId,
478         uint256 _validatorId,
479         address _addr,
480         IStaderConfig _staderConfig
481     ) internal view returns (bytes memory) {
482         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );
486         if (_addr != withdrawVaultAddress) {
487             revert CallerNotWithdrawVault();
488         }
489         return pubkey;
490     }



```

```
AddressUpgradeable._revert(bytes,string) (PermissionlessNodeRegistry.sol#1083-1095) is never used and should be removed



    
1083     function _revert(bytes memory returndata, string memory errorMessage) private pure {
1084         // Look for revert reason and bubble it up if present
1085         if (returndata.length > 0) {
1086             // The easiest way to bubble the revert reason is using memory via assembly
1087             /// @solidity memory-safe-assembly
1088             assembly {
1089                 let returndata_size := mload(returndata)
1090                 revert(add(32, returndata), returndata_size)
1091             }
1092         } else {
1093             revert(errorMessage);
1094         }
1095     }



```

```
Initializable._getInitializedVersion() (PermissionlessNodeRegistry.sol#1245-1247) is never used and should be removed



    
1245     function _getInitializedVersion() internal view returns (uint8) {
1246         return _initialized;
1247     }



```

```
AccessControlUpgradeable._setupRole(bytes32,address) (PermissionlessNodeRegistry.sol#2155-2157) is never used and should be removed



    
2155     function _setupRole(bytes32 role, address account) internal virtual {
2156         _grantRole(role, account);
2157     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes,string) (PermissionlessNodeRegistry.sol#1032-1039) is never used and should be removed



    
1032     function functionStaticCall(
1033         address target,
1034         bytes memory data,
1035         string memory errorMessage
1036     ) internal view returns (bytes memory) {
1037         (bool success, bytes memory returndata) = target.staticcall(data);
1038         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
1039     }



```

```
MathUpgradeable.log256(uint256,MathUpgradeable.Rounding) (PermissionlessNodeRegistry.sol#1824-1829) is never used and should be removed



    
1824     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
1825         unchecked {
1826             uint256 result = log256(value);
1827             return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);
1828         }
1829     }



```

```
UtilLib.sendValue(address,uint256) (PermissionlessNodeRegistry.sol#594-599) is never used and should be removed



    
594     function sendValue(address _receiver, uint256 _amount) internal {
595         (bool success, ) = payable(_receiver).call{value: _amount}('');
596         if (!success) {
597             revert TransferFailed();
598         }
599     }



```

```
MathUpgradeable.max(uint256,uint256) (PermissionlessNodeRegistry.sol#1504-1506) is never used and should be removed



    
1504     function max(uint256 a, uint256 b) internal pure returns (uint256) {
1505         return a > b ? a : b;
1506     }



```

```
ContextUpgradeable.__Context_init() (PermissionlessNodeRegistry.sol#1268-1269) is never used and should be removed



    
1268     function __Context_init() internal onlyInitializing {
1269     }



```

```
UtilLib.getOperatorRewardAddress(address,IStaderConfig) (PermissionlessNodeRegistry.sol#545-554) is never used and should be removed



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)
546         internal
547         view
548         returns (address payable)
549     {
550         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getOperatorPoolId(_operator);
551         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
552         uint256 operatorId = INodeRegistry(nodeRegistry).operatorIDByAddress(_operator);
553         return INodeRegistry(nodeRegistry).getOperatorRewardAddress(operatorId);
554     }



```

```
AddressUpgradeable.verifyCallResultFromTarget(address,bool,bytes,string) (PermissionlessNodeRegistry.sol#1047-1063) is never used and should be removed



    
1047     function verifyCallResultFromTarget(
1048         address target,
1049         bool success,
1050         bytes memory returndata,
1051         string memory errorMessage
1052     ) internal view returns (bytes memory) {
1053         if (success) {
1054             if (returndata.length == 0) {
1055                 // only check isContract if the call was successful and the return data is empty
1056                 // otherwise we already know that it was a contract
1057                 require(isContract(target), "Address: call to non-contract");
1058             }
1059             return returndata;
1060         } else {
1061             _revert(returndata, errorMessage);
1062         }
1063     }



```

```
MathUpgradeable.log256(uint256) (PermissionlessNodeRegistry.sol#1794-1818) is never used and should be removed



    
1794     function log256(uint256 value) internal pure returns (uint256) {
1795         uint256 result = 0;
1796         unchecked {
1797             if (value >> 128 > 0) {
1798                 value >>= 128;
1799                 result += 16;
1800             }
1801             if (value >> 64 > 0) {
1802                 value >>= 64;
1803                 result += 8;
1804             }
1805             if (value >> 32 > 0) {
1806                 value >>= 32;
1807                 result += 4;
1808             }
1809             if (value >> 16 > 0) {
1810                 value >>= 16;
1811                 result += 2;
1812             }
1813             if (value >> 8 > 0) {
1814                 result += 1;
1815             }
1816         }
1817         return result;
1818     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (PermissionlessNodeRegistry.sol#1005-1014) is never used and should be removed



    
1005     function functionCallWithValue(
1006         address target,
1007         bytes memory data,
1008         uint256 value,
1009         string memory errorMessage
1010     ) internal returns (bytes memory) {
1011         require(address(this).balance >= value, "Address: insufficient balance for call");
1012         (bool success, bytes memory returndata) = target.call{value: value}(data);
1013         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
1014     }



```

### PermissionlessPool.sol


```
StringsUpgradeable.toString(uint256) (PermissionlessPool.sol#1920-1940) is never used and should be removed



    
1920     function toString(uint256 value) internal pure returns (string memory) {
1921         unchecked {
1922             uint256 length = MathUpgradeable.log10(value) + 1;
1923             string memory buffer = new string(length);
1924             uint256 ptr;
1925             /// @solidity memory-safe-assembly
1926             assembly {
1927                 ptr := add(buffer, add(32, length))
1928             }
1929             while (true) {
1930                 ptr--;
1931                 /// @solidity memory-safe-assembly
1932                 assembly {
1933                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
1934                 }
1935                 value /= 10;
1936                 if (value == 0) break;
1937             }
1938             return buffer;
1939         }
1940     }



```

```
ContextUpgradeable._msgData() (PermissionlessPool.sol#1553-1555) is never used and should be removed



    
1553     function _msgData() internal view virtual returns (bytes calldata) {
1554         return msg.data;
1555     }



```

```
MathUpgradeable.log2(uint256,MathUpgradeable.Rounding) (PermissionlessPool.sol#1810-1815) is never used and should be removed



    
1810     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
1811         unchecked {
1812             uint256 result = log2(value);
1813             return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
1814         }
1815     }



```

```
Initializable._isInitializing() (PermissionlessPool.sol#1528-1530) is never used and should be removed



    
1528     function _isInitializing() internal view returns (bool) {
1529         return _initializing;
1530     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256) (PermissionlessPool.sol#1267-1273) is never used and should be removed



    
1267     function functionCallWithValue(
1268         address target,
1269         bytes memory data,
1270         uint256 value
1271     ) internal returns (bytes memory) {
1272         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
1273     }



```

```
MathUpgradeable.ceilDiv(uint256,uint256) (PermissionlessPool.sol#1608-1611) is never used and should be removed



    
1608     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
1609         // (a + b - 1) / b can overflow on addition, so we distribute.
1610         return a == 0 ? 0 : (a - 1) / b + 1;
1611     }



```

```
MathUpgradeable.min(uint256,uint256) (PermissionlessPool.sol#1589-1591) is never used and should be removed



    
1589     function min(uint256 a, uint256 b) internal pure returns (uint256) {
1590         return a < b ? a : b;
1591     }



```

```
MathUpgradeable.sqrt(uint256) (PermissionlessPool.sol#1721-1752) is never used and should be removed



    
1721     function sqrt(uint256 a) internal pure returns (uint256) {
1722         if (a == 0) {
1723             return 0;
1724         }
1725 
1726         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
1727         //
1728         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
1729         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
1730         //
1731         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
1732         // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
1733         // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
1734         //
1735         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
1736         uint256 result = 1 << (log2(a) >> 1);
1737 
1738         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
1739         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
1740         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
1741         // into the expected uint128 result.
1742         unchecked {
1743             result = (result + a / result) >> 1;
1744             result = (result + a / result) >> 1;
1745             result = (result + a / result) >> 1;
1746             result = (result + a / result) >> 1;
1747             result = (result + a / result) >> 1;
1748             result = (result + a / result) >> 1;
1749             result = (result + a / result) >> 1;
1750             return min(result, a / result);
1751         }
1752     }



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (PermissionlessPool.sol#522-532) is never used and should be removed



    
522     function getOperatorAddressByValidatorId(
523         uint8 _poolId,
524         uint256 _validatorId,
525         IStaderConfig _staderConfig
526     ) internal view returns (address) {
527         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
530 
531         return operatorAddress;
532     }



```

```
Math.ceilDiv(uint256,uint256) (PermissionlessPool.sol#882-885) is never used and should be removed



    
882     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
883         // (a + b - 1) / b can overflow on addition, so we distribute.
884         return a == 0 ? 0 : (a - 1) / b + 1;
885     }



```

```
UtilLib.getPubkeyRoot(bytes) (PermissionlessPool.sol#561-568) is never used and should be removed



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {
562         if (_pubkey.length != VALIDATOR_PUBKEY_LENGTH) {
563             revert InvalidPubkeyLength();
564         }
565 
566         // Append 16 bytes of zero padding to the pubkey and compute its hash to get the pubkey root.
567         return sha256(abi.encodePacked(_pubkey, bytes16(0)));
568     }



```

```
AccessControlUpgradeable.__AccessControl_init() (PermissionlessPool.sol#2073-2074) is never used and should be removed



    
2073     function __AccessControl_init() internal onlyInitializing {
2074     }



```

```
Math.mulDiv(uint256,uint256,uint256) (PermissionlessPool.sol#892-972) is never used and should be removed



    
892     function mulDiv(
893         uint256 x,
894         uint256 y,
895         uint256 denominator
896     ) internal pure returns (uint256 result) {
897         unchecked {
898             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
899             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
900             // variables such that product = prod1 * 2^256 + prod0.
901             uint256 prod0; // Least significant 256 bits of the product
902             uint256 prod1; // Most significant 256 bits of the product
903             assembly {
904                 let mm := mulmod(x, y, not(0))
905                 prod0 := mul(x, y)
906                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
907             }
908 
909             // Handle non-overflow cases, 256 by 256 division.
910             if (prod1 == 0) {
911                 return prod0 / denominator;
912             }
913 
914             // Make sure the result is less than 2^256. Also prevents denominator == 0.
915             require(denominator > prod1);
916 
917             ///////////////////////////////////////////////
918             // 512 by 256 division.
919             ///////////////////////////////////////////////
920 
921             // Make division exact by subtracting the remainder from [prod1 prod0].
922             uint256 remainder;
923             assembly {
924                 // Compute remainder using mulmod.
925                 remainder := mulmod(x, y, denominator)
926 
927                 // Subtract 256 bit number from 512 bit number.
928                 prod1 := sub(prod1, gt(remainder, prod0))
929                 prod0 := sub(prod0, remainder)
930             }
931 
932             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
933             // See https://cs.stackexchange.com/q/138556/92363.
934 
935             // Does not overflow because the denominator cannot be zero at this stage in the function.
936             uint256 twos = denominator & (~denominator + 1);
937             assembly {
938                 // Divide denominator by twos.
939                 denominator := div(denominator, twos)
940 
941                 // Divide [prod1 prod0] by twos.
942                 prod0 := div(prod0, twos)
943 
944                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
945                 twos := add(div(sub(0, twos), twos), 1)
946             }
947 
948             // Shift in bits from prod1 into prod0.
949             prod0 |= prod1 * twos;
950 
951             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
952             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
953             // four bits. That is, denominator * inv = 1 mod 2^4.
954             uint256 inverse = (3 * denominator) ^ 2;
955 
956             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
957             // in modular arithmetic, doubling the correct bits in each step.
958             inverse *= 2 - denominator * inverse; // inverse mod 2^8
959             inverse *= 2 - denominator * inverse; // inverse mod 2^16
960             inverse *= 2 - denominator * inverse; // inverse mod 2^32
961             inverse *= 2 - denominator * inverse; // inverse mod 2^64
962             inverse *= 2 - denominator * inverse; // inverse mod 2^128
963             inverse *= 2 - denominator * inverse; // inverse mod 2^256
964 
965             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
966             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
967             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
968             // is no longer required.
969             result = prod0 * inverse;
970             return result;
971         }
972     }



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (PermissionlessPool.sol#492-507) is never used and should be removed



    
492     function getOperatorForValidSender(
493         uint8 _poolId,
494         uint256 _validatorId,
495         address _addr,
496         IStaderConfig _staderConfig
497     ) internal view returns (address) {
498         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );
502         if (_addr != withdrawVaultAddress) {
503             revert CallerNotWithdrawVault();
504         }
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
506         return operator;
507     }



```

```
MathUpgradeable.log10(uint256,MathUpgradeable.Rounding) (PermissionlessPool.sol#1859-1864) is never used and should be removed



    
1859     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
1860         unchecked {
1861             uint256 result = log10(value);
1862             return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);
1863         }
1864     }



```

```
AddressUpgradeable.functionCall(address,bytes) (PermissionlessPool.sol#1238-1240) is never used and should be removed



    
1238     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
1239         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
1240     }



```

```
Math.sqrt(uint256,Math.Rounding) (PermissionlessPool.sol#1056-1062) is never used and should be removed



    
1056     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
1057         uint256 result = sqrt(a);
1058         if (rounding == Rounding.Up && result * result < a) {
1059             result += 1;
1060         }
1061         return result;
1062     }



```

```
ContextUpgradeable.__Context_init_unchained() (PermissionlessPool.sol#1547-1548) is never used and should be removed



    
1547     function __Context_init_unchained() internal onlyInitializing {
1548     }



```

```
Math.max(uint256,uint256) (PermissionlessPool.sol#856-858) is never used and should be removed



    
856     function max(uint256 a, uint256 b) internal pure returns (uint256) {
857         return a >= b ? a : b;
858     }



```

```
ERC165Upgradeable.__ERC165_init_unchained() (PermissionlessPool.sol#2017-2018) is never used and should be removed



    
2017     function __ERC165_init_unchained() internal onlyInitializing {
2018     }



```

```
Math.average(uint256,uint256) (PermissionlessPool.sol#871-874) is never used and should be removed



    
871     function average(uint256 a, uint256 b) internal pure returns (uint256) {
872         // (a + b) / 2 can overflow.
873         return (a & b) + (a ^ b) / 2;
874     }



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (PermissionlessPool.sol#570-580) is never used and should be removed



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)
571         internal
572         view
573         returns (bool)
574     {
575         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getValidatorPoolId(_pubkey);
576         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
577         uint256 validatorId = INodeRegistry(nodeRegistry).validatorIdByPubkey(_pubkey);
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);
579         return IVaultProxy(withdrawVaultAddress).vaultSettleStatus();
580     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PermissionlessPool.sol#1618-1698) is never used and should be removed



    
1618     function mulDiv(
1619         uint256 x,
1620         uint256 y,
1621         uint256 denominator
1622     ) internal pure returns (uint256 result) {
1623         unchecked {
1624             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
1625             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
1626             // variables such that product = prod1 * 2^256 + prod0.
1627             uint256 prod0; // Least significant 256 bits of the product
1628             uint256 prod1; // Most significant 256 bits of the product
1629             assembly {
1630                 let mm := mulmod(x, y, not(0))
1631                 prod0 := mul(x, y)
1632                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1633             }
1634 
1635             // Handle non-overflow cases, 256 by 256 division.
1636             if (prod1 == 0) {
1637                 return prod0 / denominator;
1638             }
1639 
1640             // Make sure the result is less than 2^256. Also prevents denominator == 0.
1641             require(denominator > prod1);
1642 
1643             ///////////////////////////////////////////////
1644             // 512 by 256 division.
1645             ///////////////////////////////////////////////
1646 
1647             // Make division exact by subtracting the remainder from [prod1 prod0].
1648             uint256 remainder;
1649             assembly {
1650                 // Compute remainder using mulmod.
1651                 remainder := mulmod(x, y, denominator)
1652 
1653                 // Subtract 256 bit number from 512 bit number.
1654                 prod1 := sub(prod1, gt(remainder, prod0))
1655                 prod0 := sub(prod0, remainder)
1656             }
1657 
1658             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
1659             // See https://cs.stackexchange.com/q/138556/92363.
1660 
1661             // Does not overflow because the denominator cannot be zero at this stage in the function.
1662             uint256 twos = denominator & (~denominator + 1);
1663             assembly {
1664                 // Divide denominator by twos.
1665                 denominator := div(denominator, twos)
1666 
1667                 // Divide [prod1 prod0] by twos.
1668                 prod0 := div(prod0, twos)
1669 
1670                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1671                 twos := add(div(sub(0, twos), twos), 1)
1672             }
1673 
1674             // Shift in bits from prod1 into prod0.
1675             prod0 |= prod1 * twos;
1676 
1677             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
1678             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
1679             // four bits. That is, denominator * inv = 1 mod 2^4.
1680             uint256 inverse = (3 * denominator) ^ 2;
1681 
1682             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
1683             // in modular arithmetic, doubling the correct bits in each step.
1684             inverse *= 2 - denominator * inverse; // inverse mod 2^8
1685             inverse *= 2 - denominator * inverse; // inverse mod 2^16
1686             inverse *= 2 - denominator * inverse; // inverse mod 2^32
1687             inverse *= 2 - denominator * inverse; // inverse mod 2^64
1688             inverse *= 2 - denominator * inverse; // inverse mod 2^128
1689             inverse *= 2 - denominator * inverse; // inverse mod 2^256
1690 
1691             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
1692             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
1693             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
1694             // is no longer required.
1695             result = prod0 * inverse;
1696             return result;
1697         }
1698     }



```

```
AddressUpgradeable.functionCall(address,bytes,string) (PermissionlessPool.sol#1248-1254) is never used and should be removed



    
1248     function functionCall(
1249         address target,
1250         bytes memory data,
1251         string memory errorMessage
1252     ) internal returns (bytes memory) {
1253         return functionCallWithValue(target, data, 0, errorMessage);
1254     }



```

```
AddressUpgradeable.sendValue(address,uint256) (PermissionlessPool.sol#1213-1218) is never used and should be removed



    
1213     function sendValue(address payable recipient, uint256 amount) internal {
1214         require(address(this).balance >= amount, "Address: insufficient balance");
1215 
1216         (bool success, ) = recipient.call{value: amount}("");
1217         require(success, "Address: unable to send value, recipient may have reverted");
1218     }



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (PermissionlessPool.sol#534-543) is never used and should be removed



    
534     function getOperatorAddressByOperatorId(
535         uint8 _poolId,
536         uint256 _operatorId,
537         IStaderConfig _staderConfig
538     ) internal view returns (address) {
539         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);
541 
542         return operatorAddress;
543     }



```

```
Math.sqrt(uint256) (PermissionlessPool.sol#995-1051) is never used and should be removed



    
995     function sqrt(uint256 a) internal pure returns (uint256) {
996         if (a == 0) {
997             return 0;
998         }
999 
1000         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
1001         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
1002         // `msb(a) <= a < 2*msb(a)`.
1003         // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.
1004         // This gives `2**k < a <= 2**(k+1)` → `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.
1005         // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a
1006         // good first aproximation of `sqrt(a)` with at least 1 correct bit.
1007         uint256 result = 1;
1008         uint256 x = a;
1009         if (x >> 128 > 0) {
1010             x >>= 128;
1011             result <<= 64;
1012         }
1013         if (x >> 64 > 0) {
1014             x >>= 64;
1015             result <<= 32;
1016         }
1017         if (x >> 32 > 0) {
1018             x >>= 32;
1019             result <<= 16;
1020         }
1021         if (x >> 16 > 0) {
1022             x >>= 16;
1023             result <<= 8;
1024         }
1025         if (x >> 8 > 0) {
1026             x >>= 8;
1027             result <<= 4;
1028         }
1029         if (x >> 4 > 0) {
1030             x >>= 4;
1031             result <<= 2;
1032         }
1033         if (x >> 2 > 0) {
1034             result <<= 1;
1035         }
1036 
1037         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
1038         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
1039         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
1040         // into the expected uint128 result.
1041         unchecked {
1042             result = (result + a / result) >> 1;
1043             result = (result + a / result) >> 1;
1044             result = (result + a / result) >> 1;
1045             result = (result + a / result) >> 1;
1046             result = (result + a / result) >> 1;
1047             result = (result + a / result) >> 1;
1048             result = (result + a / result) >> 1;
1049             return min(result, a / result);
1050         }
1051     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes) (PermissionlessPool.sol#1298-1300) is never used and should be removed



    
1298     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
1299         return functionStaticCall(target, data, "Address: low-level static call failed");
1300     }



```

```
MathUpgradeable.sqrt(uint256,MathUpgradeable.Rounding) (PermissionlessPool.sol#1757-1762) is never used and should be removed



    
1757     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
1758         unchecked {
1759             uint256 result = sqrt(a);
1760             return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
1761         }
1762     }



```

```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (PermissionlessPool.sol#509-520) is never used and should be removed



    
509     function onlyValidatorWithdrawVault(
510         uint8 _poolId,
511         uint256 _validatorId,
512         address _addr,
513         IStaderConfig _staderConfig
514     ) internal view {
515         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
517         if (_addr != withdrawVaultAddress) {
518             revert CallerNotWithdrawVault();
519         }
520     }



```

```
MathUpgradeable.log2(uint256) (PermissionlessPool.sol#1768-1804) is never used and should be removed



    
1768     function log2(uint256 value) internal pure returns (uint256) {
1769         uint256 result = 0;
1770         unchecked {
1771             if (value >> 128 > 0) {
1772                 value >>= 128;
1773                 result += 128;
1774             }
1775             if (value >> 64 > 0) {
1776                 value >>= 64;
1777                 result += 64;
1778             }
1779             if (value >> 32 > 0) {
1780                 value >>= 32;
1781                 result += 32;
1782             }
1783             if (value >> 16 > 0) {
1784                 value >>= 16;
1785                 result += 16;
1786             }
1787             if (value >> 8 > 0) {
1788                 value >>= 8;
1789                 result += 8;
1790             }
1791             if (value >> 4 > 0) {
1792                 value >>= 4;
1793                 result += 4;
1794             }
1795             if (value >> 2 > 0) {
1796                 value >>= 2;
1797                 result += 2;
1798             }
1799             if (value >> 1 > 0) {
1800                 result += 1;
1801             }
1802         }
1803         return result;
1804     }



```

```
UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig) (PermissionlessPool.sol#582-592) is never used and should be removed



    
582     function computeExchangeRate(
583         uint256 totalETHBalance,
584         uint256 totalETHXSupply,
585         IStaderConfig _staderConfig
586     ) internal view returns (uint256) {
587         uint256 DECIMALS = _staderConfig.getDecimals();
588         uint256 newExchangeRate = (totalETHBalance == 0 || totalETHXSupply == 0)
589             ? DECIMALS
590             : (totalETHBalance * DECIMALS) / totalETHXSupply;
591         return newExchangeRate;
592     }



```

```
AccessControlUpgradeable._setRoleAdmin(bytes32,bytes32) (PermissionlessPool.sol#2242-2246) is never used and should be removed



    
2242     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
2243         bytes32 previousAdminRole = getRoleAdmin(role);
2244         _roles[role].adminRole = adminRole;
2245         emit RoleAdminChanged(role, previousAdminRole, adminRole);
2246     }



```

```
MathUpgradeable.average(uint256,uint256) (PermissionlessPool.sol#1597-1600) is never used and should be removed



    
1597     function average(uint256 a, uint256 b) internal pure returns (uint256) {
1598         // (a + b) / 2 can overflow.
1599         return (a & b) + (a ^ b) / 2;
1600     }



```

```
StringsUpgradeable.toHexString(uint256) (PermissionlessPool.sol#1945-1949) is never used and should be removed



    
1945     function toHexString(uint256 value) internal pure returns (string memory) {
1946         unchecked {
1947             return toHexString(value, MathUpgradeable.log256(value) + 1);
1948         }
1949     }



```

```
MathUpgradeable.log10(uint256) (PermissionlessPool.sol#1821-1853) is never used and should be removed



    
1821     function log10(uint256 value) internal pure returns (uint256) {
1822         uint256 result = 0;
1823         unchecked {
1824             if (value >= 10**64) {
1825                 value /= 10**64;
1826                 result += 64;
1827             }
1828             if (value >= 10**32) {
1829                 value /= 10**32;
1830                 result += 32;
1831             }
1832             if (value >= 10**16) {
1833                 value /= 10**16;
1834                 result += 16;
1835             }
1836             if (value >= 10**8) {
1837                 value /= 10**8;
1838                 result += 8;
1839             }
1840             if (value >= 10**4) {
1841                 value /= 10**4;
1842                 result += 4;
1843             }
1844             if (value >= 10**2) {
1845                 value /= 10**2;
1846                 result += 2;
1847             }
1848             if (value >= 10**1) {
1849                 result += 1;
1850             }
1851         }
1852         return result;
1853     }



```

```
ERC165Upgradeable.__ERC165_init() (PermissionlessPool.sol#2014-2015) is never used and should be removed



    
2014     function __ERC165_init() internal onlyInitializing {
2015     }



```

```
Math.mulDiv(uint256,uint256,uint256,Math.Rounding) (PermissionlessPool.sol#977-988) is never used and should be removed



    
977     function mulDiv(
978         uint256 x,
979         uint256 y,
980         uint256 denominator,
981         Rounding rounding
982     ) internal pure returns (uint256) {
983         uint256 result = mulDiv(x, y, denominator);
984         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
985             result += 1;
986         }
987         return result;
988     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256,MathUpgradeable.Rounding) (PermissionlessPool.sol#1703-1714) is never used and should be removed



    
1703     function mulDiv(
1704         uint256 x,
1705         uint256 y,
1706         uint256 denominator,
1707         Rounding rounding
1708     ) internal pure returns (uint256) {
1709         uint256 result = mulDiv(x, y, denominator);
1710         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
1711             result += 1;
1712         }
1713         return result;
1714     }



```

```
AddressUpgradeable.verifyCallResult(bool,bytes,string) (PermissionlessPool.sol#1347-1357) is never used and should be removed



    
1347     function verifyCallResult(
1348         bool success,
1349         bytes memory returndata,
1350         string memory errorMessage
1351     ) internal pure returns (bytes memory) {
1352         if (success) {
1353             return returndata;
1354         } else {
1355             _revert(returndata, errorMessage);
1356         }
1357     }



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (PermissionlessPool.sol#476-490) is never used and should be removed



    
476     function getPubkeyForValidSender(
477         uint8 _poolId,
478         uint256 _validatorId,
479         address _addr,
480         IStaderConfig _staderConfig
481     ) internal view returns (bytes memory) {
482         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );
486         if (_addr != withdrawVaultAddress) {
487             revert CallerNotWithdrawVault();
488         }
489         return pubkey;
490     }



```

```
AddressUpgradeable._revert(bytes,string) (PermissionlessPool.sol#1359-1371) is never used and should be removed



    
1359     function _revert(bytes memory returndata, string memory errorMessage) private pure {
1360         // Look for revert reason and bubble it up if present
1361         if (returndata.length > 0) {
1362             // The easiest way to bubble the revert reason is using memory via assembly
1363             /// @solidity memory-safe-assembly
1364             assembly {
1365                 let returndata_size := mload(returndata)
1366                 revert(add(32, returndata), returndata_size)
1367             }
1368         } else {
1369             revert(errorMessage);
1370         }
1371     }



```

```
Initializable._getInitializedVersion() (PermissionlessPool.sol#1521-1523) is never used and should be removed



    
1521     function _getInitializedVersion() internal view returns (uint8) {
1522         return _initialized;
1523     }



```

```
AccessControlUpgradeable._setupRole(bytes32,address) (PermissionlessPool.sol#2233-2235) is never used and should be removed



    
2233     function _setupRole(bytes32 role, address account) internal virtual {
2234         _grantRole(role, account);
2235     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes,string) (PermissionlessPool.sol#1308-1315) is never used and should be removed



    
1308     function functionStaticCall(
1309         address target,
1310         bytes memory data,
1311         string memory errorMessage
1312     ) internal view returns (bytes memory) {
1313         (bool success, bytes memory returndata) = target.staticcall(data);
1314         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
1315     }



```

```
Math.min(uint256,uint256) (PermissionlessPool.sol#863-865) is never used and should be removed



    
863     function min(uint256 a, uint256 b) internal pure returns (uint256) {
864         return a < b ? a : b;
865     }



```

```
MathUpgradeable.log256(uint256,MathUpgradeable.Rounding) (PermissionlessPool.sol#1902-1907) is never used and should be removed



    
1902     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
1903         unchecked {
1904             uint256 result = log256(value);
1905             return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);
1906         }
1907     }



```

```
UtilLib.onlyOperatorRole(address,IStaderConfig) (PermissionlessPool.sol#459-463) is never used and should be removed



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {
460         if (!_staderConfig.onlyOperatorRole(_addr)) {
461             revert CallerNotOperator();
462         }
463     }



```

```
UtilLib.sendValue(address,uint256) (PermissionlessPool.sol#594-599) is never used and should be removed



    
594     function sendValue(address _receiver, uint256 _amount) internal {
595         (bool success, ) = payable(_receiver).call{value: _amount}('');
596         if (!success) {
597             revert TransferFailed();
598         }
599     }



```

```
MathUpgradeable.max(uint256,uint256) (PermissionlessPool.sol#1582-1584) is never used and should be removed



    
1582     function max(uint256 a, uint256 b) internal pure returns (uint256) {
1583         return a > b ? a : b;
1584     }



```

```
ContextUpgradeable.__Context_init() (PermissionlessPool.sol#1544-1545) is never used and should be removed



    
1544     function __Context_init() internal onlyInitializing {
1545     }



```

```
UtilLib.getOperatorRewardAddress(address,IStaderConfig) (PermissionlessPool.sol#545-554) is never used and should be removed



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)
546         internal
547         view
548         returns (address payable)
549     {
550         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getOperatorPoolId(_operator);
551         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
552         uint256 operatorId = INodeRegistry(nodeRegistry).operatorIDByAddress(_operator);
553         return INodeRegistry(nodeRegistry).getOperatorRewardAddress(operatorId);
554     }



```

```
AddressUpgradeable.verifyCallResultFromTarget(address,bool,bytes,string) (PermissionlessPool.sol#1323-1339) is never used and should be removed



    
1323     function verifyCallResultFromTarget(
1324         address target,
1325         bool success,
1326         bytes memory returndata,
1327         string memory errorMessage
1328     ) internal view returns (bytes memory) {
1329         if (success) {
1330             if (returndata.length == 0) {
1331                 // only check isContract if the call was successful and the return data is empty
1332                 // otherwise we already know that it was a contract
1333                 require(isContract(target), "Address: call to non-contract");
1334             }
1335             return returndata;
1336         } else {
1337             _revert(returndata, errorMessage);
1338         }
1339     }



```

```
MathUpgradeable.log256(uint256) (PermissionlessPool.sol#1872-1896) is never used and should be removed



    
1872     function log256(uint256 value) internal pure returns (uint256) {
1873         uint256 result = 0;
1874         unchecked {
1875             if (value >> 128 > 0) {
1876                 value >>= 128;
1877                 result += 16;
1878             }
1879             if (value >> 64 > 0) {
1880                 value >>= 64;
1881                 result += 8;
1882             }
1883             if (value >> 32 > 0) {
1884                 value >>= 32;
1885                 result += 4;
1886             }
1887             if (value >> 16 > 0) {
1888                 value >>= 16;
1889                 result += 2;
1890             }
1891             if (value >> 8 > 0) {
1892                 result += 1;
1893             }
1894         }
1895         return result;
1896     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (PermissionlessPool.sol#1281-1290) is never used and should be removed



    
1281     function functionCallWithValue(
1282         address target,
1283         bytes memory data,
1284         uint256 value,
1285         string memory errorMessage
1286     ) internal returns (bytes memory) {
1287         require(address(this).balance >= value, "Address: insufficient balance for call");
1288         (bool success, bytes memory returndata) = target.call{value: value}(data);
1289         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
1290     }



```

### PoolSelector.sol


```
StringsUpgradeable.toString(uint256) (PoolSelector.sol#1928-1948) is never used and should be removed



    
1928     function toString(uint256 value) internal pure returns (string memory) {
1929         unchecked {
1930             uint256 length = MathUpgradeable.log10(value) + 1;
1931             string memory buffer = new string(length);
1932             uint256 ptr;
1933             /// @solidity memory-safe-assembly
1934             assembly {
1935                 ptr := add(buffer, add(32, length))
1936             }
1937             while (true) {
1938                 ptr--;
1939                 /// @solidity memory-safe-assembly
1940                 assembly {
1941                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
1942                 }
1943                 value /= 10;
1944                 if (value == 0) break;
1945             }
1946             return buffer;
1947         }
1948     }



```

```
SafeMath.mul(uint256,uint256) (PoolSelector.sol#965-967) is never used and should be removed



    
965     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
966         return a * b;
967     }



```

```
ContextUpgradeable._msgData() (PoolSelector.sol#1561-1563) is never used and should be removed



    
1561     function _msgData() internal view virtual returns (bytes calldata) {
1562         return msg.data;
1563     }



```

```
MathUpgradeable.log2(uint256,MathUpgradeable.Rounding) (PoolSelector.sol#1818-1823) is never used and should be removed



    
1818     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
1819         unchecked {
1820             uint256 result = log2(value);
1821             return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
1822         }
1823     }



```

```
Initializable._isInitializing() (PoolSelector.sol#1536-1538) is never used and should be removed



    
1536     function _isInitializing() internal view returns (bool) {
1537         return _initializing;
1538     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256) (PoolSelector.sol#1275-1281) is never used and should be removed



    
1275     function functionCallWithValue(
1276         address target,
1277         bytes memory data,
1278         uint256 value
1279     ) internal returns (bytes memory) {
1280         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
1281     }



```

```
SafeMath.sub(uint256,uint256) (PoolSelector.sol#951-953) is never used and should be removed



    
951     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
952         return a - b;
953     }



```

```
MathUpgradeable.ceilDiv(uint256,uint256) (PoolSelector.sol#1616-1619) is never used and should be removed



    
1616     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
1617         // (a + b - 1) / b can overflow on addition, so we distribute.
1618         return a == 0 ? 0 : (a - 1) / b + 1;
1619     }



```

```
SafeMath.tryDiv(uint256,uint256) (PoolSelector.sol#908-913) is never used and should be removed



    
908     function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
909         unchecked {
910             if (b == 0) return (false, 0);
911             return (true, a / b);
912         }
913     }



```

```
MathUpgradeable.min(uint256,uint256) (PoolSelector.sol#1597-1599) is never used and should be removed



    
1597     function min(uint256 a, uint256 b) internal pure returns (uint256) {
1598         return a < b ? a : b;
1599     }



```

```
MathUpgradeable.sqrt(uint256) (PoolSelector.sol#1729-1760) is never used and should be removed



    
1729     function sqrt(uint256 a) internal pure returns (uint256) {
1730         if (a == 0) {
1731             return 0;
1732         }
1733 
1734         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
1735         //
1736         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
1737         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
1738         //
1739         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
1740         // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
1741         // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
1742         //
1743         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
1744         uint256 result = 1 << (log2(a) >> 1);
1745 
1746         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
1747         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
1748         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
1749         // into the expected uint128 result.
1750         unchecked {
1751             result = (result + a / result) >> 1;
1752             result = (result + a / result) >> 1;
1753             result = (result + a / result) >> 1;
1754             result = (result + a / result) >> 1;
1755             result = (result + a / result) >> 1;
1756             result = (result + a / result) >> 1;
1757             result = (result + a / result) >> 1;
1758             return min(result, a / result);
1759         }
1760     }



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (PoolSelector.sol#522-532) is never used and should be removed



    
522     function getOperatorAddressByValidatorId(
523         uint8 _poolId,
524         uint256 _validatorId,
525         IStaderConfig _staderConfig
526     ) internal view returns (address) {
527         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
530 
531         return operatorAddress;
532     }



```

```
Math.ceilDiv(uint256,uint256) (PoolSelector.sol#665-668) is never used and should be removed



    
665     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
666         // (a + b - 1) / b can overflow on addition, so we distribute.
667         return a == 0 ? 0 : (a - 1) / b + 1;
668     }



```

```
UtilLib.getPubkeyRoot(bytes) (PoolSelector.sol#561-568) is never used and should be removed



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {
562         if (_pubkey.length != VALIDATOR_PUBKEY_LENGTH) {
563             revert InvalidPubkeyLength();
564         }
565 
566         // Append 16 bytes of zero padding to the pubkey and compute its hash to get the pubkey root.
567         return sha256(abi.encodePacked(_pubkey, bytes16(0)));
568     }



```

```
SafeMath.add(uint256,uint256) (PoolSelector.sol#937-939) is never used and should be removed



    
937     function add(uint256 a, uint256 b) internal pure returns (uint256) {
938         return a + b;
939     }



```

```
AccessControlUpgradeable.__AccessControl_init() (PoolSelector.sol#2081-2082) is never used and should be removed



    
2081     function __AccessControl_init() internal onlyInitializing {
2082     }



```

```
SafeMath.tryMod(uint256,uint256) (PoolSelector.sol#920-925) is never used and should be removed



    
920     function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
921         unchecked {
922             if (b == 0) return (false, 0);
923             return (true, a % b);
924         }
925     }



```

```
Math.mulDiv(uint256,uint256,uint256) (PoolSelector.sol#675-755) is never used and should be removed



    
675     function mulDiv(
676         uint256 x,
677         uint256 y,
678         uint256 denominator
679     ) internal pure returns (uint256 result) {
680         unchecked {
681             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
682             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
683             // variables such that product = prod1 * 2^256 + prod0.
684             uint256 prod0; // Least significant 256 bits of the product
685             uint256 prod1; // Most significant 256 bits of the product
686             assembly {
687                 let mm := mulmod(x, y, not(0))
688                 prod0 := mul(x, y)
689                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
690             }
691 
692             // Handle non-overflow cases, 256 by 256 division.
693             if (prod1 == 0) {
694                 return prod0 / denominator;
695             }
696 
697             // Make sure the result is less than 2^256. Also prevents denominator == 0.
698             require(denominator > prod1);
699 
700             ///////////////////////////////////////////////
701             // 512 by 256 division.
702             ///////////////////////////////////////////////
703 
704             // Make division exact by subtracting the remainder from [prod1 prod0].
705             uint256 remainder;
706             assembly {
707                 // Compute remainder using mulmod.
708                 remainder := mulmod(x, y, denominator)
709 
710                 // Subtract 256 bit number from 512 bit number.
711                 prod1 := sub(prod1, gt(remainder, prod0))
712                 prod0 := sub(prod0, remainder)
713             }
714 
715             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
716             // See https://cs.stackexchange.com/q/138556/92363.
717 
718             // Does not overflow because the denominator cannot be zero at this stage in the function.
719             uint256 twos = denominator & (~denominator + 1);
720             assembly {
721                 // Divide denominator by twos.
722                 denominator := div(denominator, twos)
723 
724                 // Divide [prod1 prod0] by twos.
725                 prod0 := div(prod0, twos)
726 
727                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
728                 twos := add(div(sub(0, twos), twos), 1)
729             }
730 
731             // Shift in bits from prod1 into prod0.
732             prod0 |= prod1 * twos;
733 
734             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
735             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
736             // four bits. That is, denominator * inv = 1 mod 2^4.
737             uint256 inverse = (3 * denominator) ^ 2;
738 
739             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
740             // in modular arithmetic, doubling the correct bits in each step.
741             inverse *= 2 - denominator * inverse; // inverse mod 2^8
742             inverse *= 2 - denominator * inverse; // inverse mod 2^16
743             inverse *= 2 - denominator * inverse; // inverse mod 2^32
744             inverse *= 2 - denominator * inverse; // inverse mod 2^64
745             inverse *= 2 - denominator * inverse; // inverse mod 2^128
746             inverse *= 2 - denominator * inverse; // inverse mod 2^256
747 
748             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
749             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
750             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
751             // is no longer required.
752             result = prod0 * inverse;
753             return result;
754         }
755     }



```

```
SafeMath.sub(uint256,uint256,string) (PoolSelector.sol#1012-1021) is never used and should be removed



    
1012     function sub(
1013         uint256 a,
1014         uint256 b,
1015         string memory errorMessage
1016     ) internal pure returns (uint256) {
1017         unchecked {
1018             require(b <= a, errorMessage);
1019             return a - b;
1020         }
1021     }



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (PoolSelector.sol#492-507) is never used and should be removed



    
492     function getOperatorForValidSender(
493         uint8 _poolId,
494         uint256 _validatorId,
495         address _addr,
496         IStaderConfig _staderConfig
497     ) internal view returns (address) {
498         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );
502         if (_addr != withdrawVaultAddress) {
503             revert CallerNotWithdrawVault();
504         }
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
506         return operator;
507     }



```

```
MathUpgradeable.log10(uint256,MathUpgradeable.Rounding) (PoolSelector.sol#1867-1872) is never used and should be removed



    
1867     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
1868         unchecked {
1869             uint256 result = log10(value);
1870             return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);
1871         }
1872     }



```

```
AddressUpgradeable.functionCall(address,bytes) (PoolSelector.sol#1246-1248) is never used and should be removed



    
1246     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
1247         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
1248     }



```

```
Math.sqrt(uint256,Math.Rounding) (PoolSelector.sol#839-845) is never used and should be removed



    
839     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
840         uint256 result = sqrt(a);
841         if (rounding == Rounding.Up && result * result < a) {
842             result += 1;
843         }
844         return result;
845     }



```

```
ContextUpgradeable.__Context_init_unchained() (PoolSelector.sol#1555-1556) is never used and should be removed



    
1555     function __Context_init_unchained() internal onlyInitializing {
1556     }



```

```
Math.max(uint256,uint256) (PoolSelector.sol#639-641) is never used and should be removed



    
639     function max(uint256 a, uint256 b) internal pure returns (uint256) {
640         return a >= b ? a : b;
641     }



```

```
ERC165Upgradeable.__ERC165_init_unchained() (PoolSelector.sol#2025-2026) is never used and should be removed



    
2025     function __ERC165_init_unchained() internal onlyInitializing {
2026     }



```

```
Math.average(uint256,uint256) (PoolSelector.sol#654-657) is never used and should be removed



    
654     function average(uint256 a, uint256 b) internal pure returns (uint256) {
655         // (a + b) / 2 can overflow.
656         return (a & b) + (a ^ b) / 2;
657     }



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (PoolSelector.sol#570-580) is never used and should be removed



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)
571         internal
572         view
573         returns (bool)
574     {
575         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getValidatorPoolId(_pubkey);
576         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
577         uint256 validatorId = INodeRegistry(nodeRegistry).validatorIdByPubkey(_pubkey);
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);
579         return IVaultProxy(withdrawVaultAddress).vaultSettleStatus();
580     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PoolSelector.sol#1626-1706) is never used and should be removed



    
1626     function mulDiv(
1627         uint256 x,
1628         uint256 y,
1629         uint256 denominator
1630     ) internal pure returns (uint256 result) {
1631         unchecked {
1632             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
1633             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
1634             // variables such that product = prod1 * 2^256 + prod0.
1635             uint256 prod0; // Least significant 256 bits of the product
1636             uint256 prod1; // Most significant 256 bits of the product
1637             assembly {
1638                 let mm := mulmod(x, y, not(0))
1639                 prod0 := mul(x, y)
1640                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1641             }
1642 
1643             // Handle non-overflow cases, 256 by 256 division.
1644             if (prod1 == 0) {
1645                 return prod0 / denominator;
1646             }
1647 
1648             // Make sure the result is less than 2^256. Also prevents denominator == 0.
1649             require(denominator > prod1);
1650 
1651             ///////////////////////////////////////////////
1652             // 512 by 256 division.
1653             ///////////////////////////////////////////////
1654 
1655             // Make division exact by subtracting the remainder from [prod1 prod0].
1656             uint256 remainder;
1657             assembly {
1658                 // Compute remainder using mulmod.
1659                 remainder := mulmod(x, y, denominator)
1660 
1661                 // Subtract 256 bit number from 512 bit number.
1662                 prod1 := sub(prod1, gt(remainder, prod0))
1663                 prod0 := sub(prod0, remainder)
1664             }
1665 
1666             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
1667             // See https://cs.stackexchange.com/q/138556/92363.
1668 
1669             // Does not overflow because the denominator cannot be zero at this stage in the function.
1670             uint256 twos = denominator & (~denominator + 1);
1671             assembly {
1672                 // Divide denominator by twos.
1673                 denominator := div(denominator, twos)
1674 
1675                 // Divide [prod1 prod0] by twos.
1676                 prod0 := div(prod0, twos)
1677 
1678                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1679                 twos := add(div(sub(0, twos), twos), 1)
1680             }
1681 
1682             // Shift in bits from prod1 into prod0.
1683             prod0 |= prod1 * twos;
1684 
1685             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
1686             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
1687             // four bits. That is, denominator * inv = 1 mod 2^4.
1688             uint256 inverse = (3 * denominator) ^ 2;
1689 
1690             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
1691             // in modular arithmetic, doubling the correct bits in each step.
1692             inverse *= 2 - denominator * inverse; // inverse mod 2^8
1693             inverse *= 2 - denominator * inverse; // inverse mod 2^16
1694             inverse *= 2 - denominator * inverse; // inverse mod 2^32
1695             inverse *= 2 - denominator * inverse; // inverse mod 2^64
1696             inverse *= 2 - denominator * inverse; // inverse mod 2^128
1697             inverse *= 2 - denominator * inverse; // inverse mod 2^256
1698 
1699             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
1700             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
1701             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
1702             // is no longer required.
1703             result = prod0 * inverse;
1704             return result;
1705         }
1706     }



```

```
AddressUpgradeable.functionCall(address,bytes,string) (PoolSelector.sol#1256-1262) is never used and should be removed



    
1256     function functionCall(
1257         address target,
1258         bytes memory data,
1259         string memory errorMessage
1260     ) internal returns (bytes memory) {
1261         return functionCallWithValue(target, data, 0, errorMessage);
1262     }



```

```
AddressUpgradeable.sendValue(address,uint256) (PoolSelector.sol#1221-1226) is never used and should be removed



    
1221     function sendValue(address payable recipient, uint256 amount) internal {
1222         require(address(this).balance >= amount, "Address: insufficient balance");
1223 
1224         (bool success, ) = recipient.call{value: amount}("");
1225         require(success, "Address: unable to send value, recipient may have reverted");
1226     }



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (PoolSelector.sol#534-543) is never used and should be removed



    
534     function getOperatorAddressByOperatorId(
535         uint8 _poolId,
536         uint256 _operatorId,
537         IStaderConfig _staderConfig
538     ) internal view returns (address) {
539         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);
541 
542         return operatorAddress;
543     }



```

```
SafeMath.tryAdd(uint256,uint256) (PoolSelector.sol#866-872) is never used and should be removed



    
866     function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
867         unchecked {
868             uint256 c = a + b;
869             if (c < a) return (false, 0);
870             return (true, c);
871         }
872     }



```

```
SafeMath.mod(uint256,uint256,string) (PoolSelector.sol#1061-1070) is never used and should be removed



    
1061     function mod(
1062         uint256 a,
1063         uint256 b,
1064         string memory errorMessage
1065     ) internal pure returns (uint256) {
1066         unchecked {
1067             require(b > 0, errorMessage);
1068             return a % b;
1069         }
1070     }



```

```
Math.sqrt(uint256) (PoolSelector.sol#778-834) is never used and should be removed



    
778     function sqrt(uint256 a) internal pure returns (uint256) {
779         if (a == 0) {
780             return 0;
781         }
782 
783         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
784         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
785         // `msb(a) <= a < 2*msb(a)`.
786         // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.
787         // This gives `2**k < a <= 2**(k+1)` → `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.
788         // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a
789         // good first aproximation of `sqrt(a)` with at least 1 correct bit.
790         uint256 result = 1;
791         uint256 x = a;
792         if (x >> 128 > 0) {
793             x >>= 128;
794             result <<= 64;
795         }
796         if (x >> 64 > 0) {
797             x >>= 64;
798             result <<= 32;
799         }
800         if (x >> 32 > 0) {
801             x >>= 32;
802             result <<= 16;
803         }
804         if (x >> 16 > 0) {
805             x >>= 16;
806             result <<= 8;
807         }
808         if (x >> 8 > 0) {
809             x >>= 8;
810             result <<= 4;
811         }
812         if (x >> 4 > 0) {
813             x >>= 4;
814             result <<= 2;
815         }
816         if (x >> 2 > 0) {
817             result <<= 1;
818         }
819 
820         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
821         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
822         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
823         // into the expected uint128 result.
824         unchecked {
825             result = (result + a / result) >> 1;
826             result = (result + a / result) >> 1;
827             result = (result + a / result) >> 1;
828             result = (result + a / result) >> 1;
829             result = (result + a / result) >> 1;
830             result = (result + a / result) >> 1;
831             result = (result + a / result) >> 1;
832             return min(result, a / result);
833         }
834     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes) (PoolSelector.sol#1306-1308) is never used and should be removed



    
1306     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
1307         return functionStaticCall(target, data, "Address: low-level static call failed");
1308     }



```

```
MathUpgradeable.sqrt(uint256,MathUpgradeable.Rounding) (PoolSelector.sol#1765-1770) is never used and should be removed



    
1765     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
1766         unchecked {
1767             uint256 result = sqrt(a);
1768             return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
1769         }
1770     }



```

```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (PoolSelector.sol#509-520) is never used and should be removed



    
509     function onlyValidatorWithdrawVault(
510         uint8 _poolId,
511         uint256 _validatorId,
512         address _addr,
513         IStaderConfig _staderConfig
514     ) internal view {
515         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
517         if (_addr != withdrawVaultAddress) {
518             revert CallerNotWithdrawVault();
519         }
520     }



```

```
SafeMath.div(uint256,uint256,string) (PoolSelector.sol#1035-1044) is never used and should be removed



    
1035     function div(
1036         uint256 a,
1037         uint256 b,
1038         string memory errorMessage
1039     ) internal pure returns (uint256) {
1040         unchecked {
1041             require(b > 0, errorMessage);
1042             return a / b;
1043         }
1044     }



```

```
MathUpgradeable.log2(uint256) (PoolSelector.sol#1776-1812) is never used and should be removed



    
1776     function log2(uint256 value) internal pure returns (uint256) {
1777         uint256 result = 0;
1778         unchecked {
1779             if (value >> 128 > 0) {
1780                 value >>= 128;
1781                 result += 128;
1782             }
1783             if (value >> 64 > 0) {
1784                 value >>= 64;
1785                 result += 64;
1786             }
1787             if (value >> 32 > 0) {
1788                 value >>= 32;
1789                 result += 32;
1790             }
1791             if (value >> 16 > 0) {
1792                 value >>= 16;
1793                 result += 16;
1794             }
1795             if (value >> 8 > 0) {
1796                 value >>= 8;
1797                 result += 8;
1798             }
1799             if (value >> 4 > 0) {
1800                 value >>= 4;
1801                 result += 4;
1802             }
1803             if (value >> 2 > 0) {
1804                 value >>= 2;
1805                 result += 2;
1806             }
1807             if (value >> 1 > 0) {
1808                 result += 1;
1809             }
1810         }
1811         return result;
1812     }



```

```
UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig) (PoolSelector.sol#582-592) is never used and should be removed



    
582     function computeExchangeRate(
583         uint256 totalETHBalance,
584         uint256 totalETHXSupply,
585         IStaderConfig _staderConfig
586     ) internal view returns (uint256) {
587         uint256 DECIMALS = _staderConfig.getDecimals();
588         uint256 newExchangeRate = (totalETHBalance == 0 || totalETHXSupply == 0)
589             ? DECIMALS
590             : (totalETHBalance * DECIMALS) / totalETHXSupply;
591         return newExchangeRate;
592     }



```

```
AccessControlUpgradeable._setRoleAdmin(bytes32,bytes32) (PoolSelector.sol#2250-2254) is never used and should be removed



    
2250     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
2251         bytes32 previousAdminRole = getRoleAdmin(role);
2252         _roles[role].adminRole = adminRole;
2253         emit RoleAdminChanged(role, previousAdminRole, adminRole);
2254     }



```

```
MathUpgradeable.average(uint256,uint256) (PoolSelector.sol#1605-1608) is never used and should be removed



    
1605     function average(uint256 a, uint256 b) internal pure returns (uint256) {
1606         // (a + b) / 2 can overflow.
1607         return (a & b) + (a ^ b) / 2;
1608     }



```

```
StringsUpgradeable.toHexString(uint256) (PoolSelector.sol#1953-1957) is never used and should be removed



    
1953     function toHexString(uint256 value) internal pure returns (string memory) {
1954         unchecked {
1955             return toHexString(value, MathUpgradeable.log256(value) + 1);
1956         }
1957     }



```

```
MathUpgradeable.log10(uint256) (PoolSelector.sol#1829-1861) is never used and should be removed



    
1829     function log10(uint256 value) internal pure returns (uint256) {
1830         uint256 result = 0;
1831         unchecked {
1832             if (value >= 10**64) {
1833                 value /= 10**64;
1834                 result += 64;
1835             }
1836             if (value >= 10**32) {
1837                 value /= 10**32;
1838                 result += 32;
1839             }
1840             if (value >= 10**16) {
1841                 value /= 10**16;
1842                 result += 16;
1843             }
1844             if (value >= 10**8) {
1845                 value /= 10**8;
1846                 result += 8;
1847             }
1848             if (value >= 10**4) {
1849                 value /= 10**4;
1850                 result += 4;
1851             }
1852             if (value >= 10**2) {
1853                 value /= 10**2;
1854                 result += 2;
1855             }
1856             if (value >= 10**1) {
1857                 result += 1;
1858             }
1859         }
1860         return result;
1861     }



```

```
ERC165Upgradeable.__ERC165_init() (PoolSelector.sol#2022-2023) is never used and should be removed



    
2022     function __ERC165_init() internal onlyInitializing {
2023     }



```

```
Math.mulDiv(uint256,uint256,uint256,Math.Rounding) (PoolSelector.sol#760-771) is never used and should be removed



    
760     function mulDiv(
761         uint256 x,
762         uint256 y,
763         uint256 denominator,
764         Rounding rounding
765     ) internal pure returns (uint256) {
766         uint256 result = mulDiv(x, y, denominator);
767         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
768             result += 1;
769         }
770         return result;
771     }



```

```
SafeMath.mod(uint256,uint256) (PoolSelector.sol#995-997) is never used and should be removed



    
995     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
996         return a % b;
997     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256,MathUpgradeable.Rounding) (PoolSelector.sol#1711-1722) is never used and should be removed



    
1711     function mulDiv(
1712         uint256 x,
1713         uint256 y,
1714         uint256 denominator,
1715         Rounding rounding
1716     ) internal pure returns (uint256) {
1717         uint256 result = mulDiv(x, y, denominator);
1718         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
1719             result += 1;
1720         }
1721         return result;
1722     }



```

```
SafeMath.div(uint256,uint256) (PoolSelector.sol#979-981) is never used and should be removed



    
979     function div(uint256 a, uint256 b) internal pure returns (uint256) {
980         return a / b;
981     }



```

```
AddressUpgradeable.verifyCallResult(bool,bytes,string) (PoolSelector.sol#1355-1365) is never used and should be removed



    
1355     function verifyCallResult(
1356         bool success,
1357         bytes memory returndata,
1358         string memory errorMessage
1359     ) internal pure returns (bytes memory) {
1360         if (success) {
1361             return returndata;
1362         } else {
1363             _revert(returndata, errorMessage);
1364         }
1365     }



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (PoolSelector.sol#476-490) is never used and should be removed



    
476     function getPubkeyForValidSender(
477         uint8 _poolId,
478         uint256 _validatorId,
479         address _addr,
480         IStaderConfig _staderConfig
481     ) internal view returns (bytes memory) {
482         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );
486         if (_addr != withdrawVaultAddress) {
487             revert CallerNotWithdrawVault();
488         }
489         return pubkey;
490     }



```

```
SafeMath.tryMul(uint256,uint256) (PoolSelector.sol#891-901) is never used and should be removed



    
891     function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
892         unchecked {
893             // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
894             // benefit is lost if 'b' is also tested.
895             // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
896             if (a == 0) return (true, 0);
897             uint256 c = a * b;
898             if (c / a != b) return (false, 0);
899             return (true, c);
900         }
901     }



```

```
AddressUpgradeable._revert(bytes,string) (PoolSelector.sol#1367-1379) is never used and should be removed



    
1367     function _revert(bytes memory returndata, string memory errorMessage) private pure {
1368         // Look for revert reason and bubble it up if present
1369         if (returndata.length > 0) {
1370             // The easiest way to bubble the revert reason is using memory via assembly
1371             /// @solidity memory-safe-assembly
1372             assembly {
1373                 let returndata_size := mload(returndata)
1374                 revert(add(32, returndata), returndata_size)
1375             }
1376         } else {
1377             revert(errorMessage);
1378         }
1379     }



```

```
Initializable._getInitializedVersion() (PoolSelector.sol#1529-1531) is never used and should be removed



    
1529     function _getInitializedVersion() internal view returns (uint8) {
1530         return _initialized;
1531     }



```

```
AccessControlUpgradeable._setupRole(bytes32,address) (PoolSelector.sol#2241-2243) is never used and should be removed



    
2241     function _setupRole(bytes32 role, address account) internal virtual {
2242         _grantRole(role, account);
2243     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes,string) (PoolSelector.sol#1316-1323) is never used and should be removed



    
1316     function functionStaticCall(
1317         address target,
1318         bytes memory data,
1319         string memory errorMessage
1320     ) internal view returns (bytes memory) {
1321         (bool success, bytes memory returndata) = target.staticcall(data);
1322         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
1323     }



```

```
MathUpgradeable.log256(uint256,MathUpgradeable.Rounding) (PoolSelector.sol#1910-1915) is never used and should be removed



    
1910     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
1911         unchecked {
1912             uint256 result = log256(value);
1913             return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);
1914         }
1915     }



```

```
UtilLib.sendValue(address,uint256) (PoolSelector.sol#594-599) is never used and should be removed



    
594     function sendValue(address _receiver, uint256 _amount) internal {
595         (bool success, ) = payable(_receiver).call{value: _amount}('');
596         if (!success) {
597             revert TransferFailed();
598         }
599     }



```

```
MathUpgradeable.max(uint256,uint256) (PoolSelector.sol#1590-1592) is never used and should be removed



    
1590     function max(uint256 a, uint256 b) internal pure returns (uint256) {
1591         return a > b ? a : b;
1592     }



```

```
ContextUpgradeable.__Context_init() (PoolSelector.sol#1552-1553) is never used and should be removed



    
1552     function __Context_init() internal onlyInitializing {
1553     }



```

```
UtilLib.getOperatorRewardAddress(address,IStaderConfig) (PoolSelector.sol#545-554) is never used and should be removed



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)
546         internal
547         view
548         returns (address payable)
549     {
550         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getOperatorPoolId(_operator);
551         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
552         uint256 operatorId = INodeRegistry(nodeRegistry).operatorIDByAddress(_operator);
553         return INodeRegistry(nodeRegistry).getOperatorRewardAddress(operatorId);
554     }



```

```
AddressUpgradeable.verifyCallResultFromTarget(address,bool,bytes,string) (PoolSelector.sol#1331-1347) is never used and should be removed



    
1331     function verifyCallResultFromTarget(
1332         address target,
1333         bool success,
1334         bytes memory returndata,
1335         string memory errorMessage
1336     ) internal view returns (bytes memory) {
1337         if (success) {
1338             if (returndata.length == 0) {
1339                 // only check isContract if the call was successful and the return data is empty
1340                 // otherwise we already know that it was a contract
1341                 require(isContract(target), "Address: call to non-contract");
1342             }
1343             return returndata;
1344         } else {
1345             _revert(returndata, errorMessage);
1346         }
1347     }



```

```
MathUpgradeable.log256(uint256) (PoolSelector.sol#1880-1904) is never used and should be removed



    
1880     function log256(uint256 value) internal pure returns (uint256) {
1881         uint256 result = 0;
1882         unchecked {
1883             if (value >> 128 > 0) {
1884                 value >>= 128;
1885                 result += 16;
1886             }
1887             if (value >> 64 > 0) {
1888                 value >>= 64;
1889                 result += 8;
1890             }
1891             if (value >> 32 > 0) {
1892                 value >>= 32;
1893                 result += 4;
1894             }
1895             if (value >> 16 > 0) {
1896                 value >>= 16;
1897                 result += 2;
1898             }
1899             if (value >> 8 > 0) {
1900                 result += 1;
1901             }
1902         }
1903         return result;
1904     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (PoolSelector.sol#1289-1298) is never used and should be removed



    
1289     function functionCallWithValue(
1290         address target,
1291         bytes memory data,
1292         uint256 value,
1293         string memory errorMessage
1294     ) internal returns (bytes memory) {
1295         require(address(this).balance >= value, "Address: insufficient balance for call");
1296         (bool success, bytes memory returndata) = target.call{value: value}(data);
1297         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
1298     }



```

### PoolUtils.sol


```
StringsUpgradeable.toString(uint256) (PoolUtils.sol#1505-1525) is never used and should be removed



    
1505     function toString(uint256 value) internal pure returns (string memory) {
1506         unchecked {
1507             uint256 length = MathUpgradeable.log10(value) + 1;
1508             string memory buffer = new string(length);
1509             uint256 ptr;
1510             /// @solidity memory-safe-assembly
1511             assembly {
1512                 ptr := add(buffer, add(32, length))
1513             }
1514             while (true) {
1515                 ptr--;
1516                 /// @solidity memory-safe-assembly
1517                 assembly {
1518                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
1519                 }
1520                 value /= 10;
1521                 if (value == 0) break;
1522             }
1523             return buffer;
1524         }
1525     }



```

```
ContextUpgradeable._msgData() (PoolUtils.sol#1138-1140) is never used and should be removed



    
1138     function _msgData() internal view virtual returns (bytes calldata) {
1139         return msg.data;
1140     }



```

```
MathUpgradeable.log2(uint256,MathUpgradeable.Rounding) (PoolUtils.sol#1395-1400) is never used and should be removed



    
1395     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
1396         unchecked {
1397             uint256 result = log2(value);
1398             return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
1399         }
1400     }



```

```
Initializable._isInitializing() (PoolUtils.sol#1113-1115) is never used and should be removed



    
1113     function _isInitializing() internal view returns (bool) {
1114         return _initializing;
1115     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256) (PoolUtils.sol#852-858) is never used and should be removed



    
852     function functionCallWithValue(
853         address target,
854         bytes memory data,
855         uint256 value
856     ) internal returns (bytes memory) {
857         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
858     }



```

```
MathUpgradeable.ceilDiv(uint256,uint256) (PoolUtils.sol#1193-1196) is never used and should be removed



    
1193     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
1194         // (a + b - 1) / b can overflow on addition, so we distribute.
1195         return a == 0 ? 0 : (a - 1) / b + 1;
1196     }



```

```
MathUpgradeable.min(uint256,uint256) (PoolUtils.sol#1174-1176) is never used and should be removed



    
1174     function min(uint256 a, uint256 b) internal pure returns (uint256) {
1175         return a < b ? a : b;
1176     }



```

```
MathUpgradeable.sqrt(uint256) (PoolUtils.sol#1306-1337) is never used and should be removed



    
1306     function sqrt(uint256 a) internal pure returns (uint256) {
1307         if (a == 0) {
1308             return 0;
1309         }
1310 
1311         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
1312         //
1313         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
1314         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
1315         //
1316         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
1317         // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
1318         // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
1319         //
1320         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
1321         uint256 result = 1 << (log2(a) >> 1);
1322 
1323         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
1324         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
1325         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
1326         // into the expected uint128 result.
1327         unchecked {
1328             result = (result + a / result) >> 1;
1329             result = (result + a / result) >> 1;
1330             result = (result + a / result) >> 1;
1331             result = (result + a / result) >> 1;
1332             result = (result + a / result) >> 1;
1333             result = (result + a / result) >> 1;
1334             result = (result + a / result) >> 1;
1335             return min(result, a / result);
1336         }
1337     }



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (PoolUtils.sol#522-532) is never used and should be removed



    
522     function getOperatorAddressByValidatorId(
523         uint8 _poolId,
524         uint256 _validatorId,
525         IStaderConfig _staderConfig
526     ) internal view returns (address) {
527         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
530 
531         return operatorAddress;
532     }



```

```
UtilLib.getPubkeyRoot(bytes) (PoolUtils.sol#561-568) is never used and should be removed



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {
562         if (_pubkey.length != VALIDATOR_PUBKEY_LENGTH) {
563             revert InvalidPubkeyLength();
564         }
565 
566         // Append 16 bytes of zero padding to the pubkey and compute its hash to get the pubkey root.
567         return sha256(abi.encodePacked(_pubkey, bytes16(0)));
568     }



```

```
AccessControlUpgradeable.__AccessControl_init() (PoolUtils.sol#1658-1659) is never used and should be removed



    
1658     function __AccessControl_init() internal onlyInitializing {
1659     }



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (PoolUtils.sol#492-507) is never used and should be removed



    
492     function getOperatorForValidSender(
493         uint8 _poolId,
494         uint256 _validatorId,
495         address _addr,
496         IStaderConfig _staderConfig
497     ) internal view returns (address) {
498         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );
502         if (_addr != withdrawVaultAddress) {
503             revert CallerNotWithdrawVault();
504         }
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
506         return operator;
507     }



```

```
MathUpgradeable.log10(uint256,MathUpgradeable.Rounding) (PoolUtils.sol#1444-1449) is never used and should be removed



    
1444     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
1445         unchecked {
1446             uint256 result = log10(value);
1447             return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);
1448         }
1449     }



```

```
AddressUpgradeable.functionCall(address,bytes) (PoolUtils.sol#823-825) is never used and should be removed



    
823     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
824         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
825     }



```

```
ContextUpgradeable.__Context_init_unchained() (PoolUtils.sol#1132-1133) is never used and should be removed



    
1132     function __Context_init_unchained() internal onlyInitializing {
1133     }



```

```
ERC165Upgradeable.__ERC165_init_unchained() (PoolUtils.sol#1602-1603) is never used and should be removed



    
1602     function __ERC165_init_unchained() internal onlyInitializing {
1603     }



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (PoolUtils.sol#570-580) is never used and should be removed



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)
571         internal
572         view
573         returns (bool)
574     {
575         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getValidatorPoolId(_pubkey);
576         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
577         uint256 validatorId = INodeRegistry(nodeRegistry).validatorIdByPubkey(_pubkey);
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);
579         return IVaultProxy(withdrawVaultAddress).vaultSettleStatus();
580     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (PoolUtils.sol#1203-1283) is never used and should be removed



    
1203     function mulDiv(
1204         uint256 x,
1205         uint256 y,
1206         uint256 denominator
1207     ) internal pure returns (uint256 result) {
1208         unchecked {
1209             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
1210             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
1211             // variables such that product = prod1 * 2^256 + prod0.
1212             uint256 prod0; // Least significant 256 bits of the product
1213             uint256 prod1; // Most significant 256 bits of the product
1214             assembly {
1215                 let mm := mulmod(x, y, not(0))
1216                 prod0 := mul(x, y)
1217                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1218             }
1219 
1220             // Handle non-overflow cases, 256 by 256 division.
1221             if (prod1 == 0) {
1222                 return prod0 / denominator;
1223             }
1224 
1225             // Make sure the result is less than 2^256. Also prevents denominator == 0.
1226             require(denominator > prod1);
1227 
1228             ///////////////////////////////////////////////
1229             // 512 by 256 division.
1230             ///////////////////////////////////////////////
1231 
1232             // Make division exact by subtracting the remainder from [prod1 prod0].
1233             uint256 remainder;
1234             assembly {
1235                 // Compute remainder using mulmod.
1236                 remainder := mulmod(x, y, denominator)
1237 
1238                 // Subtract 256 bit number from 512 bit number.
1239                 prod1 := sub(prod1, gt(remainder, prod0))
1240                 prod0 := sub(prod0, remainder)
1241             }
1242 
1243             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
1244             // See https://cs.stackexchange.com/q/138556/92363.
1245 
1246             // Does not overflow because the denominator cannot be zero at this stage in the function.
1247             uint256 twos = denominator & (~denominator + 1);
1248             assembly {
1249                 // Divide denominator by twos.
1250                 denominator := div(denominator, twos)
1251 
1252                 // Divide [prod1 prod0] by twos.
1253                 prod0 := div(prod0, twos)
1254 
1255                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1256                 twos := add(div(sub(0, twos), twos), 1)
1257             }
1258 
1259             // Shift in bits from prod1 into prod0.
1260             prod0 |= prod1 * twos;
1261 
1262             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
1263             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
1264             // four bits. That is, denominator * inv = 1 mod 2^4.
1265             uint256 inverse = (3 * denominator) ^ 2;
1266 
1267             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
1268             // in modular arithmetic, doubling the correct bits in each step.
1269             inverse *= 2 - denominator * inverse; // inverse mod 2^8
1270             inverse *= 2 - denominator * inverse; // inverse mod 2^16
1271             inverse *= 2 - denominator * inverse; // inverse mod 2^32
1272             inverse *= 2 - denominator * inverse; // inverse mod 2^64
1273             inverse *= 2 - denominator * inverse; // inverse mod 2^128
1274             inverse *= 2 - denominator * inverse; // inverse mod 2^256
1275 
1276             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
1277             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
1278             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
1279             // is no longer required.
1280             result = prod0 * inverse;
1281             return result;
1282         }
1283     }



```

```
AddressUpgradeable.functionCall(address,bytes,string) (PoolUtils.sol#833-839) is never used and should be removed



    
833     function functionCall(
834         address target,
835         bytes memory data,
836         string memory errorMessage
837     ) internal returns (bytes memory) {
838         return functionCallWithValue(target, data, 0, errorMessage);
839     }



```

```
AddressUpgradeable.sendValue(address,uint256) (PoolUtils.sol#798-803) is never used and should be removed



    
798     function sendValue(address payable recipient, uint256 amount) internal {
799         require(address(this).balance >= amount, "Address: insufficient balance");
800 
801         (bool success, ) = recipient.call{value: amount}("");
802         require(success, "Address: unable to send value, recipient may have reverted");
803     }



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (PoolUtils.sol#534-543) is never used and should be removed



    
534     function getOperatorAddressByOperatorId(
535         uint8 _poolId,
536         uint256 _operatorId,
537         IStaderConfig _staderConfig
538     ) internal view returns (address) {
539         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);
541 
542         return operatorAddress;
543     }



```

```
UtilLib.onlyStaderContract(address,IStaderConfig,bytes32) (PoolUtils.sol#466-474) is never used and should be removed



    
466     function onlyStaderContract(
467         address _addr,
468         IStaderConfig _staderConfig,
469         bytes32 _contractName
470     ) internal view {
471         if (!_staderConfig.onlyStaderContract(_addr, _contractName)) {
472             revert CallerNotStaderContract();
473         }
474     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes) (PoolUtils.sol#883-885) is never used and should be removed



    
883     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
884         return functionStaticCall(target, data, "Address: low-level static call failed");
885     }



```

```
MathUpgradeable.sqrt(uint256,MathUpgradeable.Rounding) (PoolUtils.sol#1342-1347) is never used and should be removed



    
1342     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
1343         unchecked {
1344             uint256 result = sqrt(a);
1345             return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
1346         }
1347     }



```

```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (PoolUtils.sol#509-520) is never used and should be removed



    
509     function onlyValidatorWithdrawVault(
510         uint8 _poolId,
511         uint256 _validatorId,
512         address _addr,
513         IStaderConfig _staderConfig
514     ) internal view {
515         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
517         if (_addr != withdrawVaultAddress) {
518             revert CallerNotWithdrawVault();
519         }
520     }



```

```
MathUpgradeable.log2(uint256) (PoolUtils.sol#1353-1389) is never used and should be removed



    
1353     function log2(uint256 value) internal pure returns (uint256) {
1354         uint256 result = 0;
1355         unchecked {
1356             if (value >> 128 > 0) {
1357                 value >>= 128;
1358                 result += 128;
1359             }
1360             if (value >> 64 > 0) {
1361                 value >>= 64;
1362                 result += 64;
1363             }
1364             if (value >> 32 > 0) {
1365                 value >>= 32;
1366                 result += 32;
1367             }
1368             if (value >> 16 > 0) {
1369                 value >>= 16;
1370                 result += 16;
1371             }
1372             if (value >> 8 > 0) {
1373                 value >>= 8;
1374                 result += 8;
1375             }
1376             if (value >> 4 > 0) {
1377                 value >>= 4;
1378                 result += 4;
1379             }
1380             if (value >> 2 > 0) {
1381                 value >>= 2;
1382                 result += 2;
1383             }
1384             if (value >> 1 > 0) {
1385                 result += 1;
1386             }
1387         }
1388         return result;
1389     }



```

```
UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig) (PoolUtils.sol#582-592) is never used and should be removed



    
582     function computeExchangeRate(
583         uint256 totalETHBalance,
584         uint256 totalETHXSupply,
585         IStaderConfig _staderConfig
586     ) internal view returns (uint256) {
587         uint256 DECIMALS = _staderConfig.getDecimals();
588         uint256 newExchangeRate = (totalETHBalance == 0 || totalETHXSupply == 0)
589             ? DECIMALS
590             : (totalETHBalance * DECIMALS) / totalETHXSupply;
591         return newExchangeRate;
592     }



```

```
AccessControlUpgradeable._setRoleAdmin(bytes32,bytes32) (PoolUtils.sol#1827-1831) is never used and should be removed



    
1827     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
1828         bytes32 previousAdminRole = getRoleAdmin(role);
1829         _roles[role].adminRole = adminRole;
1830         emit RoleAdminChanged(role, previousAdminRole, adminRole);
1831     }



```

```
MathUpgradeable.average(uint256,uint256) (PoolUtils.sol#1182-1185) is never used and should be removed



    
1182     function average(uint256 a, uint256 b) internal pure returns (uint256) {
1183         // (a + b) / 2 can overflow.
1184         return (a & b) + (a ^ b) / 2;
1185     }



```

```
StringsUpgradeable.toHexString(uint256) (PoolUtils.sol#1530-1534) is never used and should be removed



    
1530     function toHexString(uint256 value) internal pure returns (string memory) {
1531         unchecked {
1532             return toHexString(value, MathUpgradeable.log256(value) + 1);
1533         }
1534     }



```

```
MathUpgradeable.log10(uint256) (PoolUtils.sol#1406-1438) is never used and should be removed



    
1406     function log10(uint256 value) internal pure returns (uint256) {
1407         uint256 result = 0;
1408         unchecked {
1409             if (value >= 10**64) {
1410                 value /= 10**64;
1411                 result += 64;
1412             }
1413             if (value >= 10**32) {
1414                 value /= 10**32;
1415                 result += 32;
1416             }
1417             if (value >= 10**16) {
1418                 value /= 10**16;
1419                 result += 16;
1420             }
1421             if (value >= 10**8) {
1422                 value /= 10**8;
1423                 result += 8;
1424             }
1425             if (value >= 10**4) {
1426                 value /= 10**4;
1427                 result += 4;
1428             }
1429             if (value >= 10**2) {
1430                 value /= 10**2;
1431                 result += 2;
1432             }
1433             if (value >= 10**1) {
1434                 result += 1;
1435             }
1436         }
1437         return result;
1438     }



```

```
ERC165Upgradeable.__ERC165_init() (PoolUtils.sol#1599-1600) is never used and should be removed



    
1599     function __ERC165_init() internal onlyInitializing {
1600     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256,MathUpgradeable.Rounding) (PoolUtils.sol#1288-1299) is never used and should be removed



    
1288     function mulDiv(
1289         uint256 x,
1290         uint256 y,
1291         uint256 denominator,
1292         Rounding rounding
1293     ) internal pure returns (uint256) {
1294         uint256 result = mulDiv(x, y, denominator);
1295         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
1296             result += 1;
1297         }
1298         return result;
1299     }



```

```
AddressUpgradeable.verifyCallResult(bool,bytes,string) (PoolUtils.sol#932-942) is never used and should be removed



    
932     function verifyCallResult(
933         bool success,
934         bytes memory returndata,
935         string memory errorMessage
936     ) internal pure returns (bytes memory) {
937         if (success) {
938             return returndata;
939         } else {
940             _revert(returndata, errorMessage);
941         }
942     }



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (PoolUtils.sol#476-490) is never used and should be removed



    
476     function getPubkeyForValidSender(
477         uint8 _poolId,
478         uint256 _validatorId,
479         address _addr,
480         IStaderConfig _staderConfig
481     ) internal view returns (bytes memory) {
482         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );
486         if (_addr != withdrawVaultAddress) {
487             revert CallerNotWithdrawVault();
488         }
489         return pubkey;
490     }



```

```
AddressUpgradeable._revert(bytes,string) (PoolUtils.sol#944-956) is never used and should be removed



    
944     function _revert(bytes memory returndata, string memory errorMessage) private pure {
945         // Look for revert reason and bubble it up if present
946         if (returndata.length > 0) {
947             // The easiest way to bubble the revert reason is using memory via assembly
948             /// @solidity memory-safe-assembly
949             assembly {
950                 let returndata_size := mload(returndata)
951                 revert(add(32, returndata), returndata_size)
952             }
953         } else {
954             revert(errorMessage);
955         }
956     }



```

```
Initializable._getInitializedVersion() (PoolUtils.sol#1106-1108) is never used and should be removed



    
1106     function _getInitializedVersion() internal view returns (uint8) {
1107         return _initialized;
1108     }



```

```
AccessControlUpgradeable._setupRole(bytes32,address) (PoolUtils.sol#1818-1820) is never used and should be removed



    
1818     function _setupRole(bytes32 role, address account) internal virtual {
1819         _grantRole(role, account);
1820     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes,string) (PoolUtils.sol#893-900) is never used and should be removed



    
893     function functionStaticCall(
894         address target,
895         bytes memory data,
896         string memory errorMessage
897     ) internal view returns (bytes memory) {
898         (bool success, bytes memory returndata) = target.staticcall(data);
899         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
900     }



```

```
MathUpgradeable.log256(uint256,MathUpgradeable.Rounding) (PoolUtils.sol#1487-1492) is never used and should be removed



    
1487     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
1488         unchecked {
1489             uint256 result = log256(value);
1490             return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);
1491         }
1492     }



```

```
UtilLib.sendValue(address,uint256) (PoolUtils.sol#594-599) is never used and should be removed



    
594     function sendValue(address _receiver, uint256 _amount) internal {
595         (bool success, ) = payable(_receiver).call{value: _amount}('');
596         if (!success) {
597             revert TransferFailed();
598         }
599     }



```

```
MathUpgradeable.max(uint256,uint256) (PoolUtils.sol#1167-1169) is never used and should be removed



    
1167     function max(uint256 a, uint256 b) internal pure returns (uint256) {
1168         return a > b ? a : b;
1169     }



```

```
ContextUpgradeable.__Context_init() (PoolUtils.sol#1129-1130) is never used and should be removed



    
1129     function __Context_init() internal onlyInitializing {
1130     }



```

```
UtilLib.getOperatorRewardAddress(address,IStaderConfig) (PoolUtils.sol#545-554) is never used and should be removed



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)
546         internal
547         view
548         returns (address payable)
549     {
550         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getOperatorPoolId(_operator);
551         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
552         uint256 operatorId = INodeRegistry(nodeRegistry).operatorIDByAddress(_operator);
553         return INodeRegistry(nodeRegistry).getOperatorRewardAddress(operatorId);
554     }



```

```
AddressUpgradeable.verifyCallResultFromTarget(address,bool,bytes,string) (PoolUtils.sol#908-924) is never used and should be removed



    
908     function verifyCallResultFromTarget(
909         address target,
910         bool success,
911         bytes memory returndata,
912         string memory errorMessage
913     ) internal view returns (bytes memory) {
914         if (success) {
915             if (returndata.length == 0) {
916                 // only check isContract if the call was successful and the return data is empty
917                 // otherwise we already know that it was a contract
918                 require(isContract(target), "Address: call to non-contract");
919             }
920             return returndata;
921         } else {
922             _revert(returndata, errorMessage);
923         }
924     }



```

```
MathUpgradeable.log256(uint256) (PoolUtils.sol#1457-1481) is never used and should be removed



    
1457     function log256(uint256 value) internal pure returns (uint256) {
1458         uint256 result = 0;
1459         unchecked {
1460             if (value >> 128 > 0) {
1461                 value >>= 128;
1462                 result += 16;
1463             }
1464             if (value >> 64 > 0) {
1465                 value >>= 64;
1466                 result += 8;
1467             }
1468             if (value >> 32 > 0) {
1469                 value >>= 32;
1470                 result += 4;
1471             }
1472             if (value >> 16 > 0) {
1473                 value >>= 16;
1474                 result += 2;
1475             }
1476             if (value >> 8 > 0) {
1477                 result += 1;
1478             }
1479         }
1480         return result;
1481     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (PoolUtils.sol#866-875) is never used and should be removed



    
866     function functionCallWithValue(
867         address target,
868         bytes memory data,
869         uint256 value,
870         string memory errorMessage
871     ) internal returns (bytes memory) {
872         require(address(this).balance >= value, "Address: insufficient balance for call");
873         (bool success, bytes memory returndata) = target.call{value: value}(data);
874         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
875     }



```

### SDCollateral.sol


```
StringsUpgradeable.toString(uint256) (SDCollateral.sol#2203-2223) is never used and should be removed



    
2203     function toString(uint256 value) internal pure returns (string memory) {
2204         unchecked {
2205             uint256 length = MathUpgradeable.log10(value) + 1;
2206             string memory buffer = new string(length);
2207             uint256 ptr;
2208             /// @solidity memory-safe-assembly
2209             assembly {
2210                 ptr := add(buffer, add(32, length))
2211             }
2212             while (true) {
2213                 ptr--;
2214                 /// @solidity memory-safe-assembly
2215                 assembly {
2216                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
2217                 }
2218                 value /= 10;
2219                 if (value == 0) break;
2220             }
2221             return buffer;
2222         }
2223     }



```

```
ContextUpgradeable._msgData() (SDCollateral.sol#1836-1838) is never used and should be removed



    
1836     function _msgData() internal view virtual returns (bytes calldata) {
1837         return msg.data;
1838     }



```

```
MathUpgradeable.log2(uint256,MathUpgradeable.Rounding) (SDCollateral.sol#2093-2098) is never used and should be removed



    
2093     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
2094         unchecked {
2095             uint256 result = log2(value);
2096             return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
2097         }
2098     }



```

```
Initializable._isInitializing() (SDCollateral.sol#1811-1813) is never used and should be removed



    
1811     function _isInitializing() internal view returns (bool) {
1812         return _initializing;
1813     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256) (SDCollateral.sol#1550-1556) is never used and should be removed



    
1550     function functionCallWithValue(
1551         address target,
1552         bytes memory data,
1553         uint256 value
1554     ) internal returns (bytes memory) {
1555         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
1556     }



```

```
MathUpgradeable.ceilDiv(uint256,uint256) (SDCollateral.sol#1891-1894) is never used and should be removed



    
1891     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
1892         // (a + b - 1) / b can overflow on addition, so we distribute.
1893         return a == 0 ? 0 : (a - 1) / b + 1;
1894     }



```

```
MathUpgradeable.min(uint256,uint256) (SDCollateral.sol#1872-1874) is never used and should be removed



    
1872     function min(uint256 a, uint256 b) internal pure returns (uint256) {
1873         return a < b ? a : b;
1874     }



```

```
MathUpgradeable.sqrt(uint256) (SDCollateral.sol#2004-2035) is never used and should be removed



    
2004     function sqrt(uint256 a) internal pure returns (uint256) {
2005         if (a == 0) {
2006             return 0;
2007         }
2008 
2009         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
2010         //
2011         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
2012         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
2013         //
2014         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
2015         // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
2016         // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
2017         //
2018         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
2019         uint256 result = 1 << (log2(a) >> 1);
2020 
2021         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
2022         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
2023         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
2024         // into the expected uint128 result.
2025         unchecked {
2026             result = (result + a / result) >> 1;
2027             result = (result + a / result) >> 1;
2028             result = (result + a / result) >> 1;
2029             result = (result + a / result) >> 1;
2030             result = (result + a / result) >> 1;
2031             result = (result + a / result) >> 1;
2032             result = (result + a / result) >> 1;
2033             return min(result, a / result);
2034         }
2035     }



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (SDCollateral.sol#522-532) is never used and should be removed



    
522     function getOperatorAddressByValidatorId(
523         uint8 _poolId,
524         uint256 _validatorId,
525         IStaderConfig _staderConfig
526     ) internal view returns (address) {
527         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
530 
531         return operatorAddress;
532     }



```

```
Math.ceilDiv(uint256,uint256) (SDCollateral.sol#1165-1168) is never used and should be removed



    
1165     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
1166         // (a + b - 1) / b can overflow on addition, so we distribute.
1167         return a == 0 ? 0 : (a - 1) / b + 1;
1168     }



```

```
UtilLib.getPubkeyRoot(bytes) (SDCollateral.sol#561-568) is never used and should be removed



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {
562         if (_pubkey.length != VALIDATOR_PUBKEY_LENGTH) {
563             revert InvalidPubkeyLength();
564         }
565 
566         // Append 16 bytes of zero padding to the pubkey and compute its hash to get the pubkey root.
567         return sha256(abi.encodePacked(_pubkey, bytes16(0)));
568     }



```

```
Math.mulDiv(uint256,uint256,uint256) (SDCollateral.sol#1175-1255) is never used and should be removed



    
1175     function mulDiv(
1176         uint256 x,
1177         uint256 y,
1178         uint256 denominator
1179     ) internal pure returns (uint256 result) {
1180         unchecked {
1181             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
1182             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
1183             // variables such that product = prod1 * 2^256 + prod0.
1184             uint256 prod0; // Least significant 256 bits of the product
1185             uint256 prod1; // Most significant 256 bits of the product
1186             assembly {
1187                 let mm := mulmod(x, y, not(0))
1188                 prod0 := mul(x, y)
1189                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1190             }
1191 
1192             // Handle non-overflow cases, 256 by 256 division.
1193             if (prod1 == 0) {
1194                 return prod0 / denominator;
1195             }
1196 
1197             // Make sure the result is less than 2^256. Also prevents denominator == 0.
1198             require(denominator > prod1);
1199 
1200             ///////////////////////////////////////////////
1201             // 512 by 256 division.
1202             ///////////////////////////////////////////////
1203 
1204             // Make division exact by subtracting the remainder from [prod1 prod0].
1205             uint256 remainder;
1206             assembly {
1207                 // Compute remainder using mulmod.
1208                 remainder := mulmod(x, y, denominator)
1209 
1210                 // Subtract 256 bit number from 512 bit number.
1211                 prod1 := sub(prod1, gt(remainder, prod0))
1212                 prod0 := sub(prod0, remainder)
1213             }
1214 
1215             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
1216             // See https://cs.stackexchange.com/q/138556/92363.
1217 
1218             // Does not overflow because the denominator cannot be zero at this stage in the function.
1219             uint256 twos = denominator & (~denominator + 1);
1220             assembly {
1221                 // Divide denominator by twos.
1222                 denominator := div(denominator, twos)
1223 
1224                 // Divide [prod1 prod0] by twos.
1225                 prod0 := div(prod0, twos)
1226 
1227                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1228                 twos := add(div(sub(0, twos), twos), 1)
1229             }
1230 
1231             // Shift in bits from prod1 into prod0.
1232             prod0 |= prod1 * twos;
1233 
1234             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
1235             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
1236             // four bits. That is, denominator * inv = 1 mod 2^4.
1237             uint256 inverse = (3 * denominator) ^ 2;
1238 
1239             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
1240             // in modular arithmetic, doubling the correct bits in each step.
1241             inverse *= 2 - denominator * inverse; // inverse mod 2^8
1242             inverse *= 2 - denominator * inverse; // inverse mod 2^16
1243             inverse *= 2 - denominator * inverse; // inverse mod 2^32
1244             inverse *= 2 - denominator * inverse; // inverse mod 2^64
1245             inverse *= 2 - denominator * inverse; // inverse mod 2^128
1246             inverse *= 2 - denominator * inverse; // inverse mod 2^256
1247 
1248             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
1249             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
1250             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
1251             // is no longer required.
1252             result = prod0 * inverse;
1253             return result;
1254         }
1255     }



```

```
MathUpgradeable.log10(uint256,MathUpgradeable.Rounding) (SDCollateral.sol#2142-2147) is never used and should be removed



    
2142     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
2143         unchecked {
2144             uint256 result = log10(value);
2145             return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);
2146         }
2147     }



```

```
AddressUpgradeable.functionCall(address,bytes) (SDCollateral.sol#1521-1523) is never used and should be removed



    
1521     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
1522         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
1523     }



```

```
Math.sqrt(uint256,Math.Rounding) (SDCollateral.sol#1339-1345) is never used and should be removed



    
1339     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
1340         uint256 result = sqrt(a);
1341         if (rounding == Rounding.Up && result * result < a) {
1342             result += 1;
1343         }
1344         return result;
1345     }



```

```
ContextUpgradeable.__Context_init_unchained() (SDCollateral.sol#1830-1831) is never used and should be removed



    
1830     function __Context_init_unchained() internal onlyInitializing {
1831     }



```

```
Math.max(uint256,uint256) (SDCollateral.sol#1139-1141) is never used and should be removed



    
1139     function max(uint256 a, uint256 b) internal pure returns (uint256) {
1140         return a >= b ? a : b;
1141     }



```

```
ERC165Upgradeable.__ERC165_init_unchained() (SDCollateral.sol#2300-2301) is never used and should be removed



    
2300     function __ERC165_init_unchained() internal onlyInitializing {
2301     }



```

```
Math.average(uint256,uint256) (SDCollateral.sol#1154-1157) is never used and should be removed



    
1154     function average(uint256 a, uint256 b) internal pure returns (uint256) {
1155         // (a + b) / 2 can overflow.
1156         return (a & b) + (a ^ b) / 2;
1157     }



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (SDCollateral.sol#570-580) is never used and should be removed



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)
571         internal
572         view
573         returns (bool)
574     {
575         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getValidatorPoolId(_pubkey);
576         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
577         uint256 validatorId = INodeRegistry(nodeRegistry).validatorIdByPubkey(_pubkey);
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);
579         return IVaultProxy(withdrawVaultAddress).vaultSettleStatus();
580     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (SDCollateral.sol#1901-1981) is never used and should be removed



    
1901     function mulDiv(
1902         uint256 x,
1903         uint256 y,
1904         uint256 denominator
1905     ) internal pure returns (uint256 result) {
1906         unchecked {
1907             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
1908             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
1909             // variables such that product = prod1 * 2^256 + prod0.
1910             uint256 prod0; // Least significant 256 bits of the product
1911             uint256 prod1; // Most significant 256 bits of the product
1912             assembly {
1913                 let mm := mulmod(x, y, not(0))
1914                 prod0 := mul(x, y)
1915                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1916             }
1917 
1918             // Handle non-overflow cases, 256 by 256 division.
1919             if (prod1 == 0) {
1920                 return prod0 / denominator;
1921             }
1922 
1923             // Make sure the result is less than 2^256. Also prevents denominator == 0.
1924             require(denominator > prod1);
1925 
1926             ///////////////////////////////////////////////
1927             // 512 by 256 division.
1928             ///////////////////////////////////////////////
1929 
1930             // Make division exact by subtracting the remainder from [prod1 prod0].
1931             uint256 remainder;
1932             assembly {
1933                 // Compute remainder using mulmod.
1934                 remainder := mulmod(x, y, denominator)
1935 
1936                 // Subtract 256 bit number from 512 bit number.
1937                 prod1 := sub(prod1, gt(remainder, prod0))
1938                 prod0 := sub(prod0, remainder)
1939             }
1940 
1941             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
1942             // See https://cs.stackexchange.com/q/138556/92363.
1943 
1944             // Does not overflow because the denominator cannot be zero at this stage in the function.
1945             uint256 twos = denominator & (~denominator + 1);
1946             assembly {
1947                 // Divide denominator by twos.
1948                 denominator := div(denominator, twos)
1949 
1950                 // Divide [prod1 prod0] by twos.
1951                 prod0 := div(prod0, twos)
1952 
1953                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1954                 twos := add(div(sub(0, twos), twos), 1)
1955             }
1956 
1957             // Shift in bits from prod1 into prod0.
1958             prod0 |= prod1 * twos;
1959 
1960             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
1961             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
1962             // four bits. That is, denominator * inv = 1 mod 2^4.
1963             uint256 inverse = (3 * denominator) ^ 2;
1964 
1965             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
1966             // in modular arithmetic, doubling the correct bits in each step.
1967             inverse *= 2 - denominator * inverse; // inverse mod 2^8
1968             inverse *= 2 - denominator * inverse; // inverse mod 2^16
1969             inverse *= 2 - denominator * inverse; // inverse mod 2^32
1970             inverse *= 2 - denominator * inverse; // inverse mod 2^64
1971             inverse *= 2 - denominator * inverse; // inverse mod 2^128
1972             inverse *= 2 - denominator * inverse; // inverse mod 2^256
1973 
1974             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
1975             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
1976             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
1977             // is no longer required.
1978             result = prod0 * inverse;
1979             return result;
1980         }
1981     }



```

```
AddressUpgradeable.functionCall(address,bytes,string) (SDCollateral.sol#1531-1537) is never used and should be removed



    
1531     function functionCall(
1532         address target,
1533         bytes memory data,
1534         string memory errorMessage
1535     ) internal returns (bytes memory) {
1536         return functionCallWithValue(target, data, 0, errorMessage);
1537     }



```

```
AddressUpgradeable.sendValue(address,uint256) (SDCollateral.sol#1496-1501) is never used and should be removed



    
1496     function sendValue(address payable recipient, uint256 amount) internal {
1497         require(address(this).balance >= amount, "Address: insufficient balance");
1498 
1499         (bool success, ) = recipient.call{value: amount}("");
1500         require(success, "Address: unable to send value, recipient may have reverted");
1501     }



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (SDCollateral.sol#534-543) is never used and should be removed



    
534     function getOperatorAddressByOperatorId(
535         uint8 _poolId,
536         uint256 _operatorId,
537         IStaderConfig _staderConfig
538     ) internal view returns (address) {
539         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);
541 
542         return operatorAddress;
543     }



```

```
Math.sqrt(uint256) (SDCollateral.sol#1278-1334) is never used and should be removed



    
1278     function sqrt(uint256 a) internal pure returns (uint256) {
1279         if (a == 0) {
1280             return 0;
1281         }
1282 
1283         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
1284         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
1285         // `msb(a) <= a < 2*msb(a)`.
1286         // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.
1287         // This gives `2**k < a <= 2**(k+1)` → `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.
1288         // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a
1289         // good first aproximation of `sqrt(a)` with at least 1 correct bit.
1290         uint256 result = 1;
1291         uint256 x = a;
1292         if (x >> 128 > 0) {
1293             x >>= 128;
1294             result <<= 64;
1295         }
1296         if (x >> 64 > 0) {
1297             x >>= 64;
1298             result <<= 32;
1299         }
1300         if (x >> 32 > 0) {
1301             x >>= 32;
1302             result <<= 16;
1303         }
1304         if (x >> 16 > 0) {
1305             x >>= 16;
1306             result <<= 8;
1307         }
1308         if (x >> 8 > 0) {
1309             x >>= 8;
1310             result <<= 4;
1311         }
1312         if (x >> 4 > 0) {
1313             x >>= 4;
1314             result <<= 2;
1315         }
1316         if (x >> 2 > 0) {
1317             result <<= 1;
1318         }
1319 
1320         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
1321         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
1322         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
1323         // into the expected uint128 result.
1324         unchecked {
1325             result = (result + a / result) >> 1;
1326             result = (result + a / result) >> 1;
1327             result = (result + a / result) >> 1;
1328             result = (result + a / result) >> 1;
1329             result = (result + a / result) >> 1;
1330             result = (result + a / result) >> 1;
1331             result = (result + a / result) >> 1;
1332             return min(result, a / result);
1333         }
1334     }



```

```
UtilLib.onlyStaderContract(address,IStaderConfig,bytes32) (SDCollateral.sol#466-474) is never used and should be removed



    
466     function onlyStaderContract(
467         address _addr,
468         IStaderConfig _staderConfig,
469         bytes32 _contractName
470     ) internal view {
471         if (!_staderConfig.onlyStaderContract(_addr, _contractName)) {
472             revert CallerNotStaderContract();
473         }
474     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes) (SDCollateral.sol#1581-1583) is never used and should be removed



    
1581     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
1582         return functionStaticCall(target, data, "Address: low-level static call failed");
1583     }



```

```
MathUpgradeable.sqrt(uint256,MathUpgradeable.Rounding) (SDCollateral.sol#2040-2045) is never used and should be removed



    
2040     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
2041         unchecked {
2042             uint256 result = sqrt(a);
2043             return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
2044         }
2045     }



```

```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (SDCollateral.sol#509-520) is never used and should be removed



    
509     function onlyValidatorWithdrawVault(
510         uint8 _poolId,
511         uint256 _validatorId,
512         address _addr,
513         IStaderConfig _staderConfig
514     ) internal view {
515         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
517         if (_addr != withdrawVaultAddress) {
518             revert CallerNotWithdrawVault();
519         }
520     }



```

```
MathUpgradeable.log2(uint256) (SDCollateral.sol#2051-2087) is never used and should be removed



    
2051     function log2(uint256 value) internal pure returns (uint256) {
2052         uint256 result = 0;
2053         unchecked {
2054             if (value >> 128 > 0) {
2055                 value >>= 128;
2056                 result += 128;
2057             }
2058             if (value >> 64 > 0) {
2059                 value >>= 64;
2060                 result += 64;
2061             }
2062             if (value >> 32 > 0) {
2063                 value >>= 32;
2064                 result += 32;
2065             }
2066             if (value >> 16 > 0) {
2067                 value >>= 16;
2068                 result += 16;
2069             }
2070             if (value >> 8 > 0) {
2071                 value >>= 8;
2072                 result += 8;
2073             }
2074             if (value >> 4 > 0) {
2075                 value >>= 4;
2076                 result += 4;
2077             }
2078             if (value >> 2 > 0) {
2079                 value >>= 2;
2080                 result += 2;
2081             }
2082             if (value >> 1 > 0) {
2083                 result += 1;
2084             }
2085         }
2086         return result;
2087     }



```

```
UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig) (SDCollateral.sol#582-592) is never used and should be removed



    
582     function computeExchangeRate(
583         uint256 totalETHBalance,
584         uint256 totalETHXSupply,
585         IStaderConfig _staderConfig
586     ) internal view returns (uint256) {
587         uint256 DECIMALS = _staderConfig.getDecimals();
588         uint256 newExchangeRate = (totalETHBalance == 0 || totalETHXSupply == 0)
589             ? DECIMALS
590             : (totalETHBalance * DECIMALS) / totalETHXSupply;
591         return newExchangeRate;
592     }



```

```
AccessControlUpgradeable._setRoleAdmin(bytes32,bytes32) (SDCollateral.sol#2525-2529) is never used and should be removed



    
2525     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
2526         bytes32 previousAdminRole = getRoleAdmin(role);
2527         _roles[role].adminRole = adminRole;
2528         emit RoleAdminChanged(role, previousAdminRole, adminRole);
2529     }



```

```
MathUpgradeable.average(uint256,uint256) (SDCollateral.sol#1880-1883) is never used and should be removed



    
1880     function average(uint256 a, uint256 b) internal pure returns (uint256) {
1881         // (a + b) / 2 can overflow.
1882         return (a & b) + (a ^ b) / 2;
1883     }



```

```
StringsUpgradeable.toHexString(uint256) (SDCollateral.sol#2228-2232) is never used and should be removed



    
2228     function toHexString(uint256 value) internal pure returns (string memory) {
2229         unchecked {
2230             return toHexString(value, MathUpgradeable.log256(value) + 1);
2231         }
2232     }



```

```
MathUpgradeable.log10(uint256) (SDCollateral.sol#2104-2136) is never used and should be removed



    
2104     function log10(uint256 value) internal pure returns (uint256) {
2105         uint256 result = 0;
2106         unchecked {
2107             if (value >= 10**64) {
2108                 value /= 10**64;
2109                 result += 64;
2110             }
2111             if (value >= 10**32) {
2112                 value /= 10**32;
2113                 result += 32;
2114             }
2115             if (value >= 10**16) {
2116                 value /= 10**16;
2117                 result += 16;
2118             }
2119             if (value >= 10**8) {
2120                 value /= 10**8;
2121                 result += 8;
2122             }
2123             if (value >= 10**4) {
2124                 value /= 10**4;
2125                 result += 4;
2126             }
2127             if (value >= 10**2) {
2128                 value /= 10**2;
2129                 result += 2;
2130             }
2131             if (value >= 10**1) {
2132                 result += 1;
2133             }
2134         }
2135         return result;
2136     }



```

```
ERC165Upgradeable.__ERC165_init() (SDCollateral.sol#2297-2298) is never used and should be removed



    
2297     function __ERC165_init() internal onlyInitializing {
2298     }



```

```
Math.mulDiv(uint256,uint256,uint256,Math.Rounding) (SDCollateral.sol#1260-1271) is never used and should be removed



    
1260     function mulDiv(
1261         uint256 x,
1262         uint256 y,
1263         uint256 denominator,
1264         Rounding rounding
1265     ) internal pure returns (uint256) {
1266         uint256 result = mulDiv(x, y, denominator);
1267         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
1268             result += 1;
1269         }
1270         return result;
1271     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256,MathUpgradeable.Rounding) (SDCollateral.sol#1986-1997) is never used and should be removed



    
1986     function mulDiv(
1987         uint256 x,
1988         uint256 y,
1989         uint256 denominator,
1990         Rounding rounding
1991     ) internal pure returns (uint256) {
1992         uint256 result = mulDiv(x, y, denominator);
1993         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
1994             result += 1;
1995         }
1996         return result;
1997     }



```

```
AddressUpgradeable.verifyCallResult(bool,bytes,string) (SDCollateral.sol#1630-1640) is never used and should be removed



    
1630     function verifyCallResult(
1631         bool success,
1632         bytes memory returndata,
1633         string memory errorMessage
1634     ) internal pure returns (bytes memory) {
1635         if (success) {
1636             return returndata;
1637         } else {
1638             _revert(returndata, errorMessage);
1639         }
1640     }



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (SDCollateral.sol#476-490) is never used and should be removed



    
476     function getPubkeyForValidSender(
477         uint8 _poolId,
478         uint256 _validatorId,
479         address _addr,
480         IStaderConfig _staderConfig
481     ) internal view returns (bytes memory) {
482         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );
486         if (_addr != withdrawVaultAddress) {
487             revert CallerNotWithdrawVault();
488         }
489         return pubkey;
490     }



```

```
AccessControlUpgradeable.__AccessControl_init_unchained() (SDCollateral.sol#2359-2360) is never used and should be removed



    
2359     function __AccessControl_init_unchained() internal onlyInitializing {
2360     }



```

```
AddressUpgradeable._revert(bytes,string) (SDCollateral.sol#1642-1654) is never used and should be removed



    
1642     function _revert(bytes memory returndata, string memory errorMessage) private pure {
1643         // Look for revert reason and bubble it up if present
1644         if (returndata.length > 0) {
1645             // The easiest way to bubble the revert reason is using memory via assembly
1646             /// @solidity memory-safe-assembly
1647             assembly {
1648                 let returndata_size := mload(returndata)
1649                 revert(add(32, returndata), returndata_size)
1650             }
1651         } else {
1652             revert(errorMessage);
1653         }
1654     }



```

```
Initializable._getInitializedVersion() (SDCollateral.sol#1804-1806) is never used and should be removed



    
1804     function _getInitializedVersion() internal view returns (uint8) {
1805         return _initialized;
1806     }



```

```
AccessControlUpgradeable._setupRole(bytes32,address) (SDCollateral.sol#2516-2518) is never used and should be removed



    
2516     function _setupRole(bytes32 role, address account) internal virtual {
2517         _grantRole(role, account);
2518     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes,string) (SDCollateral.sol#1591-1598) is never used and should be removed



    
1591     function functionStaticCall(
1592         address target,
1593         bytes memory data,
1594         string memory errorMessage
1595     ) internal view returns (bytes memory) {
1596         (bool success, bytes memory returndata) = target.staticcall(data);
1597         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
1598     }



```

```
MathUpgradeable.log256(uint256,MathUpgradeable.Rounding) (SDCollateral.sol#2185-2190) is never used and should be removed



    
2185     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
2186         unchecked {
2187             uint256 result = log256(value);
2188             return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);
2189         }
2190     }



```

```
UtilLib.onlyOperatorRole(address,IStaderConfig) (SDCollateral.sol#459-463) is never used and should be removed



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {
460         if (!_staderConfig.onlyOperatorRole(_addr)) {
461             revert CallerNotOperator();
462         }
463     }



```

```
UtilLib.sendValue(address,uint256) (SDCollateral.sol#594-599) is never used and should be removed



    
594     function sendValue(address _receiver, uint256 _amount) internal {
595         (bool success, ) = payable(_receiver).call{value: _amount}('');
596         if (!success) {
597             revert TransferFailed();
598         }
599     }



```

```
MathUpgradeable.max(uint256,uint256) (SDCollateral.sol#1865-1867) is never used and should be removed



    
1865     function max(uint256 a, uint256 b) internal pure returns (uint256) {
1866         return a > b ? a : b;
1867     }



```

```
ContextUpgradeable.__Context_init() (SDCollateral.sol#1827-1828) is never used and should be removed



    
1827     function __Context_init() internal onlyInitializing {
1828     }



```

```
UtilLib.getOperatorRewardAddress(address,IStaderConfig) (SDCollateral.sol#545-554) is never used and should be removed



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)
546         internal
547         view
548         returns (address payable)
549     {
550         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getOperatorPoolId(_operator);
551         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
552         uint256 operatorId = INodeRegistry(nodeRegistry).operatorIDByAddress(_operator);
553         return INodeRegistry(nodeRegistry).getOperatorRewardAddress(operatorId);
554     }



```

```
AddressUpgradeable.verifyCallResultFromTarget(address,bool,bytes,string) (SDCollateral.sol#1606-1622) is never used and should be removed



    
1606     function verifyCallResultFromTarget(
1607         address target,
1608         bool success,
1609         bytes memory returndata,
1610         string memory errorMessage
1611     ) internal view returns (bytes memory) {
1612         if (success) {
1613             if (returndata.length == 0) {
1614                 // only check isContract if the call was successful and the return data is empty
1615                 // otherwise we already know that it was a contract
1616                 require(isContract(target), "Address: call to non-contract");
1617             }
1618             return returndata;
1619         } else {
1620             _revert(returndata, errorMessage);
1621         }
1622     }



```

```
MathUpgradeable.log256(uint256) (SDCollateral.sol#2155-2179) is never used and should be removed



    
2155     function log256(uint256 value) internal pure returns (uint256) {
2156         uint256 result = 0;
2157         unchecked {
2158             if (value >> 128 > 0) {
2159                 value >>= 128;
2160                 result += 16;
2161             }
2162             if (value >> 64 > 0) {
2163                 value >>= 64;
2164                 result += 8;
2165             }
2166             if (value >> 32 > 0) {
2167                 value >>= 32;
2168                 result += 4;
2169             }
2170             if (value >> 16 > 0) {
2171                 value >>= 16;
2172                 result += 2;
2173             }
2174             if (value >> 8 > 0) {
2175                 result += 1;
2176             }
2177         }
2178         return result;
2179     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (SDCollateral.sol#1564-1573) is never used and should be removed



    
1564     function functionCallWithValue(
1565         address target,
1566         bytes memory data,
1567         uint256 value,
1568         string memory errorMessage
1569     ) internal returns (bytes memory) {
1570         require(address(this).balance >= value, "Address: insufficient balance for call");
1571         (bool success, bytes memory returndata) = target.call{value: value}(data);
1572         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
1573     }



```

### SocializingPool.sol


```
StringsUpgradeable.toString(uint256) (SocializingPool.sol#1684-1704) is never used and should be removed



    
1684     function toString(uint256 value) internal pure returns (string memory) {
1685         unchecked {
1686             uint256 length = MathUpgradeable.log10(value) + 1;
1687             string memory buffer = new string(length);
1688             uint256 ptr;
1689             /// @solidity memory-safe-assembly
1690             assembly {
1691                 ptr := add(buffer, add(32, length))
1692             }
1693             while (true) {
1694                 ptr--;
1695                 /// @solidity memory-safe-assembly
1696                 assembly {
1697                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
1698                 }
1699                 value /= 10;
1700                 if (value == 0) break;
1701             }
1702             return buffer;
1703         }
1704     }



```

```
ContextUpgradeable._msgData() (SocializingPool.sol#1317-1319) is never used and should be removed



    
1317     function _msgData() internal view virtual returns (bytes calldata) {
1318         return msg.data;
1319     }



```

```
MathUpgradeable.log2(uint256,MathUpgradeable.Rounding) (SocializingPool.sol#1574-1579) is never used and should be removed



    
1574     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
1575         unchecked {
1576             uint256 result = log2(value);
1577             return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
1578         }
1579     }



```

```
Initializable._isInitializing() (SocializingPool.sol#1292-1294) is never used and should be removed



    
1292     function _isInitializing() internal view returns (bool) {
1293         return _initializing;
1294     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256) (SocializingPool.sol#1031-1037) is never used and should be removed



    
1031     function functionCallWithValue(
1032         address target,
1033         bytes memory data,
1034         uint256 value
1035     ) internal returns (bytes memory) {
1036         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
1037     }



```

```
MathUpgradeable.ceilDiv(uint256,uint256) (SocializingPool.sol#1372-1375) is never used and should be removed



    
1372     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
1373         // (a + b - 1) / b can overflow on addition, so we distribute.
1374         return a == 0 ? 0 : (a - 1) / b + 1;
1375     }



```

```
MathUpgradeable.min(uint256,uint256) (SocializingPool.sol#1353-1355) is never used and should be removed



    
1353     function min(uint256 a, uint256 b) internal pure returns (uint256) {
1354         return a < b ? a : b;
1355     }



```

```
PausableUpgradeable._unpause() (SocializingPool.sol#2147-2150) is never used and should be removed



    
2147     function _unpause() internal virtual whenPaused {
2148         _paused = false;
2149         emit Unpaused(_msgSender());
2150     }



```

```
MathUpgradeable.sqrt(uint256) (SocializingPool.sol#1485-1516) is never used and should be removed



    
1485     function sqrt(uint256 a) internal pure returns (uint256) {
1486         if (a == 0) {
1487             return 0;
1488         }
1489 
1490         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
1491         //
1492         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
1493         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
1494         //
1495         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
1496         // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
1497         // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
1498         //
1499         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
1500         uint256 result = 1 << (log2(a) >> 1);
1501 
1502         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
1503         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
1504         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
1505         // into the expected uint128 result.
1506         unchecked {
1507             result = (result + a / result) >> 1;
1508             result = (result + a / result) >> 1;
1509             result = (result + a / result) >> 1;
1510             result = (result + a / result) >> 1;
1511             result = (result + a / result) >> 1;
1512             result = (result + a / result) >> 1;
1513             result = (result + a / result) >> 1;
1514             return min(result, a / result);
1515         }
1516     }



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (SocializingPool.sol#523-533) is never used and should be removed



    
523     function getOperatorAddressByValidatorId(
524         uint8 _poolId,
525         uint256 _validatorId,
526         IStaderConfig _staderConfig
527     ) internal view returns (address) {
528         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
529         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
530         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
531 
532         return operatorAddress;
533     }



```

```
PausableUpgradeable._requirePaused() (SocializingPool.sol#2124-2126) is never used and should be removed



    
2124     function _requirePaused() internal view virtual {
2125         require(paused(), "Pausable: not paused");
2126     }



```

```
UtilLib.getPubkeyRoot(bytes) (SocializingPool.sol#562-569) is never used and should be removed



    
562     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {
563         if (_pubkey.length != VALIDATOR_PUBKEY_LENGTH) {
564             revert InvalidPubkeyLength();
565         }
566 
567         // Append 16 bytes of zero padding to the pubkey and compute its hash to get the pubkey root.
568         return sha256(abi.encodePacked(_pubkey, bytes16(0)));
569     }



```

```
MerkleProofUpgradeable.processProofCalldata(bytes32[],bytes32) (SocializingPool.sol#2303-2309) is never used and should be removed



    
2303     function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {
2304         bytes32 computedHash = leaf;
2305         for (uint256 i = 0; i < proof.length; i++) {
2306             computedHash = _hashPair(computedHash, proof[i]);
2307         }
2308         return computedHash;
2309     }



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (SocializingPool.sol#493-508) is never used and should be removed



    
493     function getOperatorForValidSender(
494         uint8 _poolId,
495         uint256 _validatorId,
496         address _addr,
497         IStaderConfig _staderConfig
498     ) internal view returns (address) {
499         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
500         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
501             _validatorId
502         );
503         if (_addr != withdrawVaultAddress) {
504             revert CallerNotWithdrawVault();
505         }
506         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
507         return operator;
508     }



```

```
MathUpgradeable.log10(uint256,MathUpgradeable.Rounding) (SocializingPool.sol#1623-1628) is never used and should be removed



    
1623     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
1624         unchecked {
1625             uint256 result = log10(value);
1626             return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);
1627         }
1628     }



```

```
AddressUpgradeable.functionCall(address,bytes) (SocializingPool.sol#1002-1004) is never used and should be removed



    
1002     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
1003         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
1004     }



```

```
ContextUpgradeable.__Context_init_unchained() (SocializingPool.sol#1311-1312) is never used and should be removed



    
1311     function __Context_init_unchained() internal onlyInitializing {
1312     }



```

```
ERC165Upgradeable.__ERC165_init_unchained() (SocializingPool.sol#1781-1782) is never used and should be removed



    
1781     function __ERC165_init_unchained() internal onlyInitializing {
1782     }



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (SocializingPool.sol#571-581) is never used and should be removed



    
571     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)
572         internal
573         view
574         returns (bool)
575     {
576         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getValidatorPoolId(_pubkey);
577         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
578         uint256 validatorId = INodeRegistry(nodeRegistry).validatorIdByPubkey(_pubkey);
579         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);
580         return IVaultProxy(withdrawVaultAddress).vaultSettleStatus();
581     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (SocializingPool.sol#1382-1462) is never used and should be removed



    
1382     function mulDiv(
1383         uint256 x,
1384         uint256 y,
1385         uint256 denominator
1386     ) internal pure returns (uint256 result) {
1387         unchecked {
1388             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
1389             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
1390             // variables such that product = prod1 * 2^256 + prod0.
1391             uint256 prod0; // Least significant 256 bits of the product
1392             uint256 prod1; // Most significant 256 bits of the product
1393             assembly {
1394                 let mm := mulmod(x, y, not(0))
1395                 prod0 := mul(x, y)
1396                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1397             }
1398 
1399             // Handle non-overflow cases, 256 by 256 division.
1400             if (prod1 == 0) {
1401                 return prod0 / denominator;
1402             }
1403 
1404             // Make sure the result is less than 2^256. Also prevents denominator == 0.
1405             require(denominator > prod1);
1406 
1407             ///////////////////////////////////////////////
1408             // 512 by 256 division.
1409             ///////////////////////////////////////////////
1410 
1411             // Make division exact by subtracting the remainder from [prod1 prod0].
1412             uint256 remainder;
1413             assembly {
1414                 // Compute remainder using mulmod.
1415                 remainder := mulmod(x, y, denominator)
1416 
1417                 // Subtract 256 bit number from 512 bit number.
1418                 prod1 := sub(prod1, gt(remainder, prod0))
1419                 prod0 := sub(prod0, remainder)
1420             }
1421 
1422             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
1423             // See https://cs.stackexchange.com/q/138556/92363.
1424 
1425             // Does not overflow because the denominator cannot be zero at this stage in the function.
1426             uint256 twos = denominator & (~denominator + 1);
1427             assembly {
1428                 // Divide denominator by twos.
1429                 denominator := div(denominator, twos)
1430 
1431                 // Divide [prod1 prod0] by twos.
1432                 prod0 := div(prod0, twos)
1433 
1434                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1435                 twos := add(div(sub(0, twos), twos), 1)
1436             }
1437 
1438             // Shift in bits from prod1 into prod0.
1439             prod0 |= prod1 * twos;
1440 
1441             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
1442             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
1443             // four bits. That is, denominator * inv = 1 mod 2^4.
1444             uint256 inverse = (3 * denominator) ^ 2;
1445 
1446             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
1447             // in modular arithmetic, doubling the correct bits in each step.
1448             inverse *= 2 - denominator * inverse; // inverse mod 2^8
1449             inverse *= 2 - denominator * inverse; // inverse mod 2^16
1450             inverse *= 2 - denominator * inverse; // inverse mod 2^32
1451             inverse *= 2 - denominator * inverse; // inverse mod 2^64
1452             inverse *= 2 - denominator * inverse; // inverse mod 2^128
1453             inverse *= 2 - denominator * inverse; // inverse mod 2^256
1454 
1455             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
1456             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
1457             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
1458             // is no longer required.
1459             result = prod0 * inverse;
1460             return result;
1461         }
1462     }



```

```
AddressUpgradeable.functionCall(address,bytes,string) (SocializingPool.sol#1012-1018) is never used and should be removed



    
1012     function functionCall(
1013         address target,
1014         bytes memory data,
1015         string memory errorMessage
1016     ) internal returns (bytes memory) {
1017         return functionCallWithValue(target, data, 0, errorMessage);
1018     }



```

```
AddressUpgradeable.sendValue(address,uint256) (SocializingPool.sol#977-982) is never used and should be removed



    
977     function sendValue(address payable recipient, uint256 amount) internal {
978         require(address(this).balance >= amount, "Address: insufficient balance");
979 
980         (bool success, ) = recipient.call{value: amount}("");
981         require(success, "Address: unable to send value, recipient may have reverted");
982     }



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (SocializingPool.sol#535-544) is never used and should be removed



    
535     function getOperatorAddressByOperatorId(
536         uint8 _poolId,
537         uint256 _operatorId,
538         IStaderConfig _staderConfig
539     ) internal view returns (address) {
540         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
541         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);
542 
543         return operatorAddress;
544     }



```

```
MerkleProofUpgradeable.verifyCalldata(bytes32[],bytes32,bytes32) (SocializingPool.sol#2274-2280) is never used and should be removed



    
2274     function verifyCalldata(
2275         bytes32[] calldata proof,
2276         bytes32 root,
2277         bytes32 leaf
2278     ) internal pure returns (bool) {
2279         return processProofCalldata(proof, leaf) == root;
2280     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes) (SocializingPool.sol#1062-1064) is never used and should be removed



    
1062     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
1063         return functionStaticCall(target, data, "Address: low-level static call failed");
1064     }



```

```
MathUpgradeable.sqrt(uint256,MathUpgradeable.Rounding) (SocializingPool.sol#1521-1526) is never used and should be removed



    
1521     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
1522         unchecked {
1523             uint256 result = sqrt(a);
1524             return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
1525         }
1526     }



```

```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (SocializingPool.sol#510-521) is never used and should be removed



    
510     function onlyValidatorWithdrawVault(
511         uint8 _poolId,
512         uint256 _validatorId,
513         address _addr,
514         IStaderConfig _staderConfig
515     ) internal view {
516         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
517         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
518         if (_addr != withdrawVaultAddress) {
519             revert CallerNotWithdrawVault();
520         }
521     }



```

```
MathUpgradeable.log2(uint256) (SocializingPool.sol#1532-1568) is never used and should be removed



    
1532     function log2(uint256 value) internal pure returns (uint256) {
1533         uint256 result = 0;
1534         unchecked {
1535             if (value >> 128 > 0) {
1536                 value >>= 128;
1537                 result += 128;
1538             }
1539             if (value >> 64 > 0) {
1540                 value >>= 64;
1541                 result += 64;
1542             }
1543             if (value >> 32 > 0) {
1544                 value >>= 32;
1545                 result += 32;
1546             }
1547             if (value >> 16 > 0) {
1548                 value >>= 16;
1549                 result += 16;
1550             }
1551             if (value >> 8 > 0) {
1552                 value >>= 8;
1553                 result += 8;
1554             }
1555             if (value >> 4 > 0) {
1556                 value >>= 4;
1557                 result += 4;
1558             }
1559             if (value >> 2 > 0) {
1560                 value >>= 2;
1561                 result += 2;
1562             }
1563             if (value >> 1 > 0) {
1564                 result += 1;
1565             }
1566         }
1567         return result;
1568     }



```

```
UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig) (SocializingPool.sol#583-593) is never used and should be removed



    
583     function computeExchangeRate(
584         uint256 totalETHBalance,
585         uint256 totalETHXSupply,
586         IStaderConfig _staderConfig
587     ) internal view returns (uint256) {
588         uint256 DECIMALS = _staderConfig.getDecimals();
589         uint256 newExchangeRate = (totalETHBalance == 0 || totalETHXSupply == 0)
590             ? DECIMALS
591             : (totalETHBalance * DECIMALS) / totalETHXSupply;
592         return newExchangeRate;
593     }



```

```
AccessControlUpgradeable._setRoleAdmin(bytes32,bytes32) (SocializingPool.sol#2006-2010) is never used and should be removed



    
2006     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
2007         bytes32 previousAdminRole = getRoleAdmin(role);
2008         _roles[role].adminRole = adminRole;
2009         emit RoleAdminChanged(role, previousAdminRole, adminRole);
2010     }



```

```
MathUpgradeable.average(uint256,uint256) (SocializingPool.sol#1361-1364) is never used and should be removed



    
1361     function average(uint256 a, uint256 b) internal pure returns (uint256) {
1362         // (a + b) / 2 can overflow.
1363         return (a & b) + (a ^ b) / 2;
1364     }



```

```
StringsUpgradeable.toHexString(uint256) (SocializingPool.sol#1709-1713) is never used and should be removed



    
1709     function toHexString(uint256 value) internal pure returns (string memory) {
1710         unchecked {
1711             return toHexString(value, MathUpgradeable.log256(value) + 1);
1712         }
1713     }



```

```
MerkleProofUpgradeable.multiProofVerify(bytes32[],bool[],bytes32,bytes32[]) (SocializingPool.sol#2317-2324) is never used and should be removed



    
2317     function multiProofVerify(
2318         bytes32[] memory proof,
2319         bool[] memory proofFlags,
2320         bytes32 root,
2321         bytes32[] memory leaves
2322     ) internal pure returns (bool) {
2323         return processMultiProof(proof, proofFlags, leaves) == root;
2324     }



```

```
MathUpgradeable.log10(uint256) (SocializingPool.sol#1585-1617) is never used and should be removed



    
1585     function log10(uint256 value) internal pure returns (uint256) {
1586         uint256 result = 0;
1587         unchecked {
1588             if (value >= 10**64) {
1589                 value /= 10**64;
1590                 result += 64;
1591             }
1592             if (value >= 10**32) {
1593                 value /= 10**32;
1594                 result += 32;
1595             }
1596             if (value >= 10**16) {
1597                 value /= 10**16;
1598                 result += 16;
1599             }
1600             if (value >= 10**8) {
1601                 value /= 10**8;
1602                 result += 8;
1603             }
1604             if (value >= 10**4) {
1605                 value /= 10**4;
1606                 result += 4;
1607             }
1608             if (value >= 10**2) {
1609                 value /= 10**2;
1610                 result += 2;
1611             }
1612             if (value >= 10**1) {
1613                 result += 1;
1614             }
1615         }
1616         return result;
1617     }



```

```
ERC165Upgradeable.__ERC165_init() (SocializingPool.sol#1778-1779) is never used and should be removed



    
1778     function __ERC165_init() internal onlyInitializing {
1779     }



```

```
MerkleProofUpgradeable.processMultiProof(bytes32[],bool[],bytes32[]) (SocializingPool.sol#2347-2386) is never used and should be removed



    
2347     function processMultiProof(
2348         bytes32[] memory proof,
2349         bool[] memory proofFlags,
2350         bytes32[] memory leaves
2351     ) internal pure returns (bytes32 merkleRoot) {
2352         // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by
2353         // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the
2354         // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of
2355         // the merkle tree.
2356         uint256 leavesLen = leaves.length;
2357         uint256 totalHashes = proofFlags.length;
2358 
2359         // Check proof validity.
2360         require(leavesLen + proof.length - 1 == totalHashes, "MerkleProof: invalid multiproof");
2361 
2362         // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using
2363         // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's "pop".
2364         bytes32[] memory hashes = new bytes32[](totalHashes);
2365         uint256 leafPos = 0;
2366         uint256 hashPos = 0;
2367         uint256 proofPos = 0;
2368         // At each step, we compute the next hash using two values:
2369         // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we
2370         //   get the next hash.
2371         // - depending on the flag, either another value for the "main queue" (merging branches) or an element from the
2372         //   `proof` array.
2373         for (uint256 i = 0; i < totalHashes; i++) {
2374             bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];
2375             bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];
2376             hashes[i] = _hashPair(a, b);
2377         }
2378 
2379         if (totalHashes > 0) {
2380             return hashes[totalHashes - 1];
2381         } else if (leavesLen > 0) {
2382             return leaves[0];
2383         } else {
2384             return proof[0];
2385         }
2386     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256,MathUpgradeable.Rounding) (SocializingPool.sol#1467-1478) is never used and should be removed



    
1467     function mulDiv(
1468         uint256 x,
1469         uint256 y,
1470         uint256 denominator,
1471         Rounding rounding
1472     ) internal pure returns (uint256) {
1473         uint256 result = mulDiv(x, y, denominator);
1474         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
1475             result += 1;
1476         }
1477         return result;
1478     }



```

```
PausableUpgradeable._pause() (SocializingPool.sol#2135-2138) is never used and should be removed



    
2135     function _pause() internal virtual whenNotPaused {
2136         _paused = true;
2137         emit Paused(_msgSender());
2138     }



```

```
AddressUpgradeable.verifyCallResult(bool,bytes,string) (SocializingPool.sol#1111-1121) is never used and should be removed



    
1111     function verifyCallResult(
1112         bool success,
1113         bytes memory returndata,
1114         string memory errorMessage
1115     ) internal pure returns (bytes memory) {
1116         if (success) {
1117             return returndata;
1118         } else {
1119             _revert(returndata, errorMessage);
1120         }
1121     }



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (SocializingPool.sol#477-491) is never used and should be removed



    
477     function getPubkeyForValidSender(
478         uint8 _poolId,
479         uint256 _validatorId,
480         address _addr,
481         IStaderConfig _staderConfig
482     ) internal view returns (bytes memory) {
483         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
484         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
485             _validatorId
486         );
487         if (_addr != withdrawVaultAddress) {
488             revert CallerNotWithdrawVault();
489         }
490         return pubkey;
491     }



```

```
AccessControlUpgradeable.__AccessControl_init_unchained() (SocializingPool.sol#1840-1841) is never used and should be removed



    
1840     function __AccessControl_init_unchained() internal onlyInitializing {
1841     }



```

```
AddressUpgradeable._revert(bytes,string) (SocializingPool.sol#1123-1135) is never used and should be removed



    
1123     function _revert(bytes memory returndata, string memory errorMessage) private pure {
1124         // Look for revert reason and bubble it up if present
1125         if (returndata.length > 0) {
1126             // The easiest way to bubble the revert reason is using memory via assembly
1127             /// @solidity memory-safe-assembly
1128             assembly {
1129                 let returndata_size := mload(returndata)
1130                 revert(add(32, returndata), returndata_size)
1131             }
1132         } else {
1133             revert(errorMessage);
1134         }
1135     }



```

```
Initializable._getInitializedVersion() (SocializingPool.sol#1285-1287) is never used and should be removed



    
1285     function _getInitializedVersion() internal view returns (uint8) {
1286         return _initialized;
1287     }



```

```
MerkleProofUpgradeable.processMultiProofCalldata(bytes32[],bool[],bytes32[]) (SocializingPool.sol#2393-2432) is never used and should be removed



    
2393     function processMultiProofCalldata(
2394         bytes32[] calldata proof,
2395         bool[] calldata proofFlags,
2396         bytes32[] memory leaves
2397     ) internal pure returns (bytes32 merkleRoot) {
2398         // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by
2399         // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the
2400         // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of
2401         // the merkle tree.
2402         uint256 leavesLen = leaves.length;
2403         uint256 totalHashes = proofFlags.length;
2404 
2405         // Check proof validity.
2406         require(leavesLen + proof.length - 1 == totalHashes, "MerkleProof: invalid multiproof");
2407 
2408         // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using
2409         // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's "pop".
2410         bytes32[] memory hashes = new bytes32[](totalHashes);
2411         uint256 leafPos = 0;
2412         uint256 hashPos = 0;
2413         uint256 proofPos = 0;
2414         // At each step, we compute the next hash using two values:
2415         // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we
2416         //   get the next hash.
2417         // - depending on the flag, either another value for the "main queue" (merging branches) or an element from the
2418         //   `proof` array.
2419         for (uint256 i = 0; i < totalHashes; i++) {
2420             bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];
2421             bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];
2422             hashes[i] = _hashPair(a, b);
2423         }
2424 
2425         if (totalHashes > 0) {
2426             return hashes[totalHashes - 1];
2427         } else if (leavesLen > 0) {
2428             return leaves[0];
2429         } else {
2430             return proof[0];
2431         }
2432     }



```

```
AccessControlUpgradeable._setupRole(bytes32,address) (SocializingPool.sol#1997-1999) is never used and should be removed



    
1997     function _setupRole(bytes32 role, address account) internal virtual {
1998         _grantRole(role, account);
1999     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes,string) (SocializingPool.sol#1072-1079) is never used and should be removed



    
1072     function functionStaticCall(
1073         address target,
1074         bytes memory data,
1075         string memory errorMessage
1076     ) internal view returns (bytes memory) {
1077         (bool success, bytes memory returndata) = target.staticcall(data);
1078         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
1079     }



```

```
MathUpgradeable.log256(uint256,MathUpgradeable.Rounding) (SocializingPool.sol#1666-1671) is never used and should be removed



    
1666     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
1667         unchecked {
1668             uint256 result = log256(value);
1669             return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);
1670         }
1671     }



```

```
UtilLib.onlyOperatorRole(address,IStaderConfig) (SocializingPool.sol#460-464) is never used and should be removed



    
460     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {
461         if (!_staderConfig.onlyOperatorRole(_addr)) {
462             revert CallerNotOperator();
463         }
464     }



```

```
UtilLib.sendValue(address,uint256) (SocializingPool.sol#595-600) is never used and should be removed



    
595     function sendValue(address _receiver, uint256 _amount) internal {
596         (bool success, ) = payable(_receiver).call{value: _amount}('');
597         if (!success) {
598             revert TransferFailed();
599         }
600     }



```

```
MathUpgradeable.max(uint256,uint256) (SocializingPool.sol#1346-1348) is never used and should be removed



    
1346     function max(uint256 a, uint256 b) internal pure returns (uint256) {
1347         return a > b ? a : b;
1348     }



```

```
MerkleProofUpgradeable.multiProofVerifyCalldata(bytes32[],bool[],bytes32,bytes32[]) (SocializingPool.sol#2331-2338) is never used and should be removed



    
2331     function multiProofVerifyCalldata(
2332         bytes32[] calldata proof,
2333         bool[] calldata proofFlags,
2334         bytes32 root,
2335         bytes32[] memory leaves
2336     ) internal pure returns (bool) {
2337         return processMultiProofCalldata(proof, proofFlags, leaves) == root;
2338     }



```

```
ContextUpgradeable.__Context_init() (SocializingPool.sol#1308-1309) is never used and should be removed



    
1308     function __Context_init() internal onlyInitializing {
1309     }



```

```
UtilLib.onlyManagerRole(address,IStaderConfig) (SocializingPool.sol#454-458) is never used and should be removed



    
454     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {
455         if (!_staderConfig.onlyManagerRole(_addr)) {
456             revert CallerNotManager();
457         }
458     }



```

```
AddressUpgradeable.verifyCallResultFromTarget(address,bool,bytes,string) (SocializingPool.sol#1087-1103) is never used and should be removed



    
1087     function verifyCallResultFromTarget(
1088         address target,
1089         bool success,
1090         bytes memory returndata,
1091         string memory errorMessage
1092     ) internal view returns (bytes memory) {
1093         if (success) {
1094             if (returndata.length == 0) {
1095                 // only check isContract if the call was successful and the return data is empty
1096                 // otherwise we already know that it was a contract
1097                 require(isContract(target), "Address: call to non-contract");
1098             }
1099             return returndata;
1100         } else {
1101             _revert(returndata, errorMessage);
1102         }
1103     }



```

```
MathUpgradeable.log256(uint256) (SocializingPool.sol#1636-1660) is never used and should be removed



    
1636     function log256(uint256 value) internal pure returns (uint256) {
1637         uint256 result = 0;
1638         unchecked {
1639             if (value >> 128 > 0) {
1640                 value >>= 128;
1641                 result += 16;
1642             }
1643             if (value >> 64 > 0) {
1644                 value >>= 64;
1645                 result += 8;
1646             }
1647             if (value >> 32 > 0) {
1648                 value >>= 32;
1649                 result += 4;
1650             }
1651             if (value >> 16 > 0) {
1652                 value >>= 16;
1653                 result += 2;
1654             }
1655             if (value >> 8 > 0) {
1656                 result += 1;
1657             }
1658         }
1659         return result;
1660     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (SocializingPool.sol#1045-1054) is never used and should be removed



    
1045     function functionCallWithValue(
1046         address target,
1047         bytes memory data,
1048         uint256 value,
1049         string memory errorMessage
1050     ) internal returns (bytes memory) {
1051         require(address(this).balance >= value, "Address: insufficient balance for call");
1052         (bool success, bytes memory returndata) = target.call{value: value}(data);
1053         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
1054     }



```

### StaderConfig.sol


```
StringsUpgradeable.toString(uint256) (StaderConfig.sol#1457-1477) is never used and should be removed



    
1457     function toString(uint256 value) internal pure returns (string memory) {
1458         unchecked {
1459             uint256 length = MathUpgradeable.log10(value) + 1;
1460             string memory buffer = new string(length);
1461             uint256 ptr;
1462             /// @solidity memory-safe-assembly
1463             assembly {
1464                 ptr := add(buffer, add(32, length))
1465             }
1466             while (true) {
1467                 ptr--;
1468                 /// @solidity memory-safe-assembly
1469                 assembly {
1470                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
1471                 }
1472                 value /= 10;
1473                 if (value == 0) break;
1474             }
1475             return buffer;
1476         }
1477     }



```

```
ContextUpgradeable._msgData() (StaderConfig.sol#1090-1092) is never used and should be removed



    
1090     function _msgData() internal view virtual returns (bytes calldata) {
1091         return msg.data;
1092     }



```

```
MathUpgradeable.log2(uint256,MathUpgradeable.Rounding) (StaderConfig.sol#1347-1352) is never used and should be removed



    
1347     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
1348         unchecked {
1349             uint256 result = log2(value);
1350             return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
1351         }
1352     }



```

```
Initializable._isInitializing() (StaderConfig.sol#1065-1067) is never used and should be removed



    
1065     function _isInitializing() internal view returns (bool) {
1066         return _initializing;
1067     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256) (StaderConfig.sol#804-810) is never used and should be removed



    
804     function functionCallWithValue(
805         address target,
806         bytes memory data,
807         uint256 value
808     ) internal returns (bytes memory) {
809         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
810     }



```

```
MathUpgradeable.ceilDiv(uint256,uint256) (StaderConfig.sol#1145-1148) is never used and should be removed



    
1145     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
1146         // (a + b - 1) / b can overflow on addition, so we distribute.
1147         return a == 0 ? 0 : (a - 1) / b + 1;
1148     }



```

```
MathUpgradeable.min(uint256,uint256) (StaderConfig.sol#1126-1128) is never used and should be removed



    
1126     function min(uint256 a, uint256 b) internal pure returns (uint256) {
1127         return a < b ? a : b;
1128     }



```

```
MathUpgradeable.sqrt(uint256) (StaderConfig.sol#1258-1289) is never used and should be removed



    
1258     function sqrt(uint256 a) internal pure returns (uint256) {
1259         if (a == 0) {
1260             return 0;
1261         }
1262 
1263         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
1264         //
1265         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
1266         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
1267         //
1268         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
1269         // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
1270         // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
1271         //
1272         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
1273         uint256 result = 1 << (log2(a) >> 1);
1274 
1275         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
1276         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
1277         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
1278         // into the expected uint128 result.
1279         unchecked {
1280             result = (result + a / result) >> 1;
1281             result = (result + a / result) >> 1;
1282             result = (result + a / result) >> 1;
1283             result = (result + a / result) >> 1;
1284             result = (result + a / result) >> 1;
1285             result = (result + a / result) >> 1;
1286             result = (result + a / result) >> 1;
1287             return min(result, a / result);
1288         }
1289     }



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (StaderConfig.sol#522-532) is never used and should be removed



    
522     function getOperatorAddressByValidatorId(
523         uint8 _poolId,
524         uint256 _validatorId,
525         IStaderConfig _staderConfig
526     ) internal view returns (address) {
527         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
530 
531         return operatorAddress;
532     }



```

```
UtilLib.getPubkeyRoot(bytes) (StaderConfig.sol#561-568) is never used and should be removed



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {
562         if (_pubkey.length != VALIDATOR_PUBKEY_LENGTH) {
563             revert InvalidPubkeyLength();
564         }
565 
566         // Append 16 bytes of zero padding to the pubkey and compute its hash to get the pubkey root.
567         return sha256(abi.encodePacked(_pubkey, bytes16(0)));
568     }



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (StaderConfig.sol#492-507) is never used and should be removed



    
492     function getOperatorForValidSender(
493         uint8 _poolId,
494         uint256 _validatorId,
495         address _addr,
496         IStaderConfig _staderConfig
497     ) internal view returns (address) {
498         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );
502         if (_addr != withdrawVaultAddress) {
503             revert CallerNotWithdrawVault();
504         }
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
506         return operator;
507     }



```

```
MathUpgradeable.log10(uint256,MathUpgradeable.Rounding) (StaderConfig.sol#1396-1401) is never used and should be removed



    
1396     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
1397         unchecked {
1398             uint256 result = log10(value);
1399             return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);
1400         }
1401     }



```

```
AddressUpgradeable.functionCall(address,bytes) (StaderConfig.sol#775-777) is never used and should be removed



    
775     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
776         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
777     }



```

```
ContextUpgradeable.__Context_init_unchained() (StaderConfig.sol#1084-1085) is never used and should be removed



    
1084     function __Context_init_unchained() internal onlyInitializing {
1085     }



```

```
ERC165Upgradeable.__ERC165_init_unchained() (StaderConfig.sol#1554-1555) is never used and should be removed



    
1554     function __ERC165_init_unchained() internal onlyInitializing {
1555     }



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (StaderConfig.sol#570-580) is never used and should be removed



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)
571         internal
572         view
573         returns (bool)
574     {
575         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getValidatorPoolId(_pubkey);
576         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
577         uint256 validatorId = INodeRegistry(nodeRegistry).validatorIdByPubkey(_pubkey);
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);
579         return IVaultProxy(withdrawVaultAddress).vaultSettleStatus();
580     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderConfig.sol#1155-1235) is never used and should be removed



    
1155     function mulDiv(
1156         uint256 x,
1157         uint256 y,
1158         uint256 denominator
1159     ) internal pure returns (uint256 result) {
1160         unchecked {
1161             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
1162             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
1163             // variables such that product = prod1 * 2^256 + prod0.
1164             uint256 prod0; // Least significant 256 bits of the product
1165             uint256 prod1; // Most significant 256 bits of the product
1166             assembly {
1167                 let mm := mulmod(x, y, not(0))
1168                 prod0 := mul(x, y)
1169                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1170             }
1171 
1172             // Handle non-overflow cases, 256 by 256 division.
1173             if (prod1 == 0) {
1174                 return prod0 / denominator;
1175             }
1176 
1177             // Make sure the result is less than 2^256. Also prevents denominator == 0.
1178             require(denominator > prod1);
1179 
1180             ///////////////////////////////////////////////
1181             // 512 by 256 division.
1182             ///////////////////////////////////////////////
1183 
1184             // Make division exact by subtracting the remainder from [prod1 prod0].
1185             uint256 remainder;
1186             assembly {
1187                 // Compute remainder using mulmod.
1188                 remainder := mulmod(x, y, denominator)
1189 
1190                 // Subtract 256 bit number from 512 bit number.
1191                 prod1 := sub(prod1, gt(remainder, prod0))
1192                 prod0 := sub(prod0, remainder)
1193             }
1194 
1195             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
1196             // See https://cs.stackexchange.com/q/138556/92363.
1197 
1198             // Does not overflow because the denominator cannot be zero at this stage in the function.
1199             uint256 twos = denominator & (~denominator + 1);
1200             assembly {
1201                 // Divide denominator by twos.
1202                 denominator := div(denominator, twos)
1203 
1204                 // Divide [prod1 prod0] by twos.
1205                 prod0 := div(prod0, twos)
1206 
1207                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1208                 twos := add(div(sub(0, twos), twos), 1)
1209             }
1210 
1211             // Shift in bits from prod1 into prod0.
1212             prod0 |= prod1 * twos;
1213 
1214             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
1215             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
1216             // four bits. That is, denominator * inv = 1 mod 2^4.
1217             uint256 inverse = (3 * denominator) ^ 2;
1218 
1219             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
1220             // in modular arithmetic, doubling the correct bits in each step.
1221             inverse *= 2 - denominator * inverse; // inverse mod 2^8
1222             inverse *= 2 - denominator * inverse; // inverse mod 2^16
1223             inverse *= 2 - denominator * inverse; // inverse mod 2^32
1224             inverse *= 2 - denominator * inverse; // inverse mod 2^64
1225             inverse *= 2 - denominator * inverse; // inverse mod 2^128
1226             inverse *= 2 - denominator * inverse; // inverse mod 2^256
1227 
1228             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
1229             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
1230             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
1231             // is no longer required.
1232             result = prod0 * inverse;
1233             return result;
1234         }
1235     }



```

```
AddressUpgradeable.functionCall(address,bytes,string) (StaderConfig.sol#785-791) is never used and should be removed



    
785     function functionCall(
786         address target,
787         bytes memory data,
788         string memory errorMessage
789     ) internal returns (bytes memory) {
790         return functionCallWithValue(target, data, 0, errorMessage);
791     }



```

```
AddressUpgradeable.sendValue(address,uint256) (StaderConfig.sol#750-755) is never used and should be removed



    
750     function sendValue(address payable recipient, uint256 amount) internal {
751         require(address(this).balance >= amount, "Address: insufficient balance");
752 
753         (bool success, ) = recipient.call{value: amount}("");
754         require(success, "Address: unable to send value, recipient may have reverted");
755     }



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (StaderConfig.sol#534-543) is never used and should be removed



    
534     function getOperatorAddressByOperatorId(
535         uint8 _poolId,
536         uint256 _operatorId,
537         IStaderConfig _staderConfig
538     ) internal view returns (address) {
539         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);
541 
542         return operatorAddress;
543     }



```

```
UtilLib.onlyStaderContract(address,IStaderConfig,bytes32) (StaderConfig.sol#466-474) is never used and should be removed



    
466     function onlyStaderContract(
467         address _addr,
468         IStaderConfig _staderConfig,
469         bytes32 _contractName
470     ) internal view {
471         if (!_staderConfig.onlyStaderContract(_addr, _contractName)) {
472             revert CallerNotStaderContract();
473         }
474     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes) (StaderConfig.sol#835-837) is never used and should be removed



    
835     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
836         return functionStaticCall(target, data, "Address: low-level static call failed");
837     }



```

```
MathUpgradeable.sqrt(uint256,MathUpgradeable.Rounding) (StaderConfig.sol#1294-1299) is never used and should be removed



    
1294     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
1295         unchecked {
1296             uint256 result = sqrt(a);
1297             return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
1298         }
1299     }



```

```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (StaderConfig.sol#509-520) is never used and should be removed



    
509     function onlyValidatorWithdrawVault(
510         uint8 _poolId,
511         uint256 _validatorId,
512         address _addr,
513         IStaderConfig _staderConfig
514     ) internal view {
515         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
517         if (_addr != withdrawVaultAddress) {
518             revert CallerNotWithdrawVault();
519         }
520     }



```

```
MathUpgradeable.log2(uint256) (StaderConfig.sol#1305-1341) is never used and should be removed



    
1305     function log2(uint256 value) internal pure returns (uint256) {
1306         uint256 result = 0;
1307         unchecked {
1308             if (value >> 128 > 0) {
1309                 value >>= 128;
1310                 result += 128;
1311             }
1312             if (value >> 64 > 0) {
1313                 value >>= 64;
1314                 result += 64;
1315             }
1316             if (value >> 32 > 0) {
1317                 value >>= 32;
1318                 result += 32;
1319             }
1320             if (value >> 16 > 0) {
1321                 value >>= 16;
1322                 result += 16;
1323             }
1324             if (value >> 8 > 0) {
1325                 value >>= 8;
1326                 result += 8;
1327             }
1328             if (value >> 4 > 0) {
1329                 value >>= 4;
1330                 result += 4;
1331             }
1332             if (value >> 2 > 0) {
1333                 value >>= 2;
1334                 result += 2;
1335             }
1336             if (value >> 1 > 0) {
1337                 result += 1;
1338             }
1339         }
1340         return result;
1341     }



```

```
UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig) (StaderConfig.sol#582-592) is never used and should be removed



    
582     function computeExchangeRate(
583         uint256 totalETHBalance,
584         uint256 totalETHXSupply,
585         IStaderConfig _staderConfig
586     ) internal view returns (uint256) {
587         uint256 DECIMALS = _staderConfig.getDecimals();
588         uint256 newExchangeRate = (totalETHBalance == 0 || totalETHXSupply == 0)
589             ? DECIMALS
590             : (totalETHBalance * DECIMALS) / totalETHXSupply;
591         return newExchangeRate;
592     }



```

```
AccessControlUpgradeable._setRoleAdmin(bytes32,bytes32) (StaderConfig.sol#1779-1783) is never used and should be removed



    
1779     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
1780         bytes32 previousAdminRole = getRoleAdmin(role);
1781         _roles[role].adminRole = adminRole;
1782         emit RoleAdminChanged(role, previousAdminRole, adminRole);
1783     }



```

```
MathUpgradeable.average(uint256,uint256) (StaderConfig.sol#1134-1137) is never used and should be removed



    
1134     function average(uint256 a, uint256 b) internal pure returns (uint256) {
1135         // (a + b) / 2 can overflow.
1136         return (a & b) + (a ^ b) / 2;
1137     }



```

```
StringsUpgradeable.toHexString(uint256) (StaderConfig.sol#1482-1486) is never used and should be removed



    
1482     function toHexString(uint256 value) internal pure returns (string memory) {
1483         unchecked {
1484             return toHexString(value, MathUpgradeable.log256(value) + 1);
1485         }
1486     }



```

```
MathUpgradeable.log10(uint256) (StaderConfig.sol#1358-1390) is never used and should be removed



    
1358     function log10(uint256 value) internal pure returns (uint256) {
1359         uint256 result = 0;
1360         unchecked {
1361             if (value >= 10**64) {
1362                 value /= 10**64;
1363                 result += 64;
1364             }
1365             if (value >= 10**32) {
1366                 value /= 10**32;
1367                 result += 32;
1368             }
1369             if (value >= 10**16) {
1370                 value /= 10**16;
1371                 result += 16;
1372             }
1373             if (value >= 10**8) {
1374                 value /= 10**8;
1375                 result += 8;
1376             }
1377             if (value >= 10**4) {
1378                 value /= 10**4;
1379                 result += 4;
1380             }
1381             if (value >= 10**2) {
1382                 value /= 10**2;
1383                 result += 2;
1384             }
1385             if (value >= 10**1) {
1386                 result += 1;
1387             }
1388         }
1389         return result;
1390     }



```

```
ERC165Upgradeable.__ERC165_init() (StaderConfig.sol#1551-1552) is never used and should be removed



    
1551     function __ERC165_init() internal onlyInitializing {
1552     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256,MathUpgradeable.Rounding) (StaderConfig.sol#1240-1251) is never used and should be removed



    
1240     function mulDiv(
1241         uint256 x,
1242         uint256 y,
1243         uint256 denominator,
1244         Rounding rounding
1245     ) internal pure returns (uint256) {
1246         uint256 result = mulDiv(x, y, denominator);
1247         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
1248             result += 1;
1249         }
1250         return result;
1251     }



```

```
AddressUpgradeable.verifyCallResult(bool,bytes,string) (StaderConfig.sol#884-894) is never used and should be removed



    
884     function verifyCallResult(
885         bool success,
886         bytes memory returndata,
887         string memory errorMessage
888     ) internal pure returns (bytes memory) {
889         if (success) {
890             return returndata;
891         } else {
892             _revert(returndata, errorMessage);
893         }
894     }



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (StaderConfig.sol#476-490) is never used and should be removed



    
476     function getPubkeyForValidSender(
477         uint8 _poolId,
478         uint256 _validatorId,
479         address _addr,
480         IStaderConfig _staderConfig
481     ) internal view returns (bytes memory) {
482         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );
486         if (_addr != withdrawVaultAddress) {
487             revert CallerNotWithdrawVault();
488         }
489         return pubkey;
490     }



```

```
AccessControlUpgradeable.__AccessControl_init_unchained() (StaderConfig.sol#1613-1614) is never used and should be removed



    
1613     function __AccessControl_init_unchained() internal onlyInitializing {
1614     }



```

```
AddressUpgradeable._revert(bytes,string) (StaderConfig.sol#896-908) is never used and should be removed



    
896     function _revert(bytes memory returndata, string memory errorMessage) private pure {
897         // Look for revert reason and bubble it up if present
898         if (returndata.length > 0) {
899             // The easiest way to bubble the revert reason is using memory via assembly
900             /// @solidity memory-safe-assembly
901             assembly {
902                 let returndata_size := mload(returndata)
903                 revert(add(32, returndata), returndata_size)
904             }
905         } else {
906             revert(errorMessage);
907         }
908     }



```

```
Initializable._getInitializedVersion() (StaderConfig.sol#1058-1060) is never used and should be removed



    
1058     function _getInitializedVersion() internal view returns (uint8) {
1059         return _initialized;
1060     }



```

```
AccessControlUpgradeable._setupRole(bytes32,address) (StaderConfig.sol#1770-1772) is never used and should be removed



    
1770     function _setupRole(bytes32 role, address account) internal virtual {
1771         _grantRole(role, account);
1772     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes,string) (StaderConfig.sol#845-852) is never used and should be removed



    
845     function functionStaticCall(
846         address target,
847         bytes memory data,
848         string memory errorMessage
849     ) internal view returns (bytes memory) {
850         (bool success, bytes memory returndata) = target.staticcall(data);
851         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
852     }



```

```
MathUpgradeable.log256(uint256,MathUpgradeable.Rounding) (StaderConfig.sol#1439-1444) is never used and should be removed



    
1439     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
1440         unchecked {
1441             uint256 result = log256(value);
1442             return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);
1443         }
1444     }



```

```
UtilLib.onlyOperatorRole(address,IStaderConfig) (StaderConfig.sol#459-463) is never used and should be removed



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {
460         if (!_staderConfig.onlyOperatorRole(_addr)) {
461             revert CallerNotOperator();
462         }
463     }



```

```
UtilLib.sendValue(address,uint256) (StaderConfig.sol#594-599) is never used and should be removed



    
594     function sendValue(address _receiver, uint256 _amount) internal {
595         (bool success, ) = payable(_receiver).call{value: _amount}('');
596         if (!success) {
597             revert TransferFailed();
598         }
599     }



```

```
MathUpgradeable.max(uint256,uint256) (StaderConfig.sol#1119-1121) is never used and should be removed



    
1119     function max(uint256 a, uint256 b) internal pure returns (uint256) {
1120         return a > b ? a : b;
1121     }



```

```
ContextUpgradeable.__Context_init() (StaderConfig.sol#1081-1082) is never used and should be removed



    
1081     function __Context_init() internal onlyInitializing {
1082     }



```

```
UtilLib.onlyManagerRole(address,IStaderConfig) (StaderConfig.sol#453-457) is never used and should be removed



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {
454         if (!_staderConfig.onlyManagerRole(_addr)) {
455             revert CallerNotManager();
456         }
457     }



```

```
UtilLib.getOperatorRewardAddress(address,IStaderConfig) (StaderConfig.sol#545-554) is never used and should be removed



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)
546         internal
547         view
548         returns (address payable)
549     {
550         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getOperatorPoolId(_operator);
551         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
552         uint256 operatorId = INodeRegistry(nodeRegistry).operatorIDByAddress(_operator);
553         return INodeRegistry(nodeRegistry).getOperatorRewardAddress(operatorId);
554     }



```

```
AddressUpgradeable.verifyCallResultFromTarget(address,bool,bytes,string) (StaderConfig.sol#860-876) is never used and should be removed



    
860     function verifyCallResultFromTarget(
861         address target,
862         bool success,
863         bytes memory returndata,
864         string memory errorMessage
865     ) internal view returns (bytes memory) {
866         if (success) {
867             if (returndata.length == 0) {
868                 // only check isContract if the call was successful and the return data is empty
869                 // otherwise we already know that it was a contract
870                 require(isContract(target), "Address: call to non-contract");
871             }
872             return returndata;
873         } else {
874             _revert(returndata, errorMessage);
875         }
876     }



```

```
MathUpgradeable.log256(uint256) (StaderConfig.sol#1409-1433) is never used and should be removed



    
1409     function log256(uint256 value) internal pure returns (uint256) {
1410         uint256 result = 0;
1411         unchecked {
1412             if (value >> 128 > 0) {
1413                 value >>= 128;
1414                 result += 16;
1415             }
1416             if (value >> 64 > 0) {
1417                 value >>= 64;
1418                 result += 8;
1419             }
1420             if (value >> 32 > 0) {
1421                 value >>= 32;
1422                 result += 4;
1423             }
1424             if (value >> 16 > 0) {
1425                 value >>= 16;
1426                 result += 2;
1427             }
1428             if (value >> 8 > 0) {
1429                 result += 1;
1430             }
1431         }
1432         return result;
1433     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (StaderConfig.sol#818-827) is never used and should be removed



    
818     function functionCallWithValue(
819         address target,
820         bytes memory data,
821         uint256 value,
822         string memory errorMessage
823     ) internal returns (bytes memory) {
824         require(address(this).balance >= value, "Address: insufficient balance for call");
825         (bool success, bytes memory returndata) = target.call{value: value}(data);
826         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
827     }



```

### StaderInsuranceFund.sol


```
StringsUpgradeable.toString(uint256) (StaderInsuranceFund.sol#1483-1503) is never used and should be removed



    
1483     function toString(uint256 value) internal pure returns (string memory) {
1484         unchecked {
1485             uint256 length = MathUpgradeable.log10(value) + 1;
1486             string memory buffer = new string(length);
1487             uint256 ptr;
1488             /// @solidity memory-safe-assembly
1489             assembly {
1490                 ptr := add(buffer, add(32, length))
1491             }
1492             while (true) {
1493                 ptr--;
1494                 /// @solidity memory-safe-assembly
1495                 assembly {
1496                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
1497                 }
1498                 value /= 10;
1499                 if (value == 0) break;
1500             }
1501             return buffer;
1502         }
1503     }



```

```
ContextUpgradeable._msgData() (StaderInsuranceFund.sol#1116-1118) is never used and should be removed



    
1116     function _msgData() internal view virtual returns (bytes calldata) {
1117         return msg.data;
1118     }



```

```
MathUpgradeable.log2(uint256,MathUpgradeable.Rounding) (StaderInsuranceFund.sol#1373-1378) is never used and should be removed



    
1373     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
1374         unchecked {
1375             uint256 result = log2(value);
1376             return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
1377         }
1378     }



```

```
Initializable._isInitializing() (StaderInsuranceFund.sol#1091-1093) is never used and should be removed



    
1091     function _isInitializing() internal view returns (bool) {
1092         return _initializing;
1093     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256) (StaderInsuranceFund.sol#830-836) is never used and should be removed



    
830     function functionCallWithValue(
831         address target,
832         bytes memory data,
833         uint256 value
834     ) internal returns (bytes memory) {
835         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
836     }



```

```
MathUpgradeable.ceilDiv(uint256,uint256) (StaderInsuranceFund.sol#1171-1174) is never used and should be removed



    
1171     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
1172         // (a + b - 1) / b can overflow on addition, so we distribute.
1173         return a == 0 ? 0 : (a - 1) / b + 1;
1174     }



```

```
MathUpgradeable.min(uint256,uint256) (StaderInsuranceFund.sol#1152-1154) is never used and should be removed



    
1152     function min(uint256 a, uint256 b) internal pure returns (uint256) {
1153         return a < b ? a : b;
1154     }



```

```
MathUpgradeable.sqrt(uint256) (StaderInsuranceFund.sol#1284-1315) is never used and should be removed



    
1284     function sqrt(uint256 a) internal pure returns (uint256) {
1285         if (a == 0) {
1286             return 0;
1287         }
1288 
1289         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
1290         //
1291         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
1292         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
1293         //
1294         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
1295         // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
1296         // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
1297         //
1298         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
1299         uint256 result = 1 << (log2(a) >> 1);
1300 
1301         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
1302         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
1303         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
1304         // into the expected uint128 result.
1305         unchecked {
1306             result = (result + a / result) >> 1;
1307             result = (result + a / result) >> 1;
1308             result = (result + a / result) >> 1;
1309             result = (result + a / result) >> 1;
1310             result = (result + a / result) >> 1;
1311             result = (result + a / result) >> 1;
1312             result = (result + a / result) >> 1;
1313             return min(result, a / result);
1314         }
1315     }



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (StaderInsuranceFund.sol#522-532) is never used and should be removed



    
522     function getOperatorAddressByValidatorId(
523         uint8 _poolId,
524         uint256 _validatorId,
525         IStaderConfig _staderConfig
526     ) internal view returns (address) {
527         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
530 
531         return operatorAddress;
532     }



```

```
UtilLib.getPubkeyRoot(bytes) (StaderInsuranceFund.sol#561-568) is never used and should be removed



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {
562         if (_pubkey.length != VALIDATOR_PUBKEY_LENGTH) {
563             revert InvalidPubkeyLength();
564         }
565 
566         // Append 16 bytes of zero padding to the pubkey and compute its hash to get the pubkey root.
567         return sha256(abi.encodePacked(_pubkey, bytes16(0)));
568     }



```

```
AccessControlUpgradeable.__AccessControl_init() (StaderInsuranceFund.sol#1636-1637) is never used and should be removed



    
1636     function __AccessControl_init() internal onlyInitializing {
1637     }



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (StaderInsuranceFund.sol#492-507) is never used and should be removed



    
492     function getOperatorForValidSender(
493         uint8 _poolId,
494         uint256 _validatorId,
495         address _addr,
496         IStaderConfig _staderConfig
497     ) internal view returns (address) {
498         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );
502         if (_addr != withdrawVaultAddress) {
503             revert CallerNotWithdrawVault();
504         }
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
506         return operator;
507     }



```

```
MathUpgradeable.log10(uint256,MathUpgradeable.Rounding) (StaderInsuranceFund.sol#1422-1427) is never used and should be removed



    
1422     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
1423         unchecked {
1424             uint256 result = log10(value);
1425             return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);
1426         }
1427     }



```

```
AddressUpgradeable.functionCall(address,bytes) (StaderInsuranceFund.sol#801-803) is never used and should be removed



    
801     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
802         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
803     }



```

```
ContextUpgradeable.__Context_init_unchained() (StaderInsuranceFund.sol#1110-1111) is never used and should be removed



    
1110     function __Context_init_unchained() internal onlyInitializing {
1111     }



```

```
ERC165Upgradeable.__ERC165_init_unchained() (StaderInsuranceFund.sol#1580-1581) is never used and should be removed



    
1580     function __ERC165_init_unchained() internal onlyInitializing {
1581     }



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (StaderInsuranceFund.sol#570-580) is never used and should be removed



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)
571         internal
572         view
573         returns (bool)
574     {
575         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getValidatorPoolId(_pubkey);
576         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
577         uint256 validatorId = INodeRegistry(nodeRegistry).validatorIdByPubkey(_pubkey);
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);
579         return IVaultProxy(withdrawVaultAddress).vaultSettleStatus();
580     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderInsuranceFund.sol#1181-1261) is never used and should be removed



    
1181     function mulDiv(
1182         uint256 x,
1183         uint256 y,
1184         uint256 denominator
1185     ) internal pure returns (uint256 result) {
1186         unchecked {
1187             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
1188             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
1189             // variables such that product = prod1 * 2^256 + prod0.
1190             uint256 prod0; // Least significant 256 bits of the product
1191             uint256 prod1; // Most significant 256 bits of the product
1192             assembly {
1193                 let mm := mulmod(x, y, not(0))
1194                 prod0 := mul(x, y)
1195                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1196             }
1197 
1198             // Handle non-overflow cases, 256 by 256 division.
1199             if (prod1 == 0) {
1200                 return prod0 / denominator;
1201             }
1202 
1203             // Make sure the result is less than 2^256. Also prevents denominator == 0.
1204             require(denominator > prod1);
1205 
1206             ///////////////////////////////////////////////
1207             // 512 by 256 division.
1208             ///////////////////////////////////////////////
1209 
1210             // Make division exact by subtracting the remainder from [prod1 prod0].
1211             uint256 remainder;
1212             assembly {
1213                 // Compute remainder using mulmod.
1214                 remainder := mulmod(x, y, denominator)
1215 
1216                 // Subtract 256 bit number from 512 bit number.
1217                 prod1 := sub(prod1, gt(remainder, prod0))
1218                 prod0 := sub(prod0, remainder)
1219             }
1220 
1221             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
1222             // See https://cs.stackexchange.com/q/138556/92363.
1223 
1224             // Does not overflow because the denominator cannot be zero at this stage in the function.
1225             uint256 twos = denominator & (~denominator + 1);
1226             assembly {
1227                 // Divide denominator by twos.
1228                 denominator := div(denominator, twos)
1229 
1230                 // Divide [prod1 prod0] by twos.
1231                 prod0 := div(prod0, twos)
1232 
1233                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1234                 twos := add(div(sub(0, twos), twos), 1)
1235             }
1236 
1237             // Shift in bits from prod1 into prod0.
1238             prod0 |= prod1 * twos;
1239 
1240             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
1241             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
1242             // four bits. That is, denominator * inv = 1 mod 2^4.
1243             uint256 inverse = (3 * denominator) ^ 2;
1244 
1245             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
1246             // in modular arithmetic, doubling the correct bits in each step.
1247             inverse *= 2 - denominator * inverse; // inverse mod 2^8
1248             inverse *= 2 - denominator * inverse; // inverse mod 2^16
1249             inverse *= 2 - denominator * inverse; // inverse mod 2^32
1250             inverse *= 2 - denominator * inverse; // inverse mod 2^64
1251             inverse *= 2 - denominator * inverse; // inverse mod 2^128
1252             inverse *= 2 - denominator * inverse; // inverse mod 2^256
1253 
1254             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
1255             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
1256             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
1257             // is no longer required.
1258             result = prod0 * inverse;
1259             return result;
1260         }
1261     }



```

```
AddressUpgradeable.functionCall(address,bytes,string) (StaderInsuranceFund.sol#811-817) is never used and should be removed



    
811     function functionCall(
812         address target,
813         bytes memory data,
814         string memory errorMessage
815     ) internal returns (bytes memory) {
816         return functionCallWithValue(target, data, 0, errorMessage);
817     }



```

```
AddressUpgradeable.sendValue(address,uint256) (StaderInsuranceFund.sol#776-781) is never used and should be removed



    
776     function sendValue(address payable recipient, uint256 amount) internal {
777         require(address(this).balance >= amount, "Address: insufficient balance");
778 
779         (bool success, ) = recipient.call{value: amount}("");
780         require(success, "Address: unable to send value, recipient may have reverted");
781     }



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (StaderInsuranceFund.sol#534-543) is never used and should be removed



    
534     function getOperatorAddressByOperatorId(
535         uint8 _poolId,
536         uint256 _operatorId,
537         IStaderConfig _staderConfig
538     ) internal view returns (address) {
539         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);
541 
542         return operatorAddress;
543     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes) (StaderInsuranceFund.sol#861-863) is never used and should be removed



    
861     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
862         return functionStaticCall(target, data, "Address: low-level static call failed");
863     }



```

```
MathUpgradeable.sqrt(uint256,MathUpgradeable.Rounding) (StaderInsuranceFund.sol#1320-1325) is never used and should be removed



    
1320     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
1321         unchecked {
1322             uint256 result = sqrt(a);
1323             return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
1324         }
1325     }



```

```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (StaderInsuranceFund.sol#509-520) is never used and should be removed



    
509     function onlyValidatorWithdrawVault(
510         uint8 _poolId,
511         uint256 _validatorId,
512         address _addr,
513         IStaderConfig _staderConfig
514     ) internal view {
515         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
517         if (_addr != withdrawVaultAddress) {
518             revert CallerNotWithdrawVault();
519         }
520     }



```

```
MathUpgradeable.log2(uint256) (StaderInsuranceFund.sol#1331-1367) is never used and should be removed



    
1331     function log2(uint256 value) internal pure returns (uint256) {
1332         uint256 result = 0;
1333         unchecked {
1334             if (value >> 128 > 0) {
1335                 value >>= 128;
1336                 result += 128;
1337             }
1338             if (value >> 64 > 0) {
1339                 value >>= 64;
1340                 result += 64;
1341             }
1342             if (value >> 32 > 0) {
1343                 value >>= 32;
1344                 result += 32;
1345             }
1346             if (value >> 16 > 0) {
1347                 value >>= 16;
1348                 result += 16;
1349             }
1350             if (value >> 8 > 0) {
1351                 value >>= 8;
1352                 result += 8;
1353             }
1354             if (value >> 4 > 0) {
1355                 value >>= 4;
1356                 result += 4;
1357             }
1358             if (value >> 2 > 0) {
1359                 value >>= 2;
1360                 result += 2;
1361             }
1362             if (value >> 1 > 0) {
1363                 result += 1;
1364             }
1365         }
1366         return result;
1367     }



```

```
UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig) (StaderInsuranceFund.sol#582-592) is never used and should be removed



    
582     function computeExchangeRate(
583         uint256 totalETHBalance,
584         uint256 totalETHXSupply,
585         IStaderConfig _staderConfig
586     ) internal view returns (uint256) {
587         uint256 DECIMALS = _staderConfig.getDecimals();
588         uint256 newExchangeRate = (totalETHBalance == 0 || totalETHXSupply == 0)
589             ? DECIMALS
590             : (totalETHBalance * DECIMALS) / totalETHXSupply;
591         return newExchangeRate;
592     }



```

```
AccessControlUpgradeable._setRoleAdmin(bytes32,bytes32) (StaderInsuranceFund.sol#1805-1809) is never used and should be removed



    
1805     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
1806         bytes32 previousAdminRole = getRoleAdmin(role);
1807         _roles[role].adminRole = adminRole;
1808         emit RoleAdminChanged(role, previousAdminRole, adminRole);
1809     }



```

```
MathUpgradeable.average(uint256,uint256) (StaderInsuranceFund.sol#1160-1163) is never used and should be removed



    
1160     function average(uint256 a, uint256 b) internal pure returns (uint256) {
1161         // (a + b) / 2 can overflow.
1162         return (a & b) + (a ^ b) / 2;
1163     }



```

```
StringsUpgradeable.toHexString(uint256) (StaderInsuranceFund.sol#1508-1512) is never used and should be removed



    
1508     function toHexString(uint256 value) internal pure returns (string memory) {
1509         unchecked {
1510             return toHexString(value, MathUpgradeable.log256(value) + 1);
1511         }
1512     }



```

```
MathUpgradeable.log10(uint256) (StaderInsuranceFund.sol#1384-1416) is never used and should be removed



    
1384     function log10(uint256 value) internal pure returns (uint256) {
1385         uint256 result = 0;
1386         unchecked {
1387             if (value >= 10**64) {
1388                 value /= 10**64;
1389                 result += 64;
1390             }
1391             if (value >= 10**32) {
1392                 value /= 10**32;
1393                 result += 32;
1394             }
1395             if (value >= 10**16) {
1396                 value /= 10**16;
1397                 result += 16;
1398             }
1399             if (value >= 10**8) {
1400                 value /= 10**8;
1401                 result += 8;
1402             }
1403             if (value >= 10**4) {
1404                 value /= 10**4;
1405                 result += 4;
1406             }
1407             if (value >= 10**2) {
1408                 value /= 10**2;
1409                 result += 2;
1410             }
1411             if (value >= 10**1) {
1412                 result += 1;
1413             }
1414         }
1415         return result;
1416     }



```

```
ERC165Upgradeable.__ERC165_init() (StaderInsuranceFund.sol#1577-1578) is never used and should be removed



    
1577     function __ERC165_init() internal onlyInitializing {
1578     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256,MathUpgradeable.Rounding) (StaderInsuranceFund.sol#1266-1277) is never used and should be removed



    
1266     function mulDiv(
1267         uint256 x,
1268         uint256 y,
1269         uint256 denominator,
1270         Rounding rounding
1271     ) internal pure returns (uint256) {
1272         uint256 result = mulDiv(x, y, denominator);
1273         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
1274             result += 1;
1275         }
1276         return result;
1277     }



```

```
AddressUpgradeable.verifyCallResult(bool,bytes,string) (StaderInsuranceFund.sol#910-920) is never used and should be removed



    
910     function verifyCallResult(
911         bool success,
912         bytes memory returndata,
913         string memory errorMessage
914     ) internal pure returns (bytes memory) {
915         if (success) {
916             return returndata;
917         } else {
918             _revert(returndata, errorMessage);
919         }
920     }



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (StaderInsuranceFund.sol#476-490) is never used and should be removed



    
476     function getPubkeyForValidSender(
477         uint8 _poolId,
478         uint256 _validatorId,
479         address _addr,
480         IStaderConfig _staderConfig
481     ) internal view returns (bytes memory) {
482         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );
486         if (_addr != withdrawVaultAddress) {
487             revert CallerNotWithdrawVault();
488         }
489         return pubkey;
490     }



```

```
AddressUpgradeable._revert(bytes,string) (StaderInsuranceFund.sol#922-934) is never used and should be removed



    
922     function _revert(bytes memory returndata, string memory errorMessage) private pure {
923         // Look for revert reason and bubble it up if present
924         if (returndata.length > 0) {
925             // The easiest way to bubble the revert reason is using memory via assembly
926             /// @solidity memory-safe-assembly
927             assembly {
928                 let returndata_size := mload(returndata)
929                 revert(add(32, returndata), returndata_size)
930             }
931         } else {
932             revert(errorMessage);
933         }
934     }



```

```
Initializable._getInitializedVersion() (StaderInsuranceFund.sol#1084-1086) is never used and should be removed



    
1084     function _getInitializedVersion() internal view returns (uint8) {
1085         return _initialized;
1086     }



```

```
AccessControlUpgradeable._setupRole(bytes32,address) (StaderInsuranceFund.sol#1796-1798) is never used and should be removed



    
1796     function _setupRole(bytes32 role, address account) internal virtual {
1797         _grantRole(role, account);
1798     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes,string) (StaderInsuranceFund.sol#871-878) is never used and should be removed



    
871     function functionStaticCall(
872         address target,
873         bytes memory data,
874         string memory errorMessage
875     ) internal view returns (bytes memory) {
876         (bool success, bytes memory returndata) = target.staticcall(data);
877         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
878     }



```

```
MathUpgradeable.log256(uint256,MathUpgradeable.Rounding) (StaderInsuranceFund.sol#1465-1470) is never used and should be removed



    
1465     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
1466         unchecked {
1467             uint256 result = log256(value);
1468             return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);
1469         }
1470     }



```

```
UtilLib.onlyOperatorRole(address,IStaderConfig) (StaderInsuranceFund.sol#459-463) is never used and should be removed



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {
460         if (!_staderConfig.onlyOperatorRole(_addr)) {
461             revert CallerNotOperator();
462         }
463     }



```

```
UtilLib.sendValue(address,uint256) (StaderInsuranceFund.sol#594-599) is never used and should be removed



    
594     function sendValue(address _receiver, uint256 _amount) internal {
595         (bool success, ) = payable(_receiver).call{value: _amount}('');
596         if (!success) {
597             revert TransferFailed();
598         }
599     }



```

```
MathUpgradeable.max(uint256,uint256) (StaderInsuranceFund.sol#1145-1147) is never used and should be removed



    
1145     function max(uint256 a, uint256 b) internal pure returns (uint256) {
1146         return a > b ? a : b;
1147     }



```

```
ContextUpgradeable.__Context_init() (StaderInsuranceFund.sol#1107-1108) is never used and should be removed



    
1107     function __Context_init() internal onlyInitializing {
1108     }



```

```
UtilLib.getOperatorRewardAddress(address,IStaderConfig) (StaderInsuranceFund.sol#545-554) is never used and should be removed



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)
546         internal
547         view
548         returns (address payable)
549     {
550         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getOperatorPoolId(_operator);
551         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
552         uint256 operatorId = INodeRegistry(nodeRegistry).operatorIDByAddress(_operator);
553         return INodeRegistry(nodeRegistry).getOperatorRewardAddress(operatorId);
554     }



```

```
AddressUpgradeable.verifyCallResultFromTarget(address,bool,bytes,string) (StaderInsuranceFund.sol#886-902) is never used and should be removed



    
886     function verifyCallResultFromTarget(
887         address target,
888         bool success,
889         bytes memory returndata,
890         string memory errorMessage
891     ) internal view returns (bytes memory) {
892         if (success) {
893             if (returndata.length == 0) {
894                 // only check isContract if the call was successful and the return data is empty
895                 // otherwise we already know that it was a contract
896                 require(isContract(target), "Address: call to non-contract");
897             }
898             return returndata;
899         } else {
900             _revert(returndata, errorMessage);
901         }
902     }



```

```
MathUpgradeable.log256(uint256) (StaderInsuranceFund.sol#1435-1459) is never used and should be removed



    
1435     function log256(uint256 value) internal pure returns (uint256) {
1436         uint256 result = 0;
1437         unchecked {
1438             if (value >> 128 > 0) {
1439                 value >>= 128;
1440                 result += 16;
1441             }
1442             if (value >> 64 > 0) {
1443                 value >>= 64;
1444                 result += 8;
1445             }
1446             if (value >> 32 > 0) {
1447                 value >>= 32;
1448                 result += 4;
1449             }
1450             if (value >> 16 > 0) {
1451                 value >>= 16;
1452                 result += 2;
1453             }
1454             if (value >> 8 > 0) {
1455                 result += 1;
1456             }
1457         }
1458         return result;
1459     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (StaderInsuranceFund.sol#844-853) is never used and should be removed



    
844     function functionCallWithValue(
845         address target,
846         bytes memory data,
847         uint256 value,
848         string memory errorMessage
849     ) internal returns (bytes memory) {
850         require(address(this).balance >= value, "Address: insufficient balance for call");
851         (bool success, bytes memory returndata) = target.call{value: value}(data);
852         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
853     }



```

### StaderOracle.sol


```
StringsUpgradeable.toString(uint256) (StaderOracle.sol#2032-2052) is never used and should be removed



    
2032     function toString(uint256 value) internal pure returns (string memory) {
2033         unchecked {
2034             uint256 length = MathUpgradeable.log10(value) + 1;
2035             string memory buffer = new string(length);
2036             uint256 ptr;
2037             /// @solidity memory-safe-assembly
2038             assembly {
2039                 ptr := add(buffer, add(32, length))
2040             }
2041             while (true) {
2042                 ptr--;
2043                 /// @solidity memory-safe-assembly
2044                 assembly {
2045                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
2046                 }
2047                 value /= 10;
2048                 if (value == 0) break;
2049             }
2050             return buffer;
2051         }
2052     }



```

```
ContextUpgradeable._msgData() (StaderOracle.sol#1467-1469) is never used and should be removed



    
1467     function _msgData() internal view virtual returns (bytes calldata) {
1468         return msg.data;
1469     }



```

```
MathUpgradeable.log2(uint256,MathUpgradeable.Rounding) (StaderOracle.sol#1922-1927) is never used and should be removed



    
1922     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
1923         unchecked {
1924             uint256 result = log2(value);
1925             return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
1926         }
1927     }



```

```
Initializable._isInitializing() (StaderOracle.sol#1442-1444) is never used and should be removed



    
1442     function _isInitializing() internal view returns (bool) {
1443         return _initializing;
1444     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256) (StaderOracle.sol#1181-1187) is never used and should be removed



    
1181     function functionCallWithValue(
1182         address target,
1183         bytes memory data,
1184         uint256 value
1185     ) internal returns (bytes memory) {
1186         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
1187     }



```

```
MathUpgradeable.ceilDiv(uint256,uint256) (StaderOracle.sol#1720-1723) is never used and should be removed



    
1720     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
1721         // (a + b - 1) / b can overflow on addition, so we distribute.
1722         return a == 0 ? 0 : (a - 1) / b + 1;
1723     }



```

```
MathUpgradeable.min(uint256,uint256) (StaderOracle.sol#1701-1703) is never used and should be removed



    
1701     function min(uint256 a, uint256 b) internal pure returns (uint256) {
1702         return a < b ? a : b;
1703     }



```

```
PausableUpgradeable._unpause() (StaderOracle.sol#1576-1579) is never used and should be removed



    
1576     function _unpause() internal virtual whenPaused {
1577         _paused = false;
1578         emit Unpaused(_msgSender());
1579     }



```

```
MathUpgradeable.sqrt(uint256) (StaderOracle.sol#1833-1864) is never used and should be removed



    
1833     function sqrt(uint256 a) internal pure returns (uint256) {
1834         if (a == 0) {
1835             return 0;
1836         }
1837 
1838         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
1839         //
1840         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
1841         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
1842         //
1843         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
1844         // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
1845         // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
1846         //
1847         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
1848         uint256 result = 1 << (log2(a) >> 1);
1849 
1850         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
1851         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
1852         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
1853         // into the expected uint128 result.
1854         unchecked {
1855             result = (result + a / result) >> 1;
1856             result = (result + a / result) >> 1;
1857             result = (result + a / result) >> 1;
1858             result = (result + a / result) >> 1;
1859             result = (result + a / result) >> 1;
1860             result = (result + a / result) >> 1;
1861             result = (result + a / result) >> 1;
1862             return min(result, a / result);
1863         }
1864     }



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (StaderOracle.sol#522-532) is never used and should be removed



    
522     function getOperatorAddressByValidatorId(
523         uint8 _poolId,
524         uint256 _validatorId,
525         IStaderConfig _staderConfig
526     ) internal view returns (address) {
527         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
530 
531         return operatorAddress;
532     }



```

```
PausableUpgradeable._requirePaused() (StaderOracle.sol#1553-1555) is never used and should be removed



    
1553     function _requirePaused() internal view virtual {
1554         require(paused(), "Pausable: not paused");
1555     }



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (StaderOracle.sol#492-507) is never used and should be removed



    
492     function getOperatorForValidSender(
493         uint8 _poolId,
494         uint256 _validatorId,
495         address _addr,
496         IStaderConfig _staderConfig
497     ) internal view returns (address) {
498         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );
502         if (_addr != withdrawVaultAddress) {
503             revert CallerNotWithdrawVault();
504         }
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
506         return operator;
507     }



```

```
MathUpgradeable.log10(uint256,MathUpgradeable.Rounding) (StaderOracle.sol#1971-1976) is never used and should be removed



    
1971     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
1972         unchecked {
1973             uint256 result = log10(value);
1974             return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);
1975         }
1976     }



```

```
AddressUpgradeable.functionCall(address,bytes) (StaderOracle.sol#1152-1154) is never used and should be removed



    
1152     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
1153         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
1154     }



```

```
ContextUpgradeable.__Context_init_unchained() (StaderOracle.sol#1461-1462) is never used and should be removed



    
1461     function __Context_init_unchained() internal onlyInitializing {
1462     }



```

```
ERC165Upgradeable.__ERC165_init_unchained() (StaderOracle.sol#2129-2130) is never used and should be removed



    
2129     function __ERC165_init_unchained() internal onlyInitializing {
2130     }



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (StaderOracle.sol#570-580) is never used and should be removed



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)
571         internal
572         view
573         returns (bool)
574     {
575         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getValidatorPoolId(_pubkey);
576         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
577         uint256 validatorId = INodeRegistry(nodeRegistry).validatorIdByPubkey(_pubkey);
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);
579         return IVaultProxy(withdrawVaultAddress).vaultSettleStatus();
580     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderOracle.sol#1730-1810) is never used and should be removed



    
1730     function mulDiv(
1731         uint256 x,
1732         uint256 y,
1733         uint256 denominator
1734     ) internal pure returns (uint256 result) {
1735         unchecked {
1736             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
1737             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
1738             // variables such that product = prod1 * 2^256 + prod0.
1739             uint256 prod0; // Least significant 256 bits of the product
1740             uint256 prod1; // Most significant 256 bits of the product
1741             assembly {
1742                 let mm := mulmod(x, y, not(0))
1743                 prod0 := mul(x, y)
1744                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1745             }
1746 
1747             // Handle non-overflow cases, 256 by 256 division.
1748             if (prod1 == 0) {
1749                 return prod0 / denominator;
1750             }
1751 
1752             // Make sure the result is less than 2^256. Also prevents denominator == 0.
1753             require(denominator > prod1);
1754 
1755             ///////////////////////////////////////////////
1756             // 512 by 256 division.
1757             ///////////////////////////////////////////////
1758 
1759             // Make division exact by subtracting the remainder from [prod1 prod0].
1760             uint256 remainder;
1761             assembly {
1762                 // Compute remainder using mulmod.
1763                 remainder := mulmod(x, y, denominator)
1764 
1765                 // Subtract 256 bit number from 512 bit number.
1766                 prod1 := sub(prod1, gt(remainder, prod0))
1767                 prod0 := sub(prod0, remainder)
1768             }
1769 
1770             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
1771             // See https://cs.stackexchange.com/q/138556/92363.
1772 
1773             // Does not overflow because the denominator cannot be zero at this stage in the function.
1774             uint256 twos = denominator & (~denominator + 1);
1775             assembly {
1776                 // Divide denominator by twos.
1777                 denominator := div(denominator, twos)
1778 
1779                 // Divide [prod1 prod0] by twos.
1780                 prod0 := div(prod0, twos)
1781 
1782                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1783                 twos := add(div(sub(0, twos), twos), 1)
1784             }
1785 
1786             // Shift in bits from prod1 into prod0.
1787             prod0 |= prod1 * twos;
1788 
1789             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
1790             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
1791             // four bits. That is, denominator * inv = 1 mod 2^4.
1792             uint256 inverse = (3 * denominator) ^ 2;
1793 
1794             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
1795             // in modular arithmetic, doubling the correct bits in each step.
1796             inverse *= 2 - denominator * inverse; // inverse mod 2^8
1797             inverse *= 2 - denominator * inverse; // inverse mod 2^16
1798             inverse *= 2 - denominator * inverse; // inverse mod 2^32
1799             inverse *= 2 - denominator * inverse; // inverse mod 2^64
1800             inverse *= 2 - denominator * inverse; // inverse mod 2^128
1801             inverse *= 2 - denominator * inverse; // inverse mod 2^256
1802 
1803             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
1804             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
1805             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
1806             // is no longer required.
1807             result = prod0 * inverse;
1808             return result;
1809         }
1810     }



```

```
AddressUpgradeable.functionCall(address,bytes,string) (StaderOracle.sol#1162-1168) is never used and should be removed



    
1162     function functionCall(
1163         address target,
1164         bytes memory data,
1165         string memory errorMessage
1166     ) internal returns (bytes memory) {
1167         return functionCallWithValue(target, data, 0, errorMessage);
1168     }



```

```
AddressUpgradeable.sendValue(address,uint256) (StaderOracle.sol#1127-1132) is never used and should be removed



    
1127     function sendValue(address payable recipient, uint256 amount) internal {
1128         require(address(this).balance >= amount, "Address: insufficient balance");
1129 
1130         (bool success, ) = recipient.call{value: amount}("");
1131         require(success, "Address: unable to send value, recipient may have reverted");
1132     }



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (StaderOracle.sol#534-543) is never used and should be removed



    
534     function getOperatorAddressByOperatorId(
535         uint8 _poolId,
536         uint256 _operatorId,
537         IStaderConfig _staderConfig
538     ) internal view returns (address) {
539         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);
541 
542         return operatorAddress;
543     }



```

```
UtilLib.onlyStaderContract(address,IStaderConfig,bytes32) (StaderOracle.sol#466-474) is never used and should be removed



    
466     function onlyStaderContract(
467         address _addr,
468         IStaderConfig _staderConfig,
469         bytes32 _contractName
470     ) internal view {
471         if (!_staderConfig.onlyStaderContract(_addr, _contractName)) {
472             revert CallerNotStaderContract();
473         }
474     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes) (StaderOracle.sol#1212-1214) is never used and should be removed



    
1212     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
1213         return functionStaticCall(target, data, "Address: low-level static call failed");
1214     }



```

```
MathUpgradeable.sqrt(uint256,MathUpgradeable.Rounding) (StaderOracle.sol#1869-1874) is never used and should be removed



    
1869     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
1870         unchecked {
1871             uint256 result = sqrt(a);
1872             return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
1873         }
1874     }



```

```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (StaderOracle.sol#509-520) is never used and should be removed



    
509     function onlyValidatorWithdrawVault(
510         uint8 _poolId,
511         uint256 _validatorId,
512         address _addr,
513         IStaderConfig _staderConfig
514     ) internal view {
515         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
517         if (_addr != withdrawVaultAddress) {
518             revert CallerNotWithdrawVault();
519         }
520     }



```

```
MathUpgradeable.log2(uint256) (StaderOracle.sol#1880-1916) is never used and should be removed



    
1880     function log2(uint256 value) internal pure returns (uint256) {
1881         uint256 result = 0;
1882         unchecked {
1883             if (value >> 128 > 0) {
1884                 value >>= 128;
1885                 result += 128;
1886             }
1887             if (value >> 64 > 0) {
1888                 value >>= 64;
1889                 result += 64;
1890             }
1891             if (value >> 32 > 0) {
1892                 value >>= 32;
1893                 result += 32;
1894             }
1895             if (value >> 16 > 0) {
1896                 value >>= 16;
1897                 result += 16;
1898             }
1899             if (value >> 8 > 0) {
1900                 value >>= 8;
1901                 result += 8;
1902             }
1903             if (value >> 4 > 0) {
1904                 value >>= 4;
1905                 result += 4;
1906             }
1907             if (value >> 2 > 0) {
1908                 value >>= 2;
1909                 result += 2;
1910             }
1911             if (value >> 1 > 0) {
1912                 result += 1;
1913             }
1914         }
1915         return result;
1916     }



```

```
AccessControlUpgradeable._setRoleAdmin(bytes32,bytes32) (StaderOracle.sol#2354-2358) is never used and should be removed



    
2354     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
2355         bytes32 previousAdminRole = getRoleAdmin(role);
2356         _roles[role].adminRole = adminRole;
2357         emit RoleAdminChanged(role, previousAdminRole, adminRole);
2358     }



```

```
MathUpgradeable.average(uint256,uint256) (StaderOracle.sol#1709-1712) is never used and should be removed



    
1709     function average(uint256 a, uint256 b) internal pure returns (uint256) {
1710         // (a + b) / 2 can overflow.
1711         return (a & b) + (a ^ b) / 2;
1712     }



```

```
StringsUpgradeable.toHexString(uint256) (StaderOracle.sol#2057-2061) is never used and should be removed



    
2057     function toHexString(uint256 value) internal pure returns (string memory) {
2058         unchecked {
2059             return toHexString(value, MathUpgradeable.log256(value) + 1);
2060         }
2061     }



```

```
MathUpgradeable.log10(uint256) (StaderOracle.sol#1933-1965) is never used and should be removed



    
1933     function log10(uint256 value) internal pure returns (uint256) {
1934         uint256 result = 0;
1935         unchecked {
1936             if (value >= 10**64) {
1937                 value /= 10**64;
1938                 result += 64;
1939             }
1940             if (value >= 10**32) {
1941                 value /= 10**32;
1942                 result += 32;
1943             }
1944             if (value >= 10**16) {
1945                 value /= 10**16;
1946                 result += 16;
1947             }
1948             if (value >= 10**8) {
1949                 value /= 10**8;
1950                 result += 8;
1951             }
1952             if (value >= 10**4) {
1953                 value /= 10**4;
1954                 result += 4;
1955             }
1956             if (value >= 10**2) {
1957                 value /= 10**2;
1958                 result += 2;
1959             }
1960             if (value >= 10**1) {
1961                 result += 1;
1962             }
1963         }
1964         return result;
1965     }



```

```
ERC165Upgradeable.__ERC165_init() (StaderOracle.sol#2126-2127) is never used and should be removed



    
2126     function __ERC165_init() internal onlyInitializing {
2127     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256,MathUpgradeable.Rounding) (StaderOracle.sol#1815-1826) is never used and should be removed



    
1815     function mulDiv(
1816         uint256 x,
1817         uint256 y,
1818         uint256 denominator,
1819         Rounding rounding
1820     ) internal pure returns (uint256) {
1821         uint256 result = mulDiv(x, y, denominator);
1822         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
1823             result += 1;
1824         }
1825         return result;
1826     }



```

```
PausableUpgradeable._pause() (StaderOracle.sol#1564-1567) is never used and should be removed



    
1564     function _pause() internal virtual whenNotPaused {
1565         _paused = true;
1566         emit Paused(_msgSender());
1567     }



```

```
AddressUpgradeable.verifyCallResult(bool,bytes,string) (StaderOracle.sol#1261-1271) is never used and should be removed



    
1261     function verifyCallResult(
1262         bool success,
1263         bytes memory returndata,
1264         string memory errorMessage
1265     ) internal pure returns (bytes memory) {
1266         if (success) {
1267             return returndata;
1268         } else {
1269             _revert(returndata, errorMessage);
1270         }
1271     }



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (StaderOracle.sol#476-490) is never used and should be removed



    
476     function getPubkeyForValidSender(
477         uint8 _poolId,
478         uint256 _validatorId,
479         address _addr,
480         IStaderConfig _staderConfig
481     ) internal view returns (bytes memory) {
482         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );
486         if (_addr != withdrawVaultAddress) {
487             revert CallerNotWithdrawVault();
488         }
489         return pubkey;
490     }



```

```
AccessControlUpgradeable.__AccessControl_init_unchained() (StaderOracle.sol#2188-2189) is never used and should be removed



    
2188     function __AccessControl_init_unchained() internal onlyInitializing {
2189     }



```

```
AddressUpgradeable._revert(bytes,string) (StaderOracle.sol#1273-1285) is never used and should be removed



    
1273     function _revert(bytes memory returndata, string memory errorMessage) private pure {
1274         // Look for revert reason and bubble it up if present
1275         if (returndata.length > 0) {
1276             // The easiest way to bubble the revert reason is using memory via assembly
1277             /// @solidity memory-safe-assembly
1278             assembly {
1279                 let returndata_size := mload(returndata)
1280                 revert(add(32, returndata), returndata_size)
1281             }
1282         } else {
1283             revert(errorMessage);
1284         }
1285     }



```

```
Initializable._getInitializedVersion() (StaderOracle.sol#1435-1437) is never used and should be removed



    
1435     function _getInitializedVersion() internal view returns (uint8) {
1436         return _initialized;
1437     }



```

```
AccessControlUpgradeable._setupRole(bytes32,address) (StaderOracle.sol#2345-2347) is never used and should be removed



    
2345     function _setupRole(bytes32 role, address account) internal virtual {
2346         _grantRole(role, account);
2347     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes,string) (StaderOracle.sol#1222-1229) is never used and should be removed



    
1222     function functionStaticCall(
1223         address target,
1224         bytes memory data,
1225         string memory errorMessage
1226     ) internal view returns (bytes memory) {
1227         (bool success, bytes memory returndata) = target.staticcall(data);
1228         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
1229     }



```

```
MathUpgradeable.log256(uint256,MathUpgradeable.Rounding) (StaderOracle.sol#2014-2019) is never used and should be removed



    
2014     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
2015         unchecked {
2016             uint256 result = log256(value);
2017             return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);
2018         }
2019     }



```

```
UtilLib.onlyOperatorRole(address,IStaderConfig) (StaderOracle.sol#459-463) is never used and should be removed



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {
460         if (!_staderConfig.onlyOperatorRole(_addr)) {
461             revert CallerNotOperator();
462         }
463     }



```

```
UtilLib.sendValue(address,uint256) (StaderOracle.sol#594-599) is never used and should be removed



    
594     function sendValue(address _receiver, uint256 _amount) internal {
595         (bool success, ) = payable(_receiver).call{value: _amount}('');
596         if (!success) {
597             revert TransferFailed();
598         }
599     }



```

```
MathUpgradeable.max(uint256,uint256) (StaderOracle.sol#1694-1696) is never used and should be removed



    
1694     function max(uint256 a, uint256 b) internal pure returns (uint256) {
1695         return a > b ? a : b;
1696     }



```

```
ContextUpgradeable.__Context_init() (StaderOracle.sol#1458-1459) is never used and should be removed



    
1458     function __Context_init() internal onlyInitializing {
1459     }



```

```
UtilLib.getOperatorRewardAddress(address,IStaderConfig) (StaderOracle.sol#545-554) is never used and should be removed



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)
546         internal
547         view
548         returns (address payable)
549     {
550         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getOperatorPoolId(_operator);
551         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
552         uint256 operatorId = INodeRegistry(nodeRegistry).operatorIDByAddress(_operator);
553         return INodeRegistry(nodeRegistry).getOperatorRewardAddress(operatorId);
554     }



```

```
AddressUpgradeable.verifyCallResultFromTarget(address,bool,bytes,string) (StaderOracle.sol#1237-1253) is never used and should be removed



    
1237     function verifyCallResultFromTarget(
1238         address target,
1239         bool success,
1240         bytes memory returndata,
1241         string memory errorMessage
1242     ) internal view returns (bytes memory) {
1243         if (success) {
1244             if (returndata.length == 0) {
1245                 // only check isContract if the call was successful and the return data is empty
1246                 // otherwise we already know that it was a contract
1247                 require(isContract(target), "Address: call to non-contract");
1248             }
1249             return returndata;
1250         } else {
1251             _revert(returndata, errorMessage);
1252         }
1253     }



```

```
MathUpgradeable.log256(uint256) (StaderOracle.sol#1984-2008) is never used and should be removed



    
1984     function log256(uint256 value) internal pure returns (uint256) {
1985         uint256 result = 0;
1986         unchecked {
1987             if (value >> 128 > 0) {
1988                 value >>= 128;
1989                 result += 16;
1990             }
1991             if (value >> 64 > 0) {
1992                 value >>= 64;
1993                 result += 8;
1994             }
1995             if (value >> 32 > 0) {
1996                 value >>= 32;
1997                 result += 4;
1998             }
1999             if (value >> 16 > 0) {
2000                 value >>= 16;
2001                 result += 2;
2002             }
2003             if (value >> 8 > 0) {
2004                 result += 1;
2005             }
2006         }
2007         return result;
2008     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (StaderOracle.sol#1195-1204) is never used and should be removed



    
1195     function functionCallWithValue(
1196         address target,
1197         bytes memory data,
1198         uint256 value,
1199         string memory errorMessage
1200     ) internal returns (bytes memory) {
1201         require(address(this).balance >= value, "Address: insufficient balance for call");
1202         (bool success, bytes memory returndata) = target.call{value: value}(data);
1203         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
1204     }



```

### StaderStakePoolsManager.sol


```
StringsUpgradeable.toString(uint256) (StaderStakePoolsManager.sol#1956-1976) is never used and should be removed



    
1956     function toString(uint256 value) internal pure returns (string memory) {
1957         unchecked {
1958             uint256 length = MathUpgradeable.log10(value) + 1;
1959             string memory buffer = new string(length);
1960             uint256 ptr;
1961             /// @solidity memory-safe-assembly
1962             assembly {
1963                 ptr := add(buffer, add(32, length))
1964             }
1965             while (true) {
1966                 ptr--;
1967                 /// @solidity memory-safe-assembly
1968                 assembly {
1969                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
1970                 }
1971                 value /= 10;
1972                 if (value == 0) break;
1973             }
1974             return buffer;
1975         }
1976     }



```

```
SafeMath.mul(uint256,uint256) (StaderStakePoolsManager.sol#3426-3428) is never used and should be removed



    
3426     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
3427         return a * b;
3428     }



```

```
ContextUpgradeable._msgData() (StaderStakePoolsManager.sol#1109-1111) is never used and should be removed



    
1109     function _msgData() internal view virtual returns (bytes calldata) {
1110         return msg.data;
1111     }



```

```
MathUpgradeable.log2(uint256,MathUpgradeable.Rounding) (StaderStakePoolsManager.sol#1846-1851) is never used and should be removed



    
1846     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
1847         unchecked {
1848             uint256 result = log2(value);
1849             return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
1850         }
1851     }



```

```
Initializable._isInitializing() (StaderStakePoolsManager.sol#1084-1086) is never used and should be removed



    
1084     function _isInitializing() internal view returns (bool) {
1085         return _initializing;
1086     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256) (StaderStakePoolsManager.sol#823-829) is never used and should be removed



    
823     function functionCallWithValue(
824         address target,
825         bytes memory data,
826         uint256 value
827     ) internal returns (bytes memory) {
828         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
829     }



```

```
SafeMath.sub(uint256,uint256) (StaderStakePoolsManager.sol#3412-3414) is never used and should be removed



    
3412     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
3413         return a - b;
3414     }



```

```
MathUpgradeable.ceilDiv(uint256,uint256) (StaderStakePoolsManager.sol#1644-1647) is never used and should be removed



    
1644     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
1645         // (a + b - 1) / b can overflow on addition, so we distribute.
1646         return a == 0 ? 0 : (a - 1) / b + 1;
1647     }



```

```
SafeMath.tryDiv(uint256,uint256) (StaderStakePoolsManager.sol#3369-3374) is never used and should be removed



    
3369     function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
3370         unchecked {
3371             if (b == 0) return (false, 0);
3372             return (true, a / b);
3373         }
3374     }



```

```
MathUpgradeable.min(uint256,uint256) (StaderStakePoolsManager.sol#1625-1627) is never used and should be removed



    
1625     function min(uint256 a, uint256 b) internal pure returns (uint256) {
1626         return a < b ? a : b;
1627     }



```

```
MathUpgradeable.sqrt(uint256) (StaderStakePoolsManager.sol#1757-1788) is never used and should be removed



    
1757     function sqrt(uint256 a) internal pure returns (uint256) {
1758         if (a == 0) {
1759             return 0;
1760         }
1761 
1762         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
1763         //
1764         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
1765         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
1766         //
1767         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
1768         // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
1769         // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
1770         //
1771         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
1772         uint256 result = 1 << (log2(a) >> 1);
1773 
1774         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
1775         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
1776         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
1777         // into the expected uint128 result.
1778         unchecked {
1779             result = (result + a / result) >> 1;
1780             result = (result + a / result) >> 1;
1781             result = (result + a / result) >> 1;
1782             result = (result + a / result) >> 1;
1783             result = (result + a / result) >> 1;
1784             result = (result + a / result) >> 1;
1785             result = (result + a / result) >> 1;
1786             return min(result, a / result);
1787         }
1788     }



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (StaderStakePoolsManager.sol#523-533) is never used and should be removed



    
523     function getOperatorAddressByValidatorId(
524         uint8 _poolId,
525         uint256 _validatorId,
526         IStaderConfig _staderConfig
527     ) internal view returns (address) {
528         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
529         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
530         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
531 
532         return operatorAddress;
533     }



```

```
Math.ceilDiv(uint256,uint256) (StaderStakePoolsManager.sol#3126-3129) is never used and should be removed



    
3126     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
3127         // (a + b - 1) / b can overflow on addition, so we distribute.
3128         return a == 0 ? 0 : (a - 1) / b + 1;
3129     }



```

```
UtilLib.getPubkeyRoot(bytes) (StaderStakePoolsManager.sol#562-569) is never used and should be removed



    
562     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {
563         if (_pubkey.length != VALIDATOR_PUBKEY_LENGTH) {
564             revert InvalidPubkeyLength();
565         }
566 
567         // Append 16 bytes of zero padding to the pubkey and compute its hash to get the pubkey root.
568         return sha256(abi.encodePacked(_pubkey, bytes16(0)));
569     }



```

```
SafeMath.add(uint256,uint256) (StaderStakePoolsManager.sol#3398-3400) is never used and should be removed



    
3398     function add(uint256 a, uint256 b) internal pure returns (uint256) {
3399         return a + b;
3400     }



```

```
SafeMath.tryMod(uint256,uint256) (StaderStakePoolsManager.sol#3381-3386) is never used and should be removed



    
3381     function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
3382         unchecked {
3383             if (b == 0) return (false, 0);
3384             return (true, a % b);
3385         }
3386     }



```

```
SafeMath.sub(uint256,uint256,string) (StaderStakePoolsManager.sol#3473-3482) is never used and should be removed



    
3473     function sub(
3474         uint256 a,
3475         uint256 b,
3476         string memory errorMessage
3477     ) internal pure returns (uint256) {
3478         unchecked {
3479             require(b <= a, errorMessage);
3480             return a - b;
3481         }
3482     }



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (StaderStakePoolsManager.sol#493-508) is never used and should be removed



    
493     function getOperatorForValidSender(
494         uint8 _poolId,
495         uint256 _validatorId,
496         address _addr,
497         IStaderConfig _staderConfig
498     ) internal view returns (address) {
499         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
500         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
501             _validatorId
502         );
503         if (_addr != withdrawVaultAddress) {
504             revert CallerNotWithdrawVault();
505         }
506         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
507         return operator;
508     }



```

```
MathUpgradeable.log10(uint256,MathUpgradeable.Rounding) (StaderStakePoolsManager.sol#1895-1900) is never used and should be removed



    
1895     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
1896         unchecked {
1897             uint256 result = log10(value);
1898             return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);
1899         }
1900     }



```

```
AddressUpgradeable.functionCall(address,bytes) (StaderStakePoolsManager.sol#794-796) is never used and should be removed



    
794     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
795         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
796     }



```

```
Math.sqrt(uint256,Math.Rounding) (StaderStakePoolsManager.sol#3300-3306) is never used and should be removed



    
3300     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
3301         uint256 result = sqrt(a);
3302         if (rounding == Rounding.Up && result * result < a) {
3303             result += 1;
3304         }
3305         return result;
3306     }



```

```
ContextUpgradeable.__Context_init_unchained() (StaderStakePoolsManager.sol#1103-1104) is never used and should be removed



    
1103     function __Context_init_unchained() internal onlyInitializing {
1104     }



```

```
Math.max(uint256,uint256) (StaderStakePoolsManager.sol#3100-3102) is never used and should be removed



    
3100     function max(uint256 a, uint256 b) internal pure returns (uint256) {
3101         return a >= b ? a : b;
3102     }



```

```
ERC165Upgradeable.__ERC165_init_unchained() (StaderStakePoolsManager.sol#2053-2054) is never used and should be removed



    
2053     function __ERC165_init_unchained() internal onlyInitializing {
2054     }



```

```
Math.average(uint256,uint256) (StaderStakePoolsManager.sol#3115-3118) is never used and should be removed



    
3115     function average(uint256 a, uint256 b) internal pure returns (uint256) {
3116         // (a + b) / 2 can overflow.
3117         return (a & b) + (a ^ b) / 2;
3118     }



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (StaderStakePoolsManager.sol#571-581) is never used and should be removed



    
571     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)
572         internal
573         view
574         returns (bool)
575     {
576         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getValidatorPoolId(_pubkey);
577         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
578         uint256 validatorId = INodeRegistry(nodeRegistry).validatorIdByPubkey(_pubkey);
579         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);
580         return IVaultProxy(withdrawVaultAddress).vaultSettleStatus();
581     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (StaderStakePoolsManager.sol#1654-1734) is never used and should be removed



    
1654     function mulDiv(
1655         uint256 x,
1656         uint256 y,
1657         uint256 denominator
1658     ) internal pure returns (uint256 result) {
1659         unchecked {
1660             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
1661             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
1662             // variables such that product = prod1 * 2^256 + prod0.
1663             uint256 prod0; // Least significant 256 bits of the product
1664             uint256 prod1; // Most significant 256 bits of the product
1665             assembly {
1666                 let mm := mulmod(x, y, not(0))
1667                 prod0 := mul(x, y)
1668                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1669             }
1670 
1671             // Handle non-overflow cases, 256 by 256 division.
1672             if (prod1 == 0) {
1673                 return prod0 / denominator;
1674             }
1675 
1676             // Make sure the result is less than 2^256. Also prevents denominator == 0.
1677             require(denominator > prod1);
1678 
1679             ///////////////////////////////////////////////
1680             // 512 by 256 division.
1681             ///////////////////////////////////////////////
1682 
1683             // Make division exact by subtracting the remainder from [prod1 prod0].
1684             uint256 remainder;
1685             assembly {
1686                 // Compute remainder using mulmod.
1687                 remainder := mulmod(x, y, denominator)
1688 
1689                 // Subtract 256 bit number from 512 bit number.
1690                 prod1 := sub(prod1, gt(remainder, prod0))
1691                 prod0 := sub(prod0, remainder)
1692             }
1693 
1694             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
1695             // See https://cs.stackexchange.com/q/138556/92363.
1696 
1697             // Does not overflow because the denominator cannot be zero at this stage in the function.
1698             uint256 twos = denominator & (~denominator + 1);
1699             assembly {
1700                 // Divide denominator by twos.
1701                 denominator := div(denominator, twos)
1702 
1703                 // Divide [prod1 prod0] by twos.
1704                 prod0 := div(prod0, twos)
1705 
1706                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1707                 twos := add(div(sub(0, twos), twos), 1)
1708             }
1709 
1710             // Shift in bits from prod1 into prod0.
1711             prod0 |= prod1 * twos;
1712 
1713             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
1714             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
1715             // four bits. That is, denominator * inv = 1 mod 2^4.
1716             uint256 inverse = (3 * denominator) ^ 2;
1717 
1718             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
1719             // in modular arithmetic, doubling the correct bits in each step.
1720             inverse *= 2 - denominator * inverse; // inverse mod 2^8
1721             inverse *= 2 - denominator * inverse; // inverse mod 2^16
1722             inverse *= 2 - denominator * inverse; // inverse mod 2^32
1723             inverse *= 2 - denominator * inverse; // inverse mod 2^64
1724             inverse *= 2 - denominator * inverse; // inverse mod 2^128
1725             inverse *= 2 - denominator * inverse; // inverse mod 2^256
1726 
1727             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
1728             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
1729             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
1730             // is no longer required.
1731             result = prod0 * inverse;
1732             return result;
1733         }
1734     }



```

```
AddressUpgradeable.functionCall(address,bytes,string) (StaderStakePoolsManager.sol#804-810) is never used and should be removed



    
804     function functionCall(
805         address target,
806         bytes memory data,
807         string memory errorMessage
808     ) internal returns (bytes memory) {
809         return functionCallWithValue(target, data, 0, errorMessage);
810     }



```

```
AddressUpgradeable.sendValue(address,uint256) (StaderStakePoolsManager.sol#769-774) is never used and should be removed



    
769     function sendValue(address payable recipient, uint256 amount) internal {
770         require(address(this).balance >= amount, "Address: insufficient balance");
771 
772         (bool success, ) = recipient.call{value: amount}("");
773         require(success, "Address: unable to send value, recipient may have reverted");
774     }



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (StaderStakePoolsManager.sol#535-544) is never used and should be removed



    
535     function getOperatorAddressByOperatorId(
536         uint8 _poolId,
537         uint256 _operatorId,
538         IStaderConfig _staderConfig
539     ) internal view returns (address) {
540         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
541         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);
542 
543         return operatorAddress;
544     }



```

```
SafeMath.tryAdd(uint256,uint256) (StaderStakePoolsManager.sol#3327-3333) is never used and should be removed



    
3327     function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
3328         unchecked {
3329             uint256 c = a + b;
3330             if (c < a) return (false, 0);
3331             return (true, c);
3332         }
3333     }



```

```
SafeMath.mod(uint256,uint256,string) (StaderStakePoolsManager.sol#3522-3531) is never used and should be removed



    
3522     function mod(
3523         uint256 a,
3524         uint256 b,
3525         string memory errorMessage
3526     ) internal pure returns (uint256) {
3527         unchecked {
3528             require(b > 0, errorMessage);
3529             return a % b;
3530         }
3531     }



```

```
Math.sqrt(uint256) (StaderStakePoolsManager.sol#3239-3295) is never used and should be removed



    
3239     function sqrt(uint256 a) internal pure returns (uint256) {
3240         if (a == 0) {
3241             return 0;
3242         }
3243 
3244         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
3245         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
3246         // `msb(a) <= a < 2*msb(a)`.
3247         // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.
3248         // This gives `2**k < a <= 2**(k+1)` → `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.
3249         // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a
3250         // good first aproximation of `sqrt(a)` with at least 1 correct bit.
3251         uint256 result = 1;
3252         uint256 x = a;
3253         if (x >> 128 > 0) {
3254             x >>= 128;
3255             result <<= 64;
3256         }
3257         if (x >> 64 > 0) {
3258             x >>= 64;
3259             result <<= 32;
3260         }
3261         if (x >> 32 > 0) {
3262             x >>= 32;
3263             result <<= 16;
3264         }
3265         if (x >> 16 > 0) {
3266             x >>= 16;
3267             result <<= 8;
3268         }
3269         if (x >> 8 > 0) {
3270             x >>= 8;
3271             result <<= 4;
3272         }
3273         if (x >> 4 > 0) {
3274             x >>= 4;
3275             result <<= 2;
3276         }
3277         if (x >> 2 > 0) {
3278             result <<= 1;
3279         }
3280 
3281         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
3282         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
3283         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
3284         // into the expected uint128 result.
3285         unchecked {
3286             result = (result + a / result) >> 1;
3287             result = (result + a / result) >> 1;
3288             result = (result + a / result) >> 1;
3289             result = (result + a / result) >> 1;
3290             result = (result + a / result) >> 1;
3291             result = (result + a / result) >> 1;
3292             result = (result + a / result) >> 1;
3293             return min(result, a / result);
3294         }
3295     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes) (StaderStakePoolsManager.sol#854-856) is never used and should be removed



    
854     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
855         return functionStaticCall(target, data, "Address: low-level static call failed");
856     }



```

```
MathUpgradeable.sqrt(uint256,MathUpgradeable.Rounding) (StaderStakePoolsManager.sol#1793-1798) is never used and should be removed



    
1793     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
1794         unchecked {
1795             uint256 result = sqrt(a);
1796             return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
1797         }
1798     }



```

```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (StaderStakePoolsManager.sol#510-521) is never used and should be removed



    
510     function onlyValidatorWithdrawVault(
511         uint8 _poolId,
512         uint256 _validatorId,
513         address _addr,
514         IStaderConfig _staderConfig
515     ) internal view {
516         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
517         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
518         if (_addr != withdrawVaultAddress) {
519             revert CallerNotWithdrawVault();
520         }
521     }



```

```
SafeMath.div(uint256,uint256,string) (StaderStakePoolsManager.sol#3496-3505) is never used and should be removed



    
3496     function div(
3497         uint256 a,
3498         uint256 b,
3499         string memory errorMessage
3500     ) internal pure returns (uint256) {
3501         unchecked {
3502             require(b > 0, errorMessage);
3503             return a / b;
3504         }
3505     }



```

```
MathUpgradeable.log2(uint256) (StaderStakePoolsManager.sol#1804-1840) is never used and should be removed



    
1804     function log2(uint256 value) internal pure returns (uint256) {
1805         uint256 result = 0;
1806         unchecked {
1807             if (value >> 128 > 0) {
1808                 value >>= 128;
1809                 result += 128;
1810             }
1811             if (value >> 64 > 0) {
1812                 value >>= 64;
1813                 result += 64;
1814             }
1815             if (value >> 32 > 0) {
1816                 value >>= 32;
1817                 result += 32;
1818             }
1819             if (value >> 16 > 0) {
1820                 value >>= 16;
1821                 result += 16;
1822             }
1823             if (value >> 8 > 0) {
1824                 value >>= 8;
1825                 result += 8;
1826             }
1827             if (value >> 4 > 0) {
1828                 value >>= 4;
1829                 result += 4;
1830             }
1831             if (value >> 2 > 0) {
1832                 value >>= 2;
1833                 result += 2;
1834             }
1835             if (value >> 1 > 0) {
1836                 result += 1;
1837             }
1838         }
1839         return result;
1840     }



```

```
AccessControlUpgradeable._setRoleAdmin(bytes32,bytes32) (StaderStakePoolsManager.sol#2278-2282) is never used and should be removed



    
2278     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
2279         bytes32 previousAdminRole = getRoleAdmin(role);
2280         _roles[role].adminRole = adminRole;
2281         emit RoleAdminChanged(role, previousAdminRole, adminRole);
2282     }



```

```
MathUpgradeable.average(uint256,uint256) (StaderStakePoolsManager.sol#1633-1636) is never used and should be removed



    
1633     function average(uint256 a, uint256 b) internal pure returns (uint256) {
1634         // (a + b) / 2 can overflow.
1635         return (a & b) + (a ^ b) / 2;
1636     }



```

```
StringsUpgradeable.toHexString(uint256) (StaderStakePoolsManager.sol#1981-1985) is never used and should be removed



    
1981     function toHexString(uint256 value) internal pure returns (string memory) {
1982         unchecked {
1983             return toHexString(value, MathUpgradeable.log256(value) + 1);
1984         }
1985     }



```

```
MathUpgradeable.log10(uint256) (StaderStakePoolsManager.sol#1857-1889) is never used and should be removed



    
1857     function log10(uint256 value) internal pure returns (uint256) {
1858         uint256 result = 0;
1859         unchecked {
1860             if (value >= 10**64) {
1861                 value /= 10**64;
1862                 result += 64;
1863             }
1864             if (value >= 10**32) {
1865                 value /= 10**32;
1866                 result += 32;
1867             }
1868             if (value >= 10**16) {
1869                 value /= 10**16;
1870                 result += 16;
1871             }
1872             if (value >= 10**8) {
1873                 value /= 10**8;
1874                 result += 8;
1875             }
1876             if (value >= 10**4) {
1877                 value /= 10**4;
1878                 result += 4;
1879             }
1880             if (value >= 10**2) {
1881                 value /= 10**2;
1882                 result += 2;
1883             }
1884             if (value >= 10**1) {
1885                 result += 1;
1886             }
1887         }
1888         return result;
1889     }



```

```
ERC165Upgradeable.__ERC165_init() (StaderStakePoolsManager.sol#2050-2051) is never used and should be removed



    
2050     function __ERC165_init() internal onlyInitializing {
2051     }



```

```
SafeMath.mod(uint256,uint256) (StaderStakePoolsManager.sol#3456-3458) is never used and should be removed



    
3456     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
3457         return a % b;
3458     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256,MathUpgradeable.Rounding) (StaderStakePoolsManager.sol#1739-1750) is never used and should be removed



    
1739     function mulDiv(
1740         uint256 x,
1741         uint256 y,
1742         uint256 denominator,
1743         Rounding rounding
1744     ) internal pure returns (uint256) {
1745         uint256 result = mulDiv(x, y, denominator);
1746         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
1747             result += 1;
1748         }
1749         return result;
1750     }



```

```
SafeMath.div(uint256,uint256) (StaderStakePoolsManager.sol#3440-3442) is never used and should be removed



    
3440     function div(uint256 a, uint256 b) internal pure returns (uint256) {
3441         return a / b;
3442     }



```

```
AddressUpgradeable.verifyCallResult(bool,bytes,string) (StaderStakePoolsManager.sol#903-913) is never used and should be removed



    
903     function verifyCallResult(
904         bool success,
905         bytes memory returndata,
906         string memory errorMessage
907     ) internal pure returns (bytes memory) {
908         if (success) {
909             return returndata;
910         } else {
911             _revert(returndata, errorMessage);
912         }
913     }



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (StaderStakePoolsManager.sol#477-491) is never used and should be removed



    
477     function getPubkeyForValidSender(
478         uint8 _poolId,
479         uint256 _validatorId,
480         address _addr,
481         IStaderConfig _staderConfig
482     ) internal view returns (bytes memory) {
483         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
484         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
485             _validatorId
486         );
487         if (_addr != withdrawVaultAddress) {
488             revert CallerNotWithdrawVault();
489         }
490         return pubkey;
491     }



```

```
SafeMath.tryMul(uint256,uint256) (StaderStakePoolsManager.sol#3352-3362) is never used and should be removed



    
3352     function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
3353         unchecked {
3354             // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
3355             // benefit is lost if 'b' is also tested.
3356             // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
3357             if (a == 0) return (true, 0);
3358             uint256 c = a * b;
3359             if (c / a != b) return (false, 0);
3360             return (true, c);
3361         }
3362     }



```

```
AccessControlUpgradeable.__AccessControl_init_unchained() (StaderStakePoolsManager.sol#2112-2113) is never used and should be removed



    
2112     function __AccessControl_init_unchained() internal onlyInitializing {
2113     }



```

```
AddressUpgradeable._revert(bytes,string) (StaderStakePoolsManager.sol#915-927) is never used and should be removed



    
915     function _revert(bytes memory returndata, string memory errorMessage) private pure {
916         // Look for revert reason and bubble it up if present
917         if (returndata.length > 0) {
918             // The easiest way to bubble the revert reason is using memory via assembly
919             /// @solidity memory-safe-assembly
920             assembly {
921                 let returndata_size := mload(returndata)
922                 revert(add(32, returndata), returndata_size)
923             }
924         } else {
925             revert(errorMessage);
926         }
927     }



```

```
Initializable._getInitializedVersion() (StaderStakePoolsManager.sol#1077-1079) is never used and should be removed



    
1077     function _getInitializedVersion() internal view returns (uint8) {
1078         return _initialized;
1079     }



```

```
AccessControlUpgradeable._setupRole(bytes32,address) (StaderStakePoolsManager.sol#2269-2271) is never used and should be removed



    
2269     function _setupRole(bytes32 role, address account) internal virtual {
2270         _grantRole(role, account);
2271     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes,string) (StaderStakePoolsManager.sol#864-871) is never used and should be removed



    
864     function functionStaticCall(
865         address target,
866         bytes memory data,
867         string memory errorMessage
868     ) internal view returns (bytes memory) {
869         (bool success, bytes memory returndata) = target.staticcall(data);
870         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
871     }



```

```
Math.min(uint256,uint256) (StaderStakePoolsManager.sol#3107-3109) is never used and should be removed



    
3107     function min(uint256 a, uint256 b) internal pure returns (uint256) {
3108         return a < b ? a : b;
3109     }



```

```
MathUpgradeable.log256(uint256,MathUpgradeable.Rounding) (StaderStakePoolsManager.sol#1938-1943) is never used and should be removed



    
1938     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
1939         unchecked {
1940             uint256 result = log256(value);
1941             return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);
1942         }
1943     }



```

```
UtilLib.onlyOperatorRole(address,IStaderConfig) (StaderStakePoolsManager.sol#460-464) is never used and should be removed



    
460     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {
461         if (!_staderConfig.onlyOperatorRole(_addr)) {
462             revert CallerNotOperator();
463         }
464     }



```

```
UtilLib.sendValue(address,uint256) (StaderStakePoolsManager.sol#595-600) is never used and should be removed



    
595     function sendValue(address _receiver, uint256 _amount) internal {
596         (bool success, ) = payable(_receiver).call{value: _amount}('');
597         if (!success) {
598             revert TransferFailed();
599         }
600     }



```

```
MathUpgradeable.max(uint256,uint256) (StaderStakePoolsManager.sol#1618-1620) is never used and should be removed



    
1618     function max(uint256 a, uint256 b) internal pure returns (uint256) {
1619         return a > b ? a : b;
1620     }



```

```
ContextUpgradeable.__Context_init() (StaderStakePoolsManager.sol#1100-1101) is never used and should be removed



    
1100     function __Context_init() internal onlyInitializing {
1101     }



```

```
UtilLib.getOperatorRewardAddress(address,IStaderConfig) (StaderStakePoolsManager.sol#546-555) is never used and should be removed



    
546     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)
547         internal
548         view
549         returns (address payable)
550     {
551         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getOperatorPoolId(_operator);
552         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
553         uint256 operatorId = INodeRegistry(nodeRegistry).operatorIDByAddress(_operator);
554         return INodeRegistry(nodeRegistry).getOperatorRewardAddress(operatorId);
555     }



```

```
AddressUpgradeable.verifyCallResultFromTarget(address,bool,bytes,string) (StaderStakePoolsManager.sol#879-895) is never used and should be removed



    
879     function verifyCallResultFromTarget(
880         address target,
881         bool success,
882         bytes memory returndata,
883         string memory errorMessage
884     ) internal view returns (bytes memory) {
885         if (success) {
886             if (returndata.length == 0) {
887                 // only check isContract if the call was successful and the return data is empty
888                 // otherwise we already know that it was a contract
889                 require(isContract(target), "Address: call to non-contract");
890             }
891             return returndata;
892         } else {
893             _revert(returndata, errorMessage);
894         }
895     }



```

```
MathUpgradeable.log256(uint256) (StaderStakePoolsManager.sol#1908-1932) is never used and should be removed



    
1908     function log256(uint256 value) internal pure returns (uint256) {
1909         uint256 result = 0;
1910         unchecked {
1911             if (value >> 128 > 0) {
1912                 value >>= 128;
1913                 result += 16;
1914             }
1915             if (value >> 64 > 0) {
1916                 value >>= 64;
1917                 result += 8;
1918             }
1919             if (value >> 32 > 0) {
1920                 value >>= 32;
1921                 result += 4;
1922             }
1923             if (value >> 16 > 0) {
1924                 value >>= 16;
1925                 result += 2;
1926             }
1927             if (value >> 8 > 0) {
1928                 result += 1;
1929             }
1930         }
1931         return result;
1932     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (StaderStakePoolsManager.sol#837-846) is never used and should be removed



    
837     function functionCallWithValue(
838         address target,
839         bytes memory data,
840         uint256 value,
841         string memory errorMessage
842     ) internal returns (bytes memory) {
843         require(address(this).balance >= value, "Address: insufficient balance for call");
844         (bool success, bytes memory returndata) = target.call{value: value}(data);
845         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
846     }



```

### UserWithdrawalManager.sol


```
StringsUpgradeable.toString(uint256) (UserWithdrawalManager.sol#1955-1975) is never used and should be removed



    
1955     function toString(uint256 value) internal pure returns (string memory) {
1956         unchecked {
1957             uint256 length = MathUpgradeable.log10(value) + 1;
1958             string memory buffer = new string(length);
1959             uint256 ptr;
1960             /// @solidity memory-safe-assembly
1961             assembly {
1962                 ptr := add(buffer, add(32, length))
1963             }
1964             while (true) {
1965                 ptr--;
1966                 /// @solidity memory-safe-assembly
1967                 assembly {
1968                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
1969                 }
1970                 value /= 10;
1971                 if (value == 0) break;
1972             }
1973             return buffer;
1974         }
1975     }



```

```
ContextUpgradeable._msgData() (UserWithdrawalManager.sol#1108-1110) is never used and should be removed



    
1108     function _msgData() internal view virtual returns (bytes calldata) {
1109         return msg.data;
1110     }



```

```
MathUpgradeable.log2(uint256,MathUpgradeable.Rounding) (UserWithdrawalManager.sol#1845-1850) is never used and should be removed



    
1845     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
1846         unchecked {
1847             uint256 result = log2(value);
1848             return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
1849         }
1850     }



```

```
Initializable._isInitializing() (UserWithdrawalManager.sol#1083-1085) is never used and should be removed



    
1083     function _isInitializing() internal view returns (bool) {
1084         return _initializing;
1085     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256) (UserWithdrawalManager.sol#822-828) is never used and should be removed



    
822     function functionCallWithValue(
823         address target,
824         bytes memory data,
825         uint256 value
826     ) internal returns (bytes memory) {
827         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
828     }



```

```
MathUpgradeable.ceilDiv(uint256,uint256) (UserWithdrawalManager.sol#1643-1646) is never used and should be removed



    
1643     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
1644         // (a + b - 1) / b can overflow on addition, so we distribute.
1645         return a == 0 ? 0 : (a - 1) / b + 1;
1646     }



```

```
MathUpgradeable.min(uint256,uint256) (UserWithdrawalManager.sol#1624-1626) is never used and should be removed



    
1624     function min(uint256 a, uint256 b) internal pure returns (uint256) {
1625         return a < b ? a : b;
1626     }



```

```
SafeERC20Upgradeable.safeApprove(IERC20Upgradeable,address,uint256) (UserWithdrawalManager.sol#3334-3347) is never used and should be removed



    
3334     function safeApprove(
3335         IERC20Upgradeable token,
3336         address spender,
3337         uint256 value
3338     ) internal {
3339         // safeApprove should only be called when setting an initial allowance,
3340         // or when resetting it to zero. To increase and decrease it, use
3341         // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
3342         require(
3343             (value == 0) || (token.allowance(address(this), spender) == 0),
3344             "SafeERC20: approve from non-zero to non-zero allowance"
3345         );
3346         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
3347     }



```

```
MathUpgradeable.sqrt(uint256) (UserWithdrawalManager.sol#1756-1787) is never used and should be removed



    
1756     function sqrt(uint256 a) internal pure returns (uint256) {
1757         if (a == 0) {
1758             return 0;
1759         }
1760 
1761         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
1762         //
1763         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
1764         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
1765         //
1766         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
1767         // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
1768         // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
1769         //
1770         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
1771         uint256 result = 1 << (log2(a) >> 1);
1772 
1773         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
1774         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
1775         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
1776         // into the expected uint128 result.
1777         unchecked {
1778             result = (result + a / result) >> 1;
1779             result = (result + a / result) >> 1;
1780             result = (result + a / result) >> 1;
1781             result = (result + a / result) >> 1;
1782             result = (result + a / result) >> 1;
1783             result = (result + a / result) >> 1;
1784             result = (result + a / result) >> 1;
1785             return min(result, a / result);
1786         }
1787     }



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (UserWithdrawalManager.sol#522-532) is never used and should be removed



    
522     function getOperatorAddressByValidatorId(
523         uint8 _poolId,
524         uint256 _validatorId,
525         IStaderConfig _staderConfig
526     ) internal view returns (address) {
527         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
530 
531         return operatorAddress;
532     }



```

```
Math.ceilDiv(uint256,uint256) (UserWithdrawalManager.sol#3055-3058) is never used and should be removed



    
3055     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
3056         // (a + b - 1) / b can overflow on addition, so we distribute.
3057         return a == 0 ? 0 : (a - 1) / b + 1;
3058     }



```

```
UtilLib.getPubkeyRoot(bytes) (UserWithdrawalManager.sol#561-568) is never used and should be removed



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {
562         if (_pubkey.length != VALIDATOR_PUBKEY_LENGTH) {
563             revert InvalidPubkeyLength();
564         }
565 
566         // Append 16 bytes of zero padding to the pubkey and compute its hash to get the pubkey root.
567         return sha256(abi.encodePacked(_pubkey, bytes16(0)));
568     }



```

```
SafeERC20Upgradeable.safeIncreaseAllowance(IERC20Upgradeable,address,uint256) (UserWithdrawalManager.sol#3349-3356) is never used and should be removed



    
3349     function safeIncreaseAllowance(
3350         IERC20Upgradeable token,
3351         address spender,
3352         uint256 value
3353     ) internal {
3354         uint256 newAllowance = token.allowance(address(this), spender) + value;
3355         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
3356     }



```

```
Math.mulDiv(uint256,uint256,uint256) (UserWithdrawalManager.sol#3065-3145) is never used and should be removed



    
3065     function mulDiv(
3066         uint256 x,
3067         uint256 y,
3068         uint256 denominator
3069     ) internal pure returns (uint256 result) {
3070         unchecked {
3071             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
3072             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
3073             // variables such that product = prod1 * 2^256 + prod0.
3074             uint256 prod0; // Least significant 256 bits of the product
3075             uint256 prod1; // Most significant 256 bits of the product
3076             assembly {
3077                 let mm := mulmod(x, y, not(0))
3078                 prod0 := mul(x, y)
3079                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
3080             }
3081 
3082             // Handle non-overflow cases, 256 by 256 division.
3083             if (prod1 == 0) {
3084                 return prod0 / denominator;
3085             }
3086 
3087             // Make sure the result is less than 2^256. Also prevents denominator == 0.
3088             require(denominator > prod1);
3089 
3090             ///////////////////////////////////////////////
3091             // 512 by 256 division.
3092             ///////////////////////////////////////////////
3093 
3094             // Make division exact by subtracting the remainder from [prod1 prod0].
3095             uint256 remainder;
3096             assembly {
3097                 // Compute remainder using mulmod.
3098                 remainder := mulmod(x, y, denominator)
3099 
3100                 // Subtract 256 bit number from 512 bit number.
3101                 prod1 := sub(prod1, gt(remainder, prod0))
3102                 prod0 := sub(prod0, remainder)
3103             }
3104 
3105             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
3106             // See https://cs.stackexchange.com/q/138556/92363.
3107 
3108             // Does not overflow because the denominator cannot be zero at this stage in the function.
3109             uint256 twos = denominator & (~denominator + 1);
3110             assembly {
3111                 // Divide denominator by twos.
3112                 denominator := div(denominator, twos)
3113 
3114                 // Divide [prod1 prod0] by twos.
3115                 prod0 := div(prod0, twos)
3116 
3117                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
3118                 twos := add(div(sub(0, twos), twos), 1)
3119             }
3120 
3121             // Shift in bits from prod1 into prod0.
3122             prod0 |= prod1 * twos;
3123 
3124             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
3125             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
3126             // four bits. That is, denominator * inv = 1 mod 2^4.
3127             uint256 inverse = (3 * denominator) ^ 2;
3128 
3129             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
3130             // in modular arithmetic, doubling the correct bits in each step.
3131             inverse *= 2 - denominator * inverse; // inverse mod 2^8
3132             inverse *= 2 - denominator * inverse; // inverse mod 2^16
3133             inverse *= 2 - denominator * inverse; // inverse mod 2^32
3134             inverse *= 2 - denominator * inverse; // inverse mod 2^64
3135             inverse *= 2 - denominator * inverse; // inverse mod 2^128
3136             inverse *= 2 - denominator * inverse; // inverse mod 2^256
3137 
3138             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
3139             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
3140             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
3141             // is no longer required.
3142             result = prod0 * inverse;
3143             return result;
3144         }
3145     }



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (UserWithdrawalManager.sol#492-507) is never used and should be removed



    
492     function getOperatorForValidSender(
493         uint8 _poolId,
494         uint256 _validatorId,
495         address _addr,
496         IStaderConfig _staderConfig
497     ) internal view returns (address) {
498         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );
502         if (_addr != withdrawVaultAddress) {
503             revert CallerNotWithdrawVault();
504         }
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
506         return operator;
507     }



```

```
MathUpgradeable.log10(uint256,MathUpgradeable.Rounding) (UserWithdrawalManager.sol#1894-1899) is never used and should be removed



    
1894     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
1895         unchecked {
1896             uint256 result = log10(value);
1897             return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);
1898         }
1899     }



```

```
AddressUpgradeable.functionCall(address,bytes) (UserWithdrawalManager.sol#793-795) is never used and should be removed



    
793     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
794         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
795     }



```

```
Math.sqrt(uint256,Math.Rounding) (UserWithdrawalManager.sol#3229-3235) is never used and should be removed



    
3229     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
3230         uint256 result = sqrt(a);
3231         if (rounding == Rounding.Up && result * result < a) {
3232             result += 1;
3233         }
3234         return result;
3235     }



```

```
ContextUpgradeable.__Context_init_unchained() (UserWithdrawalManager.sol#1102-1103) is never used and should be removed



    
1102     function __Context_init_unchained() internal onlyInitializing {
1103     }



```

```
Math.max(uint256,uint256) (UserWithdrawalManager.sol#3029-3031) is never used and should be removed



    
3029     function max(uint256 a, uint256 b) internal pure returns (uint256) {
3030         return a >= b ? a : b;
3031     }



```

```
ERC165Upgradeable.__ERC165_init_unchained() (UserWithdrawalManager.sol#2052-2053) is never used and should be removed



    
2052     function __ERC165_init_unchained() internal onlyInitializing {
2053     }



```

```
Math.average(uint256,uint256) (UserWithdrawalManager.sol#3044-3047) is never used and should be removed



    
3044     function average(uint256 a, uint256 b) internal pure returns (uint256) {
3045         // (a + b) / 2 can overflow.
3046         return (a & b) + (a ^ b) / 2;
3047     }



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (UserWithdrawalManager.sol#570-580) is never used and should be removed



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)
571         internal
572         view
573         returns (bool)
574     {
575         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getValidatorPoolId(_pubkey);
576         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
577         uint256 validatorId = INodeRegistry(nodeRegistry).validatorIdByPubkey(_pubkey);
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);
579         return IVaultProxy(withdrawVaultAddress).vaultSettleStatus();
580     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (UserWithdrawalManager.sol#1653-1733) is never used and should be removed



    
1653     function mulDiv(
1654         uint256 x,
1655         uint256 y,
1656         uint256 denominator
1657     ) internal pure returns (uint256 result) {
1658         unchecked {
1659             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
1660             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
1661             // variables such that product = prod1 * 2^256 + prod0.
1662             uint256 prod0; // Least significant 256 bits of the product
1663             uint256 prod1; // Most significant 256 bits of the product
1664             assembly {
1665                 let mm := mulmod(x, y, not(0))
1666                 prod0 := mul(x, y)
1667                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1668             }
1669 
1670             // Handle non-overflow cases, 256 by 256 division.
1671             if (prod1 == 0) {
1672                 return prod0 / denominator;
1673             }
1674 
1675             // Make sure the result is less than 2^256. Also prevents denominator == 0.
1676             require(denominator > prod1);
1677 
1678             ///////////////////////////////////////////////
1679             // 512 by 256 division.
1680             ///////////////////////////////////////////////
1681 
1682             // Make division exact by subtracting the remainder from [prod1 prod0].
1683             uint256 remainder;
1684             assembly {
1685                 // Compute remainder using mulmod.
1686                 remainder := mulmod(x, y, denominator)
1687 
1688                 // Subtract 256 bit number from 512 bit number.
1689                 prod1 := sub(prod1, gt(remainder, prod0))
1690                 prod0 := sub(prod0, remainder)
1691             }
1692 
1693             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
1694             // See https://cs.stackexchange.com/q/138556/92363.
1695 
1696             // Does not overflow because the denominator cannot be zero at this stage in the function.
1697             uint256 twos = denominator & (~denominator + 1);
1698             assembly {
1699                 // Divide denominator by twos.
1700                 denominator := div(denominator, twos)
1701 
1702                 // Divide [prod1 prod0] by twos.
1703                 prod0 := div(prod0, twos)
1704 
1705                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1706                 twos := add(div(sub(0, twos), twos), 1)
1707             }
1708 
1709             // Shift in bits from prod1 into prod0.
1710             prod0 |= prod1 * twos;
1711 
1712             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
1713             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
1714             // four bits. That is, denominator * inv = 1 mod 2^4.
1715             uint256 inverse = (3 * denominator) ^ 2;
1716 
1717             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
1718             // in modular arithmetic, doubling the correct bits in each step.
1719             inverse *= 2 - denominator * inverse; // inverse mod 2^8
1720             inverse *= 2 - denominator * inverse; // inverse mod 2^16
1721             inverse *= 2 - denominator * inverse; // inverse mod 2^32
1722             inverse *= 2 - denominator * inverse; // inverse mod 2^64
1723             inverse *= 2 - denominator * inverse; // inverse mod 2^128
1724             inverse *= 2 - denominator * inverse; // inverse mod 2^256
1725 
1726             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
1727             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
1728             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
1729             // is no longer required.
1730             result = prod0 * inverse;
1731             return result;
1732         }
1733     }



```

```
AddressUpgradeable.sendValue(address,uint256) (UserWithdrawalManager.sol#768-773) is never used and should be removed



    
768     function sendValue(address payable recipient, uint256 amount) internal {
769         require(address(this).balance >= amount, "Address: insufficient balance");
770 
771         (bool success, ) = recipient.call{value: amount}("");
772         require(success, "Address: unable to send value, recipient may have reverted");
773     }



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (UserWithdrawalManager.sol#534-543) is never used and should be removed



    
534     function getOperatorAddressByOperatorId(
535         uint8 _poolId,
536         uint256 _operatorId,
537         IStaderConfig _staderConfig
538     ) internal view returns (address) {
539         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);
541 
542         return operatorAddress;
543     }



```

```
Math.sqrt(uint256) (UserWithdrawalManager.sol#3168-3224) is never used and should be removed



    
3168     function sqrt(uint256 a) internal pure returns (uint256) {
3169         if (a == 0) {
3170             return 0;
3171         }
3172 
3173         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
3174         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
3175         // `msb(a) <= a < 2*msb(a)`.
3176         // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.
3177         // This gives `2**k < a <= 2**(k+1)` → `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.
3178         // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a
3179         // good first aproximation of `sqrt(a)` with at least 1 correct bit.
3180         uint256 result = 1;
3181         uint256 x = a;
3182         if (x >> 128 > 0) {
3183             x >>= 128;
3184             result <<= 64;
3185         }
3186         if (x >> 64 > 0) {
3187             x >>= 64;
3188             result <<= 32;
3189         }
3190         if (x >> 32 > 0) {
3191             x >>= 32;
3192             result <<= 16;
3193         }
3194         if (x >> 16 > 0) {
3195             x >>= 16;
3196             result <<= 8;
3197         }
3198         if (x >> 8 > 0) {
3199             x >>= 8;
3200             result <<= 4;
3201         }
3202         if (x >> 4 > 0) {
3203             x >>= 4;
3204             result <<= 2;
3205         }
3206         if (x >> 2 > 0) {
3207             result <<= 1;
3208         }
3209 
3210         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
3211         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
3212         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
3213         // into the expected uint128 result.
3214         unchecked {
3215             result = (result + a / result) >> 1;
3216             result = (result + a / result) >> 1;
3217             result = (result + a / result) >> 1;
3218             result = (result + a / result) >> 1;
3219             result = (result + a / result) >> 1;
3220             result = (result + a / result) >> 1;
3221             result = (result + a / result) >> 1;
3222             return min(result, a / result);
3223         }
3224     }



```

```
UtilLib.onlyStaderContract(address,IStaderConfig,bytes32) (UserWithdrawalManager.sol#466-474) is never used and should be removed



    
466     function onlyStaderContract(
467         address _addr,
468         IStaderConfig _staderConfig,
469         bytes32 _contractName
470     ) internal view {
471         if (!_staderConfig.onlyStaderContract(_addr, _contractName)) {
472             revert CallerNotStaderContract();
473         }
474     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes) (UserWithdrawalManager.sol#853-855) is never used and should be removed



    
853     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
854         return functionStaticCall(target, data, "Address: low-level static call failed");
855     }



```

```
MathUpgradeable.sqrt(uint256,MathUpgradeable.Rounding) (UserWithdrawalManager.sol#1792-1797) is never used and should be removed



    
1792     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
1793         unchecked {
1794             uint256 result = sqrt(a);
1795             return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
1796         }
1797     }



```

```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (UserWithdrawalManager.sol#509-520) is never used and should be removed



    
509     function onlyValidatorWithdrawVault(
510         uint8 _poolId,
511         uint256 _validatorId,
512         address _addr,
513         IStaderConfig _staderConfig
514     ) internal view {
515         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
517         if (_addr != withdrawVaultAddress) {
518             revert CallerNotWithdrawVault();
519         }
520     }



```

```
MathUpgradeable.log2(uint256) (UserWithdrawalManager.sol#1803-1839) is never used and should be removed



    
1803     function log2(uint256 value) internal pure returns (uint256) {
1804         uint256 result = 0;
1805         unchecked {
1806             if (value >> 128 > 0) {
1807                 value >>= 128;
1808                 result += 128;
1809             }
1810             if (value >> 64 > 0) {
1811                 value >>= 64;
1812                 result += 64;
1813             }
1814             if (value >> 32 > 0) {
1815                 value >>= 32;
1816                 result += 32;
1817             }
1818             if (value >> 16 > 0) {
1819                 value >>= 16;
1820                 result += 16;
1821             }
1822             if (value >> 8 > 0) {
1823                 value >>= 8;
1824                 result += 8;
1825             }
1826             if (value >> 4 > 0) {
1827                 value >>= 4;
1828                 result += 4;
1829             }
1830             if (value >> 2 > 0) {
1831                 value >>= 2;
1832                 result += 2;
1833             }
1834             if (value >> 1 > 0) {
1835                 result += 1;
1836             }
1837         }
1838         return result;
1839     }



```

```
UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig) (UserWithdrawalManager.sol#582-592) is never used and should be removed



    
582     function computeExchangeRate(
583         uint256 totalETHBalance,
584         uint256 totalETHXSupply,
585         IStaderConfig _staderConfig
586     ) internal view returns (uint256) {
587         uint256 DECIMALS = _staderConfig.getDecimals();
588         uint256 newExchangeRate = (totalETHBalance == 0 || totalETHXSupply == 0)
589             ? DECIMALS
590             : (totalETHBalance * DECIMALS) / totalETHXSupply;
591         return newExchangeRate;
592     }



```

```
AccessControlUpgradeable._setRoleAdmin(bytes32,bytes32) (UserWithdrawalManager.sol#2277-2281) is never used and should be removed



    
2277     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
2278         bytes32 previousAdminRole = getRoleAdmin(role);
2279         _roles[role].adminRole = adminRole;
2280         emit RoleAdminChanged(role, previousAdminRole, adminRole);
2281     }



```

```
MathUpgradeable.average(uint256,uint256) (UserWithdrawalManager.sol#1632-1635) is never used and should be removed



    
1632     function average(uint256 a, uint256 b) internal pure returns (uint256) {
1633         // (a + b) / 2 can overflow.
1634         return (a & b) + (a ^ b) / 2;
1635     }



```

```
StringsUpgradeable.toHexString(uint256) (UserWithdrawalManager.sol#1980-1984) is never used and should be removed



    
1980     function toHexString(uint256 value) internal pure returns (string memory) {
1981         unchecked {
1982             return toHexString(value, MathUpgradeable.log256(value) + 1);
1983         }
1984     }



```

```
SafeERC20Upgradeable.safeDecreaseAllowance(IERC20Upgradeable,address,uint256) (UserWithdrawalManager.sol#3358-3369) is never used and should be removed



    
3358     function safeDecreaseAllowance(
3359         IERC20Upgradeable token,
3360         address spender,
3361         uint256 value
3362     ) internal {
3363         unchecked {
3364             uint256 oldAllowance = token.allowance(address(this), spender);
3365             require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
3366             uint256 newAllowance = oldAllowance - value;
3367             _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
3368         }
3369     }



```

```
MathUpgradeable.log10(uint256) (UserWithdrawalManager.sol#1856-1888) is never used and should be removed



    
1856     function log10(uint256 value) internal pure returns (uint256) {
1857         uint256 result = 0;
1858         unchecked {
1859             if (value >= 10**64) {
1860                 value /= 10**64;
1861                 result += 64;
1862             }
1863             if (value >= 10**32) {
1864                 value /= 10**32;
1865                 result += 32;
1866             }
1867             if (value >= 10**16) {
1868                 value /= 10**16;
1869                 result += 16;
1870             }
1871             if (value >= 10**8) {
1872                 value /= 10**8;
1873                 result += 8;
1874             }
1875             if (value >= 10**4) {
1876                 value /= 10**4;
1877                 result += 4;
1878             }
1879             if (value >= 10**2) {
1880                 value /= 10**2;
1881                 result += 2;
1882             }
1883             if (value >= 10**1) {
1884                 result += 1;
1885             }
1886         }
1887         return result;
1888     }



```

```
ERC165Upgradeable.__ERC165_init() (UserWithdrawalManager.sol#2049-2050) is never used and should be removed



    
2049     function __ERC165_init() internal onlyInitializing {
2050     }



```

```
Math.mulDiv(uint256,uint256,uint256,Math.Rounding) (UserWithdrawalManager.sol#3150-3161) is never used and should be removed



    
3150     function mulDiv(
3151         uint256 x,
3152         uint256 y,
3153         uint256 denominator,
3154         Rounding rounding
3155     ) internal pure returns (uint256) {
3156         uint256 result = mulDiv(x, y, denominator);
3157         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
3158             result += 1;
3159         }
3160         return result;
3161     }



```

```
SafeERC20Upgradeable.safePermit(IERC20PermitUpgradeable,address,address,uint256,uint256,uint8,bytes32,bytes32) (UserWithdrawalManager.sol#3371-3385) is never used and should be removed



    
3371     function safePermit(
3372         IERC20PermitUpgradeable token,
3373         address owner,
3374         address spender,
3375         uint256 value,
3376         uint256 deadline,
3377         uint8 v,
3378         bytes32 r,
3379         bytes32 s
3380     ) internal {
3381         uint256 nonceBefore = token.nonces(owner);
3382         token.permit(owner, spender, value, deadline, v, r, s);
3383         uint256 nonceAfter = token.nonces(owner);
3384         require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");
3385     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256,MathUpgradeable.Rounding) (UserWithdrawalManager.sol#1738-1749) is never used and should be removed



    
1738     function mulDiv(
1739         uint256 x,
1740         uint256 y,
1741         uint256 denominator,
1742         Rounding rounding
1743     ) internal pure returns (uint256) {
1744         uint256 result = mulDiv(x, y, denominator);
1745         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
1746             result += 1;
1747         }
1748         return result;
1749     }



```

```
AddressUpgradeable.verifyCallResult(bool,bytes,string) (UserWithdrawalManager.sol#902-912) is never used and should be removed



    
902     function verifyCallResult(
903         bool success,
904         bytes memory returndata,
905         string memory errorMessage
906     ) internal pure returns (bytes memory) {
907         if (success) {
908             return returndata;
909         } else {
910             _revert(returndata, errorMessage);
911         }
912     }



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (UserWithdrawalManager.sol#476-490) is never used and should be removed



    
476     function getPubkeyForValidSender(
477         uint8 _poolId,
478         uint256 _validatorId,
479         address _addr,
480         IStaderConfig _staderConfig
481     ) internal view returns (bytes memory) {
482         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );
486         if (_addr != withdrawVaultAddress) {
487             revert CallerNotWithdrawVault();
488         }
489         return pubkey;
490     }



```

```
Initializable._getInitializedVersion() (UserWithdrawalManager.sol#1076-1078) is never used and should be removed



    
1076     function _getInitializedVersion() internal view returns (uint8) {
1077         return _initialized;
1078     }



```

```
AccessControlUpgradeable._setupRole(bytes32,address) (UserWithdrawalManager.sol#2268-2270) is never used and should be removed



    
2268     function _setupRole(bytes32 role, address account) internal virtual {
2269         _grantRole(role, account);
2270     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes,string) (UserWithdrawalManager.sol#863-870) is never used and should be removed



    
863     function functionStaticCall(
864         address target,
865         bytes memory data,
866         string memory errorMessage
867     ) internal view returns (bytes memory) {
868         (bool success, bytes memory returndata) = target.staticcall(data);
869         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
870     }



```

```
SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable,address,uint256) (UserWithdrawalManager.sol#3310-3316) is never used and should be removed



    
3310     function safeTransfer(
3311         IERC20Upgradeable token,
3312         address to,
3313         uint256 value
3314     ) internal {
3315         _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
3316     }



```

```
MathUpgradeable.log256(uint256,MathUpgradeable.Rounding) (UserWithdrawalManager.sol#1937-1942) is never used and should be removed



    
1937     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
1938         unchecked {
1939             uint256 result = log256(value);
1940             return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);
1941         }
1942     }



```

```
UtilLib.onlyOperatorRole(address,IStaderConfig) (UserWithdrawalManager.sol#459-463) is never used and should be removed



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {
460         if (!_staderConfig.onlyOperatorRole(_addr)) {
461             revert CallerNotOperator();
462         }
463     }



```

```
UtilLib.sendValue(address,uint256) (UserWithdrawalManager.sol#594-599) is never used and should be removed



    
594     function sendValue(address _receiver, uint256 _amount) internal {
595         (bool success, ) = payable(_receiver).call{value: _amount}('');
596         if (!success) {
597             revert TransferFailed();
598         }
599     }



```

```
MathUpgradeable.max(uint256,uint256) (UserWithdrawalManager.sol#1617-1619) is never used and should be removed



    
1617     function max(uint256 a, uint256 b) internal pure returns (uint256) {
1618         return a > b ? a : b;
1619     }



```

```
ContextUpgradeable.__Context_init() (UserWithdrawalManager.sol#1099-1100) is never used and should be removed



    
1099     function __Context_init() internal onlyInitializing {
1100     }



```

```
UtilLib.getOperatorRewardAddress(address,IStaderConfig) (UserWithdrawalManager.sol#545-554) is never used and should be removed



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)
546         internal
547         view
548         returns (address payable)
549     {
550         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getOperatorPoolId(_operator);
551         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
552         uint256 operatorId = INodeRegistry(nodeRegistry).operatorIDByAddress(_operator);
553         return INodeRegistry(nodeRegistry).getOperatorRewardAddress(operatorId);
554     }



```

```
MathUpgradeable.log256(uint256) (UserWithdrawalManager.sol#1907-1931) is never used and should be removed



    
1907     function log256(uint256 value) internal pure returns (uint256) {
1908         uint256 result = 0;
1909         unchecked {
1910             if (value >> 128 > 0) {
1911                 value >>= 128;
1912                 result += 16;
1913             }
1914             if (value >> 64 > 0) {
1915                 value >>= 64;
1916                 result += 8;
1917             }
1918             if (value >> 32 > 0) {
1919                 value >>= 32;
1920                 result += 4;
1921             }
1922             if (value >> 16 > 0) {
1923                 value >>= 16;
1924                 result += 2;
1925             }
1926             if (value >> 8 > 0) {
1927                 result += 1;
1928             }
1929         }
1930         return result;
1931     }



```

### UtilLib.sol


```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (UtilLib.sol#522-532) is never used and should be removed



    
522     function getOperatorAddressByValidatorId(
523         uint8 _poolId,
524         uint256 _validatorId,
525         IStaderConfig _staderConfig
526     ) internal view returns (address) {
527         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
530 
531         return operatorAddress;
532     }



```

```
UtilLib.getPubkeyRoot(bytes) (UtilLib.sol#561-568) is never used and should be removed



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {
562         if (_pubkey.length != VALIDATOR_PUBKEY_LENGTH) {
563             revert InvalidPubkeyLength();
564         }
565 
566         // Append 16 bytes of zero padding to the pubkey and compute its hash to get the pubkey root.
567         return sha256(abi.encodePacked(_pubkey, bytes16(0)));
568     }



```

```
UtilLib.checkNonZeroAddress(address) (UtilLib.sol#448-450) is never used and should be removed



    
448     function checkNonZeroAddress(address _address) internal pure {
449         if (_address == address(0)) revert ZeroAddress();
450     }



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (UtilLib.sol#492-507) is never used and should be removed



    
492     function getOperatorForValidSender(
493         uint8 _poolId,
494         uint256 _validatorId,
495         address _addr,
496         IStaderConfig _staderConfig
497     ) internal view returns (address) {
498         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );
502         if (_addr != withdrawVaultAddress) {
503             revert CallerNotWithdrawVault();
504         }
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
506         return operator;
507     }



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (UtilLib.sol#570-580) is never used and should be removed



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)
571         internal
572         view
573         returns (bool)
574     {
575         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getValidatorPoolId(_pubkey);
576         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
577         uint256 validatorId = INodeRegistry(nodeRegistry).validatorIdByPubkey(_pubkey);
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);
579         return IVaultProxy(withdrawVaultAddress).vaultSettleStatus();
580     }



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (UtilLib.sol#534-543) is never used and should be removed



    
534     function getOperatorAddressByOperatorId(
535         uint8 _poolId,
536         uint256 _operatorId,
537         IStaderConfig _staderConfig
538     ) internal view returns (address) {
539         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);
541 
542         return operatorAddress;
543     }



```

```
UtilLib.onlyStaderContract(address,IStaderConfig,bytes32) (UtilLib.sol#466-474) is never used and should be removed



    
466     function onlyStaderContract(
467         address _addr,
468         IStaderConfig _staderConfig,
469         bytes32 _contractName
470     ) internal view {
471         if (!_staderConfig.onlyStaderContract(_addr, _contractName)) {
472             revert CallerNotStaderContract();
473         }
474     }



```

```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (UtilLib.sol#509-520) is never used and should be removed



    
509     function onlyValidatorWithdrawVault(
510         uint8 _poolId,
511         uint256 _validatorId,
512         address _addr,
513         IStaderConfig _staderConfig
514     ) internal view {
515         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
517         if (_addr != withdrawVaultAddress) {
518             revert CallerNotWithdrawVault();
519         }
520     }



```

```
UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig) (UtilLib.sol#582-592) is never used and should be removed



    
582     function computeExchangeRate(
583         uint256 totalETHBalance,
584         uint256 totalETHXSupply,
585         IStaderConfig _staderConfig
586     ) internal view returns (uint256) {
587         uint256 DECIMALS = _staderConfig.getDecimals();
588         uint256 newExchangeRate = (totalETHBalance == 0 || totalETHXSupply == 0)
589             ? DECIMALS
590             : (totalETHBalance * DECIMALS) / totalETHXSupply;
591         return newExchangeRate;
592     }



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (UtilLib.sol#476-490) is never used and should be removed



    
476     function getPubkeyForValidSender(
477         uint8 _poolId,
478         uint256 _validatorId,
479         address _addr,
480         IStaderConfig _staderConfig
481     ) internal view returns (bytes memory) {
482         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );
486         if (_addr != withdrawVaultAddress) {
487             revert CallerNotWithdrawVault();
488         }
489         return pubkey;
490     }



```

```
UtilLib.onlyOperatorRole(address,IStaderConfig) (UtilLib.sol#459-463) is never used and should be removed



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {
460         if (!_staderConfig.onlyOperatorRole(_addr)) {
461             revert CallerNotOperator();
462         }
463     }



```

```
UtilLib.sendValue(address,uint256) (UtilLib.sol#594-599) is never used and should be removed



    
594     function sendValue(address _receiver, uint256 _amount) internal {
595         (bool success, ) = payable(_receiver).call{value: _amount}('');
596         if (!success) {
597             revert TransferFailed();
598         }
599     }



```

```
UtilLib.onlyManagerRole(address,IStaderConfig) (UtilLib.sol#453-457) is never used and should be removed



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {
454         if (!_staderConfig.onlyManagerRole(_addr)) {
455             revert CallerNotManager();
456         }
457     }



```

```
UtilLib.getOperatorRewardAddress(address,IStaderConfig) (UtilLib.sol#545-554) is never used and should be removed



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)
546         internal
547         view
548         returns (address payable)
549     {
550         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getOperatorPoolId(_operator);
551         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
552         uint256 operatorId = INodeRegistry(nodeRegistry).operatorIDByAddress(_operator);
553         return INodeRegistry(nodeRegistry).getOperatorRewardAddress(operatorId);
554     }



```

### ValidatorWithdrawalVault.sol


```
Math.ceilDiv(uint256,uint256) (ValidatorWithdrawalVault.sol#986-989) is never used and should be removed



    
986     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
987         // (a + b - 1) / b can overflow on addition, so we distribute.
988         return a == 0 ? 0 : (a - 1) / b + 1;
989     }



```

```
UtilLib.getPubkeyRoot(bytes) (ValidatorWithdrawalVault.sol#561-568) is never used and should be removed



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {
562         if (_pubkey.length != VALIDATOR_PUBKEY_LENGTH) {
563             revert InvalidPubkeyLength();
564         }
565 
566         // Append 16 bytes of zero padding to the pubkey and compute its hash to get the pubkey root.
567         return sha256(abi.encodePacked(_pubkey, bytes16(0)));
568     }



```

```
Math.mulDiv(uint256,uint256,uint256) (ValidatorWithdrawalVault.sol#996-1076) is never used and should be removed



    
996     function mulDiv(
997         uint256 x,
998         uint256 y,
999         uint256 denominator
1000     ) internal pure returns (uint256 result) {
1001         unchecked {
1002             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
1003             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
1004             // variables such that product = prod1 * 2^256 + prod0.
1005             uint256 prod0; // Least significant 256 bits of the product
1006             uint256 prod1; // Most significant 256 bits of the product
1007             assembly {
1008                 let mm := mulmod(x, y, not(0))
1009                 prod0 := mul(x, y)
1010                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1011             }
1012 
1013             // Handle non-overflow cases, 256 by 256 division.
1014             if (prod1 == 0) {
1015                 return prod0 / denominator;
1016             }
1017 
1018             // Make sure the result is less than 2^256. Also prevents denominator == 0.
1019             require(denominator > prod1);
1020 
1021             ///////////////////////////////////////////////
1022             // 512 by 256 division.
1023             ///////////////////////////////////////////////
1024 
1025             // Make division exact by subtracting the remainder from [prod1 prod0].
1026             uint256 remainder;
1027             assembly {
1028                 // Compute remainder using mulmod.
1029                 remainder := mulmod(x, y, denominator)
1030 
1031                 // Subtract 256 bit number from 512 bit number.
1032                 prod1 := sub(prod1, gt(remainder, prod0))
1033                 prod0 := sub(prod0, remainder)
1034             }
1035 
1036             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
1037             // See https://cs.stackexchange.com/q/138556/92363.
1038 
1039             // Does not overflow because the denominator cannot be zero at this stage in the function.
1040             uint256 twos = denominator & (~denominator + 1);
1041             assembly {
1042                 // Divide denominator by twos.
1043                 denominator := div(denominator, twos)
1044 
1045                 // Divide [prod1 prod0] by twos.
1046                 prod0 := div(prod0, twos)
1047 
1048                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1049                 twos := add(div(sub(0, twos), twos), 1)
1050             }
1051 
1052             // Shift in bits from prod1 into prod0.
1053             prod0 |= prod1 * twos;
1054 
1055             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
1056             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
1057             // four bits. That is, denominator * inv = 1 mod 2^4.
1058             uint256 inverse = (3 * denominator) ^ 2;
1059 
1060             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
1061             // in modular arithmetic, doubling the correct bits in each step.
1062             inverse *= 2 - denominator * inverse; // inverse mod 2^8
1063             inverse *= 2 - denominator * inverse; // inverse mod 2^16
1064             inverse *= 2 - denominator * inverse; // inverse mod 2^32
1065             inverse *= 2 - denominator * inverse; // inverse mod 2^64
1066             inverse *= 2 - denominator * inverse; // inverse mod 2^128
1067             inverse *= 2 - denominator * inverse; // inverse mod 2^256
1068 
1069             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
1070             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
1071             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
1072             // is no longer required.
1073             result = prod0 * inverse;
1074             return result;
1075         }
1076     }



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (ValidatorWithdrawalVault.sol#492-507) is never used and should be removed



    
492     function getOperatorForValidSender(
493         uint8 _poolId,
494         uint256 _validatorId,
495         address _addr,
496         IStaderConfig _staderConfig
497     ) internal view returns (address) {
498         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );
502         if (_addr != withdrawVaultAddress) {
503             revert CallerNotWithdrawVault();
504         }
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
506         return operator;
507     }



```

```
Math.sqrt(uint256,Math.Rounding) (ValidatorWithdrawalVault.sol#1160-1166) is never used and should be removed



    
1160     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
1161         uint256 result = sqrt(a);
1162         if (rounding == Rounding.Up && result * result < a) {
1163             result += 1;
1164         }
1165         return result;
1166     }



```

```
Math.max(uint256,uint256) (ValidatorWithdrawalVault.sol#960-962) is never used and should be removed



    
960     function max(uint256 a, uint256 b) internal pure returns (uint256) {
961         return a >= b ? a : b;
962     }



```

```
Math.average(uint256,uint256) (ValidatorWithdrawalVault.sol#975-978) is never used and should be removed



    
975     function average(uint256 a, uint256 b) internal pure returns (uint256) {
976         // (a + b) / 2 can overflow.
977         return (a & b) + (a ^ b) / 2;
978     }



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (ValidatorWithdrawalVault.sol#570-580) is never used and should be removed



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)
571         internal
572         view
573         returns (bool)
574     {
575         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getValidatorPoolId(_pubkey);
576         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
577         uint256 validatorId = INodeRegistry(nodeRegistry).validatorIdByPubkey(_pubkey);
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);
579         return IVaultProxy(withdrawVaultAddress).vaultSettleStatus();
580     }



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (ValidatorWithdrawalVault.sol#534-543) is never used and should be removed



    
534     function getOperatorAddressByOperatorId(
535         uint8 _poolId,
536         uint256 _operatorId,
537         IStaderConfig _staderConfig
538     ) internal view returns (address) {
539         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);
541 
542         return operatorAddress;
543     }



```

```
Math.sqrt(uint256) (ValidatorWithdrawalVault.sol#1099-1155) is never used and should be removed



    
1099     function sqrt(uint256 a) internal pure returns (uint256) {
1100         if (a == 0) {
1101             return 0;
1102         }
1103 
1104         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
1105         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
1106         // `msb(a) <= a < 2*msb(a)`.
1107         // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.
1108         // This gives `2**k < a <= 2**(k+1)` → `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.
1109         // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a
1110         // good first aproximation of `sqrt(a)` with at least 1 correct bit.
1111         uint256 result = 1;
1112         uint256 x = a;
1113         if (x >> 128 > 0) {
1114             x >>= 128;
1115             result <<= 64;
1116         }
1117         if (x >> 64 > 0) {
1118             x >>= 64;
1119             result <<= 32;
1120         }
1121         if (x >> 32 > 0) {
1122             x >>= 32;
1123             result <<= 16;
1124         }
1125         if (x >> 16 > 0) {
1126             x >>= 16;
1127             result <<= 8;
1128         }
1129         if (x >> 8 > 0) {
1130             x >>= 8;
1131             result <<= 4;
1132         }
1133         if (x >> 4 > 0) {
1134             x >>= 4;
1135             result <<= 2;
1136         }
1137         if (x >> 2 > 0) {
1138             result <<= 1;
1139         }
1140 
1141         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
1142         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
1143         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
1144         // into the expected uint128 result.
1145         unchecked {
1146             result = (result + a / result) >> 1;
1147             result = (result + a / result) >> 1;
1148             result = (result + a / result) >> 1;
1149             result = (result + a / result) >> 1;
1150             result = (result + a / result) >> 1;
1151             result = (result + a / result) >> 1;
1152             result = (result + a / result) >> 1;
1153             return min(result, a / result);
1154         }
1155     }



```

```
UtilLib.onlyStaderContract(address,IStaderConfig,bytes32) (ValidatorWithdrawalVault.sol#466-474) is never used and should be removed



    
466     function onlyStaderContract(
467         address _addr,
468         IStaderConfig _staderConfig,
469         bytes32 _contractName
470     ) internal view {
471         if (!_staderConfig.onlyStaderContract(_addr, _contractName)) {
472             revert CallerNotStaderContract();
473         }
474     }



```

```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (ValidatorWithdrawalVault.sol#509-520) is never used and should be removed



    
509     function onlyValidatorWithdrawVault(
510         uint8 _poolId,
511         uint256 _validatorId,
512         address _addr,
513         IStaderConfig _staderConfig
514     ) internal view {
515         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
517         if (_addr != withdrawVaultAddress) {
518             revert CallerNotWithdrawVault();
519         }
520     }



```

```
UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig) (ValidatorWithdrawalVault.sol#582-592) is never used and should be removed



    
582     function computeExchangeRate(
583         uint256 totalETHBalance,
584         uint256 totalETHXSupply,
585         IStaderConfig _staderConfig
586     ) internal view returns (uint256) {
587         uint256 DECIMALS = _staderConfig.getDecimals();
588         uint256 newExchangeRate = (totalETHBalance == 0 || totalETHXSupply == 0)
589             ? DECIMALS
590             : (totalETHBalance * DECIMALS) / totalETHXSupply;
591         return newExchangeRate;
592     }



```

```
Math.mulDiv(uint256,uint256,uint256,Math.Rounding) (ValidatorWithdrawalVault.sol#1081-1092) is never used and should be removed



    
1081     function mulDiv(
1082         uint256 x,
1083         uint256 y,
1084         uint256 denominator,
1085         Rounding rounding
1086     ) internal pure returns (uint256) {
1087         uint256 result = mulDiv(x, y, denominator);
1088         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
1089             result += 1;
1090         }
1091         return result;
1092     }



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (ValidatorWithdrawalVault.sol#476-490) is never used and should be removed



    
476     function getPubkeyForValidSender(
477         uint8 _poolId,
478         uint256 _validatorId,
479         address _addr,
480         IStaderConfig _staderConfig
481     ) internal view returns (bytes memory) {
482         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );
486         if (_addr != withdrawVaultAddress) {
487             revert CallerNotWithdrawVault();
488         }
489         return pubkey;
490     }



```

```
Math.min(uint256,uint256) (ValidatorWithdrawalVault.sol#967-969) is never used and should be removed



    
967     function min(uint256 a, uint256 b) internal pure returns (uint256) {
968         return a < b ? a : b;
969     }



```

```
UtilLib.onlyOperatorRole(address,IStaderConfig) (ValidatorWithdrawalVault.sol#459-463) is never used and should be removed



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {
460         if (!_staderConfig.onlyOperatorRole(_addr)) {
461             revert CallerNotOperator();
462         }
463     }



```

```
UtilLib.onlyManagerRole(address,IStaderConfig) (ValidatorWithdrawalVault.sol#453-457) is never used and should be removed



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {
454         if (!_staderConfig.onlyManagerRole(_addr)) {
455             revert CallerNotManager();
456         }
457     }



```

```
UtilLib.getOperatorRewardAddress(address,IStaderConfig) (ValidatorWithdrawalVault.sol#545-554) is never used and should be removed



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)
546         internal
547         view
548         returns (address payable)
549     {
550         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getOperatorPoolId(_operator);
551         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
552         uint256 operatorId = INodeRegistry(nodeRegistry).operatorIDByAddress(_operator);
553         return INodeRegistry(nodeRegistry).getOperatorRewardAddress(operatorId);
554     }



```

### VaultFactory.sol


```
StringsUpgradeable.toString(uint256) (VaultFactory.sol#1652-1672) is never used and should be removed



    
1652     function toString(uint256 value) internal pure returns (string memory) {
1653         unchecked {
1654             uint256 length = MathUpgradeable.log10(value) + 1;
1655             string memory buffer = new string(length);
1656             uint256 ptr;
1657             /// @solidity memory-safe-assembly
1658             assembly {
1659                 ptr := add(buffer, add(32, length))
1660             }
1661             while (true) {
1662                 ptr--;
1663                 /// @solidity memory-safe-assembly
1664                 assembly {
1665                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
1666                 }
1667                 value /= 10;
1668                 if (value == 0) break;
1669             }
1670             return buffer;
1671         }
1672     }



```

```
ContextUpgradeable._msgData() (VaultFactory.sol#1285-1287) is never used and should be removed



    
1285     function _msgData() internal view virtual returns (bytes calldata) {
1286         return msg.data;
1287     }



```

```
MathUpgradeable.log2(uint256,MathUpgradeable.Rounding) (VaultFactory.sol#1542-1547) is never used and should be removed



    
1542     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
1543         unchecked {
1544             uint256 result = log2(value);
1545             return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
1546         }
1547     }



```

```
Initializable._isInitializing() (VaultFactory.sol#1260-1262) is never used and should be removed



    
1260     function _isInitializing() internal view returns (bool) {
1261         return _initializing;
1262     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256) (VaultFactory.sol#999-1005) is never used and should be removed



    
999     function functionCallWithValue(
1000         address target,
1001         bytes memory data,
1002         uint256 value
1003     ) internal returns (bytes memory) {
1004         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
1005     }



```

```
MathUpgradeable.ceilDiv(uint256,uint256) (VaultFactory.sol#1340-1343) is never used and should be removed



    
1340     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
1341         // (a + b - 1) / b can overflow on addition, so we distribute.
1342         return a == 0 ? 0 : (a - 1) / b + 1;
1343     }



```

```
MathUpgradeable.min(uint256,uint256) (VaultFactory.sol#1321-1323) is never used and should be removed



    
1321     function min(uint256 a, uint256 b) internal pure returns (uint256) {
1322         return a < b ? a : b;
1323     }



```

```
MathUpgradeable.sqrt(uint256) (VaultFactory.sol#1453-1484) is never used and should be removed



    
1453     function sqrt(uint256 a) internal pure returns (uint256) {
1454         if (a == 0) {
1455             return 0;
1456         }
1457 
1458         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
1459         //
1460         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
1461         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
1462         //
1463         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
1464         // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
1465         // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
1466         //
1467         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
1468         uint256 result = 1 << (log2(a) >> 1);
1469 
1470         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
1471         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
1472         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
1473         // into the expected uint128 result.
1474         unchecked {
1475             result = (result + a / result) >> 1;
1476             result = (result + a / result) >> 1;
1477             result = (result + a / result) >> 1;
1478             result = (result + a / result) >> 1;
1479             result = (result + a / result) >> 1;
1480             result = (result + a / result) >> 1;
1481             result = (result + a / result) >> 1;
1482             return min(result, a / result);
1483         }
1484     }



```

```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (VaultFactory.sol#522-532) is never used and should be removed



    
522     function getOperatorAddressByValidatorId(
523         uint8 _poolId,
524         uint256 _validatorId,
525         IStaderConfig _staderConfig
526     ) internal view returns (address) {
527         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
530 
531         return operatorAddress;
532     }



```

```
UtilLib.getPubkeyRoot(bytes) (VaultFactory.sol#561-568) is never used and should be removed



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {
562         if (_pubkey.length != VALIDATOR_PUBKEY_LENGTH) {
563             revert InvalidPubkeyLength();
564         }
565 
566         // Append 16 bytes of zero padding to the pubkey and compute its hash to get the pubkey root.
567         return sha256(abi.encodePacked(_pubkey, bytes16(0)));
568     }



```

```
AccessControlUpgradeable.__AccessControl_init() (VaultFactory.sol#1805-1806) is never used and should be removed



    
1805     function __AccessControl_init() internal onlyInitializing {
1806     }



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (VaultFactory.sol#492-507) is never used and should be removed



    
492     function getOperatorForValidSender(
493         uint8 _poolId,
494         uint256 _validatorId,
495         address _addr,
496         IStaderConfig _staderConfig
497     ) internal view returns (address) {
498         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );
502         if (_addr != withdrawVaultAddress) {
503             revert CallerNotWithdrawVault();
504         }
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
506         return operator;
507     }



```

```
MathUpgradeable.log10(uint256,MathUpgradeable.Rounding) (VaultFactory.sol#1591-1596) is never used and should be removed



    
1591     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
1592         unchecked {
1593             uint256 result = log10(value);
1594             return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);
1595         }
1596     }



```

```
AddressUpgradeable.functionCall(address,bytes) (VaultFactory.sol#970-972) is never used and should be removed



    
970     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
971         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
972     }



```

```
ContextUpgradeable.__Context_init_unchained() (VaultFactory.sol#1279-1280) is never used and should be removed



    
1279     function __Context_init_unchained() internal onlyInitializing {
1280     }



```

```
ERC165Upgradeable.__ERC165_init_unchained() (VaultFactory.sol#1749-1750) is never used and should be removed



    
1749     function __ERC165_init_unchained() internal onlyInitializing {
1750     }



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (VaultFactory.sol#570-580) is never used and should be removed



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)
571         internal
572         view
573         returns (bool)
574     {
575         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getValidatorPoolId(_pubkey);
576         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
577         uint256 validatorId = INodeRegistry(nodeRegistry).validatorIdByPubkey(_pubkey);
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);
579         return IVaultProxy(withdrawVaultAddress).vaultSettleStatus();
580     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256) (VaultFactory.sol#1350-1430) is never used and should be removed



    
1350     function mulDiv(
1351         uint256 x,
1352         uint256 y,
1353         uint256 denominator
1354     ) internal pure returns (uint256 result) {
1355         unchecked {
1356             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
1357             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
1358             // variables such that product = prod1 * 2^256 + prod0.
1359             uint256 prod0; // Least significant 256 bits of the product
1360             uint256 prod1; // Most significant 256 bits of the product
1361             assembly {
1362                 let mm := mulmod(x, y, not(0))
1363                 prod0 := mul(x, y)
1364                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
1365             }
1366 
1367             // Handle non-overflow cases, 256 by 256 division.
1368             if (prod1 == 0) {
1369                 return prod0 / denominator;
1370             }
1371 
1372             // Make sure the result is less than 2^256. Also prevents denominator == 0.
1373             require(denominator > prod1);
1374 
1375             ///////////////////////////////////////////////
1376             // 512 by 256 division.
1377             ///////////////////////////////////////////////
1378 
1379             // Make division exact by subtracting the remainder from [prod1 prod0].
1380             uint256 remainder;
1381             assembly {
1382                 // Compute remainder using mulmod.
1383                 remainder := mulmod(x, y, denominator)
1384 
1385                 // Subtract 256 bit number from 512 bit number.
1386                 prod1 := sub(prod1, gt(remainder, prod0))
1387                 prod0 := sub(prod0, remainder)
1388             }
1389 
1390             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
1391             // See https://cs.stackexchange.com/q/138556/92363.
1392 
1393             // Does not overflow because the denominator cannot be zero at this stage in the function.
1394             uint256 twos = denominator & (~denominator + 1);
1395             assembly {
1396                 // Divide denominator by twos.
1397                 denominator := div(denominator, twos)
1398 
1399                 // Divide [prod1 prod0] by twos.
1400                 prod0 := div(prod0, twos)
1401 
1402                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
1403                 twos := add(div(sub(0, twos), twos), 1)
1404             }
1405 
1406             // Shift in bits from prod1 into prod0.
1407             prod0 |= prod1 * twos;
1408 
1409             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
1410             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
1411             // four bits. That is, denominator * inv = 1 mod 2^4.
1412             uint256 inverse = (3 * denominator) ^ 2;
1413 
1414             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
1415             // in modular arithmetic, doubling the correct bits in each step.
1416             inverse *= 2 - denominator * inverse; // inverse mod 2^8
1417             inverse *= 2 - denominator * inverse; // inverse mod 2^16
1418             inverse *= 2 - denominator * inverse; // inverse mod 2^32
1419             inverse *= 2 - denominator * inverse; // inverse mod 2^64
1420             inverse *= 2 - denominator * inverse; // inverse mod 2^128
1421             inverse *= 2 - denominator * inverse; // inverse mod 2^256
1422 
1423             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
1424             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
1425             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
1426             // is no longer required.
1427             result = prod0 * inverse;
1428             return result;
1429         }
1430     }



```

```
AddressUpgradeable.functionCall(address,bytes,string) (VaultFactory.sol#980-986) is never used and should be removed



    
980     function functionCall(
981         address target,
982         bytes memory data,
983         string memory errorMessage
984     ) internal returns (bytes memory) {
985         return functionCallWithValue(target, data, 0, errorMessage);
986     }



```

```
AddressUpgradeable.sendValue(address,uint256) (VaultFactory.sol#945-950) is never used and should be removed



    
945     function sendValue(address payable recipient, uint256 amount) internal {
946         require(address(this).balance >= amount, "Address: insufficient balance");
947 
948         (bool success, ) = recipient.call{value: amount}("");
949         require(success, "Address: unable to send value, recipient may have reverted");
950     }



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (VaultFactory.sol#534-543) is never used and should be removed



    
534     function getOperatorAddressByOperatorId(
535         uint8 _poolId,
536         uint256 _operatorId,
537         IStaderConfig _staderConfig
538     ) internal view returns (address) {
539         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);
541 
542         return operatorAddress;
543     }



```

```
UtilLib.onlyStaderContract(address,IStaderConfig,bytes32) (VaultFactory.sol#466-474) is never used and should be removed



    
466     function onlyStaderContract(
467         address _addr,
468         IStaderConfig _staderConfig,
469         bytes32 _contractName
470     ) internal view {
471         if (!_staderConfig.onlyStaderContract(_addr, _contractName)) {
472             revert CallerNotStaderContract();
473         }
474     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes) (VaultFactory.sol#1030-1032) is never used and should be removed



    
1030     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
1031         return functionStaticCall(target, data, "Address: low-level static call failed");
1032     }



```

```
MathUpgradeable.sqrt(uint256,MathUpgradeable.Rounding) (VaultFactory.sol#1489-1494) is never used and should be removed



    
1489     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
1490         unchecked {
1491             uint256 result = sqrt(a);
1492             return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
1493         }
1494     }



```

```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (VaultFactory.sol#509-520) is never used and should be removed



    
509     function onlyValidatorWithdrawVault(
510         uint8 _poolId,
511         uint256 _validatorId,
512         address _addr,
513         IStaderConfig _staderConfig
514     ) internal view {
515         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
517         if (_addr != withdrawVaultAddress) {
518             revert CallerNotWithdrawVault();
519         }
520     }



```

```
MathUpgradeable.log2(uint256) (VaultFactory.sol#1500-1536) is never used and should be removed



    
1500     function log2(uint256 value) internal pure returns (uint256) {
1501         uint256 result = 0;
1502         unchecked {
1503             if (value >> 128 > 0) {
1504                 value >>= 128;
1505                 result += 128;
1506             }
1507             if (value >> 64 > 0) {
1508                 value >>= 64;
1509                 result += 64;
1510             }
1511             if (value >> 32 > 0) {
1512                 value >>= 32;
1513                 result += 32;
1514             }
1515             if (value >> 16 > 0) {
1516                 value >>= 16;
1517                 result += 16;
1518             }
1519             if (value >> 8 > 0) {
1520                 value >>= 8;
1521                 result += 8;
1522             }
1523             if (value >> 4 > 0) {
1524                 value >>= 4;
1525                 result += 4;
1526             }
1527             if (value >> 2 > 0) {
1528                 value >>= 2;
1529                 result += 2;
1530             }
1531             if (value >> 1 > 0) {
1532                 result += 1;
1533             }
1534         }
1535         return result;
1536     }



```

```
UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig) (VaultFactory.sol#582-592) is never used and should be removed



    
582     function computeExchangeRate(
583         uint256 totalETHBalance,
584         uint256 totalETHXSupply,
585         IStaderConfig _staderConfig
586     ) internal view returns (uint256) {
587         uint256 DECIMALS = _staderConfig.getDecimals();
588         uint256 newExchangeRate = (totalETHBalance == 0 || totalETHXSupply == 0)
589             ? DECIMALS
590             : (totalETHBalance * DECIMALS) / totalETHXSupply;
591         return newExchangeRate;
592     }



```

```
AccessControlUpgradeable._setRoleAdmin(bytes32,bytes32) (VaultFactory.sol#1974-1978) is never used and should be removed



    
1974     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
1975         bytes32 previousAdminRole = getRoleAdmin(role);
1976         _roles[role].adminRole = adminRole;
1977         emit RoleAdminChanged(role, previousAdminRole, adminRole);
1978     }



```

```
MathUpgradeable.average(uint256,uint256) (VaultFactory.sol#1329-1332) is never used and should be removed



    
1329     function average(uint256 a, uint256 b) internal pure returns (uint256) {
1330         // (a + b) / 2 can overflow.
1331         return (a & b) + (a ^ b) / 2;
1332     }



```

```
StringsUpgradeable.toHexString(uint256) (VaultFactory.sol#1677-1681) is never used and should be removed



    
1677     function toHexString(uint256 value) internal pure returns (string memory) {
1678         unchecked {
1679             return toHexString(value, MathUpgradeable.log256(value) + 1);
1680         }
1681     }



```

```
MathUpgradeable.log10(uint256) (VaultFactory.sol#1553-1585) is never used and should be removed



    
1553     function log10(uint256 value) internal pure returns (uint256) {
1554         uint256 result = 0;
1555         unchecked {
1556             if (value >= 10**64) {
1557                 value /= 10**64;
1558                 result += 64;
1559             }
1560             if (value >= 10**32) {
1561                 value /= 10**32;
1562                 result += 32;
1563             }
1564             if (value >= 10**16) {
1565                 value /= 10**16;
1566                 result += 16;
1567             }
1568             if (value >= 10**8) {
1569                 value /= 10**8;
1570                 result += 8;
1571             }
1572             if (value >= 10**4) {
1573                 value /= 10**4;
1574                 result += 4;
1575             }
1576             if (value >= 10**2) {
1577                 value /= 10**2;
1578                 result += 2;
1579             }
1580             if (value >= 10**1) {
1581                 result += 1;
1582             }
1583         }
1584         return result;
1585     }



```

```
ERC165Upgradeable.__ERC165_init() (VaultFactory.sol#1746-1747) is never used and should be removed



    
1746     function __ERC165_init() internal onlyInitializing {
1747     }



```

```
MathUpgradeable.mulDiv(uint256,uint256,uint256,MathUpgradeable.Rounding) (VaultFactory.sol#1435-1446) is never used and should be removed



    
1435     function mulDiv(
1436         uint256 x,
1437         uint256 y,
1438         uint256 denominator,
1439         Rounding rounding
1440     ) internal pure returns (uint256) {
1441         uint256 result = mulDiv(x, y, denominator);
1442         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
1443             result += 1;
1444         }
1445         return result;
1446     }



```

```
AddressUpgradeable.verifyCallResult(bool,bytes,string) (VaultFactory.sol#1079-1089) is never used and should be removed



    
1079     function verifyCallResult(
1080         bool success,
1081         bytes memory returndata,
1082         string memory errorMessage
1083     ) internal pure returns (bytes memory) {
1084         if (success) {
1085             return returndata;
1086         } else {
1087             _revert(returndata, errorMessage);
1088         }
1089     }



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (VaultFactory.sol#476-490) is never used and should be removed



    
476     function getPubkeyForValidSender(
477         uint8 _poolId,
478         uint256 _validatorId,
479         address _addr,
480         IStaderConfig _staderConfig
481     ) internal view returns (bytes memory) {
482         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );
486         if (_addr != withdrawVaultAddress) {
487             revert CallerNotWithdrawVault();
488         }
489         return pubkey;
490     }



```

```
AddressUpgradeable._revert(bytes,string) (VaultFactory.sol#1091-1103) is never used and should be removed



    
1091     function _revert(bytes memory returndata, string memory errorMessage) private pure {
1092         // Look for revert reason and bubble it up if present
1093         if (returndata.length > 0) {
1094             // The easiest way to bubble the revert reason is using memory via assembly
1095             /// @solidity memory-safe-assembly
1096             assembly {
1097                 let returndata_size := mload(returndata)
1098                 revert(add(32, returndata), returndata_size)
1099             }
1100         } else {
1101             revert(errorMessage);
1102         }
1103     }



```

```
Initializable._getInitializedVersion() (VaultFactory.sol#1253-1255) is never used and should be removed



    
1253     function _getInitializedVersion() internal view returns (uint8) {
1254         return _initialized;
1255     }



```

```
AccessControlUpgradeable._setupRole(bytes32,address) (VaultFactory.sol#1965-1967) is never used and should be removed



    
1965     function _setupRole(bytes32 role, address account) internal virtual {
1966         _grantRole(role, account);
1967     }



```

```
AddressUpgradeable.functionStaticCall(address,bytes,string) (VaultFactory.sol#1040-1047) is never used and should be removed



    
1040     function functionStaticCall(
1041         address target,
1042         bytes memory data,
1043         string memory errorMessage
1044     ) internal view returns (bytes memory) {
1045         (bool success, bytes memory returndata) = target.staticcall(data);
1046         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
1047     }



```

```
MathUpgradeable.log256(uint256,MathUpgradeable.Rounding) (VaultFactory.sol#1634-1639) is never used and should be removed



    
1634     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
1635         unchecked {
1636             uint256 result = log256(value);
1637             return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);
1638         }
1639     }



```

```
UtilLib.onlyOperatorRole(address,IStaderConfig) (VaultFactory.sol#459-463) is never used and should be removed



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {
460         if (!_staderConfig.onlyOperatorRole(_addr)) {
461             revert CallerNotOperator();
462         }
463     }



```

```
UtilLib.sendValue(address,uint256) (VaultFactory.sol#594-599) is never used and should be removed



    
594     function sendValue(address _receiver, uint256 _amount) internal {
595         (bool success, ) = payable(_receiver).call{value: _amount}('');
596         if (!success) {
597             revert TransferFailed();
598         }
599     }



```

```
MathUpgradeable.max(uint256,uint256) (VaultFactory.sol#1314-1316) is never used and should be removed



    
1314     function max(uint256 a, uint256 b) internal pure returns (uint256) {
1315         return a > b ? a : b;
1316     }



```

```
ClonesUpgradeable.clone(address) (VaultFactory.sol#731-742) is never used and should be removed



    
731     function clone(address implementation) internal returns (address instance) {
732         /// @solidity memory-safe-assembly
733         assembly {
734             // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
735             // of the `implementation` address with the bytecode before the address.
736             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
737             // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
738             mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
739             instance := create(0, 0x09, 0x37)
740         }
741         require(instance != address(0), "ERC1167: create failed");
742     }



```

```
ContextUpgradeable.__Context_init() (VaultFactory.sol#1276-1277) is never used and should be removed



    
1276     function __Context_init() internal onlyInitializing {
1277     }



```

```
UtilLib.onlyManagerRole(address,IStaderConfig) (VaultFactory.sol#453-457) is never used and should be removed



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {
454         if (!_staderConfig.onlyManagerRole(_addr)) {
455             revert CallerNotManager();
456         }
457     }



```

```
UtilLib.getOperatorRewardAddress(address,IStaderConfig) (VaultFactory.sol#545-554) is never used and should be removed



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)
546         internal
547         view
548         returns (address payable)
549     {
550         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getOperatorPoolId(_operator);
551         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
552         uint256 operatorId = INodeRegistry(nodeRegistry).operatorIDByAddress(_operator);
553         return INodeRegistry(nodeRegistry).getOperatorRewardAddress(operatorId);
554     }



```

```
AddressUpgradeable.verifyCallResultFromTarget(address,bool,bytes,string) (VaultFactory.sol#1055-1071) is never used and should be removed



    
1055     function verifyCallResultFromTarget(
1056         address target,
1057         bool success,
1058         bytes memory returndata,
1059         string memory errorMessage
1060     ) internal view returns (bytes memory) {
1061         if (success) {
1062             if (returndata.length == 0) {
1063                 // only check isContract if the call was successful and the return data is empty
1064                 // otherwise we already know that it was a contract
1065                 require(isContract(target), "Address: call to non-contract");
1066             }
1067             return returndata;
1068         } else {
1069             _revert(returndata, errorMessage);
1070         }
1071     }



```

```
MathUpgradeable.log256(uint256) (VaultFactory.sol#1604-1628) is never used and should be removed



    
1604     function log256(uint256 value) internal pure returns (uint256) {
1605         uint256 result = 0;
1606         unchecked {
1607             if (value >> 128 > 0) {
1608                 value >>= 128;
1609                 result += 16;
1610             }
1611             if (value >> 64 > 0) {
1612                 value >>= 64;
1613                 result += 8;
1614             }
1615             if (value >> 32 > 0) {
1616                 value >>= 32;
1617                 result += 4;
1618             }
1619             if (value >> 16 > 0) {
1620                 value >>= 16;
1621                 result += 2;
1622             }
1623             if (value >> 8 > 0) {
1624                 result += 1;
1625             }
1626         }
1627         return result;
1628     }



```

```
AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (VaultFactory.sol#1013-1022) is never used and should be removed



    
1013     function functionCallWithValue(
1014         address target,
1015         bytes memory data,
1016         uint256 value,
1017         string memory errorMessage
1018     ) internal returns (bytes memory) {
1019         require(address(this).balance >= value, "Address: insufficient balance for call");
1020         (bool success, bytes memory returndata) = target.call{value: value}(data);
1021         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
1022     }



```

### VaultProxy.sol


```
UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig) (VaultProxy.sol#522-532) is never used and should be removed



    
522     function getOperatorAddressByValidatorId(
523         uint8 _poolId,
524         uint256 _validatorId,
525         IStaderConfig _staderConfig
526     ) internal view returns (address) {
527         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
528         (, , , , , uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
529         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
530 
531         return operatorAddress;
532     }



```

```
UtilLib.getPubkeyRoot(bytes) (VaultProxy.sol#561-568) is never used and should be removed



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {
562         if (_pubkey.length != VALIDATOR_PUBKEY_LENGTH) {
563             revert InvalidPubkeyLength();
564         }
565 
566         // Append 16 bytes of zero padding to the pubkey and compute its hash to get the pubkey root.
567         return sha256(abi.encodePacked(_pubkey, bytes16(0)));
568     }



```

```
UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig) (VaultProxy.sol#492-507) is never used and should be removed



    
492     function getOperatorForValidSender(
493         uint8 _poolId,
494         uint256 _validatorId,
495         address _addr,
496         IStaderConfig _staderConfig
497     ) internal view returns (address) {
498         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
499         (, , , , address withdrawVaultAddress, uint256 operatorId, , ) = INodeRegistry(nodeRegistry).validatorRegistry(
500             _validatorId
501         );
502         if (_addr != withdrawVaultAddress) {
503             revert CallerNotWithdrawVault();
504         }
505         (, , , , address operator) = INodeRegistry(nodeRegistry).operatorStructById(operatorId);
506         return operator;
507     }



```

```
UtilLib.getValidatorSettleStatus(bytes,IStaderConfig) (VaultProxy.sol#570-580) is never used and should be removed



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)
571         internal
572         view
573         returns (bool)
574     {
575         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getValidatorPoolId(_pubkey);
576         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
577         uint256 validatorId = INodeRegistry(nodeRegistry).validatorIdByPubkey(_pubkey);
578         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(validatorId);
579         return IVaultProxy(withdrawVaultAddress).vaultSettleStatus();
580     }



```

```
UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig) (VaultProxy.sol#534-543) is never used and should be removed



    
534     function getOperatorAddressByOperatorId(
535         uint8 _poolId,
536         uint256 _operatorId,
537         IStaderConfig _staderConfig
538     ) internal view returns (address) {
539         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
540         (, , , , address operatorAddress) = INodeRegistry(nodeRegistry).operatorStructById(_operatorId);
541 
542         return operatorAddress;
543     }



```

```
UtilLib.onlyStaderContract(address,IStaderConfig,bytes32) (VaultProxy.sol#466-474) is never used and should be removed



    
466     function onlyStaderContract(
467         address _addr,
468         IStaderConfig _staderConfig,
469         bytes32 _contractName
470     ) internal view {
471         if (!_staderConfig.onlyStaderContract(_addr, _contractName)) {
472             revert CallerNotStaderContract();
473         }
474     }



```

```
UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig) (VaultProxy.sol#509-520) is never used and should be removed



    
509     function onlyValidatorWithdrawVault(
510         uint8 _poolId,
511         uint256 _validatorId,
512         address _addr,
513         IStaderConfig _staderConfig
514     ) internal view {
515         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
516         (, , , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);
517         if (_addr != withdrawVaultAddress) {
518             revert CallerNotWithdrawVault();
519         }
520     }



```

```
UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig) (VaultProxy.sol#582-592) is never used and should be removed



    
582     function computeExchangeRate(
583         uint256 totalETHBalance,
584         uint256 totalETHXSupply,
585         IStaderConfig _staderConfig
586     ) internal view returns (uint256) {
587         uint256 DECIMALS = _staderConfig.getDecimals();
588         uint256 newExchangeRate = (totalETHBalance == 0 || totalETHXSupply == 0)
589             ? DECIMALS
590             : (totalETHBalance * DECIMALS) / totalETHXSupply;
591         return newExchangeRate;
592     }



```

```
UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig) (VaultProxy.sol#476-490) is never used and should be removed



    
476     function getPubkeyForValidSender(
477         uint8 _poolId,
478         uint256 _validatorId,
479         address _addr,
480         IStaderConfig _staderConfig
481     ) internal view returns (bytes memory) {
482         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);
483         (, bytes memory pubkey, , , address withdrawVaultAddress, , , ) = INodeRegistry(nodeRegistry).validatorRegistry(
484             _validatorId
485         );
486         if (_addr != withdrawVaultAddress) {
487             revert CallerNotWithdrawVault();
488         }
489         return pubkey;
490     }



```

```
UtilLib.onlyOperatorRole(address,IStaderConfig) (VaultProxy.sol#459-463) is never used and should be removed



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {
460         if (!_staderConfig.onlyOperatorRole(_addr)) {
461             revert CallerNotOperator();
462         }
463     }



```

```
UtilLib.sendValue(address,uint256) (VaultProxy.sol#594-599) is never used and should be removed



    
594     function sendValue(address _receiver, uint256 _amount) internal {
595         (bool success, ) = payable(_receiver).call{value: _amount}('');
596         if (!success) {
597             revert TransferFailed();
598         }
599     }



```

```
UtilLib.onlyManagerRole(address,IStaderConfig) (VaultProxy.sol#453-457) is never used and should be removed



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {
454         if (!_staderConfig.onlyManagerRole(_addr)) {
455             revert CallerNotManager();
456         }
457     }



```

```
UtilLib.getOperatorRewardAddress(address,IStaderConfig) (VaultProxy.sol#545-554) is never used and should be removed



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)
546         internal
547         view
548         returns (address payable)
549     {
550         uint8 poolId = IPoolUtils(_staderConfig.getPoolUtils()).getOperatorPoolId(_operator);
551         address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(poolId);
552         uint256 operatorId = INodeRegistry(nodeRegistry).operatorIDByAddress(_operator);
553         return INodeRegistry(nodeRegistry).getOperatorRewardAddress(operatorId);
554     }



```

## solc-version
### Severity: Informational

### Auction.sol


```
solc-0.8.16 is not recommended for deployment



```

```
Pragma version0.8.16 (Auction.sol#2) allows old versions



    
2 pragma solidity 0.8.16;



```

### ETHx.sol


```
solc-0.8.16 is not recommended for deployment



```

```
Pragma version0.8.16 (ETHx.sol#2) allows old versions



    
2 pragma solidity 0.8.16;



```

### NodeELRewardVault.sol


```
solc-0.8.16 is not recommended for deployment



```

```
Pragma version0.8.16 (NodeELRewardVault.sol#2) allows old versions



    
2 pragma solidity 0.8.16;



```

### OperatorRewardsCollector.sol


```
solc-0.8.16 is not recommended for deployment



```

```
Pragma version0.8.16 (OperatorRewardsCollector.sol#2) allows old versions



    
2 pragma solidity 0.8.16;



```

### Penalty.sol


```
solc-0.8.16 is not recommended for deployment



```

```
Pragma version0.8.16 (Penalty.sol#2) allows old versions



    
2 pragma solidity 0.8.16;



```

### PermissionedNodeRegistry.sol


```
solc-0.8.16 is not recommended for deployment



```

```
Pragma version0.8.16 (PermissionedNodeRegistry.sol#2) allows old versions



    
2 pragma solidity 0.8.16;



```

### PermissionedPool.sol


```
solc-0.8.16 is not recommended for deployment



```

```
Pragma version0.8.16 (PermissionedPool.sol#2) allows old versions



    
2 pragma solidity 0.8.16;



```

### PermissionlessNodeRegistry.sol


```
solc-0.8.16 is not recommended for deployment



```

```
Pragma version0.8.16 (PermissionlessNodeRegistry.sol#2) allows old versions



    
2 pragma solidity 0.8.16;



```

### PermissionlessPool.sol


```
solc-0.8.16 is not recommended for deployment



```

```
Pragma version0.8.16 (PermissionlessPool.sol#2) allows old versions



    
2 pragma solidity 0.8.16;



```

### PoolSelector.sol


```
solc-0.8.16 is not recommended for deployment



```

```
Pragma version0.8.16 (PoolSelector.sol#2) allows old versions



    
2 pragma solidity 0.8.16;



```

### PoolUtils.sol


```
solc-0.8.16 is not recommended for deployment



```

```
Pragma version0.8.16 (PoolUtils.sol#2) allows old versions



    
2 pragma solidity 0.8.16;



```

### SDCollateral.sol


```
solc-0.8.16 is not recommended for deployment



```

```
Pragma version0.8.16 (SDCollateral.sol#2) allows old versions



    
2 pragma solidity 0.8.16;



```

### SocializingPool.sol


```
solc-0.8.16 is not recommended for deployment



```

```
Pragma version0.8.16 (SocializingPool.sol#3) allows old versions



    
3 pragma solidity 0.8.16;



```

### StaderConfig.sol


```
solc-0.8.16 is not recommended for deployment



```

```
Pragma version0.8.16 (StaderConfig.sol#2) allows old versions



    
2 pragma solidity 0.8.16;



```

### StaderInsuranceFund.sol


```
solc-0.8.16 is not recommended for deployment



```

```
Pragma version0.8.16 (StaderInsuranceFund.sol#2) allows old versions



    
2 pragma solidity 0.8.16;



```

### StaderOracle.sol


```
solc-0.8.16 is not recommended for deployment



```

```
Pragma version0.8.16 (StaderOracle.sol#2) allows old versions



    
2 pragma solidity 0.8.16;



```

### StaderStakePoolsManager.sol


```
solc-0.8.16 is not recommended for deployment



```

```
Pragma version0.8.16 (StaderStakePoolsManager.sol#3) allows old versions



    
3 pragma solidity 0.8.16;



```

### UserWithdrawalManager.sol


```
solc-0.8.16 is not recommended for deployment



```

```
Pragma version0.8.16 (UserWithdrawalManager.sol#2) allows old versions



    
2 pragma solidity 0.8.16;



```

### UtilLib.sol


```
solc-0.8.16 is not recommended for deployment



```

```
Pragma version0.8.16 (UtilLib.sol#2) allows old versions



    
2 pragma solidity 0.8.16;



```

### ValidatorStatus.sol


```
solc-0.8.16 is not recommended for deployment



```

```
Pragma version0.8.16 (ValidatorStatus.sol#2) allows old versions



    
2 pragma solidity 0.8.16;



```

### ValidatorWithdrawalVault.sol


```
solc-0.8.16 is not recommended for deployment



```

```
Pragma version0.8.16 (ValidatorWithdrawalVault.sol#2) allows old versions



    
2 pragma solidity 0.8.16;



```

### VaultFactory.sol


```
solc-0.8.16 is not recommended for deployment



```

```
Pragma version0.8.16 (VaultFactory.sol#2) allows old versions



    
2 pragma solidity 0.8.16;



```

### VaultProxy.sol


```
solc-0.8.16 is not recommended for deployment



```

```
Pragma version^0.8.16 (VaultProxy.sol#2) allows old versions



    
2 pragma solidity ^0.8.16;



```

## low-level-calls
### Severity: Informational

### Auction.sol


```
Low level call in Auction.withdrawUnselectedBid(uint256) (Auction.sol#2322-2337):
	- (success) = address(msg.sender).call{value: withdrawalAmount}() (Auction.sol#2333)



    
2333         (bool success, ) = payable(msg.sender).call{value: withdrawalAmount}('');



```

```
Low level call in AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (Auction.sol#1023-1032):
	- (success,returndata) = target.call{value: value}(data) (Auction.sol#1030)



    
1030         (bool success, bytes memory returndata) = target.call{value: value}(data);



```

```
Low level call in UtilLib.sendValue(address,uint256) (Auction.sol#594-599):
	- (success) = address(_receiver).call{value: _amount}() (Auction.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

```
Low level call in AddressUpgradeable.functionStaticCall(address,bytes,string) (Auction.sol#1050-1057):
	- (success,returndata) = target.staticcall(data) (Auction.sol#1055)



    
1055         (bool success, bytes memory returndata) = target.staticcall(data);



```

```
Low level call in AddressUpgradeable.sendValue(address,uint256) (Auction.sol#955-960):
	- (success) = recipient.call{value: amount}() (Auction.sol#958)



    
958         (bool success, ) = recipient.call{value: amount}("");



```

### ETHx.sol


```
Low level call in AddressUpgradeable.functionStaticCall(address,bytes,string) (ETHx.sol#863-870):
	- (success,returndata) = target.staticcall(data) (ETHx.sol#868)



    
868         (bool success, bytes memory returndata) = target.staticcall(data);



```

```
Low level call in AddressUpgradeable.sendValue(address,uint256) (ETHx.sol#768-773):
	- (success) = recipient.call{value: amount}() (ETHx.sol#771)



    
771         (bool success, ) = recipient.call{value: amount}("");



```

```
Low level call in UtilLib.sendValue(address,uint256) (ETHx.sol#594-599):
	- (success) = address(_receiver).call{value: _amount}() (ETHx.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

```
Low level call in AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (ETHx.sol#836-845):
	- (success,returndata) = target.call{value: value}(data) (ETHx.sol#843)



    
843         (bool success, bytes memory returndata) = target.call{value: value}(data);



```

### NodeELRewardVault.sol


```
Low level call in UtilLib.sendValue(address,uint256) (NodeELRewardVault.sol#594-599):
	- (success) = address(_receiver).call{value: _amount}() (NodeELRewardVault.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

### OperatorRewardsCollector.sol


```
Low level call in AddressUpgradeable.functionStaticCall(address,bytes,string) (OperatorRewardsCollector.sol#858-865):
	- (success,returndata) = target.staticcall(data) (OperatorRewardsCollector.sol#863)



    
863         (bool success, bytes memory returndata) = target.staticcall(data);



```

```
Low level call in AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (OperatorRewardsCollector.sol#831-840):
	- (success,returndata) = target.call{value: value}(data) (OperatorRewardsCollector.sol#838)



    
838         (bool success, bytes memory returndata) = target.call{value: value}(data);



```

```
Low level call in UtilLib.sendValue(address,uint256) (OperatorRewardsCollector.sol#594-599):
	- (success) = address(_receiver).call{value: _amount}() (OperatorRewardsCollector.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

```
Low level call in AddressUpgradeable.sendValue(address,uint256) (OperatorRewardsCollector.sol#763-768):
	- (success) = recipient.call{value: amount}() (OperatorRewardsCollector.sol#766)



    
766         (bool success, ) = recipient.call{value: amount}("");



```

### Penalty.sol


```
Low level call in AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (Penalty.sol#1293-1302):
	- (success,returndata) = target.call{value: value}(data) (Penalty.sol#1300)



    
1300         (bool success, bytes memory returndata) = target.call{value: value}(data);



```

```
Low level call in AddressUpgradeable.sendValue(address,uint256) (Penalty.sol#1225-1230):
	- (success) = recipient.call{value: amount}() (Penalty.sol#1228)



    
1228         (bool success, ) = recipient.call{value: amount}("");



```

```
Low level call in UtilLib.sendValue(address,uint256) (Penalty.sol#594-599):
	- (success) = address(_receiver).call{value: _amount}() (Penalty.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

```
Low level call in AddressUpgradeable.functionStaticCall(address,bytes,string) (Penalty.sol#1320-1327):
	- (success,returndata) = target.staticcall(data) (Penalty.sol#1325)



    
1325         (bool success, bytes memory returndata) = target.staticcall(data);



```

### PermissionedNodeRegistry.sol


```
Low level call in AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (PermissionedNodeRegistry.sol#1173-1182):
	- (success,returndata) = target.call{value: value}(data) (PermissionedNodeRegistry.sol#1180)



    
1180         (bool success, bytes memory returndata) = target.call{value: value}(data);



```

```
Low level call in AddressUpgradeable.functionStaticCall(address,bytes,string) (PermissionedNodeRegistry.sol#1200-1207):
	- (success,returndata) = target.staticcall(data) (PermissionedNodeRegistry.sol#1205)



    
1205         (bool success, bytes memory returndata) = target.staticcall(data);



```

```
Low level call in UtilLib.sendValue(address,uint256) (PermissionedNodeRegistry.sol#594-599):
	- (success) = address(_receiver).call{value: _amount}() (PermissionedNodeRegistry.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

```
Low level call in AddressUpgradeable.sendValue(address,uint256) (PermissionedNodeRegistry.sol#1105-1110):
	- (success) = recipient.call{value: amount}() (PermissionedNodeRegistry.sol#1108)



    
1108         (bool success, ) = recipient.call{value: amount}("");



```

### PermissionedPool.sol


```
Low level call in AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (PermissionedPool.sol#1296-1305):
	- (success,returndata) = target.call{value: value}(data) (PermissionedPool.sol#1303)



    
1303         (bool success, bytes memory returndata) = target.call{value: value}(data);



```

```
Low level call in UtilLib.sendValue(address,uint256) (PermissionedPool.sol#594-599):
	- (success) = address(_receiver).call{value: _amount}() (PermissionedPool.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

```
Low level call in AddressUpgradeable.functionStaticCall(address,bytes,string) (PermissionedPool.sol#1323-1330):
	- (success,returndata) = target.staticcall(data) (PermissionedPool.sol#1328)



    
1328         (bool success, bytes memory returndata) = target.staticcall(data);



```

```
Low level call in AddressUpgradeable.sendValue(address,uint256) (PermissionedPool.sol#1228-1233):
	- (success) = recipient.call{value: amount}() (PermissionedPool.sol#1231)



    
1231         (bool success, ) = recipient.call{value: amount}("");



```

### PermissionlessNodeRegistry.sol


```
Low level call in AddressUpgradeable.sendValue(address,uint256) (PermissionlessNodeRegistry.sol#937-942):
	- (success) = recipient.call{value: amount}() (PermissionlessNodeRegistry.sol#940)



    
940         (bool success, ) = recipient.call{value: amount}("");



```

```
Low level call in UtilLib.sendValue(address,uint256) (PermissionlessNodeRegistry.sol#594-599):
	- (success) = address(_receiver).call{value: _amount}() (PermissionlessNodeRegistry.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

```
Low level call in AddressUpgradeable.functionStaticCall(address,bytes,string) (PermissionlessNodeRegistry.sol#1032-1039):
	- (success,returndata) = target.staticcall(data) (PermissionlessNodeRegistry.sol#1037)



    
1037         (bool success, bytes memory returndata) = target.staticcall(data);



```

```
Low level call in AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (PermissionlessNodeRegistry.sol#1005-1014):
	- (success,returndata) = target.call{value: value}(data) (PermissionlessNodeRegistry.sol#1012)



    
1012         (bool success, bytes memory returndata) = target.call{value: value}(data);



```

### PermissionlessPool.sol


```
Low level call in AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (PermissionlessPool.sol#1281-1290):
	- (success,returndata) = target.call{value: value}(data) (PermissionlessPool.sol#1288)



    
1288         (bool success, bytes memory returndata) = target.call{value: value}(data);



```

```
Low level call in AddressUpgradeable.sendValue(address,uint256) (PermissionlessPool.sol#1213-1218):
	- (success) = recipient.call{value: amount}() (PermissionlessPool.sol#1216)



    
1216         (bool success, ) = recipient.call{value: amount}("");



```

```
Low level call in UtilLib.sendValue(address,uint256) (PermissionlessPool.sol#594-599):
	- (success) = address(_receiver).call{value: _amount}() (PermissionlessPool.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

```
Low level call in AddressUpgradeable.functionStaticCall(address,bytes,string) (PermissionlessPool.sol#1308-1315):
	- (success,returndata) = target.staticcall(data) (PermissionlessPool.sol#1313)



    
1313         (bool success, bytes memory returndata) = target.staticcall(data);



```

### PoolSelector.sol


```
Low level call in UtilLib.sendValue(address,uint256) (PoolSelector.sol#594-599):
	- (success) = address(_receiver).call{value: _amount}() (PoolSelector.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

```
Low level call in AddressUpgradeable.functionStaticCall(address,bytes,string) (PoolSelector.sol#1316-1323):
	- (success,returndata) = target.staticcall(data) (PoolSelector.sol#1321)



    
1321         (bool success, bytes memory returndata) = target.staticcall(data);



```

```
Low level call in AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (PoolSelector.sol#1289-1298):
	- (success,returndata) = target.call{value: value}(data) (PoolSelector.sol#1296)



    
1296         (bool success, bytes memory returndata) = target.call{value: value}(data);



```

```
Low level call in AddressUpgradeable.sendValue(address,uint256) (PoolSelector.sol#1221-1226):
	- (success) = recipient.call{value: amount}() (PoolSelector.sol#1224)



    
1224         (bool success, ) = recipient.call{value: amount}("");



```

### PoolUtils.sol


```
Low level call in AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (PoolUtils.sol#866-875):
	- (success,returndata) = target.call{value: value}(data) (PoolUtils.sol#873)



    
873         (bool success, bytes memory returndata) = target.call{value: value}(data);



```

```
Low level call in AddressUpgradeable.functionStaticCall(address,bytes,string) (PoolUtils.sol#893-900):
	- (success,returndata) = target.staticcall(data) (PoolUtils.sol#898)



    
898         (bool success, bytes memory returndata) = target.staticcall(data);



```

```
Low level call in UtilLib.sendValue(address,uint256) (PoolUtils.sol#594-599):
	- (success) = address(_receiver).call{value: _amount}() (PoolUtils.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

```
Low level call in AddressUpgradeable.sendValue(address,uint256) (PoolUtils.sol#798-803):
	- (success) = recipient.call{value: amount}() (PoolUtils.sol#801)



    
801         (bool success, ) = recipient.call{value: amount}("");



```

### SDCollateral.sol


```
Low level call in AddressUpgradeable.functionStaticCall(address,bytes,string) (SDCollateral.sol#1591-1598):
	- (success,returndata) = target.staticcall(data) (SDCollateral.sol#1596)



    
1596         (bool success, bytes memory returndata) = target.staticcall(data);



```

```
Low level call in AddressUpgradeable.sendValue(address,uint256) (SDCollateral.sol#1496-1501):
	- (success) = recipient.call{value: amount}() (SDCollateral.sol#1499)



    
1499         (bool success, ) = recipient.call{value: amount}("");



```

```
Low level call in UtilLib.sendValue(address,uint256) (SDCollateral.sol#594-599):
	- (success) = address(_receiver).call{value: _amount}() (SDCollateral.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

```
Low level call in AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (SDCollateral.sol#1564-1573):
	- (success,returndata) = target.call{value: value}(data) (SDCollateral.sol#1571)



    
1571         (bool success, bytes memory returndata) = target.call{value: value}(data);



```

### SocializingPool.sol


```
Low level call in AddressUpgradeable.functionStaticCall(address,bytes,string) (SocializingPool.sol#1072-1079):
	- (success,returndata) = target.staticcall(data) (SocializingPool.sol#1077)



    
1077         (bool success, bytes memory returndata) = target.staticcall(data);



```

```
Low level call in AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (SocializingPool.sol#1045-1054):
	- (success,returndata) = target.call{value: value}(data) (SocializingPool.sol#1052)



    
1052         (bool success, bytes memory returndata) = target.call{value: value}(data);



```

```
Low level call in SocializingPool.claim(uint256[],uint256[],uint256[],bytes32[][]) (SocializingPool.sol#2618-2646):
	- (success,None) = address(operatorRewardsAddr).call{value: totalAmountETH}() (SocializingPool.sol#2632)



    
2632             (success, ) = payable(operatorRewardsAddr).call{value: totalAmountETH}('');



```

```
Low level call in AddressUpgradeable.sendValue(address,uint256) (SocializingPool.sol#977-982):
	- (success) = recipient.call{value: amount}() (SocializingPool.sol#980)



    
980         (bool success, ) = recipient.call{value: amount}("");



```

```
Low level call in UtilLib.sendValue(address,uint256) (SocializingPool.sol#595-600):
	- (success) = address(_receiver).call{value: _amount}() (SocializingPool.sol#596)



    
596         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

```
Low level call in SocializingPool.handleRewards(RewardsData) (SocializingPool.sol#2572-2616):
	- (success) = address(staderConfig.getStaderTreasury()).call{value: _rewardsData.protocolETHRewards}() (SocializingPool.sol#2602)



    
2602         (bool success, ) = payable(staderConfig.getStaderTreasury()).call{value: _rewardsData.protocolETHRewards}('');



```

### StaderConfig.sol


```
Low level call in UtilLib.sendValue(address,uint256) (StaderConfig.sol#594-599):
	- (success) = address(_receiver).call{value: _amount}() (StaderConfig.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

```
Low level call in AddressUpgradeable.functionStaticCall(address,bytes,string) (StaderConfig.sol#845-852):
	- (success,returndata) = target.staticcall(data) (StaderConfig.sol#850)



    
850         (bool success, bytes memory returndata) = target.staticcall(data);



```

```
Low level call in AddressUpgradeable.sendValue(address,uint256) (StaderConfig.sol#750-755):
	- (success) = recipient.call{value: amount}() (StaderConfig.sol#753)



    
753         (bool success, ) = recipient.call{value: amount}("");



```

```
Low level call in AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (StaderConfig.sol#818-827):
	- (success,returndata) = target.call{value: value}(data) (StaderConfig.sol#825)



    
825         (bool success, bytes memory returndata) = target.call{value: value}(data);



```

### StaderInsuranceFund.sol


```
Low level call in StaderInsuranceFund.withdrawFund(uint256) (StaderInsuranceFund.sol#1953-1965):
	- (success) = address(msg.sender).call{value: _amount}() (StaderInsuranceFund.sol#1960)



    
1960         (bool success, ) = payable(msg.sender).call{value: _amount}('');



```

```
Low level call in AddressUpgradeable.functionStaticCall(address,bytes,string) (StaderInsuranceFund.sol#871-878):
	- (success,returndata) = target.staticcall(data) (StaderInsuranceFund.sol#876)



    
876         (bool success, bytes memory returndata) = target.staticcall(data);



```

```
Low level call in UtilLib.sendValue(address,uint256) (StaderInsuranceFund.sol#594-599):
	- (success) = address(_receiver).call{value: _amount}() (StaderInsuranceFund.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

```
Low level call in AddressUpgradeable.sendValue(address,uint256) (StaderInsuranceFund.sol#776-781):
	- (success) = recipient.call{value: amount}() (StaderInsuranceFund.sol#779)



    
779         (bool success, ) = recipient.call{value: amount}("");



```

```
Low level call in AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (StaderInsuranceFund.sol#844-853):
	- (success,returndata) = target.call{value: value}(data) (StaderInsuranceFund.sol#851)



    
851         (bool success, bytes memory returndata) = target.call{value: value}(data);



```

### StaderOracle.sol


```
Low level call in UtilLib.sendValue(address,uint256) (StaderOracle.sol#594-599):
	- (success) = address(_receiver).call{value: _amount}() (StaderOracle.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

```
Low level call in AddressUpgradeable.functionStaticCall(address,bytes,string) (StaderOracle.sol#1222-1229):
	- (success,returndata) = target.staticcall(data) (StaderOracle.sol#1227)



    
1227         (bool success, bytes memory returndata) = target.staticcall(data);



```

```
Low level call in AddressUpgradeable.sendValue(address,uint256) (StaderOracle.sol#1127-1132):
	- (success) = recipient.call{value: amount}() (StaderOracle.sol#1130)



    
1130         (bool success, ) = recipient.call{value: amount}("");



```

```
Low level call in AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (StaderOracle.sol#1195-1204):
	- (success,returndata) = target.call{value: value}(data) (StaderOracle.sol#1202)



    
1202         (bool success, bytes memory returndata) = target.call{value: value}(data);



```

### StaderStakePoolsManager.sol


```
Low level call in AddressUpgradeable.functionStaticCall(address,bytes,string) (StaderStakePoolsManager.sol#864-871):
	- (success,returndata) = target.staticcall(data) (StaderStakePoolsManager.sol#869)



    
869         (bool success, bytes memory returndata) = target.staticcall(data);



```

```
Low level call in AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (StaderStakePoolsManager.sol#837-846):
	- (success,returndata) = target.call{value: value}(data) (StaderStakePoolsManager.sol#844)



    
844         (bool success, bytes memory returndata) = target.call{value: value}(data);



```

```
Low level call in StaderStakePoolsManager.transferETHToUserWithdrawManager(uint256) (StaderStakePoolsManager.sol#3689-3697):
	- (success) = address(staderConfig.getUserWithdrawManager()).call{value: _amount}() (StaderStakePoolsManager.sol#3692)



    
3692         (bool success, ) = payable(staderConfig.getUserWithdrawManager()).call{value: _amount}('');



```

```
Low level call in AddressUpgradeable.sendValue(address,uint256) (StaderStakePoolsManager.sol#769-774):
	- (success) = recipient.call{value: amount}() (StaderStakePoolsManager.sol#772)



    
772         (bool success, ) = recipient.call{value: amount}("");



```

```
Low level call in UtilLib.sendValue(address,uint256) (StaderStakePoolsManager.sol#595-600):
	- (success) = address(_receiver).call{value: _amount}() (StaderStakePoolsManager.sol#596)



    
596         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

### UserWithdrawalManager.sol


```
Low level call in AddressUpgradeable.functionStaticCall(address,bytes,string) (UserWithdrawalManager.sol#863-870):
	- (success,returndata) = target.staticcall(data) (UserWithdrawalManager.sol#868)



    
868         (bool success, bytes memory returndata) = target.staticcall(data);



```

```
Low level call in AddressUpgradeable.sendValue(address,uint256) (UserWithdrawalManager.sol#768-773):
	- (success) = recipient.call{value: amount}() (UserWithdrawalManager.sol#771)



    
771         (bool success, ) = recipient.call{value: amount}("");



```

```
Low level call in UserWithdrawalManager.sendValue(address,uint256) (UserWithdrawalManager.sol#3689-3699):
	- (success) = _recipient.call{value: _amount}() (UserWithdrawalManager.sol#3695)



    
3695         (bool success, ) = _recipient.call{value: _amount}('');



```

```
Low level call in UtilLib.sendValue(address,uint256) (UserWithdrawalManager.sol#594-599):
	- (success) = address(_receiver).call{value: _amount}() (UserWithdrawalManager.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

```
Low level call in AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (UserWithdrawalManager.sol#836-845):
	- (success,returndata) = target.call{value: value}(data) (UserWithdrawalManager.sol#843)



    
843         (bool success, bytes memory returndata) = target.call{value: value}(data);



```

### UtilLib.sol


```
Low level call in UtilLib.sendValue(address,uint256) (UtilLib.sol#594-599):
	- (success) = address(_receiver).call{value: _amount}() (UtilLib.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

### ValidatorWithdrawalVault.sol


```
Low level call in UtilLib.sendValue(address,uint256) (ValidatorWithdrawalVault.sol#594-599):
	- (success) = address(_receiver).call{value: _amount}() (ValidatorWithdrawalVault.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

```
Low level call in VaultProxy.fallback(bytes) (ValidatorWithdrawalVault.sol#636-645):
	- (success,data) = vaultImplementation.delegatecall(_input) (ValidatorWithdrawalVault.sol#640)



    
640         (bool success, bytes memory data) = vaultImplementation.delegatecall(_input);



```

### VaultFactory.sol


```
Low level call in AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (VaultFactory.sol#1013-1022):
	- (success,returndata) = target.call{value: value}(data) (VaultFactory.sol#1020)



    
1020         (bool success, bytes memory returndata) = target.call{value: value}(data);



```

```
Low level call in AddressUpgradeable.sendValue(address,uint256) (VaultFactory.sol#945-950):
	- (success) = recipient.call{value: amount}() (VaultFactory.sol#948)



    
948         (bool success, ) = recipient.call{value: amount}("");



```

```
Low level call in AddressUpgradeable.functionStaticCall(address,bytes,string) (VaultFactory.sol#1040-1047):
	- (success,returndata) = target.staticcall(data) (VaultFactory.sol#1045)



    
1045         (bool success, bytes memory returndata) = target.staticcall(data);



```

```
Low level call in UtilLib.sendValue(address,uint256) (VaultFactory.sol#594-599):
	- (success) = address(_receiver).call{value: _amount}() (VaultFactory.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

```
Low level call in VaultProxy.fallback(bytes) (VaultFactory.sol#636-645):
	- (success,data) = vaultImplementation.delegatecall(_input) (VaultFactory.sol#640)



    
640         (bool success, bytes memory data) = vaultImplementation.delegatecall(_input);



```

### VaultProxy.sol


```
Low level call in UtilLib.sendValue(address,uint256) (VaultProxy.sol#594-599):
	- (success) = address(_receiver).call{value: _amount}() (VaultProxy.sol#595)



    
595         (bool success, ) = payable(_receiver).call{value: _amount}('');



```

```
Low level call in VaultProxy.fallback(bytes) (VaultProxy.sol#636-645):
	- (success,data) = vaultImplementation.delegatecall(_input) (VaultProxy.sol#640)



    
640         (bool success, bytes memory data) = vaultImplementation.delegatecall(_input);



```

## naming-convention
### Severity: Informational

### Auction.sol


```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._addr (Auction.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.PERMISSIONED_NODE_REGISTRY() (Auction.sol#48) is not in mixedCase



    
48     function PERMISSIONED_NODE_REGISTRY() external view returns (bytes32);



```

```
Function IStaderConfig.PERMISSIONLESS_SOCIALIZING_POOL() (Auction.sol#54) is not in mixedCase



    
54     function PERMISSIONLESS_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._validatorId (Auction.sol#511) is not in mixedCase



    
511         uint256 _validatorId,



```

```
Parameter Auction.initialize(address,address)._staderConfig (Auction.sol#2231) is not in mixedCase



    
2231     function initialize(address _admin, address _staderConfig) external initializer {



```

```
Function IStaderConfig.VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() (Auction.sol#58) is not in mixedCase



    
58     function VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._staderConfig (Auction.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.POOL_SELECTOR() (Auction.sol#22) is not in mixedCase



    
22     function POOL_SELECTOR() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._poolId (Auction.sol#535) is not in mixedCase



    
535         uint8 _poolId,



```

```
Function IStaderConfig.ETHX_SUPPLY_POR_FEED() (Auction.sol#63) is not in mixedCase



    
63     function ETHX_SUPPLY_POR_FEED() external view returns (bytes32);



```

```
Function IStaderConfig.POOL_UTILS() (Auction.sol#20) is not in mixedCase



    
20     function POOL_UTILS() external view returns (bytes32);



```

```
Function AccessControlUpgradeable.__AccessControl_init_unchained() (Auction.sol#1818-1819) is not in mixedCase



    
1818     function __AccessControl_init_unchained() internal onlyInitializing {
1819     }



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._operatorId (Auction.sol#536) is not in mixedCase



    
536         uint256 _operatorId,



```

```
Function IStaderConfig.OPERATOR_REWARD_COLLECTOR() (Auction.sol#26) is not in mixedCase



    
26     function OPERATOR_REWARD_COLLECTOR() external view returns (bytes32);



```

```
Variable ContextUpgradeable.__gap (Auction.sol#1304) is not in mixedCase



    
1304     uint256[50] private __gap;



```

```
Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained() (Auction.sol#2177-2179) is not in mixedCase



    
2177     function __ReentrancyGuard_init_unchained() internal onlyInitializing {
2178         _status = _NOT_ENTERED;
2179     }



```

```
Variable AccessControlUpgradeable.__gap (Auction.sol#2023) is not in mixedCase



    
2023     uint256[49] private __gap;



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._staderConfig (Auction.sol#537) is not in mixedCase



    
537         IStaderConfig _staderConfig



```

```
Parameter UtilLib.sendValue(address,uint256)._amount (Auction.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (Auction.sol#494) is not in mixedCase



    
494         uint256 _validatorId,



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._validatorId (Auction.sol#524) is not in mixedCase



    
524         uint256 _validatorId,



```

```
Function IStaderConfig.STADER_ORACLE() (Auction.sol#30) is not in mixedCase



    
30     function STADER_ORACLE() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (Auction.sol#496) is not in mixedCase



    
496         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._addr (Auction.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._staderConfig (Auction.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.AUCTION_CONTRACT() (Auction.sol#32) is not in mixedCase



    
32     function AUCTION_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (Auction.sol#478) is not in mixedCase



    
478         uint256 _validatorId,



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._staderConfig (Auction.sol#468) is not in mixedCase



    
468         IStaderConfig _staderConfig,



```

```
Variable PausableUpgradeable.__gap (Auction.sol#2135) is not in mixedCase



    
2135     uint256[49] private __gap;



```

```
Function IStaderConfig.USER_WITHDRAW_MANAGER() (Auction.sol#44) is not in mixedCase



    
44     function USER_WITHDRAW_MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.NODE_EL_REWARD_VAULT_IMPLEMENTATION() (Auction.sol#56) is not in mixedCase



    
56     function NODE_EL_REWARD_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._staderConfig (Auction.sol#513) is not in mixedCase



    
513         IStaderConfig _staderConfig



```

```
Function IStaderConfig.VAULT_FACTORY() (Auction.sol#28) is not in mixedCase



    
28     function VAULT_FACTORY() external view returns (bytes32);



```

```
Function IStaderConfig.STAKE_POOL_MANAGER() (Auction.sol#38) is not in mixedCase



    
38     function STAKE_POOL_MANAGER() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._poolId (Auction.sol#493) is not in mixedCase



    
493         uint8 _poolId,



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._contractName (Auction.sol#469) is not in mixedCase



    
469         bytes32 _contractName



```

```
Function IStaderConfig.OPERATOR() (Auction.sol#68) is not in mixedCase



    
68     function OPERATOR() external view returns (bytes32);



```

```
Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init() (Auction.sol#2173-2175) is not in mixedCase



    
2173     function __ReentrancyGuard_init() internal onlyInitializing {
2174         __ReentrancyGuard_init_unchained();
2175     }



```

```
Function ERC165Upgradeable.__ERC165_init_unchained() (Auction.sol#1759-1760) is not in mixedCase



    
1759     function __ERC165_init_unchained() internal onlyInitializing {
1760     }



```

```
Function ContextUpgradeable.__Context_init_unchained() (Auction.sol#1289-1290) is not in mixedCase



    
1289     function __Context_init_unchained() internal onlyInitializing {
1290     }



```

```
Function IStaderConfig.PERMISSIONED_POOL() (Auction.sol#36) is not in mixedCase



    
36     function PERMISSIONED_POOL() external view returns (bytes32);



```

```
Function INodeRegistry.POOL_ID() (Auction.sol#302) is not in mixedCase



    
302     function POOL_ID() external view returns (uint8);



```

```
Parameter UtilLib.sendValue(address,uint256)._receiver (Auction.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Function IStaderConfig.PERMISSIONLESS_POOL() (Auction.sol#42) is not in mixedCase



    
42     function PERMISSIONLESS_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._addr (Auction.sol#479) is not in mixedCase



    
479         address _addr,



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (Auction.sol#480) is not in mixedCase



    
480         IStaderConfig _staderConfig



```

```
Variable ReentrancyGuardUpgradeable.__gap (Auction.sol#2213) is not in mixedCase



    
2213     uint256[49] private __gap;



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._staderConfig (Auction.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._staderConfig (Auction.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.SD_COLLATERAL() (Auction.sol#24) is not in mixedCase



    
24     function SD_COLLATERAL() external view returns (bytes32);



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._pubkey (Auction.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function AccessControlUpgradeable.__AccessControl_init() (Auction.sol#1815-1816) is not in mixedCase



    
1815     function __AccessControl_init() internal onlyInitializing {
1816     }



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._addr (Auction.sol#495) is not in mixedCase



    
495         address _addr,



```

```
Parameter UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig)._staderConfig (Auction.sol#585) is not in mixedCase



    
585         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._addr (Auction.sol#467) is not in mixedCase



    
467         address _addr,



```

```
Parameter Auction.updateStaderConfig(address)._staderConfig (Auction.sol#2340) is not in mixedCase



    
2340     function updateStaderConfig(address _staderConfig) external override onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Function IStaderConfig.PERMISSIONED_SOCIALIZING_POOL() (Auction.sol#52) is not in mixedCase



    
52     function PERMISSIONED_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Function IStaderConfig.PENALTY_CONTRACT() (Auction.sol#34) is not in mixedCase



    
34     function PENALTY_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._poolId (Auction.sol#477) is not in mixedCase



    
477         uint8 _poolId,



```

```
Variable ERC165Upgradeable.__gap (Auction.sol#1773) is not in mixedCase



    
1773     uint256[50] private __gap;



```

```
Function IStaderConfig.ETH_DEPOSIT_CONTRACT() (Auction.sol#40) is not in mixedCase



    
40     function ETH_DEPOSIT_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._operator (Auction.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.ETH_BALANCE_POR_FEED() (Auction.sol#61) is not in mixedCase



    
61     function ETH_BALANCE_POR_FEED() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._poolId (Auction.sol#510) is not in mixedCase



    
510         uint8 _poolId,



```

```
Parameter Auction.initialize(address,address)._admin (Auction.sol#2231) is not in mixedCase



    
2231     function initialize(address _admin, address _staderConfig) external initializer {



```

```
Parameter UtilLib.getPubkeyRoot(bytes)._pubkey (Auction.sol#561) is not in mixedCase



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {



```

```
Function PausableUpgradeable.__Pausable_init() (Auction.sol#2053-2055) is not in mixedCase



    
2053     function __Pausable_init() internal onlyInitializing {
2054         __Pausable_init_unchained();
2055     }



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._poolId (Auction.sol#523) is not in mixedCase



    
523         uint8 _poolId,



```

```
Parameter Auction.updateBidIncrement(uint256)._bidIncrement (Auction.sol#2353) is not in mixedCase



    
2353     function updateBidIncrement(uint256 _bidIncrement) external override {



```

```
Function IStaderConfig.MANAGER() (Auction.sol#66) is not in mixedCase



    
66     function MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.STADER_INSURANCE_FUND() (Auction.sol#46) is not in mixedCase



    
46     function STADER_INSURANCE_FUND() external view returns (bytes32);



```

```
Function ContextUpgradeable.__Context_init() (Auction.sol#1286-1287) is not in mixedCase



    
1286     function __Context_init() internal onlyInitializing {
1287     }



```

```
Function IStaderConfig.PERMISSIONLESS_NODE_REGISTRY() (Auction.sol#50) is not in mixedCase



    
50     function PERMISSIONLESS_NODE_REGISTRY() external view returns (bytes32);



```

```
Function ERC165Upgradeable.__ERC165_init() (Auction.sol#1756-1757) is not in mixedCase



    
1756     function __ERC165_init() internal onlyInitializing {
1757     }



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._staderConfig (Auction.sol#525) is not in mixedCase



    
525         IStaderConfig _staderConfig



```

```
Parameter UtilLib.checkNonZeroAddress(address)._address (Auction.sol#448) is not in mixedCase



    
448     function checkNonZeroAddress(address _address) internal pure {



```

```
Parameter Auction.createLot(uint256)._sdAmount (Auction.sol#2250) is not in mixedCase



    
2250     function createLot(uint256 _sdAmount) external override whenNotPaused {



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._addr (Auction.sol#512) is not in mixedCase



    
512         address _addr,



```

```
Parameter Auction.updateDuration(uint256)._duration (Auction.sol#2346) is not in mixedCase



    
2346     function updateDuration(uint256 _duration) external override {



```

```
Function PausableUpgradeable.__Pausable_init_unchained() (Auction.sol#2057-2059) is not in mixedCase



    
2057     function __Pausable_init_unchained() internal onlyInitializing {
2058         _paused = false;
2059     }



```

### ETHx.sol


```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._addr (ETHx.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.PERMISSIONED_NODE_REGISTRY() (ETHx.sol#48) is not in mixedCase



    
48     function PERMISSIONED_NODE_REGISTRY() external view returns (bytes32);



```

```
Function IStaderConfig.PERMISSIONLESS_SOCIALIZING_POOL() (ETHx.sol#54) is not in mixedCase



    
54     function PERMISSIONLESS_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._validatorId (ETHx.sol#511) is not in mixedCase



    
511         uint256 _validatorId,



```

```
Function IStaderConfig.VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() (ETHx.sol#58) is not in mixedCase



    
58     function VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._staderConfig (ETHx.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.POOL_SELECTOR() (ETHx.sol#22) is not in mixedCase



    
22     function POOL_SELECTOR() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._poolId (ETHx.sol#535) is not in mixedCase



    
535         uint8 _poolId,



```

```
Function IStaderConfig.ETHX_SUPPLY_POR_FEED() (ETHx.sol#63) is not in mixedCase



    
63     function ETHX_SUPPLY_POR_FEED() external view returns (bytes32);



```

```
Function IStaderConfig.POOL_UTILS() (ETHx.sol#20) is not in mixedCase



    
20     function POOL_UTILS() external view returns (bytes32);



```

```
Function AccessControlUpgradeable.__AccessControl_init_unchained() (ETHx.sol#2111-2112) is not in mixedCase



    
2111     function __AccessControl_init_unchained() internal onlyInitializing {
2112     }



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._operatorId (ETHx.sol#536) is not in mixedCase



    
536         uint256 _operatorId,



```

```
Function IStaderConfig.OPERATOR_REWARD_COLLECTOR() (ETHx.sol#26) is not in mixedCase



    
26     function OPERATOR_REWARD_COLLECTOR() external view returns (bytes32);



```

```
Variable ContextUpgradeable.__gap (ETHx.sol#1117) is not in mixedCase



    
1117     uint256[50] private __gap;



```

```
Parameter ETHx.initialize(address,address)._admin (ETHx.sol#2449) is not in mixedCase



    
2449     function initialize(address _admin, address _staderConfig) public initializer {



```

```
Variable AccessControlUpgradeable.__gap (ETHx.sol#2316) is not in mixedCase



    
2316     uint256[49] private __gap;



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._staderConfig (ETHx.sol#537) is not in mixedCase



    
537         IStaderConfig _staderConfig



```

```
Parameter UtilLib.sendValue(address,uint256)._amount (ETHx.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (ETHx.sol#494) is not in mixedCase



    
494         uint256 _validatorId,



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._validatorId (ETHx.sol#524) is not in mixedCase



    
524         uint256 _validatorId,



```

```
Function IStaderConfig.STADER_ORACLE() (ETHx.sol#30) is not in mixedCase



    
30     function STADER_ORACLE() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (ETHx.sol#496) is not in mixedCase



    
496         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._addr (ETHx.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._staderConfig (ETHx.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.AUCTION_CONTRACT() (ETHx.sol#32) is not in mixedCase



    
32     function AUCTION_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (ETHx.sol#478) is not in mixedCase



    
478         uint256 _validatorId,



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._staderConfig (ETHx.sol#468) is not in mixedCase



    
468         IStaderConfig _staderConfig,



```

```
Variable PausableUpgradeable.__gap (ETHx.sol#2428) is not in mixedCase



    
2428     uint256[49] private __gap;



```

```
Function IStaderConfig.USER_WITHDRAW_MANAGER() (ETHx.sol#44) is not in mixedCase



    
44     function USER_WITHDRAW_MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.NODE_EL_REWARD_VAULT_IMPLEMENTATION() (ETHx.sol#56) is not in mixedCase



    
56     function NODE_EL_REWARD_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._staderConfig (ETHx.sol#513) is not in mixedCase



    
513         IStaderConfig _staderConfig



```

```
Function IStaderConfig.VAULT_FACTORY() (ETHx.sol#28) is not in mixedCase



    
28     function VAULT_FACTORY() external view returns (bytes32);



```

```
Function IStaderConfig.STAKE_POOL_MANAGER() (ETHx.sol#38) is not in mixedCase



    
38     function STAKE_POOL_MANAGER() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._poolId (ETHx.sol#493) is not in mixedCase



    
493         uint8 _poolId,



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._contractName (ETHx.sol#469) is not in mixedCase



    
469         bytes32 _contractName



```

```
Function ERC20Upgradeable.__ERC20_init_unchained(string,string) (ETHx.sol#1168-1171) is not in mixedCase



    
1168     function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {
1169         _name = name_;
1170         _symbol = symbol_;
1171     }



```

```
Function IStaderConfig.OPERATOR() (ETHx.sol#68) is not in mixedCase



    
68     function OPERATOR() external view returns (bytes32);



```

```
Function ERC20Upgradeable.__ERC20_init(string,string) (ETHx.sol#1164-1166) is not in mixedCase



    
1164     function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {
1165         __ERC20_init_unchained(name_, symbol_);
1166     }



```

```
Function ERC165Upgradeable.__ERC165_init_unchained() (ETHx.sol#2052-2053) is not in mixedCase



    
2052     function __ERC165_init_unchained() internal onlyInitializing {
2053     }



```

```
Function ContextUpgradeable.__Context_init_unchained() (ETHx.sol#1102-1103) is not in mixedCase



    
1102     function __Context_init_unchained() internal onlyInitializing {
1103     }



```

```
Function IStaderConfig.PERMISSIONED_POOL() (ETHx.sol#36) is not in mixedCase



    
36     function PERMISSIONED_POOL() external view returns (bytes32);



```

```
Function INodeRegistry.POOL_ID() (ETHx.sol#302) is not in mixedCase



    
302     function POOL_ID() external view returns (uint8);



```

```
Parameter UtilLib.sendValue(address,uint256)._receiver (ETHx.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Function IStaderConfig.PERMISSIONLESS_POOL() (ETHx.sol#42) is not in mixedCase



    
42     function PERMISSIONLESS_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._addr (ETHx.sol#479) is not in mixedCase



    
479         address _addr,



```

```
Variable ERC20Upgradeable.__gap (ETHx.sol#1509) is not in mixedCase



    
1509     uint256[45] private __gap;



```

```
Parameter ETHx.initialize(address,address)._staderConfig (ETHx.sol#2449) is not in mixedCase



    
2449     function initialize(address _admin, address _staderConfig) public initializer {



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (ETHx.sol#480) is not in mixedCase



    
480         IStaderConfig _staderConfig



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._staderConfig (ETHx.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._staderConfig (ETHx.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Parameter ETHx.updateStaderConfig(address)._staderConfig (ETHx.sol#2505) is not in mixedCase



    
2505     function updateStaderConfig(address _staderConfig) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Function IStaderConfig.SD_COLLATERAL() (ETHx.sol#24) is not in mixedCase



    
24     function SD_COLLATERAL() external view returns (bytes32);



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._pubkey (ETHx.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function AccessControlUpgradeable.__AccessControl_init() (ETHx.sol#2108-2109) is not in mixedCase



    
2108     function __AccessControl_init() internal onlyInitializing {
2109     }



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._addr (ETHx.sol#495) is not in mixedCase



    
495         address _addr,



```

```
Parameter UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig)._staderConfig (ETHx.sol#585) is not in mixedCase



    
585         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._addr (ETHx.sol#467) is not in mixedCase



    
467         address _addr,



```

```
Function IStaderConfig.PERMISSIONED_SOCIALIZING_POOL() (ETHx.sol#52) is not in mixedCase



    
52     function PERMISSIONED_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Function IStaderConfig.PENALTY_CONTRACT() (ETHx.sol#34) is not in mixedCase



    
34     function PENALTY_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._poolId (ETHx.sol#477) is not in mixedCase



    
477         uint8 _poolId,



```

```
Variable ERC165Upgradeable.__gap (ETHx.sol#2066) is not in mixedCase



    
2066     uint256[50] private __gap;



```

```
Function IStaderConfig.ETH_DEPOSIT_CONTRACT() (ETHx.sol#40) is not in mixedCase



    
40     function ETH_DEPOSIT_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._operator (ETHx.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.ETH_BALANCE_POR_FEED() (ETHx.sol#61) is not in mixedCase



    
61     function ETH_BALANCE_POR_FEED() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._poolId (ETHx.sol#510) is not in mixedCase



    
510         uint8 _poolId,



```

```
Parameter UtilLib.getPubkeyRoot(bytes)._pubkey (ETHx.sol#561) is not in mixedCase



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {



```

```
Function PausableUpgradeable.__Pausable_init() (ETHx.sol#2346-2348) is not in mixedCase



    
2346     function __Pausable_init() internal onlyInitializing {
2347         __Pausable_init_unchained();
2348     }



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._poolId (ETHx.sol#523) is not in mixedCase



    
523         uint8 _poolId,



```

```
Function IStaderConfig.MANAGER() (ETHx.sol#66) is not in mixedCase



    
66     function MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.STADER_INSURANCE_FUND() (ETHx.sol#46) is not in mixedCase



    
46     function STADER_INSURANCE_FUND() external view returns (bytes32);



```

```
Function ContextUpgradeable.__Context_init() (ETHx.sol#1099-1100) is not in mixedCase



    
1099     function __Context_init() internal onlyInitializing {
1100     }



```

```
Function IStaderConfig.PERMISSIONLESS_NODE_REGISTRY() (ETHx.sol#50) is not in mixedCase



    
50     function PERMISSIONLESS_NODE_REGISTRY() external view returns (bytes32);



```

```
Function ERC165Upgradeable.__ERC165_init() (ETHx.sol#2049-2050) is not in mixedCase



    
2049     function __ERC165_init() internal onlyInitializing {
2050     }



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._staderConfig (ETHx.sol#525) is not in mixedCase



    
525         IStaderConfig _staderConfig



```

```
Parameter UtilLib.checkNonZeroAddress(address)._address (ETHx.sol#448) is not in mixedCase



    
448     function checkNonZeroAddress(address _address) internal pure {



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._addr (ETHx.sol#512) is not in mixedCase



    
512         address _addr,



```

```
Function PausableUpgradeable.__Pausable_init_unchained() (ETHx.sol#2350-2352) is not in mixedCase



    
2350     function __Pausable_init_unchained() internal onlyInitializing {
2351         _paused = false;
2352     }



```

### NodeELRewardVault.sol


```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._addr (NodeELRewardVault.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.PERMISSIONED_NODE_REGISTRY() (NodeELRewardVault.sol#48) is not in mixedCase



    
48     function PERMISSIONED_NODE_REGISTRY() external view returns (bytes32);



```

```
Function IStaderConfig.PERMISSIONLESS_SOCIALIZING_POOL() (NodeELRewardVault.sol#54) is not in mixedCase



    
54     function PERMISSIONLESS_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._validatorId (NodeELRewardVault.sol#511) is not in mixedCase



    
511         uint256 _validatorId,



```

```
Function IStaderConfig.VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() (NodeELRewardVault.sol#58) is not in mixedCase



    
58     function VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._staderConfig (NodeELRewardVault.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.POOL_SELECTOR() (NodeELRewardVault.sol#22) is not in mixedCase



    
22     function POOL_SELECTOR() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._poolId (NodeELRewardVault.sol#535) is not in mixedCase



    
535         uint8 _poolId,



```

```
Function IStaderConfig.ETHX_SUPPLY_POR_FEED() (NodeELRewardVault.sol#63) is not in mixedCase



    
63     function ETHX_SUPPLY_POR_FEED() external view returns (bytes32);



```

```
Function IStaderConfig.POOL_UTILS() (NodeELRewardVault.sol#20) is not in mixedCase



    
20     function POOL_UTILS() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._operatorId (NodeELRewardVault.sol#536) is not in mixedCase



    
536         uint256 _operatorId,



```

```
Function IStaderConfig.OPERATOR_REWARD_COLLECTOR() (NodeELRewardVault.sol#26) is not in mixedCase



    
26     function OPERATOR_REWARD_COLLECTOR() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._staderConfig (NodeELRewardVault.sol#537) is not in mixedCase



    
537         IStaderConfig _staderConfig



```

```
Parameter UtilLib.sendValue(address,uint256)._amount (NodeELRewardVault.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (NodeELRewardVault.sol#494) is not in mixedCase



    
494         uint256 _validatorId,



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._validatorId (NodeELRewardVault.sol#524) is not in mixedCase



    
524         uint256 _validatorId,



```

```
Function IStaderConfig.STADER_ORACLE() (NodeELRewardVault.sol#30) is not in mixedCase



    
30     function STADER_ORACLE() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (NodeELRewardVault.sol#496) is not in mixedCase



    
496         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._addr (NodeELRewardVault.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._staderConfig (NodeELRewardVault.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.AUCTION_CONTRACT() (NodeELRewardVault.sol#32) is not in mixedCase



    
32     function AUCTION_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (NodeELRewardVault.sol#478) is not in mixedCase



    
478         uint256 _validatorId,



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._staderConfig (NodeELRewardVault.sol#468) is not in mixedCase



    
468         IStaderConfig _staderConfig,



```

```
Function IStaderConfig.USER_WITHDRAW_MANAGER() (NodeELRewardVault.sol#44) is not in mixedCase



    
44     function USER_WITHDRAW_MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.NODE_EL_REWARD_VAULT_IMPLEMENTATION() (NodeELRewardVault.sol#56) is not in mixedCase



    
56     function NODE_EL_REWARD_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._staderConfig (NodeELRewardVault.sol#513) is not in mixedCase



    
513         IStaderConfig _staderConfig



```

```
Function IStaderConfig.VAULT_FACTORY() (NodeELRewardVault.sol#28) is not in mixedCase



    
28     function VAULT_FACTORY() external view returns (bytes32);



```

```
Function IStaderConfig.STAKE_POOL_MANAGER() (NodeELRewardVault.sol#38) is not in mixedCase



    
38     function STAKE_POOL_MANAGER() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._poolId (NodeELRewardVault.sol#493) is not in mixedCase



    
493         uint8 _poolId,



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._contractName (NodeELRewardVault.sol#469) is not in mixedCase



    
469         bytes32 _contractName



```

```
Function IStaderConfig.OPERATOR() (NodeELRewardVault.sol#68) is not in mixedCase



    
68     function OPERATOR() external view returns (bytes32);



```

```
Function IStaderConfig.PERMISSIONED_POOL() (NodeELRewardVault.sol#36) is not in mixedCase



    
36     function PERMISSIONED_POOL() external view returns (bytes32);



```

```
Function INodeRegistry.POOL_ID() (NodeELRewardVault.sol#302) is not in mixedCase



    
302     function POOL_ID() external view returns (uint8);



```

```
Parameter UtilLib.sendValue(address,uint256)._receiver (NodeELRewardVault.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Function IStaderConfig.PERMISSIONLESS_POOL() (NodeELRewardVault.sol#42) is not in mixedCase



    
42     function PERMISSIONLESS_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._addr (NodeELRewardVault.sol#479) is not in mixedCase



    
479         address _addr,



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (NodeELRewardVault.sol#480) is not in mixedCase



    
480         IStaderConfig _staderConfig



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._staderConfig (NodeELRewardVault.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._staderConfig (NodeELRewardVault.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.SD_COLLATERAL() (NodeELRewardVault.sol#24) is not in mixedCase



    
24     function SD_COLLATERAL() external view returns (bytes32);



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._pubkey (NodeELRewardVault.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._addr (NodeELRewardVault.sol#495) is not in mixedCase



    
495         address _addr,



```

```
Parameter UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig)._staderConfig (NodeELRewardVault.sol#585) is not in mixedCase



    
585         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._addr (NodeELRewardVault.sol#467) is not in mixedCase



    
467         address _addr,



```

```
Function IStaderConfig.PERMISSIONED_SOCIALIZING_POOL() (NodeELRewardVault.sol#52) is not in mixedCase



    
52     function PERMISSIONED_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Function IStaderConfig.PENALTY_CONTRACT() (NodeELRewardVault.sol#34) is not in mixedCase



    
34     function PENALTY_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._poolId (NodeELRewardVault.sol#477) is not in mixedCase



    
477         uint8 _poolId,



```

```
Function IStaderConfig.ETH_DEPOSIT_CONTRACT() (NodeELRewardVault.sol#40) is not in mixedCase



    
40     function ETH_DEPOSIT_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._operator (NodeELRewardVault.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.ETH_BALANCE_POR_FEED() (NodeELRewardVault.sol#61) is not in mixedCase



    
61     function ETH_BALANCE_POR_FEED() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._poolId (NodeELRewardVault.sol#510) is not in mixedCase



    
510         uint8 _poolId,



```

```
Parameter UtilLib.getPubkeyRoot(bytes)._pubkey (NodeELRewardVault.sol#561) is not in mixedCase



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._poolId (NodeELRewardVault.sol#523) is not in mixedCase



    
523         uint8 _poolId,



```

```
Function IStaderConfig.MANAGER() (NodeELRewardVault.sol#66) is not in mixedCase



    
66     function MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.STADER_INSURANCE_FUND() (NodeELRewardVault.sol#46) is not in mixedCase



    
46     function STADER_INSURANCE_FUND() external view returns (bytes32);



```

```
Function IStaderConfig.PERMISSIONLESS_NODE_REGISTRY() (NodeELRewardVault.sol#50) is not in mixedCase



    
50     function PERMISSIONLESS_NODE_REGISTRY() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._staderConfig (NodeELRewardVault.sol#525) is not in mixedCase



    
525         IStaderConfig _staderConfig



```

```
Parameter UtilLib.checkNonZeroAddress(address)._address (NodeELRewardVault.sol#448) is not in mixedCase



    
448     function checkNonZeroAddress(address _address) internal pure {



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._addr (NodeELRewardVault.sol#512) is not in mixedCase



    
512         address _addr,



```

### OperatorRewardsCollector.sol


```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._addr (OperatorRewardsCollector.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.PERMISSIONED_NODE_REGISTRY() (OperatorRewardsCollector.sol#48) is not in mixedCase



    
48     function PERMISSIONED_NODE_REGISTRY() external view returns (bytes32);



```

```
Function IStaderConfig.PERMISSIONLESS_SOCIALIZING_POOL() (OperatorRewardsCollector.sol#54) is not in mixedCase



    
54     function PERMISSIONLESS_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._validatorId (OperatorRewardsCollector.sol#511) is not in mixedCase



    
511         uint256 _validatorId,



```

```
Function IStaderConfig.VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() (OperatorRewardsCollector.sol#58) is not in mixedCase



    
58     function VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._staderConfig (OperatorRewardsCollector.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.POOL_SELECTOR() (OperatorRewardsCollector.sol#22) is not in mixedCase



    
22     function POOL_SELECTOR() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._poolId (OperatorRewardsCollector.sol#535) is not in mixedCase



    
535         uint8 _poolId,



```

```
Function IStaderConfig.ETHX_SUPPLY_POR_FEED() (OperatorRewardsCollector.sol#63) is not in mixedCase



    
63     function ETHX_SUPPLY_POR_FEED() external view returns (bytes32);



```

```
Function IStaderConfig.POOL_UTILS() (OperatorRewardsCollector.sol#20) is not in mixedCase



    
20     function POOL_UTILS() external view returns (bytes32);



```

```
Function AccessControlUpgradeable.__AccessControl_init_unchained() (OperatorRewardsCollector.sol#1626-1627) is not in mixedCase



    
1626     function __AccessControl_init_unchained() internal onlyInitializing {
1627     }



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._operatorId (OperatorRewardsCollector.sol#536) is not in mixedCase



    
536         uint256 _operatorId,



```

```
Function IStaderConfig.OPERATOR_REWARD_COLLECTOR() (OperatorRewardsCollector.sol#26) is not in mixedCase



    
26     function OPERATOR_REWARD_COLLECTOR() external view returns (bytes32);



```

```
Variable ContextUpgradeable.__gap (OperatorRewardsCollector.sol#1112) is not in mixedCase



    
1112     uint256[50] private __gap;



```

```
Variable AccessControlUpgradeable.__gap (OperatorRewardsCollector.sol#1831) is not in mixedCase



    
1831     uint256[49] private __gap;



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._staderConfig (OperatorRewardsCollector.sol#537) is not in mixedCase



    
537         IStaderConfig _staderConfig



```

```
Parameter UtilLib.sendValue(address,uint256)._amount (OperatorRewardsCollector.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (OperatorRewardsCollector.sol#494) is not in mixedCase



    
494         uint256 _validatorId,



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._validatorId (OperatorRewardsCollector.sol#524) is not in mixedCase



    
524         uint256 _validatorId,



```

```
Function IStaderConfig.STADER_ORACLE() (OperatorRewardsCollector.sol#30) is not in mixedCase



    
30     function STADER_ORACLE() external view returns (bytes32);



```

```
Parameter OperatorRewardsCollector.initialize(address,address)._staderConfig (OperatorRewardsCollector.sol#1961) is not in mixedCase



    
1961     function initialize(address _admin, address _staderConfig) external initializer {



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (OperatorRewardsCollector.sol#496) is not in mixedCase



    
496         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._addr (OperatorRewardsCollector.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._staderConfig (OperatorRewardsCollector.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.AUCTION_CONTRACT() (OperatorRewardsCollector.sol#32) is not in mixedCase



    
32     function AUCTION_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (OperatorRewardsCollector.sol#478) is not in mixedCase



    
478         uint256 _validatorId,



```

```
Parameter OperatorRewardsCollector.depositFor(address)._receiver (OperatorRewardsCollector.sol#1974) is not in mixedCase



    
1974     function depositFor(address _receiver) external payable {



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._staderConfig (OperatorRewardsCollector.sol#468) is not in mixedCase



    
468         IStaderConfig _staderConfig,



```

```
Variable PausableUpgradeable.__gap (OperatorRewardsCollector.sol#1943) is not in mixedCase



    
1943     uint256[49] private __gap;



```

```
Function IStaderConfig.USER_WITHDRAW_MANAGER() (OperatorRewardsCollector.sol#44) is not in mixedCase



    
44     function USER_WITHDRAW_MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.NODE_EL_REWARD_VAULT_IMPLEMENTATION() (OperatorRewardsCollector.sol#56) is not in mixedCase



    
56     function NODE_EL_REWARD_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._staderConfig (OperatorRewardsCollector.sol#513) is not in mixedCase



    
513         IStaderConfig _staderConfig



```

```
Function IStaderConfig.VAULT_FACTORY() (OperatorRewardsCollector.sol#28) is not in mixedCase



    
28     function VAULT_FACTORY() external view returns (bytes32);



```

```
Function IStaderConfig.STAKE_POOL_MANAGER() (OperatorRewardsCollector.sol#38) is not in mixedCase



    
38     function STAKE_POOL_MANAGER() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._poolId (OperatorRewardsCollector.sol#493) is not in mixedCase



    
493         uint8 _poolId,



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._contractName (OperatorRewardsCollector.sol#469) is not in mixedCase



    
469         bytes32 _contractName



```

```
Function IStaderConfig.OPERATOR() (OperatorRewardsCollector.sol#68) is not in mixedCase



    
68     function OPERATOR() external view returns (bytes32);



```

```
Parameter OperatorRewardsCollector.initialize(address,address)._admin (OperatorRewardsCollector.sol#1961) is not in mixedCase



    
1961     function initialize(address _admin, address _staderConfig) external initializer {



```

```
Function ERC165Upgradeable.__ERC165_init_unchained() (OperatorRewardsCollector.sol#1567-1568) is not in mixedCase



    
1567     function __ERC165_init_unchained() internal onlyInitializing {
1568     }



```

```
Function ContextUpgradeable.__Context_init_unchained() (OperatorRewardsCollector.sol#1097-1098) is not in mixedCase



    
1097     function __Context_init_unchained() internal onlyInitializing {
1098     }



```

```
Function IStaderConfig.PERMISSIONED_POOL() (OperatorRewardsCollector.sol#36) is not in mixedCase



    
36     function PERMISSIONED_POOL() external view returns (bytes32);



```

```
Function INodeRegistry.POOL_ID() (OperatorRewardsCollector.sol#302) is not in mixedCase



    
302     function POOL_ID() external view returns (uint8);



```

```
Parameter UtilLib.sendValue(address,uint256)._receiver (OperatorRewardsCollector.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Function IStaderConfig.PERMISSIONLESS_POOL() (OperatorRewardsCollector.sol#42) is not in mixedCase



    
42     function PERMISSIONLESS_POOL() external view returns (bytes32);



```

```
Parameter OperatorRewardsCollector.updateStaderConfig(address)._staderConfig (OperatorRewardsCollector.sol#1990) is not in mixedCase



    
1990     function updateStaderConfig(address _staderConfig) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._addr (OperatorRewardsCollector.sol#479) is not in mixedCase



    
479         address _addr,



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (OperatorRewardsCollector.sol#480) is not in mixedCase



    
480         IStaderConfig _staderConfig



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._staderConfig (OperatorRewardsCollector.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._staderConfig (OperatorRewardsCollector.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.SD_COLLATERAL() (OperatorRewardsCollector.sol#24) is not in mixedCase



    
24     function SD_COLLATERAL() external view returns (bytes32);



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._pubkey (OperatorRewardsCollector.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function AccessControlUpgradeable.__AccessControl_init() (OperatorRewardsCollector.sol#1623-1624) is not in mixedCase



    
1623     function __AccessControl_init() internal onlyInitializing {
1624     }



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._addr (OperatorRewardsCollector.sol#495) is not in mixedCase



    
495         address _addr,



```

```
Parameter UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig)._staderConfig (OperatorRewardsCollector.sol#585) is not in mixedCase



    
585         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._addr (OperatorRewardsCollector.sol#467) is not in mixedCase



    
467         address _addr,



```

```
Function IStaderConfig.PERMISSIONED_SOCIALIZING_POOL() (OperatorRewardsCollector.sol#52) is not in mixedCase



    
52     function PERMISSIONED_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Function IStaderConfig.PENALTY_CONTRACT() (OperatorRewardsCollector.sol#34) is not in mixedCase



    
34     function PENALTY_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._poolId (OperatorRewardsCollector.sol#477) is not in mixedCase



    
477         uint8 _poolId,



```

```
Variable ERC165Upgradeable.__gap (OperatorRewardsCollector.sol#1581) is not in mixedCase



    
1581     uint256[50] private __gap;



```

```
Function IStaderConfig.ETH_DEPOSIT_CONTRACT() (OperatorRewardsCollector.sol#40) is not in mixedCase



    
40     function ETH_DEPOSIT_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._operator (OperatorRewardsCollector.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.ETH_BALANCE_POR_FEED() (OperatorRewardsCollector.sol#61) is not in mixedCase



    
61     function ETH_BALANCE_POR_FEED() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._poolId (OperatorRewardsCollector.sol#510) is not in mixedCase



    
510         uint8 _poolId,



```

```
Parameter UtilLib.getPubkeyRoot(bytes)._pubkey (OperatorRewardsCollector.sol#561) is not in mixedCase



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {



```

```
Function PausableUpgradeable.__Pausable_init() (OperatorRewardsCollector.sol#1861-1863) is not in mixedCase



    
1861     function __Pausable_init() internal onlyInitializing {
1862         __Pausable_init_unchained();
1863     }



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._poolId (OperatorRewardsCollector.sol#523) is not in mixedCase



    
523         uint8 _poolId,



```

```
Function IStaderConfig.MANAGER() (OperatorRewardsCollector.sol#66) is not in mixedCase



    
66     function MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.STADER_INSURANCE_FUND() (OperatorRewardsCollector.sol#46) is not in mixedCase



    
46     function STADER_INSURANCE_FUND() external view returns (bytes32);



```

```
Function ContextUpgradeable.__Context_init() (OperatorRewardsCollector.sol#1094-1095) is not in mixedCase



    
1094     function __Context_init() internal onlyInitializing {
1095     }



```

```
Function IStaderConfig.PERMISSIONLESS_NODE_REGISTRY() (OperatorRewardsCollector.sol#50) is not in mixedCase



    
50     function PERMISSIONLESS_NODE_REGISTRY() external view returns (bytes32);



```

```
Function ERC165Upgradeable.__ERC165_init() (OperatorRewardsCollector.sol#1564-1565) is not in mixedCase



    
1564     function __ERC165_init() internal onlyInitializing {
1565     }



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._staderConfig (OperatorRewardsCollector.sol#525) is not in mixedCase



    
525         IStaderConfig _staderConfig



```

```
Parameter UtilLib.checkNonZeroAddress(address)._address (OperatorRewardsCollector.sol#448) is not in mixedCase



    
448     function checkNonZeroAddress(address _address) internal pure {



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._addr (OperatorRewardsCollector.sol#512) is not in mixedCase



    
512         address _addr,



```

```
Function PausableUpgradeable.__Pausable_init_unchained() (OperatorRewardsCollector.sol#1865-1867) is not in mixedCase



    
1865     function __Pausable_init_unchained() internal onlyInitializing {
1866         _paused = false;
1867     }



```

### Penalty.sol


```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._addr (Penalty.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.PERMISSIONED_NODE_REGISTRY() (Penalty.sol#48) is not in mixedCase



    
48     function PERMISSIONED_NODE_REGISTRY() external view returns (bytes32);



```

```
Function IStaderConfig.PERMISSIONLESS_SOCIALIZING_POOL() (Penalty.sol#54) is not in mixedCase



    
54     function PERMISSIONLESS_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._validatorId (Penalty.sol#511) is not in mixedCase



    
511         uint256 _validatorId,



```

```
Function IStaderConfig.VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() (Penalty.sol#58) is not in mixedCase



    
58     function VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._staderConfig (Penalty.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Parameter Penalty.updateRatedOracleAddress(address)._ratedOracleAddress (Penalty.sol#2442) is not in mixedCase



    
2442     function updateRatedOracleAddress(address _ratedOracleAddress) external override {



```

```
Function IStaderConfig.POOL_SELECTOR() (Penalty.sol#22) is not in mixedCase



    
22     function POOL_SELECTOR() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._poolId (Penalty.sol#535) is not in mixedCase



    
535         uint8 _poolId,



```

```
Parameter Penalty.updateMissedAttestationPenaltyPerStrike(uint256)._missedAttestationPenaltyPerStrike (Penalty.sol#2428) is not in mixedCase



    
2428     function updateMissedAttestationPenaltyPerStrike(uint256 _missedAttestationPenaltyPerStrike) external override {



```

```
Function IStaderConfig.ETHX_SUPPLY_POR_FEED() (Penalty.sol#63) is not in mixedCase



    
63     function ETHX_SUPPLY_POR_FEED() external view returns (bytes32);



```

```
Function IStaderConfig.POOL_UTILS() (Penalty.sol#20) is not in mixedCase



    
20     function POOL_UTILS() external view returns (bytes32);



```

```
Function AccessControlUpgradeable.__AccessControl_init_unchained() (Penalty.sol#2088-2089) is not in mixedCase



    
2088     function __AccessControl_init_unchained() internal onlyInitializing {
2089     }



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._operatorId (Penalty.sol#536) is not in mixedCase



    
536         uint256 _operatorId,



```

```
Function IStaderConfig.OPERATOR_REWARD_COLLECTOR() (Penalty.sol#26) is not in mixedCase



    
26     function OPERATOR_REWARD_COLLECTOR() external view returns (bytes32);



```

```
Parameter Penalty.initialize(address,address,address)._staderConfig (Penalty.sol#2393) is not in mixedCase



    
2393         address _staderConfig,



```

```
Variable ContextUpgradeable.__gap (Penalty.sol#1574) is not in mixedCase



    
1574     uint256[50] private __gap;



```

```
Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained() (Penalty.sol#2335-2337) is not in mixedCase



    
2335     function __ReentrancyGuard_init_unchained() internal onlyInitializing {
2336         _status = _NOT_ENTERED;
2337     }



```

```
Variable AccessControlUpgradeable.__gap (Penalty.sol#2293) is not in mixedCase



    
2293     uint256[49] private __gap;



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._staderConfig (Penalty.sol#537) is not in mixedCase



    
537         IStaderConfig _staderConfig



```

```
Parameter UtilLib.sendValue(address,uint256)._amount (Penalty.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Parameter Penalty.updateMEVTheftPenaltyPerStrike(uint256)._mevTheftPenaltyPerStrike (Penalty.sol#2421) is not in mixedCase



    
2421     function updateMEVTheftPenaltyPerStrike(uint256 _mevTheftPenaltyPerStrike) external override {



```

```
Parameter Penalty.setAdditionalPenaltyAmount(bytes,uint256)._amount (Penalty.sol#2413) is not in mixedCase



    
2413     function setAdditionalPenaltyAmount(bytes calldata _pubkey, uint256 _amount) external override {



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (Penalty.sol#494) is not in mixedCase



    
494         uint256 _validatorId,



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._validatorId (Penalty.sol#524) is not in mixedCase



    
524         uint256 _validatorId,



```

```
Function IStaderConfig.STADER_ORACLE() (Penalty.sol#30) is not in mixedCase



    
30     function STADER_ORACLE() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (Penalty.sol#496) is not in mixedCase



    
496         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._addr (Penalty.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._staderConfig (Penalty.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.AUCTION_CONTRACT() (Penalty.sol#32) is not in mixedCase



    
32     function AUCTION_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (Penalty.sol#478) is not in mixedCase



    
478         uint256 _validatorId,



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._staderConfig (Penalty.sol#468) is not in mixedCase



    
468         IStaderConfig _staderConfig,



```

```
Function IStaderConfig.USER_WITHDRAW_MANAGER() (Penalty.sol#44) is not in mixedCase



    
44     function USER_WITHDRAW_MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.NODE_EL_REWARD_VAULT_IMPLEMENTATION() (Penalty.sol#56) is not in mixedCase



    
56     function NODE_EL_REWARD_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._staderConfig (Penalty.sol#513) is not in mixedCase



    
513         IStaderConfig _staderConfig



```

```
Function IStaderConfig.VAULT_FACTORY() (Penalty.sol#28) is not in mixedCase



    
28     function VAULT_FACTORY() external view returns (bytes32);



```

```
Function IStaderConfig.STAKE_POOL_MANAGER() (Penalty.sol#38) is not in mixedCase



    
38     function STAKE_POOL_MANAGER() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._poolId (Penalty.sol#493) is not in mixedCase



    
493         uint8 _poolId,



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._contractName (Penalty.sol#469) is not in mixedCase



    
469         bytes32 _contractName



```

```
Function IStaderConfig.OPERATOR() (Penalty.sol#68) is not in mixedCase



    
68     function OPERATOR() external view returns (bytes32);



```

```
Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init() (Penalty.sol#2331-2333) is not in mixedCase



    
2331     function __ReentrancyGuard_init() internal onlyInitializing {
2332         __ReentrancyGuard_init_unchained();
2333     }



```

```
Function ERC165Upgradeable.__ERC165_init_unchained() (Penalty.sol#2029-2030) is not in mixedCase



    
2029     function __ERC165_init_unchained() internal onlyInitializing {
2030     }



```

```
Function ContextUpgradeable.__Context_init_unchained() (Penalty.sol#1559-1560) is not in mixedCase



    
1559     function __Context_init_unchained() internal onlyInitializing {
1560     }



```

```
Function IStaderConfig.PERMISSIONED_POOL() (Penalty.sol#36) is not in mixedCase



    
36     function PERMISSIONED_POOL() external view returns (bytes32);



```

```
Function INodeRegistry.POOL_ID() (Penalty.sol#302) is not in mixedCase



    
302     function POOL_ID() external view returns (uint8);



```

```
Parameter UtilLib.sendValue(address,uint256)._receiver (Penalty.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Function IStaderConfig.PERMISSIONLESS_POOL() (Penalty.sol#42) is not in mixedCase



    
42     function PERMISSIONLESS_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._addr (Penalty.sol#479) is not in mixedCase



    
479         address _addr,



```

```
Parameter Penalty.initialize(address,address,address)._ratedOracleAddress (Penalty.sol#2394) is not in mixedCase



    
2394         address _ratedOracleAddress



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (Penalty.sol#480) is not in mixedCase



    
480         IStaderConfig _staderConfig



```

```
Variable ReentrancyGuardUpgradeable.__gap (Penalty.sol#2371) is not in mixedCase



    
2371     uint256[49] private __gap;



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._staderConfig (Penalty.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._staderConfig (Penalty.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Parameter Penalty.calculateMEVTheftPenalty(bytes32)._pubkeyRoot (Penalty.sol#2480) is not in mixedCase



    
2480     function calculateMEVTheftPenalty(bytes32 _pubkeyRoot) public override returns (uint256) {



```

```
Parameter Penalty.updateValidatorExitPenaltyThreshold(uint256)._validatorExitPenaltyThreshold (Penalty.sol#2435) is not in mixedCase



    
2435     function updateValidatorExitPenaltyThreshold(uint256 _validatorExitPenaltyThreshold) external override {



```

```
Function IStaderConfig.SD_COLLATERAL() (Penalty.sol#24) is not in mixedCase



    
24     function SD_COLLATERAL() external view returns (bytes32);



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._pubkey (Penalty.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function AccessControlUpgradeable.__AccessControl_init() (Penalty.sol#2085-2086) is not in mixedCase



    
2085     function __AccessControl_init() internal onlyInitializing {
2086     }



```

```
Parameter Penalty.updateTotalPenaltyAmount(bytes[])._pubkey (Penalty.sol#2457) is not in mixedCase



    
2457     function updateTotalPenaltyAmount(bytes[] calldata _pubkey) external override nonReentrant {



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._addr (Penalty.sol#495) is not in mixedCase



    
495         address _addr,



```

```
Parameter UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig)._staderConfig (Penalty.sol#585) is not in mixedCase



    
585         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._addr (Penalty.sol#467) is not in mixedCase



    
467         address _addr,



```

```
Parameter Penalty.getAdditionalPenaltyAmount(bytes)._pubkey (Penalty.sol#2495) is not in mixedCase



    
2495     function getAdditionalPenaltyAmount(bytes calldata _pubkey) external view override returns (uint256) {



```

```
Parameter Penalty.calculateMissedAttestationPenalty(bytes32)._pubkeyRoot (Penalty.sol#2488) is not in mixedCase



    
2488     function calculateMissedAttestationPenalty(bytes32 _pubkeyRoot) public view override returns (uint256) {



```

```
Function IStaderConfig.PERMISSIONED_SOCIALIZING_POOL() (Penalty.sol#52) is not in mixedCase



    
52     function PERMISSIONED_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Parameter Penalty.updateStaderConfig(address)._staderConfig (Penalty.sol#2450) is not in mixedCase



    
2450     function updateStaderConfig(address _staderConfig) external override onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Function IStaderConfig.PENALTY_CONTRACT() (Penalty.sol#34) is not in mixedCase



    
34     function PENALTY_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._poolId (Penalty.sol#477) is not in mixedCase



    
477         uint8 _poolId,



```

```
Parameter Penalty.markValidatorSettled(uint8,uint256)._poolId (Penalty.sol#2500) is not in mixedCase



    
2500     function markValidatorSettled(uint8 _poolId, uint256 _validatorId) external override {



```

```
Variable ERC165Upgradeable.__gap (Penalty.sol#2043) is not in mixedCase



    
2043     uint256[50] private __gap;



```

```
Function IStaderConfig.ETH_DEPOSIT_CONTRACT() (Penalty.sol#40) is not in mixedCase



    
40     function ETH_DEPOSIT_CONTRACT() external view returns (bytes32);



```

```
Parameter Penalty.initialize(address,address,address)._admin (Penalty.sol#2392) is not in mixedCase



    
2392         address _admin,



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._operator (Penalty.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Parameter Penalty.setAdditionalPenaltyAmount(bytes,uint256)._pubkey (Penalty.sol#2413) is not in mixedCase



    
2413     function setAdditionalPenaltyAmount(bytes calldata _pubkey, uint256 _amount) external override {



```

```
Function IStaderConfig.ETH_BALANCE_POR_FEED() (Penalty.sol#61) is not in mixedCase



    
61     function ETH_BALANCE_POR_FEED() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._poolId (Penalty.sol#510) is not in mixedCase



    
510         uint8 _poolId,



```

```
Parameter UtilLib.getPubkeyRoot(bytes)._pubkey (Penalty.sol#561) is not in mixedCase



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._poolId (Penalty.sol#523) is not in mixedCase



    
523         uint8 _poolId,



```

```
Function IStaderConfig.MANAGER() (Penalty.sol#66) is not in mixedCase



    
66     function MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.STADER_INSURANCE_FUND() (Penalty.sol#46) is not in mixedCase



    
46     function STADER_INSURANCE_FUND() external view returns (bytes32);



```

```
Function ContextUpgradeable.__Context_init() (Penalty.sol#1556-1557) is not in mixedCase



    
1556     function __Context_init() internal onlyInitializing {
1557     }



```

```
Function IStaderConfig.PERMISSIONLESS_NODE_REGISTRY() (Penalty.sol#50) is not in mixedCase



    
50     function PERMISSIONLESS_NODE_REGISTRY() external view returns (bytes32);



```

```
Function ERC165Upgradeable.__ERC165_init() (Penalty.sol#2026-2027) is not in mixedCase



    
2026     function __ERC165_init() internal onlyInitializing {
2027     }



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._staderConfig (Penalty.sol#525) is not in mixedCase



    
525         IStaderConfig _staderConfig



```

```
Parameter UtilLib.checkNonZeroAddress(address)._address (Penalty.sol#448) is not in mixedCase



    
448     function checkNonZeroAddress(address _address) internal pure {



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._addr (Penalty.sol#512) is not in mixedCase



    
512         address _addr,



```

```
Parameter Penalty.markValidatorSettled(uint8,uint256)._validatorId (Penalty.sol#2500) is not in mixedCase



    
2500     function markValidatorSettled(uint8 _poolId, uint256 _validatorId) external override {



```

### PermissionedNodeRegistry.sol


```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._addr (PermissionedNodeRegistry.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.PERMISSIONED_NODE_REGISTRY() (PermissionedNodeRegistry.sol#48) is not in mixedCase



    
48     function PERMISSIONED_NODE_REGISTRY() external view returns (bytes32);



```

```
Function IStaderConfig.PERMISSIONLESS_SOCIALIZING_POOL() (PermissionedNodeRegistry.sol#54) is not in mixedCase



    
54     function PERMISSIONLESS_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._validatorId (PermissionedNodeRegistry.sol#511) is not in mixedCase



    
511         uint256 _validatorId,



```

```
Function IStaderConfig.VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() (PermissionedNodeRegistry.sol#58) is not in mixedCase



    
58     function VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter PermissionedNodeRegistry.addValidatorKeys(bytes[],bytes[],bytes[])._depositSignature (PermissionedNodeRegistry.sol#2573) is not in mixedCase



    
2573         bytes[] calldata _depositSignature



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._staderConfig (PermissionedNodeRegistry.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Parameter PermissionedNodeRegistry.decreaseTotalActiveValidatorCount(uint256)._count (PermissionedNodeRegistry.sol#3175) is not in mixedCase



    
3175     function decreaseTotalActiveValidatorCount(uint256 _count) internal {



```

```
Parameter PermissionedNodeRegistry.checkInputKeysCountAndCollateral(uint256,uint256,uint256,uint256)._operatorId (PermissionedNodeRegistry.sol#3119) is not in mixedCase



    
3119         uint256 _operatorId



```

```
Function IStaderConfig.POOL_SELECTOR() (PermissionedNodeRegistry.sol#22) is not in mixedCase



    
22     function POOL_SELECTOR() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._poolId (PermissionedNodeRegistry.sol#535) is not in mixedCase



    
535         uint8 _poolId,



```

```
Parameter PermissionedNodeRegistry.deactivateNodeOperator(uint256)._operatorId (PermissionedNodeRegistry.sol#2768) is not in mixedCase



    
2768     function deactivateNodeOperator(uint256 _operatorId) external override {



```

```
Parameter PermissionedNodeRegistry.onboardNodeOperator(string,address)._operatorName (PermissionedNodeRegistry.sol#2537) is not in mixedCase



    
2537     function onboardNodeOperator(string calldata _operatorName, address payable _operatorRewardAddress)



```

```
Function IStaderConfig.ETHX_SUPPLY_POR_FEED() (PermissionedNodeRegistry.sol#63) is not in mixedCase



    
63     function ETHX_SUPPLY_POR_FEED() external view returns (bytes32);



```

```
Function IStaderConfig.POOL_UTILS() (PermissionedNodeRegistry.sol#20) is not in mixedCase



    
20     function POOL_UTILS() external view returns (bytes32);



```

```
Function AccessControlUpgradeable.__AccessControl_init_unchained() (PermissionedNodeRegistry.sol#2166-2167) is not in mixedCase



    
2166     function __AccessControl_init_unchained() internal onlyInitializing {
2167     }



```

```
Parameter PermissionedNodeRegistry.getOperatorQueuedValidatorCount(uint256)._operatorId (PermissionedNodeRegistry.sol#3108) is not in mixedCase



    
3108     function getOperatorQueuedValidatorCount(uint256 _operatorId) internal view returns (uint256 _validatorCount) {



```

```
Parameter PermissionedNodeRegistry.withdrawnValidators(bytes[])._pubkeys (PermissionedNodeRegistry.sol#2741) is not in mixedCase



    
2741     function withdrawnValidators(bytes[] calldata _pubkeys) external override {



```

```
Parameter PermissionedNodeRegistry.handleFrontRun(uint256)._validatorId (PermissionedNodeRegistry.sol#3099) is not in mixedCase



    
3099     function handleFrontRun(uint256 _validatorId) internal {



```

```
Parameter PermissionedNodeRegistry.onboardOperator(string,address)._operatorName (PermissionedNodeRegistry.sol#3089) is not in mixedCase



    
3089     function onboardOperator(string calldata _operatorName, address payable _operatorRewardAddress) internal {



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._operatorId (PermissionedNodeRegistry.sol#536) is not in mixedCase



    
536         uint256 _operatorId,



```

```
Function IStaderConfig.OPERATOR_REWARD_COLLECTOR() (PermissionedNodeRegistry.sol#26) is not in mixedCase



    
26     function OPERATOR_REWARD_COLLECTOR() external view returns (bytes32);



```

```
Parameter PermissionedNodeRegistry.whitelistPermissionedNOs(address[])._permissionedNOs (PermissionedNodeRegistry.sol#2519) is not in mixedCase



    
2519     function whitelistPermissionedNOs(address[] calldata _permissionedNOs) external override {



```

```
Parameter PermissionedNodeRegistry.getOperatorTotalNonTerminalKeys(address,uint256,uint256)._nodeOperator (PermissionedNodeRegistry.sol#2953) is not in mixedCase



    
2953         address _nodeOperator,



```

```
Variable ContextUpgradeable.__gap (PermissionedNodeRegistry.sol#1454) is not in mixedCase



    
1454     uint256[50] private __gap;



```

```
Parameter PermissionedNodeRegistry.isActiveValidator(uint256)._validatorId (PermissionedNodeRegistry.sol#3160) is not in mixedCase



    
3160     function isActiveValidator(uint256 _validatorId) internal view returns (bool) {



```

```
Parameter PermissionedNodeRegistry.getOperatorTotalNonTerminalKeys(address,uint256,uint256)._startIndex (PermissionedNodeRegistry.sol#2954) is not in mixedCase



    
2954         uint256 _startIndex,



```

```
Parameter PermissionedNodeRegistry.updateStaderConfig(address)._staderConfig (PermissionedNodeRegistry.sol#2889) is not in mixedCase



    
2889     function updateStaderConfig(address _staderConfig) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained() (PermissionedNodeRegistry.sol#2413-2415) is not in mixedCase



    
2413     function __ReentrancyGuard_init_unchained() internal onlyInitializing {
2414         _status = _NOT_ENTERED;
2415     }



```

```
Parameter PermissionedNodeRegistry.isNonTerminalValidator(uint256)._validatorId (PermissionedNodeRegistry.sol#3166) is not in mixedCase



    
3166     function isNonTerminalValidator(uint256 _validatorId) internal view returns (bool) {



```

```
Variable AccessControlUpgradeable.__gap (PermissionedNodeRegistry.sol#2371) is not in mixedCase



    
2371     uint256[49] private __gap;



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._staderConfig (PermissionedNodeRegistry.sol#537) is not in mixedCase



    
537         IStaderConfig _staderConfig



```

```
Parameter PermissionedNodeRegistry.updateVerifiedKeysBatchSize(uint256)._verifiedKeysBatchSize (PermissionedNodeRegistry.sol#2868) is not in mixedCase



    
2868     function updateVerifiedKeysBatchSize(uint256 _verifiedKeysBatchSize) external {



```

```
Parameter PermissionedNodeRegistry.markValidatorReadyToDeposit(bytes[],bytes[],bytes[])._invalidSignaturePubkey (PermissionedNodeRegistry.sol#2687) is not in mixedCase



    
2687         bytes[] calldata _invalidSignaturePubkey



```

```
Parameter PermissionedNodeRegistry.onboardOperator(string,address)._operatorRewardAddress (PermissionedNodeRegistry.sol#3089) is not in mixedCase



    
3089     function onboardOperator(string calldata _operatorName, address payable _operatorRewardAddress) internal {



```

```
Parameter UtilLib.sendValue(address,uint256)._amount (PermissionedNodeRegistry.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Parameter PermissionedNodeRegistry.initialize(address,address)._admin (PermissionedNodeRegistry.sol#2497) is not in mixedCase



    
2497     function initialize(address _admin, address _staderConfig) public initializer {



```

```
Parameter PermissionedNodeRegistry.updateQueuedValidatorIndex(uint256,uint256)._operatorId (PermissionedNodeRegistry.sol#2795) is not in mixedCase



    
2795     function updateQueuedValidatorIndex(uint256 _operatorId, uint256 _nextQueuedValidatorIndex) external override {



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (PermissionedNodeRegistry.sol#494) is not in mixedCase



    
494         uint256 _validatorId,



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._validatorId (PermissionedNodeRegistry.sol#524) is not in mixedCase



    
524         uint256 _validatorId,



```

```
Function IStaderConfig.STADER_ORACLE() (PermissionedNodeRegistry.sol#30) is not in mixedCase



    
30     function STADER_ORACLE() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (PermissionedNodeRegistry.sol#496) is not in mixedCase



    
496         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._addr (PermissionedNodeRegistry.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._staderConfig (PermissionedNodeRegistry.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.AUCTION_CONTRACT() (PermissionedNodeRegistry.sol#32) is not in mixedCase



    
32     function AUCTION_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (PermissionedNodeRegistry.sol#478) is not in mixedCase



    
478         uint256 _validatorId,



```

```
Parameter PermissionedNodeRegistry.updateOperatorDetails(string,address)._rewardAddress (PermissionedNodeRegistry.sol#2831) is not in mixedCase



    
2831     function updateOperatorDetails(string calldata _operatorName, address payable _rewardAddress) external override {



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._staderConfig (PermissionedNodeRegistry.sol#468) is not in mixedCase



    
468         IStaderConfig _staderConfig,



```

```
Variable PausableUpgradeable.__gap (PermissionedNodeRegistry.sol#1564) is not in mixedCase



    
1564     uint256[49] private __gap;



```

```
Parameter PermissionedNodeRegistry.updateMaxOperatorId(uint256)._maxOperatorId (PermissionedNodeRegistry.sol#2879) is not in mixedCase



    
2879     function updateMaxOperatorId(uint256 _maxOperatorId) external {



```

```
Function IStaderConfig.USER_WITHDRAW_MANAGER() (PermissionedNodeRegistry.sol#44) is not in mixedCase



    
44     function USER_WITHDRAW_MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.NODE_EL_REWARD_VAULT_IMPLEMENTATION() (PermissionedNodeRegistry.sol#56) is not in mixedCase



    
56     function NODE_EL_REWARD_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._staderConfig (PermissionedNodeRegistry.sol#513) is not in mixedCase



    
513         IStaderConfig _staderConfig



```

```
Function IStaderConfig.VAULT_FACTORY() (PermissionedNodeRegistry.sol#28) is not in mixedCase



    
28     function VAULT_FACTORY() external view returns (bytes32);



```

```
Function IStaderConfig.STAKE_POOL_MANAGER() (PermissionedNodeRegistry.sol#38) is not in mixedCase



    
38     function STAKE_POOL_MANAGER() external view returns (bytes32);



```

```
Parameter PermissionedNodeRegistry.addValidatorKeys(bytes[],bytes[],bytes[])._preDepositSignature (PermissionedNodeRegistry.sol#2572) is not in mixedCase



    
2572         bytes[] calldata _preDepositSignature,



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._poolId (PermissionedNodeRegistry.sol#493) is not in mixedCase



    
493         uint8 _poolId,



```

```
Parameter PermissionedNodeRegistry.onlyPreDepositValidator(bytes)._pubkey (PermissionedNodeRegistry.sol#3084) is not in mixedCase



    
3084     function onlyPreDepositValidator(bytes calldata _pubkey) external view override {



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._contractName (PermissionedNodeRegistry.sol#469) is not in mixedCase



    
469         bytes32 _contractName



```

```
Parameter PermissionedNodeRegistry.getSocializingPoolStateChangeBlock(uint256)._operatorId (PermissionedNodeRegistry.sol#2896) is not in mixedCase



    
2896     function getSocializingPoolStateChangeBlock(uint256 _operatorId) external view returns (uint256) {



```

```
Function IStaderConfig.OPERATOR() (PermissionedNodeRegistry.sol#68) is not in mixedCase



    
68     function OPERATOR() external view returns (bytes32);



```

```
Parameter PermissionedNodeRegistry.allocateValidatorsAndUpdateOperatorId(uint256)._numValidators (PermissionedNodeRegistry.sol#2622) is not in mixedCase



    
2622     function allocateValidatorsAndUpdateOperatorId(uint256 _numValidators)



```

```
Parameter PermissionedNodeRegistry.getValidatorsByOperator(address,uint256,uint256)._pageNumber (PermissionedNodeRegistry.sol#3050) is not in mixedCase



    
3050         uint256 _pageNumber,



```

```
Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init() (PermissionedNodeRegistry.sol#2409-2411) is not in mixedCase



    
2409     function __ReentrancyGuard_init() internal onlyInitializing {
2410         __ReentrancyGuard_init_unchained();
2411     }



```

```
Function ERC165Upgradeable.__ERC165_init_unchained() (PermissionedNodeRegistry.sol#2107-2108) is not in mixedCase



    
2107     function __ERC165_init_unchained() internal onlyInitializing {
2108     }



```

```
Function ContextUpgradeable.__Context_init_unchained() (PermissionedNodeRegistry.sol#1439-1440) is not in mixedCase



    
1439     function __Context_init_unchained() internal onlyInitializing {
1440     }



```

```
Function IStaderConfig.PERMISSIONED_POOL() (PermissionedNodeRegistry.sol#36) is not in mixedCase



    
36     function PERMISSIONED_POOL() external view returns (bytes32);



```

```
Parameter PermissionedNodeRegistry.getValidatorsByOperator(address,uint256,uint256)._operator (PermissionedNodeRegistry.sol#3049) is not in mixedCase



    
3049         address _operator,



```

```
Function INodeRegistry.POOL_ID() (PermissionedNodeRegistry.sol#302) is not in mixedCase



    
302     function POOL_ID() external view returns (uint8);



```

```
Parameter PermissionedNodeRegistry.onboardNodeOperator(string,address)._operatorRewardAddress (PermissionedNodeRegistry.sol#2537) is not in mixedCase



    
2537     function onboardNodeOperator(string calldata _operatorName, address payable _operatorRewardAddress)



```

```
Parameter UtilLib.sendValue(address,uint256)._receiver (PermissionedNodeRegistry.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Parameter PermissionedNodeRegistry.markValidatorReadyToDeposit(bytes[],bytes[],bytes[])._readyToDepositPubkey (PermissionedNodeRegistry.sol#2685) is not in mixedCase



    
2685         bytes[] calldata _readyToDepositPubkey,



```

```
Parameter PermissionedNodeRegistry.markValidatorStatusAsPreDeposit(bytes)._pubkey (PermissionedNodeRegistry.sol#2818) is not in mixedCase



    
2818     function markValidatorStatusAsPreDeposit(bytes calldata _pubkey) external override {



```

```
Function IStaderConfig.PERMISSIONLESS_POOL() (PermissionedNodeRegistry.sol#42) is not in mixedCase



    
42     function PERMISSIONLESS_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._addr (PermissionedNodeRegistry.sol#479) is not in mixedCase



    
479         address _addr,



```

```
Parameter PermissionedNodeRegistry.checkInputKeysCountAndCollateral(uint256,uint256,uint256,uint256)._pubkeyLength (PermissionedNodeRegistry.sol#3116) is not in mixedCase



    
3116         uint256 _pubkeyLength,



```

```
Parameter PermissionedNodeRegistry.getValidatorsByOperator(address,uint256,uint256)._pageSize (PermissionedNodeRegistry.sol#3051) is not in mixedCase



    
3051         uint256 _pageSize



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (PermissionedNodeRegistry.sol#480) is not in mixedCase



    
480         IStaderConfig _staderConfig



```

```
Parameter PermissionedNodeRegistry.initialize(address,address)._staderConfig (PermissionedNodeRegistry.sol#2497) is not in mixedCase



    
2497     function initialize(address _admin, address _staderConfig) public initializer {



```

```
Parameter PermissionedNodeRegistry.onlyActiveOperator(address)._operAddr (PermissionedNodeRegistry.sol#3148) is not in mixedCase



    
3148     function onlyActiveOperator(address _operAddr) internal view returns (uint256 _operatorId) {



```

```
Variable ReentrancyGuardUpgradeable.__gap (PermissionedNodeRegistry.sol#2449) is not in mixedCase



    
2449     uint256[49] private __gap;



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._staderConfig (PermissionedNodeRegistry.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._staderConfig (PermissionedNodeRegistry.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.SD_COLLATERAL() (PermissionedNodeRegistry.sol#24) is not in mixedCase



    
24     function SD_COLLATERAL() external view returns (bytes32);



```

```
Parameter PermissionedNodeRegistry.getAllActiveValidators(uint256,uint256)._pageSize (PermissionedNodeRegistry.sol#3012) is not in mixedCase



    
3012     function getAllActiveValidators(uint256 _pageNumber, uint256 _pageSize)



```

```
Parameter PermissionedNodeRegistry.getAllActiveValidators(uint256,uint256)._pageNumber (PermissionedNodeRegistry.sol#3012) is not in mixedCase



    
3012     function getAllActiveValidators(uint256 _pageNumber, uint256 _pageSize)



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._pubkey (PermissionedNodeRegistry.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Parameter PermissionedNodeRegistry.markValidatorReadyToDeposit(bytes[],bytes[],bytes[])._frontRunPubkey (PermissionedNodeRegistry.sol#2686) is not in mixedCase



    
2686         bytes[] calldata _frontRunPubkey,



```

```
Function AccessControlUpgradeable.__AccessControl_init() (PermissionedNodeRegistry.sol#2163-2164) is not in mixedCase



    
2163     function __AccessControl_init() internal onlyInitializing {
2164     }



```

```
Parameter PermissionedNodeRegistry.onlyPreDepositValidator(uint256)._validatorId (PermissionedNodeRegistry.sol#3180) is not in mixedCase



    
3180     function onlyPreDepositValidator(uint256 _validatorId) internal view {



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._addr (PermissionedNodeRegistry.sol#495) is not in mixedCase



    
495         address _addr,



```

```
Parameter UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig)._staderConfig (PermissionedNodeRegistry.sol#585) is not in mixedCase



    
585         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._addr (PermissionedNodeRegistry.sol#467) is not in mixedCase



    
467         address _addr,



```

```
Parameter PermissionedNodeRegistry.checkInputKeysCountAndCollateral(uint256,uint256,uint256,uint256)._depositSignatureLength (PermissionedNodeRegistry.sol#3118) is not in mixedCase



    
3118         uint256 _depositSignatureLength,



```

```
Function IStaderConfig.PERMISSIONED_SOCIALIZING_POOL() (PermissionedNodeRegistry.sol#52) is not in mixedCase



    
52     function PERMISSIONED_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Parameter PermissionedNodeRegistry.updateMaxNonTerminalKeyPerOperator(uint64)._maxNonTerminalKeyPerOperator (PermissionedNodeRegistry.sol#2846) is not in mixedCase



    
2846     function updateMaxNonTerminalKeyPerOperator(uint64 _maxNonTerminalKeyPerOperator) external override {



```

```
Function IStaderConfig.PENALTY_CONTRACT() (PermissionedNodeRegistry.sol#34) is not in mixedCase



    
34     function PENALTY_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._poolId (PermissionedNodeRegistry.sol#477) is not in mixedCase



    
477         uint8 _poolId,



```

```
Variable ERC165Upgradeable.__gap (PermissionedNodeRegistry.sol#2121) is not in mixedCase



    
2121     uint256[50] private __gap;



```

```
Parameter PermissionedNodeRegistry.isExistingOperator(address)._operAddr (PermissionedNodeRegistry.sol#3079) is not in mixedCase



    
3079     function isExistingOperator(address _operAddr) external view override returns (bool) {



```

```
Parameter PermissionedNodeRegistry.getOperatorRewardAddress(uint256)._operatorId (PermissionedNodeRegistry.sol#2982) is not in mixedCase



    
2982     function getOperatorRewardAddress(uint256 _operatorId) external view override returns (address payable) {



```

```
Parameter PermissionedNodeRegistry.updateInputKeyCountLimit(uint16)._inputKeyCountLimit (PermissionedNodeRegistry.sol#2857) is not in mixedCase



    
2857     function updateInputKeyCountLimit(uint16 _inputKeyCountLimit) external override {



```

```
Function IStaderConfig.ETH_DEPOSIT_CONTRACT() (PermissionedNodeRegistry.sol#40) is not in mixedCase



    
40     function ETH_DEPOSIT_CONTRACT() external view returns (bytes32);



```

```
Parameter PermissionedNodeRegistry.getOperatorTotalNonTerminalKeys(address,uint256,uint256)._endIndex (PermissionedNodeRegistry.sol#2955) is not in mixedCase



    
2955         uint256 _endIndex



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._operator (PermissionedNodeRegistry.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.ETH_BALANCE_POR_FEED() (PermissionedNodeRegistry.sol#61) is not in mixedCase



    
61     function ETH_BALANCE_POR_FEED() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._poolId (PermissionedNodeRegistry.sol#510) is not in mixedCase



    
510         uint8 _poolId,



```

```
Parameter PermissionedNodeRegistry.updateOperatorDetails(string,address)._operatorName (PermissionedNodeRegistry.sol#2831) is not in mixedCase



    
2831     function updateOperatorDetails(string calldata _operatorName, address payable _rewardAddress) external override {



```

```
Parameter PermissionedNodeRegistry.getOperatorTotalKeys(uint256)._operatorId (PermissionedNodeRegistry.sol#2943) is not in mixedCase



    
2943     function getOperatorTotalKeys(uint256 _operatorId) public view override returns (uint256 _totalKeys) {



```

```
Parameter UtilLib.getPubkeyRoot(bytes)._pubkey (PermissionedNodeRegistry.sol#561) is not in mixedCase



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {



```

```
Parameter PermissionedNodeRegistry.markValidatorDeposited(uint256)._validatorId (PermissionedNodeRegistry.sol#3186) is not in mixedCase



    
3186     function markValidatorDeposited(uint256 _validatorId) internal {



```

```
Function IVaultFactory.NODE_REGISTRY_CONTRACT() (PermissionedNodeRegistry.sol#608) is not in mixedCase



    
608     function NODE_REGISTRY_CONTRACT() external view returns (bytes32);



```

```
Parameter PermissionedNodeRegistry.increaseTotalActiveValidatorCount(uint256)._count (PermissionedNodeRegistry.sol#2905) is not in mixedCase



    
2905     function increaseTotalActiveValidatorCount(uint256 _count) external override {



```

```
Function PausableUpgradeable.__Pausable_init() (PermissionedNodeRegistry.sol#1482-1484) is not in mixedCase



    
1482     function __Pausable_init() internal onlyInitializing {
1483         __Pausable_init_unchained();
1484     }



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._poolId (PermissionedNodeRegistry.sol#523) is not in mixedCase



    
523         uint8 _poolId,



```

```
Parameter PermissionedNodeRegistry.activateNodeOperator(uint256)._operatorId (PermissionedNodeRegistry.sol#2781) is not in mixedCase



    
2781     function activateNodeOperator(uint256 _operatorId) external override {



```

```
Function IStaderConfig.MANAGER() (PermissionedNodeRegistry.sol#66) is not in mixedCase



    
66     function MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.STADER_INSURANCE_FUND() (PermissionedNodeRegistry.sol#46) is not in mixedCase



    
46     function STADER_INSURANCE_FUND() external view returns (bytes32);



```

```
Function ContextUpgradeable.__Context_init() (PermissionedNodeRegistry.sol#1436-1437) is not in mixedCase



    
1436     function __Context_init() internal onlyInitializing {
1437     }



```

```
Function IStaderConfig.PERMISSIONLESS_NODE_REGISTRY() (PermissionedNodeRegistry.sol#50) is not in mixedCase



    
50     function PERMISSIONLESS_NODE_REGISTRY() external view returns (bytes32);



```

```
Parameter PermissionedNodeRegistry.addValidatorKeys(bytes[],bytes[],bytes[])._pubkey (PermissionedNodeRegistry.sol#2571) is not in mixedCase



    
2571         bytes[] calldata _pubkey,



```

```
Function ERC165Upgradeable.__ERC165_init() (PermissionedNodeRegistry.sol#2104-2105) is not in mixedCase



    
2104     function __ERC165_init() internal onlyInitializing {
2105     }



```

```
Parameter PermissionedNodeRegistry.updateDepositStatusAndBlock(uint256)._validatorId (PermissionedNodeRegistry.sol#2806) is not in mixedCase



    
2806     function updateDepositStatusAndBlock(uint256 _validatorId) external override {



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._staderConfig (PermissionedNodeRegistry.sol#525) is not in mixedCase



    
525         IStaderConfig _staderConfig



```

```
Parameter UtilLib.checkNonZeroAddress(address)._address (PermissionedNodeRegistry.sol#448) is not in mixedCase



    
448     function checkNonZeroAddress(address _address) internal pure {



```

```
Parameter PermissionedNodeRegistry.isExistingPubkey(bytes)._pubkey (PermissionedNodeRegistry.sol#3074) is not in mixedCase



    
3074     function isExistingPubkey(bytes calldata _pubkey) external view override returns (bool) {



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._addr (PermissionedNodeRegistry.sol#512) is not in mixedCase



    
512         address _addr,



```

```
Parameter PermissionedNodeRegistry.checkInputKeysCountAndCollateral(uint256,uint256,uint256,uint256)._preDepositSignatureLength (PermissionedNodeRegistry.sol#3117) is not in mixedCase



    
3117         uint256 _preDepositSignatureLength,



```

```
Parameter PermissionedNodeRegistry.updateQueuedValidatorIndex(uint256,uint256)._nextQueuedValidatorIndex (PermissionedNodeRegistry.sol#2795) is not in mixedCase



    
2795     function updateQueuedValidatorIndex(uint256 _operatorId, uint256 _nextQueuedValidatorIndex) external override {



```

```
Function PausableUpgradeable.__Pausable_init_unchained() (PermissionedNodeRegistry.sol#1486-1488) is not in mixedCase



    
1486     function __Pausable_init_unchained() internal onlyInitializing {
1487         _paused = false;
1488     }



```

### PermissionedPool.sol


```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._addr (PermissionedPool.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.PERMISSIONED_NODE_REGISTRY() (PermissionedPool.sol#48) is not in mixedCase



    
48     function PERMISSIONED_NODE_REGISTRY() external view returns (bytes32);



```

```
Parameter PermissionedPool.getOperatorTotalNonTerminalKeys(address,uint256,uint256)._endIndex (PermissionedPool.sol#2558) is not in mixedCase



    
2558         uint256 _endIndex



```

```
Function IStaderConfig.PERMISSIONLESS_SOCIALIZING_POOL() (PermissionedPool.sol#54) is not in mixedCase



    
54     function PERMISSIONLESS_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._validatorId (PermissionedPool.sol#511) is not in mixedCase



    
511         uint256 _validatorId,



```

```
Parameter PermissionedPool.getOperatorTotalNonTerminalKeys(address,uint256,uint256)._startIndex (PermissionedPool.sol#2557) is not in mixedCase



    
2557         uint256 _startIndex,



```

```
Function IStaderConfig.VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() (PermissionedPool.sol#58) is not in mixedCase



    
58     function VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._staderConfig (PermissionedPool.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.POOL_SELECTOR() (PermissionedPool.sol#22) is not in mixedCase



    
22     function POOL_SELECTOR() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._poolId (PermissionedPool.sol#535) is not in mixedCase



    
535         uint8 _poolId,



```

```
Parameter PermissionedPool.computeDepositDataRoot(bytes,bytes,bytes,uint256)._signature (PermissionedPool.sol#2614) is not in mixedCase



    
2614         bytes calldata _signature,



```

```
Function IStaderConfig.ETHX_SUPPLY_POR_FEED() (PermissionedPool.sol#63) is not in mixedCase



    
63     function ETHX_SUPPLY_POR_FEED() external view returns (bytes32);



```

```
Function IStaderConfig.POOL_UTILS() (PermissionedPool.sol#20) is not in mixedCase



    
20     function POOL_UTILS() external view returns (bytes32);



```

```
Parameter PermissionedPool.getOperatorTotalNonTerminalKeys(address,uint256,uint256)._nodeOperator (PermissionedPool.sol#2556) is not in mixedCase



    
2556         address _nodeOperator,



```

```
Function AccessControlUpgradeable.__AccessControl_init_unchained() (PermissionedPool.sol#2091-2092) is not in mixedCase



    
2091     function __AccessControl_init_unchained() internal onlyInitializing {
2092     }



```

```
Parameter PermissionedPool.decreasePreDepositValidatorCount(uint256)._count (PermissionedPool.sol#2639) is not in mixedCase



    
2639     function decreasePreDepositValidatorCount(uint256 _count) internal {



```

```
Parameter PermissionedPool.preDepositOnBeaconChain(address,address,address,uint256)._vaultFactory (PermissionedPool.sol#2646) is not in mixedCase



    
2646         address _vaultFactory,



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._operatorId (PermissionedPool.sol#536) is not in mixedCase



    
536         uint256 _operatorId,



```

```
Function IStaderConfig.OPERATOR_REWARD_COLLECTOR() (PermissionedPool.sol#26) is not in mixedCase



    
26     function OPERATOR_REWARD_COLLECTOR() external view returns (bytes32);



```

```
Variable ContextUpgradeable.__gap (PermissionedPool.sol#1577) is not in mixedCase



    
1577     uint256[50] private __gap;



```

```
Parameter PermissionedPool.computeDepositDataRoot(bytes,bytes,bytes,uint256)._pubkey (PermissionedPool.sol#2613) is not in mixedCase



    
2613         bytes calldata _pubkey,



```

```
Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained() (PermissionedPool.sol#2338-2340) is not in mixedCase



    
2338     function __ReentrancyGuard_init_unchained() internal onlyInitializing {
2339         _status = _NOT_ENTERED;
2340     }



```

```
Variable AccessControlUpgradeable.__gap (PermissionedPool.sol#2296) is not in mixedCase



    
2296     uint256[49] private __gap;



```

```
Parameter PermissionedPool.isExistingPubkey(bytes)._pubkey (PermissionedPool.sol#2582) is not in mixedCase



    
2582     function isExistingPubkey(bytes calldata _pubkey) external view override returns (bool) {



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._staderConfig (PermissionedPool.sol#537) is not in mixedCase



    
537         IStaderConfig _staderConfig



```

```
Parameter UtilLib.sendValue(address,uint256)._amount (PermissionedPool.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Parameter PermissionedPool.preDepositOnBeaconChain(address,address,address,uint256)._nodeRegistryAddress (PermissionedPool.sol#2645) is not in mixedCase



    
2645         address _nodeRegistryAddress,



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (PermissionedPool.sol#494) is not in mixedCase



    
494         uint256 _validatorId,



```

```
Function PermissionedPool.to_little_endian_64(uint256) (PermissionedPool.sol#2677-2691) is not in mixedCase



    
2677     function to_little_endian_64(uint256 _depositAmount) internal pure returns (bytes memory ret) {
2678         uint64 value = uint64(_depositAmount / 1 gwei);
2679 
2680         ret = new bytes(8);
2681         bytes8 bytesValue = bytes8(value);
2682         // Byteswapping during copying to bytes.
2683         ret[0] = bytesValue[7];
2684         ret[1] = bytesValue[6];
2685         ret[2] = bytesValue[5];
2686         ret[3] = bytesValue[4];
2687         ret[4] = bytesValue[3];
2688         ret[5] = bytesValue[2];
2689         ret[6] = bytesValue[1];
2690         ret[7] = bytesValue[0];
2691     }



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._validatorId (PermissionedPool.sol#524) is not in mixedCase



    
524         uint256 _validatorId,



```

```
Parameter PermissionedPool.computeDepositDataRoot(bytes,bytes,bytes,uint256)._depositAmount (PermissionedPool.sol#2616) is not in mixedCase



    
2616         uint256 _depositAmount



```

```
Function IStaderConfig.STADER_ORACLE() (PermissionedPool.sol#30) is not in mixedCase



    
30     function STADER_ORACLE() external view returns (bytes32);



```

```
Parameter PermissionedPool.increasePreDepositValidatorCount(uint256)._count (PermissionedPool.sol#2635) is not in mixedCase



    
2635     function increasePreDepositValidatorCount(uint256 _count) internal {



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (PermissionedPool.sol#496) is not in mixedCase



    
496         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._addr (PermissionedPool.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._staderConfig (PermissionedPool.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.AUCTION_CONTRACT() (PermissionedPool.sol#32) is not in mixedCase



    
32     function AUCTION_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (PermissionedPool.sol#478) is not in mixedCase



    
478         uint256 _validatorId,



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._staderConfig (PermissionedPool.sol#468) is not in mixedCase



    
468         IStaderConfig _staderConfig,



```

```
Function IStaderConfig.USER_WITHDRAW_MANAGER() (PermissionedPool.sol#44) is not in mixedCase



    
44     function USER_WITHDRAW_MANAGER() external view returns (bytes32);



```

```
Parameter PermissionedPool.updateStaderConfig(address)._staderConfig (PermissionedPool.sol#2604) is not in mixedCase



    
2604     function updateStaderConfig(address _staderConfig) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Function IStaderConfig.NODE_EL_REWARD_VAULT_IMPLEMENTATION() (PermissionedPool.sol#56) is not in mixedCase



    
56     function NODE_EL_REWARD_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._staderConfig (PermissionedPool.sol#513) is not in mixedCase



    
513         IStaderConfig _staderConfig



```

```
Function IStaderConfig.VAULT_FACTORY() (PermissionedPool.sol#28) is not in mixedCase



    
28     function VAULT_FACTORY() external view returns (bytes32);



```

```
Function IStaderConfig.STAKE_POOL_MANAGER() (PermissionedPool.sol#38) is not in mixedCase



    
38     function STAKE_POOL_MANAGER() external view returns (bytes32);



```

```
Function IDepositContract.get_deposit_root() (PermissionedPool.sol#704) is not in mixedCase



    
704     function get_deposit_root() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._poolId (PermissionedPool.sol#493) is not in mixedCase



    
493         uint8 _poolId,



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._contractName (PermissionedPool.sol#469) is not in mixedCase



    
469         bytes32 _contractName



```

```
Function IStaderConfig.OPERATOR() (PermissionedPool.sol#68) is not in mixedCase



    
68     function OPERATOR() external view returns (bytes32);



```

```
Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init() (PermissionedPool.sol#2334-2336) is not in mixedCase



    
2334     function __ReentrancyGuard_init() internal onlyInitializing {
2335         __ReentrancyGuard_init_unchained();
2336     }



```

```
Function ERC165Upgradeable.__ERC165_init_unchained() (PermissionedPool.sol#2032-2033) is not in mixedCase



    
2032     function __ERC165_init_unchained() internal onlyInitializing {
2033     }



```

```
Function ContextUpgradeable.__Context_init_unchained() (PermissionedPool.sol#1562-1563) is not in mixedCase



    
1562     function __Context_init_unchained() internal onlyInitializing {
1563     }



```

```
Function IStaderConfig.PERMISSIONED_POOL() (PermissionedPool.sol#36) is not in mixedCase



    
36     function PERMISSIONED_POOL() external view returns (bytes32);



```

```
Function INodeRegistry.POOL_ID() (PermissionedPool.sol#302) is not in mixedCase



    
302     function POOL_ID() external view returns (uint8);



```

```
Parameter UtilLib.sendValue(address,uint256)._receiver (PermissionedPool.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Parameter PermissionedPool.preDepositOnBeaconChain(address,address,address,uint256)._validatorId (PermissionedPool.sol#2648) is not in mixedCase



    
2648         uint256 _validatorId



```

```
Parameter PermissionedPool.setCommissionFees(uint256,uint256)._protocolFee (PermissionedPool.sol#2592) is not in mixedCase



    
2592     function setCommissionFees(uint256 _protocolFee, uint256 _operatorFee) external {



```

```
Function IStaderConfig.PERMISSIONLESS_POOL() (PermissionedPool.sol#42) is not in mixedCase



    
42     function PERMISSIONLESS_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._addr (PermissionedPool.sol#479) is not in mixedCase



    
479         address _addr,



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (PermissionedPool.sol#480) is not in mixedCase



    
480         IStaderConfig _staderConfig



```

```
Variable ReentrancyGuardUpgradeable.__gap (PermissionedPool.sol#2374) is not in mixedCase



    
2374     uint256[49] private __gap;



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._staderConfig (PermissionedPool.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._staderConfig (PermissionedPool.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.SD_COLLATERAL() (PermissionedPool.sol#24) is not in mixedCase



    
24     function SD_COLLATERAL() external view returns (bytes32);



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._pubkey (PermissionedPool.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function AccessControlUpgradeable.__AccessControl_init() (PermissionedPool.sol#2088-2089) is not in mixedCase



    
2088     function __AccessControl_init() internal onlyInitializing {
2089     }



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._addr (PermissionedPool.sol#495) is not in mixedCase



    
495         address _addr,



```

```
Parameter UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig)._staderConfig (PermissionedPool.sol#585) is not in mixedCase



    
585         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._addr (PermissionedPool.sol#467) is not in mixedCase



    
467         address _addr,



```

```
Parameter PermissionedPool.transferETHOfDefectiveKeysToSSPM(uint256)._defectiveKeyCount (PermissionedPool.sol#2423) is not in mixedCase



    
2423     function transferETHOfDefectiveKeysToSSPM(uint256 _defectiveKeyCount) external nonReentrant {



```

```
Parameter PermissionedPool.fullDepositOnBeaconChain(bytes[])._pubkey (PermissionedPool.sol#2485) is not in mixedCase



    
2485     function fullDepositOnBeaconChain(bytes[] calldata _pubkey) external nonReentrant {



```

```
Function IStaderConfig.PERMISSIONED_SOCIALIZING_POOL() (PermissionedPool.sol#52) is not in mixedCase



    
52     function PERMISSIONED_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Function IStaderConfig.PENALTY_CONTRACT() (PermissionedPool.sol#34) is not in mixedCase



    
34     function PENALTY_CONTRACT() external view returns (bytes32);



```

```
Parameter PermissionedPool.to_little_endian_64(uint256)._depositAmount (PermissionedPool.sol#2677) is not in mixedCase



    
2677     function to_little_endian_64(uint256 _depositAmount) internal pure returns (bytes memory ret) {



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._poolId (PermissionedPool.sol#477) is not in mixedCase



    
477         uint8 _poolId,



```

```
Variable ERC165Upgradeable.__gap (PermissionedPool.sol#2046) is not in mixedCase



    
2046     uint256[50] private __gap;



```

```
Parameter IDepositContract.deposit(bytes,bytes,bytes,bytes32).deposit_data_root (PermissionedPool.sol#699) is not in mixedCase



    
699         bytes32 deposit_data_root



```

```
Parameter PermissionedPool.setCommissionFees(uint256,uint256)._operatorFee (PermissionedPool.sol#2592) is not in mixedCase



    
2592     function setCommissionFees(uint256 _protocolFee, uint256 _operatorFee) external {



```

```
Parameter PermissionedPool.initialize(address,address)._staderConfig (PermissionedPool.sol#2396) is not in mixedCase



    
2396     function initialize(address _admin, address _staderConfig) public initializer {



```

```
Function IStaderConfig.ETH_DEPOSIT_CONTRACT() (PermissionedPool.sol#40) is not in mixedCase



    
40     function ETH_DEPOSIT_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._operator (PermissionedPool.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Function IDepositContract.get_deposit_count() (PermissionedPool.sol#708) is not in mixedCase



    
708     function get_deposit_count() external view returns (bytes memory);



```

```
Function IStaderConfig.ETH_BALANCE_POR_FEED() (PermissionedPool.sol#61) is not in mixedCase



    
61     function ETH_BALANCE_POR_FEED() external view returns (bytes32);



```

```
Parameter PermissionedPool.preDepositOnBeaconChain(address,address,address,uint256)._ethDepositContract (PermissionedPool.sol#2647) is not in mixedCase



    
2647         address _ethDepositContract,



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._poolId (PermissionedPool.sol#510) is not in mixedCase



    
510         uint8 _poolId,



```

```
Parameter UtilLib.getPubkeyRoot(bytes)._pubkey (PermissionedPool.sol#561) is not in mixedCase



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {



```

```
Function IVaultFactory.NODE_REGISTRY_CONTRACT() (PermissionedPool.sol#608) is not in mixedCase



    
608     function NODE_REGISTRY_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._poolId (PermissionedPool.sol#523) is not in mixedCase



    
523         uint8 _poolId,



```

```
Function IStaderConfig.MANAGER() (PermissionedPool.sol#66) is not in mixedCase



    
66     function MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.STADER_INSURANCE_FUND() (PermissionedPool.sol#46) is not in mixedCase



    
46     function STADER_INSURANCE_FUND() external view returns (bytes32);



```

```
Function ContextUpgradeable.__Context_init() (PermissionedPool.sol#1559-1560) is not in mixedCase



    
1559     function __Context_init() internal onlyInitializing {
1560     }



```

```
Function IStaderConfig.PERMISSIONLESS_NODE_REGISTRY() (PermissionedPool.sol#50) is not in mixedCase



    
50     function PERMISSIONLESS_NODE_REGISTRY() external view returns (bytes32);



```

```
Parameter PermissionedPool.initialize(address,address)._admin (PermissionedPool.sol#2396) is not in mixedCase



    
2396     function initialize(address _admin, address _staderConfig) public initializer {



```

```
Function ERC165Upgradeable.__ERC165_init() (PermissionedPool.sol#2029-2030) is not in mixedCase



    
2029     function __ERC165_init() internal onlyInitializing {
2030     }



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._staderConfig (PermissionedPool.sol#525) is not in mixedCase



    
525         IStaderConfig _staderConfig



```

```
Parameter UtilLib.checkNonZeroAddress(address)._address (PermissionedPool.sol#448) is not in mixedCase



    
448     function checkNonZeroAddress(address _address) internal pure {



```

```
Parameter IDepositContract.deposit(bytes,bytes,bytes,bytes32).withdrawal_credentials (PermissionedPool.sol#697) is not in mixedCase



    
697         bytes calldata withdrawal_credentials,



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._addr (PermissionedPool.sol#512) is not in mixedCase



    
512         address _addr,



```

```
Parameter PermissionedPool.isExistingOperator(address)._operAddr (PermissionedPool.sol#2587) is not in mixedCase



    
2587     function isExistingOperator(address _operAddr) external view override returns (bool) {



```

```
Parameter PermissionedPool.computeDepositDataRoot(bytes,bytes,bytes,uint256)._withdrawCredential (PermissionedPool.sol#2615) is not in mixedCase



    
2615         bytes calldata _withdrawCredential,



```

### PermissionlessNodeRegistry.sol


```
Parameter PermissionlessNodeRegistry.getValidatorsByOperator(address,uint256,uint256)._pageNumber (PermissionlessNodeRegistry.sol#2789) is not in mixedCase



    
2789         uint256 _pageNumber,



```

```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._addr (PermissionlessNodeRegistry.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.PERMISSIONED_NODE_REGISTRY() (PermissionlessNodeRegistry.sol#48) is not in mixedCase



    
48     function PERMISSIONED_NODE_REGISTRY() external view returns (bytes32);



```

```
Parameter PermissionlessNodeRegistry.onlyActiveOperator(address)._operAddr (PermissionlessNodeRegistry.sol#2941) is not in mixedCase



    
2941     function onlyActiveOperator(address _operAddr) internal view returns (uint256 _operatorId) {



```

```
Function IStaderConfig.PERMISSIONLESS_SOCIALIZING_POOL() (PermissionlessNodeRegistry.sol#54) is not in mixedCase



    
54     function PERMISSIONLESS_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._validatorId (PermissionlessNodeRegistry.sol#511) is not in mixedCase



    
511         uint256 _validatorId,



```

```
Function IStaderConfig.VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() (PermissionlessNodeRegistry.sol#58) is not in mixedCase



    
58     function VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._staderConfig (PermissionlessNodeRegistry.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.POOL_SELECTOR() (PermissionlessNodeRegistry.sol#22) is not in mixedCase



    
22     function POOL_SELECTOR() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._poolId (PermissionlessNodeRegistry.sol#535) is not in mixedCase



    
535         uint8 _poolId,



```

```
Parameter PermissionlessNodeRegistry.getOperatorTotalKeys(uint256)._operatorId (PermissionlessNodeRegistry.sol#2693) is not in mixedCase



    
2693     function getOperatorTotalKeys(uint256 _operatorId) public view override returns (uint256 _totalKeys) {



```

```
Function IStaderConfig.ETHX_SUPPLY_POR_FEED() (PermissionlessNodeRegistry.sol#63) is not in mixedCase



    
63     function ETHX_SUPPLY_POR_FEED() external view returns (bytes32);



```

```
Parameter PermissionlessNodeRegistry.updateOperatorDetails(string,address)._rewardAddress (PermissionlessNodeRegistry.sol#2627) is not in mixedCase



    
2627     function updateOperatorDetails(string calldata _operatorName, address payable _rewardAddress) external override {



```

```
Function IStaderConfig.POOL_UTILS() (PermissionlessNodeRegistry.sol#20) is not in mixedCase



    
20     function POOL_UTILS() external view returns (bytes32);



```

```
Function AccessControlUpgradeable.__AccessControl_init_unchained() (PermissionlessNodeRegistry.sol#1998-1999) is not in mixedCase



    
1998     function __AccessControl_init_unchained() internal onlyInitializing {
1999     }



```

```
Parameter PermissionlessNodeRegistry.markValidatorReadyToDeposit(bytes[],bytes[],bytes[])._invalidSignaturePubkey (PermissionlessNodeRegistry.sol#2447) is not in mixedCase



    
2447         bytes[] calldata _invalidSignaturePubkey



```

```
Parameter PermissionlessNodeRegistry.increaseTotalActiveValidatorCount(uint256)._count (PermissionlessNodeRegistry.sol#2642) is not in mixedCase



    
2642     function increaseTotalActiveValidatorCount(uint256 _count) external override {



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._operatorId (PermissionlessNodeRegistry.sol#536) is not in mixedCase



    
536         uint256 _operatorId,



```

```
Function IStaderConfig.OPERATOR_REWARD_COLLECTOR() (PermissionlessNodeRegistry.sol#26) is not in mixedCase



    
26     function OPERATOR_REWARD_COLLECTOR() external view returns (bytes32);



```

```
Parameter PermissionlessNodeRegistry.updateNextQueuedValidatorIndex(uint256)._nextQueuedValidatorIndex (PermissionlessNodeRegistry.sol#2529) is not in mixedCase



    
2529     function updateNextQueuedValidatorIndex(uint256 _nextQueuedValidatorIndex) external {



```

```
Variable ContextUpgradeable.__gap (PermissionlessNodeRegistry.sol#1286) is not in mixedCase



    
1286     uint256[50] private __gap;



```

```
Parameter PermissionlessNodeRegistry.decreaseTotalActiveValidatorCount(uint256)._count (PermissionlessNodeRegistry.sol#2967) is not in mixedCase



    
2967     function decreaseTotalActiveValidatorCount(uint256 _count) internal {



```

```
Parameter PermissionlessNodeRegistry.updateMaxNonTerminalKeyPerOperator(uint64)._maxNonTerminalKeyPerOperator (PermissionlessNodeRegistry.sol#2597) is not in mixedCase



    
2597     function updateMaxNonTerminalKeyPerOperator(uint64 _maxNonTerminalKeyPerOperator) external override {



```

```
Parameter PermissionlessNodeRegistry.checkInputKeysCountAndCollateral(uint256,uint256,uint256,uint256)._pubkeyLength (PermissionlessNodeRegistry.sol#2905) is not in mixedCase



    
2905         uint256 _pubkeyLength,



```

```
Parameter PermissionlessNodeRegistry.isExistingOperator(address)._operAddr (PermissionlessNodeRegistry.sol#2855) is not in mixedCase



    
2855     function isExistingOperator(address _operAddr) external view override returns (bool) {



```

```
Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained() (PermissionlessNodeRegistry.sol#2245-2247) is not in mixedCase



    
2245     function __ReentrancyGuard_init_unchained() internal onlyInitializing {
2246         _status = _NOT_ENTERED;
2247     }



```

```
Variable AccessControlUpgradeable.__gap (PermissionlessNodeRegistry.sol#2203) is not in mixedCase



    
2203     uint256[49] private __gap;



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._staderConfig (PermissionlessNodeRegistry.sol#537) is not in mixedCase



    
537         IStaderConfig _staderConfig



```

```
Function IPermissionlessNodeRegistry.FRONT_RUN_PENALTY() (PermissionlessNodeRegistry.sol#814) is not in mixedCase



    
814     function FRONT_RUN_PENALTY() external view returns (uint256);



```

```
Parameter UtilLib.sendValue(address,uint256)._amount (PermissionlessNodeRegistry.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Parameter PermissionlessNodeRegistry.markKeyReadyToDeposit(uint256)._validatorId (PermissionlessNodeRegistry.sol#2879) is not in mixedCase



    
2879     function markKeyReadyToDeposit(uint256 _validatorId) internal {



```

```
Parameter PermissionlessNodeRegistry.getOperatorTotalNonTerminalKeys(address,uint256,uint256)._endIndex (PermissionlessNodeRegistry.sol#2667) is not in mixedCase



    
2667         uint256 _endIndex



```

```
Parameter PermissionlessNodeRegistry.getOperatorTotalNonTerminalKeys(address,uint256,uint256)._startIndex (PermissionlessNodeRegistry.sol#2666) is not in mixedCase



    
2666         uint256 _startIndex,



```

```
Parameter PermissionlessNodeRegistry.getSocializingPoolStateChangeBlock(uint256)._operatorId (PermissionlessNodeRegistry.sol#2577) is not in mixedCase



    
2577     function getSocializingPoolStateChangeBlock(uint256 _operatorId) external view returns (uint256) {



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (PermissionlessNodeRegistry.sol#494) is not in mixedCase



    
494         uint256 _validatorId,



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._validatorId (PermissionlessNodeRegistry.sol#524) is not in mixedCase



    
524         uint256 _validatorId,



```

```
Function IStaderConfig.STADER_ORACLE() (PermissionlessNodeRegistry.sol#30) is not in mixedCase



    
30     function STADER_ORACLE() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (PermissionlessNodeRegistry.sol#496) is not in mixedCase



    
496         IStaderConfig _staderConfig



```

```
Parameter PermissionlessNodeRegistry.markValidatorDeposited(uint256)._validatorId (PermissionlessNodeRegistry.sol#2978) is not in mixedCase



    
2978     function markValidatorDeposited(uint256 _validatorId) internal {



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._addr (PermissionlessNodeRegistry.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Parameter PermissionlessNodeRegistry.getNodeELVaultAddressForOptOutOperators(uint256,uint256)._pageNumber (PermissionlessNodeRegistry.sol#2820) is not in mixedCase



    
2820     function getNodeELVaultAddressForOptOutOperators(uint256 _pageNumber, uint256 _pageSize)



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._staderConfig (PermissionlessNodeRegistry.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.AUCTION_CONTRACT() (PermissionlessNodeRegistry.sol#32) is not in mixedCase



    
32     function AUCTION_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (PermissionlessNodeRegistry.sol#478) is not in mixedCase



    
478         uint256 _validatorId,



```

```
Parameter PermissionlessNodeRegistry.addValidatorKeys(bytes[],bytes[],bytes[])._depositSignature (PermissionlessNodeRegistry.sol#2389) is not in mixedCase



    
2389         bytes[] calldata _depositSignature



```

```
Parameter PermissionlessNodeRegistry.isActiveValidator(uint256)._validatorId (PermissionlessNodeRegistry.sol#2962) is not in mixedCase



    
2962     function isActiveValidator(uint256 _validatorId) internal view returns (bool) {



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._staderConfig (PermissionlessNodeRegistry.sol#468) is not in mixedCase



    
468         IStaderConfig _staderConfig,



```

```
Variable PausableUpgradeable.__gap (PermissionlessNodeRegistry.sol#1396) is not in mixedCase



    
1396     uint256[49] private __gap;



```

```
Parameter PermissionlessNodeRegistry.getValidatorsByOperator(address,uint256,uint256)._operator (PermissionlessNodeRegistry.sol#2788) is not in mixedCase



    
2788         address _operator,



```

```
Function IStaderConfig.USER_WITHDRAW_MANAGER() (PermissionlessNodeRegistry.sol#44) is not in mixedCase



    
44     function USER_WITHDRAW_MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.NODE_EL_REWARD_VAULT_IMPLEMENTATION() (PermissionlessNodeRegistry.sol#56) is not in mixedCase



    
56     function NODE_EL_REWARD_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._staderConfig (PermissionlessNodeRegistry.sol#513) is not in mixedCase



    
513         IStaderConfig _staderConfig



```

```
Function IStaderConfig.VAULT_FACTORY() (PermissionlessNodeRegistry.sol#28) is not in mixedCase



    
28     function VAULT_FACTORY() external view returns (bytes32);



```

```
Function IStaderConfig.STAKE_POOL_MANAGER() (PermissionlessNodeRegistry.sol#38) is not in mixedCase



    
38     function STAKE_POOL_MANAGER() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._poolId (PermissionlessNodeRegistry.sol#493) is not in mixedCase



    
493         uint8 _poolId,



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._contractName (PermissionlessNodeRegistry.sol#469) is not in mixedCase



    
469         bytes32 _contractName



```

```
Parameter PermissionlessNodeRegistry.isNonTerminalValidator(uint256)._validatorId (PermissionlessNodeRegistry.sol#2952) is not in mixedCase



    
2952     function isNonTerminalValidator(uint256 _validatorId) internal view returns (bool) {



```

```
Function IStaderConfig.OPERATOR() (PermissionlessNodeRegistry.sol#68) is not in mixedCase



    
68     function OPERATOR() external view returns (bytes32);



```

```
Parameter PermissionlessNodeRegistry.updateInputKeyCountLimit(uint16)._inputKeyCountLimit (PermissionlessNodeRegistry.sol#2586) is not in mixedCase



    
2586     function updateInputKeyCountLimit(uint16 _inputKeyCountLimit) external override {



```

```
Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init() (PermissionlessNodeRegistry.sol#2241-2243) is not in mixedCase



    
2241     function __ReentrancyGuard_init() internal onlyInitializing {
2242         __ReentrancyGuard_init_unchained();
2243     }



```

```
Parameter PermissionlessNodeRegistry.onboardNodeOperator(bool,string,address)._optInForSocializingPool (PermissionlessNodeRegistry.sol#2351) is not in mixedCase



    
2351         bool _optInForSocializingPool,



```

```
Function ERC165Upgradeable.__ERC165_init_unchained() (PermissionlessNodeRegistry.sol#1939-1940) is not in mixedCase



    
1939     function __ERC165_init_unchained() internal onlyInitializing {
1940     }



```

```
Parameter PermissionlessNodeRegistry.onboardOperator(bool,string,address)._optInForSocializingPool (PermissionlessNodeRegistry.sol#2860) is not in mixedCase



    
2860         bool _optInForSocializingPool,



```

```
Function ContextUpgradeable.__Context_init_unchained() (PermissionlessNodeRegistry.sol#1271-1272) is not in mixedCase



    
1271     function __Context_init_unchained() internal onlyInitializing {
1272     }



```

```
Function IStaderConfig.PERMISSIONED_POOL() (PermissionlessNodeRegistry.sol#36) is not in mixedCase



    
36     function PERMISSIONED_POOL() external view returns (bytes32);



```

```
Function INodeRegistry.POOL_ID() (PermissionlessNodeRegistry.sol#302) is not in mixedCase



    
302     function POOL_ID() external view returns (uint8);



```

```
Parameter PermissionlessNodeRegistry.checkInputKeysCountAndCollateral(uint256,uint256,uint256,uint256)._operatorId (PermissionlessNodeRegistry.sol#2908) is not in mixedCase



    
2908         uint256 _operatorId



```

```
Parameter UtilLib.sendValue(address,uint256)._receiver (PermissionlessNodeRegistry.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Parameter PermissionlessNodeRegistry.handleFrontRun(uint256)._validatorId (PermissionlessNodeRegistry.sol#2886) is not in mixedCase



    
2886     function handleFrontRun(uint256 _validatorId) internal {



```

```
Parameter PermissionlessNodeRegistry.isExistingPubkey(bytes)._pubkey (PermissionlessNodeRegistry.sol#2850) is not in mixedCase



    
2850     function isExistingPubkey(bytes calldata _pubkey) external view override returns (bool) {



```

```
Parameter PermissionlessNodeRegistry.markValidatorReadyToDeposit(bytes[],bytes[],bytes[])._frontRunPubkey (PermissionlessNodeRegistry.sol#2446) is not in mixedCase



    
2446         bytes[] calldata _frontRunPubkey,



```

```
Function IStaderConfig.PERMISSIONLESS_POOL() (PermissionlessNodeRegistry.sol#42) is not in mixedCase



    
42     function PERMISSIONLESS_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._addr (PermissionlessNodeRegistry.sol#479) is not in mixedCase



    
479         address _addr,



```

```
Parameter PermissionlessNodeRegistry.markValidatorReadyToDeposit(bytes[],bytes[],bytes[])._readyToDepositPubkey (PermissionlessNodeRegistry.sol#2445) is not in mixedCase



    
2445         bytes[] calldata _readyToDepositPubkey,



```

```
Parameter PermissionlessNodeRegistry.checkInputKeysCountAndCollateral(uint256,uint256,uint256,uint256)._preDepositSignatureLength (PermissionlessNodeRegistry.sol#2906) is not in mixedCase



    
2906         uint256 _preDepositSignatureLength,



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (PermissionlessNodeRegistry.sol#480) is not in mixedCase



    
480         IStaderConfig _staderConfig



```

```
Parameter PermissionlessNodeRegistry.getNodeELVaultAddressForOptOutOperators(uint256,uint256)._pageSize (PermissionlessNodeRegistry.sol#2820) is not in mixedCase



    
2820     function getNodeELVaultAddressForOptOutOperators(uint256 _pageNumber, uint256 _pageSize)



```

```
Variable ReentrancyGuardUpgradeable.__gap (PermissionlessNodeRegistry.sol#2281) is not in mixedCase



    
2281     uint256[49] private __gap;



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._staderConfig (PermissionlessNodeRegistry.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._staderConfig (PermissionlessNodeRegistry.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.SD_COLLATERAL() (PermissionlessNodeRegistry.sol#24) is not in mixedCase



    
24     function SD_COLLATERAL() external view returns (bytes32);



```

```
Parameter PermissionlessNodeRegistry.addValidatorKeys(bytes[],bytes[],bytes[])._preDepositSignature (PermissionlessNodeRegistry.sol#2388) is not in mixedCase



    
2388         bytes[] calldata _preDepositSignature,



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._pubkey (PermissionlessNodeRegistry.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Parameter PermissionlessNodeRegistry.onlyInitializedValidator(uint256)._validatorId (PermissionlessNodeRegistry.sol#2972) is not in mixedCase



    
2972     function onlyInitializedValidator(uint256 _validatorId) internal view {



```

```
Function AccessControlUpgradeable.__AccessControl_init() (PermissionlessNodeRegistry.sol#1995-1996) is not in mixedCase



    
1995     function __AccessControl_init() internal onlyInitializing {
1996     }



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._addr (PermissionlessNodeRegistry.sol#495) is not in mixedCase



    
495         address _addr,



```

```
Parameter UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig)._staderConfig (PermissionlessNodeRegistry.sol#585) is not in mixedCase



    
585         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._addr (PermissionlessNodeRegistry.sol#467) is not in mixedCase



    
467         address _addr,



```

```
Parameter PermissionlessNodeRegistry.onboardNodeOperator(bool,string,address)._operatorRewardAddress (PermissionlessNodeRegistry.sol#2353) is not in mixedCase



    
2353         address payable _operatorRewardAddress



```

```
Parameter PermissionlessNodeRegistry.getOperatorRewardAddress(uint256)._operatorId (PermissionlessNodeRegistry.sol#2721) is not in mixedCase



    
2721     function getOperatorRewardAddress(uint256 _operatorId) external view override returns (address payable) {



```

```
Parameter PermissionlessNodeRegistry.onboardNodeOperator(bool,string,address)._operatorName (PermissionlessNodeRegistry.sol#2352) is not in mixedCase



    
2352         string calldata _operatorName,



```

```
Parameter PermissionlessNodeRegistry.updateStaderConfig(address)._staderConfig (PermissionlessNodeRegistry.sol#2615) is not in mixedCase



    
2615     function updateStaderConfig(address _staderConfig) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Function IStaderConfig.PERMISSIONED_SOCIALIZING_POOL() (PermissionlessNodeRegistry.sol#52) is not in mixedCase



    
52     function PERMISSIONED_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Function IStaderConfig.PENALTY_CONTRACT() (PermissionlessNodeRegistry.sol#34) is not in mixedCase



    
34     function PENALTY_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._poolId (PermissionlessNodeRegistry.sol#477) is not in mixedCase



    
477         uint8 _poolId,



```

```
Variable ERC165Upgradeable.__gap (PermissionlessNodeRegistry.sol#1953) is not in mixedCase



    
1953     uint256[50] private __gap;



```

```
Parameter PermissionlessNodeRegistry.initialize(address,address)._admin (PermissionlessNodeRegistry.sol#2327) is not in mixedCase



    
2327     function initialize(address _admin, address _staderConfig) public initializer {



```

```
Parameter PermissionlessNodeRegistry.handleInvalidSignature(uint256)._validatorId (PermissionlessNodeRegistry.sol#2894) is not in mixedCase



    
2894     function handleInvalidSignature(uint256 _validatorId) internal {



```

```
Parameter PermissionlessNodeRegistry.updateOperatorDetails(string,address)._operatorName (PermissionlessNodeRegistry.sol#2627) is not in mixedCase



    
2627     function updateOperatorDetails(string calldata _operatorName, address payable _rewardAddress) external override {



```

```
Function IStaderConfig.ETH_DEPOSIT_CONTRACT() (PermissionlessNodeRegistry.sol#40) is not in mixedCase



    
40     function ETH_DEPOSIT_CONTRACT() external view returns (bytes32);



```

```
Parameter PermissionlessNodeRegistry.updateVerifiedKeysBatchSize(uint256)._verifiedKeysBatchSize (PermissionlessNodeRegistry.sol#2608) is not in mixedCase



    
2608     function updateVerifiedKeysBatchSize(uint256 _verifiedKeysBatchSize) external {



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._operator (PermissionlessNodeRegistry.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.ETH_BALANCE_POR_FEED() (PermissionlessNodeRegistry.sol#61) is not in mixedCase



    
61     function ETH_BALANCE_POR_FEED() external view returns (bytes32);



```

```
Parameter PermissionlessNodeRegistry.initialize(address,address)._staderConfig (PermissionlessNodeRegistry.sol#2327) is not in mixedCase



    
2327     function initialize(address _admin, address _staderConfig) public initializer {



```

```
Parameter PermissionlessNodeRegistry.withdrawnValidators(bytes[])._pubkeys (PermissionlessNodeRegistry.sol#2502) is not in mixedCase



    
2502     function withdrawnValidators(bytes[] calldata _pubkeys) external override {



```

```
Parameter PermissionlessNodeRegistry.transferCollateralToPool(uint256)._amount (PermissionlessNodeRegistry.sol#2653) is not in mixedCase



    
2653     function transferCollateralToPool(uint256 _amount) external override nonReentrant {



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._poolId (PermissionlessNodeRegistry.sol#510) is not in mixedCase



    
510         uint8 _poolId,



```

```
Parameter PermissionlessNodeRegistry.addValidatorKeys(bytes[],bytes[],bytes[])._pubkey (PermissionlessNodeRegistry.sol#2387) is not in mixedCase



    
2387         bytes[] calldata _pubkey,



```

```
Parameter UtilLib.getPubkeyRoot(bytes)._pubkey (PermissionlessNodeRegistry.sol#561) is not in mixedCase



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {



```

```
Function IVaultFactory.NODE_REGISTRY_CONTRACT() (PermissionlessNodeRegistry.sol#608) is not in mixedCase



    
608     function NODE_REGISTRY_CONTRACT() external view returns (bytes32);



```

```
Parameter PermissionlessNodeRegistry.getOperatorTotalNonTerminalKeys(address,uint256,uint256)._nodeOperator (PermissionlessNodeRegistry.sol#2665) is not in mixedCase



    
2665         address _nodeOperator,



```

```
Parameter PermissionlessNodeRegistry.changeSocializingPoolState(bool)._optInForSocializingPool (PermissionlessNodeRegistry.sol#2548) is not in mixedCase



    
2548     function changeSocializingPoolState(bool _optInForSocializingPool)



```

```
Parameter PermissionlessNodeRegistry.checkInputKeysCountAndCollateral(uint256,uint256,uint256,uint256)._depositSignatureLength (PermissionlessNodeRegistry.sol#2907) is not in mixedCase



    
2907         uint256 _depositSignatureLength,



```

```
Parameter PermissionlessNodeRegistry.updateDepositStatusAndBlock(uint256)._validatorId (PermissionlessNodeRegistry.sol#2540) is not in mixedCase



    
2540     function updateDepositStatusAndBlock(uint256 _validatorId) external override {



```

```
Function PausableUpgradeable.__Pausable_init() (PermissionlessNodeRegistry.sol#1314-1316) is not in mixedCase



    
1314     function __Pausable_init() internal onlyInitializing {
1315         __Pausable_init_unchained();
1316     }



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._poolId (PermissionlessNodeRegistry.sol#523) is not in mixedCase



    
523         uint8 _poolId,



```

```
Function IStaderConfig.MANAGER() (PermissionlessNodeRegistry.sol#66) is not in mixedCase



    
66     function MANAGER() external view returns (bytes32);



```

```
Parameter PermissionlessNodeRegistry.onboardOperator(bool,string,address)._operatorRewardAddress (PermissionlessNodeRegistry.sol#2862) is not in mixedCase



    
2862         address payable _operatorRewardAddress



```

```
Function IStaderConfig.STADER_INSURANCE_FUND() (PermissionlessNodeRegistry.sol#46) is not in mixedCase



    
46     function STADER_INSURANCE_FUND() external view returns (bytes32);



```

```
Parameter PermissionlessNodeRegistry.getValidatorsByOperator(address,uint256,uint256)._pageSize (PermissionlessNodeRegistry.sol#2790) is not in mixedCase



    
2790         uint256 _pageSize



```

```
Function ContextUpgradeable.__Context_init() (PermissionlessNodeRegistry.sol#1268-1269) is not in mixedCase



    
1268     function __Context_init() internal onlyInitializing {
1269     }



```

```
Function IStaderConfig.PERMISSIONLESS_NODE_REGISTRY() (PermissionlessNodeRegistry.sol#50) is not in mixedCase



    
50     function PERMISSIONLESS_NODE_REGISTRY() external view returns (bytes32);



```

```
Parameter PermissionlessNodeRegistry.onboardOperator(bool,string,address)._operatorName (PermissionlessNodeRegistry.sol#2861) is not in mixedCase



    
2861         string calldata _operatorName,



```

```
Function ERC165Upgradeable.__ERC165_init() (PermissionlessNodeRegistry.sol#1936-1937) is not in mixedCase



    
1936     function __ERC165_init() internal onlyInitializing {
1937     }



```

```
Parameter PermissionlessNodeRegistry.getAllActiveValidators(uint256,uint256)._pageSize (PermissionlessNodeRegistry.sol#2751) is not in mixedCase



    
2751     function getAllActiveValidators(uint256 _pageNumber, uint256 _pageSize)



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._staderConfig (PermissionlessNodeRegistry.sol#525) is not in mixedCase



    
525         IStaderConfig _staderConfig



```

```
Parameter UtilLib.checkNonZeroAddress(address)._address (PermissionlessNodeRegistry.sol#448) is not in mixedCase



    
448     function checkNonZeroAddress(address _address) internal pure {



```

```
Parameter PermissionlessNodeRegistry.getAllActiveValidators(uint256,uint256)._pageNumber (PermissionlessNodeRegistry.sol#2751) is not in mixedCase



    
2751     function getAllActiveValidators(uint256 _pageNumber, uint256 _pageSize)



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._addr (PermissionlessNodeRegistry.sol#512) is not in mixedCase



    
512         address _addr,



```

```
Function PausableUpgradeable.__Pausable_init_unchained() (PermissionlessNodeRegistry.sol#1318-1320) is not in mixedCase



    
1318     function __Pausable_init_unchained() internal onlyInitializing {
1319         _paused = false;
1320     }



```

### PermissionlessPool.sol


```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._addr (PermissionlessPool.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.PERMISSIONED_NODE_REGISTRY() (PermissionlessPool.sol#48) is not in mixedCase



    
48     function PERMISSIONED_NODE_REGISTRY() external view returns (bytes32);



```

```
Function IStaderConfig.PERMISSIONLESS_SOCIALIZING_POOL() (PermissionlessPool.sol#54) is not in mixedCase



    
54     function PERMISSIONLESS_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._validatorId (PermissionlessPool.sol#511) is not in mixedCase



    
511         uint256 _validatorId,



```

```
Function IStaderConfig.VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() (PermissionlessPool.sol#58) is not in mixedCase



    
58     function VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._staderConfig (PermissionlessPool.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.POOL_SELECTOR() (PermissionlessPool.sol#22) is not in mixedCase



    
22     function POOL_SELECTOR() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._poolId (PermissionlessPool.sol#535) is not in mixedCase



    
535         uint8 _poolId,



```

```
Parameter PermissionlessPool.initialize(address,address)._staderConfig (PermissionlessPool.sol#2381) is not in mixedCase



    
2381     function initialize(address _admin, address _staderConfig) public initializer {



```

```
Parameter PermissionlessPool.setCommissionFees(uint256,uint256)._operatorFee (PermissionlessPool.sol#2409) is not in mixedCase



    
2409     function setCommissionFees(uint256 _protocolFee, uint256 _operatorFee) external {



```

```
Function IStaderConfig.ETHX_SUPPLY_POR_FEED() (PermissionlessPool.sol#63) is not in mixedCase



    
63     function ETHX_SUPPLY_POR_FEED() external view returns (bytes32);



```

```
Function IStaderConfig.POOL_UTILS() (PermissionlessPool.sol#20) is not in mixedCase



    
20     function POOL_UTILS() external view returns (bytes32);



```

```
Function AccessControlUpgradeable.__AccessControl_init_unchained() (PermissionlessPool.sol#2076-2077) is not in mixedCase



    
2076     function __AccessControl_init_unchained() internal onlyInitializing {
2077     }



```

```
Parameter PermissionlessPool.getOperatorTotalNonTerminalKeys(address,uint256,uint256)._startIndex (PermissionlessPool.sol#2523) is not in mixedCase



    
2523         uint256 _startIndex,



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._operatorId (PermissionlessPool.sol#536) is not in mixedCase



    
536         uint256 _operatorId,



```

```
Function IStaderConfig.OPERATOR_REWARD_COLLECTOR() (PermissionlessPool.sol#26) is not in mixedCase



    
26     function OPERATOR_REWARD_COLLECTOR() external view returns (bytes32);



```

```
Variable ContextUpgradeable.__gap (PermissionlessPool.sol#1562) is not in mixedCase



    
1562     uint256[50] private __gap;



```

```
Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained() (PermissionlessPool.sol#2323-2325) is not in mixedCase



    
2323     function __ReentrancyGuard_init_unchained() internal onlyInitializing {
2324         _status = _NOT_ENTERED;
2325     }



```

```
Variable AccessControlUpgradeable.__gap (PermissionlessPool.sol#2281) is not in mixedCase



    
2281     uint256[49] private __gap;



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._staderConfig (PermissionlessPool.sol#537) is not in mixedCase



    
537         IStaderConfig _staderConfig



```

```
Function IPermissionlessNodeRegistry.FRONT_RUN_PENALTY() (PermissionlessPool.sol#793) is not in mixedCase



    
793     function FRONT_RUN_PENALTY() external view returns (uint256);



```

```
Parameter PermissionlessPool.initialize(address,address)._admin (PermissionlessPool.sol#2381) is not in mixedCase



    
2381     function initialize(address _admin, address _staderConfig) public initializer {



```

```
Parameter UtilLib.sendValue(address,uint256)._amount (PermissionlessPool.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (PermissionlessPool.sol#494) is not in mixedCase



    
494         uint256 _validatorId,



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._validatorId (PermissionlessPool.sol#524) is not in mixedCase



    
524         uint256 _validatorId,



```

```
Function IStaderConfig.STADER_ORACLE() (PermissionlessPool.sol#30) is not in mixedCase



    
30     function STADER_ORACLE() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (PermissionlessPool.sol#496) is not in mixedCase



    
496         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._addr (PermissionlessPool.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Parameter PermissionlessPool.to_little_endian_64(uint256)._depositAmount (PermissionlessPool.sol#2616) is not in mixedCase



    
2616     function to_little_endian_64(uint256 _depositAmount) internal pure returns (bytes memory ret) {



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._staderConfig (PermissionlessPool.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.AUCTION_CONTRACT() (PermissionlessPool.sol#32) is not in mixedCase



    
32     function AUCTION_CONTRACT() external view returns (bytes32);



```

```
Parameter PermissionlessPool.fullDepositOnBeaconChain(address,address,address,uint256,uint256)._nodeRegistryAddress (PermissionlessPool.sol#2585) is not in mixedCase



    
2585         address _nodeRegistryAddress,



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (PermissionlessPool.sol#478) is not in mixedCase



    
478         uint256 _validatorId,



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._staderConfig (PermissionlessPool.sol#468) is not in mixedCase



    
468         IStaderConfig _staderConfig,



```

```
Parameter PermissionlessPool.computeDepositDataRoot(bytes,bytes,bytes,uint256)._depositAmount (PermissionlessPool.sol#2565) is not in mixedCase



    
2565         uint256 _depositAmount



```

```
Parameter PermissionlessPool.fullDepositOnBeaconChain(address,address,address,uint256,uint256)._validatorId (PermissionlessPool.sol#2588) is not in mixedCase



    
2588         uint256 _validatorId,



```

```
Function IStaderConfig.USER_WITHDRAW_MANAGER() (PermissionlessPool.sol#44) is not in mixedCase



    
44     function USER_WITHDRAW_MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.NODE_EL_REWARD_VAULT_IMPLEMENTATION() (PermissionlessPool.sol#56) is not in mixedCase



    
56     function NODE_EL_REWARD_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._staderConfig (PermissionlessPool.sol#513) is not in mixedCase



    
513         IStaderConfig _staderConfig



```

```
Function IStaderConfig.VAULT_FACTORY() (PermissionlessPool.sol#28) is not in mixedCase



    
28     function VAULT_FACTORY() external view returns (bytes32);



```

```
Function IStaderConfig.STAKE_POOL_MANAGER() (PermissionlessPool.sol#38) is not in mixedCase



    
38     function STAKE_POOL_MANAGER() external view returns (bytes32);



```

```
Function IDepositContract.get_deposit_root() (PermissionlessPool.sol#704) is not in mixedCase



    
704     function get_deposit_root() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._poolId (PermissionlessPool.sol#493) is not in mixedCase



    
493         uint8 _poolId,



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._contractName (PermissionlessPool.sol#469) is not in mixedCase



    
469         bytes32 _contractName



```

```
Function IStaderConfig.OPERATOR() (PermissionlessPool.sol#68) is not in mixedCase



    
68     function OPERATOR() external view returns (bytes32);



```

```
Parameter PermissionlessPool.preDepositOnBeaconChain(bytes[],bytes[],uint256,uint256)._operatorTotalKeys (PermissionlessPool.sol#2432) is not in mixedCase



    
2432         uint256 _operatorTotalKeys



```

```
Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init() (PermissionlessPool.sol#2319-2321) is not in mixedCase



    
2319     function __ReentrancyGuard_init() internal onlyInitializing {
2320         __ReentrancyGuard_init_unchained();
2321     }



```

```
Function ERC165Upgradeable.__ERC165_init_unchained() (PermissionlessPool.sol#2017-2018) is not in mixedCase



    
2017     function __ERC165_init_unchained() internal onlyInitializing {
2018     }



```

```
Function ContextUpgradeable.__Context_init_unchained() (PermissionlessPool.sol#1547-1548) is not in mixedCase



    
1547     function __Context_init_unchained() internal onlyInitializing {
1548     }



```

```
Function IStaderConfig.PERMISSIONED_POOL() (PermissionlessPool.sol#36) is not in mixedCase



    
36     function PERMISSIONED_POOL() external view returns (bytes32);



```

```
Function INodeRegistry.POOL_ID() (PermissionlessPool.sol#302) is not in mixedCase



    
302     function POOL_ID() external view returns (uint8);



```

```
Parameter UtilLib.sendValue(address,uint256)._receiver (PermissionlessPool.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Function IStaderConfig.PERMISSIONLESS_POOL() (PermissionlessPool.sol#42) is not in mixedCase



    
42     function PERMISSIONLESS_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._addr (PermissionlessPool.sol#479) is not in mixedCase



    
479         address _addr,



```

```
Parameter PermissionlessPool.getOperatorTotalNonTerminalKeys(address,uint256,uint256)._endIndex (PermissionlessPool.sol#2524) is not in mixedCase



    
2524         uint256 _endIndex



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (PermissionlessPool.sol#480) is not in mixedCase



    
480         IStaderConfig _staderConfig



```

```
Variable ReentrancyGuardUpgradeable.__gap (PermissionlessPool.sol#2359) is not in mixedCase



    
2359     uint256[49] private __gap;



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._staderConfig (PermissionlessPool.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._staderConfig (PermissionlessPool.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.SD_COLLATERAL() (PermissionlessPool.sol#24) is not in mixedCase



    
24     function SD_COLLATERAL() external view returns (bytes32);



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._pubkey (PermissionlessPool.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function AccessControlUpgradeable.__AccessControl_init() (PermissionlessPool.sol#2073-2074) is not in mixedCase



    
2073     function __AccessControl_init() internal onlyInitializing {
2074     }



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._addr (PermissionlessPool.sol#495) is not in mixedCase



    
495         address _addr,



```

```
Parameter UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig)._staderConfig (PermissionlessPool.sol#585) is not in mixedCase



    
585         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._addr (PermissionlessPool.sol#467) is not in mixedCase



    
467         address _addr,



```

```
Parameter PermissionlessPool.computeDepositDataRoot(bytes,bytes,bytes,uint256)._withdrawCredential (PermissionlessPool.sol#2564) is not in mixedCase



    
2564         bytes calldata _withdrawCredential,



```

```
Parameter PermissionlessPool.getOperatorTotalNonTerminalKeys(address,uint256,uint256)._nodeOperator (PermissionlessPool.sol#2522) is not in mixedCase



    
2522         address _nodeOperator,



```

```
Parameter PermissionlessPool.computeDepositDataRoot(bytes,bytes,bytes,uint256)._signature (PermissionlessPool.sol#2563) is not in mixedCase



    
2563         bytes calldata _signature,



```

```
Parameter PermissionlessPool.isExistingPubkey(bytes)._pubkey (PermissionlessPool.sol#2543) is not in mixedCase



    
2543     function isExistingPubkey(bytes calldata _pubkey) external view override returns (bool) {



```

```
Function IStaderConfig.PERMISSIONED_SOCIALIZING_POOL() (PermissionlessPool.sol#52) is not in mixedCase



    
52     function PERMISSIONED_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Function IStaderConfig.PENALTY_CONTRACT() (PermissionlessPool.sol#34) is not in mixedCase



    
34     function PENALTY_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._poolId (PermissionlessPool.sol#477) is not in mixedCase



    
477         uint8 _poolId,



```

```
Variable ERC165Upgradeable.__gap (PermissionlessPool.sol#2031) is not in mixedCase



    
2031     uint256[50] private __gap;



```

```
Parameter IDepositContract.deposit(bytes,bytes,bytes,bytes32).deposit_data_root (PermissionlessPool.sol#699) is not in mixedCase



    
699         bytes32 deposit_data_root



```

```
Function IStaderConfig.ETH_DEPOSIT_CONTRACT() (PermissionlessPool.sol#40) is not in mixedCase



    
40     function ETH_DEPOSIT_CONTRACT() external view returns (bytes32);



```

```
Parameter PermissionlessPool.preDepositOnBeaconChain(bytes[],bytes[],uint256,uint256)._operatorId (PermissionlessPool.sol#2431) is not in mixedCase



    
2431         uint256 _operatorId,



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._operator (PermissionlessPool.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Parameter PermissionlessPool.isExistingOperator(address)._operAddr (PermissionlessPool.sol#2548) is not in mixedCase



    
2548     function isExistingOperator(address _operAddr) external view override returns (bool) {



```

```
Parameter PermissionlessPool.fullDepositOnBeaconChain(address,address,address,uint256,uint256)._vaultFactoryAddress (PermissionlessPool.sol#2586) is not in mixedCase



    
2586         address _vaultFactoryAddress,



```

```
Function IDepositContract.get_deposit_count() (PermissionlessPool.sol#708) is not in mixedCase



    
708     function get_deposit_count() external view returns (bytes memory);



```

```
Function IStaderConfig.ETH_BALANCE_POR_FEED() (PermissionlessPool.sol#61) is not in mixedCase



    
61     function ETH_BALANCE_POR_FEED() external view returns (bytes32);



```

```
Parameter PermissionlessPool.computeDepositDataRoot(bytes,bytes,bytes,uint256)._pubkey (PermissionlessPool.sol#2562) is not in mixedCase



    
2562         bytes calldata _pubkey,



```

```
Parameter PermissionlessPool.preDepositOnBeaconChain(bytes[],bytes[],uint256,uint256)._pubkey (PermissionlessPool.sol#2429) is not in mixedCase



    
2429         bytes[] calldata _pubkey,



```

```
Function PermissionlessPool.to_little_endian_64(uint256) (PermissionlessPool.sol#2616-2630) is not in mixedCase



    
2616     function to_little_endian_64(uint256 _depositAmount) internal pure returns (bytes memory ret) {
2617         uint64 value = uint64(_depositAmount / 1 gwei);
2618 
2619         ret = new bytes(8);
2620         bytes8 bytesValue = bytes8(value);
2621         // Byteswapping during copying to bytes.
2622         ret[0] = bytesValue[7];
2623         ret[1] = bytesValue[6];
2624         ret[2] = bytesValue[5];
2625         ret[3] = bytesValue[4];
2626         ret[4] = bytesValue[3];
2627         ret[5] = bytesValue[2];
2628         ret[6] = bytesValue[1];
2629         ret[7] = bytesValue[0];
2630     }



```

```
Parameter PermissionlessPool.preDepositOnBeaconChain(bytes[],bytes[],uint256,uint256)._preDepositSignature (PermissionlessPool.sol#2430) is not in mixedCase



    
2430         bytes[] calldata _preDepositSignature,



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._poolId (PermissionlessPool.sol#510) is not in mixedCase



    
510         uint8 _poolId,



```

```
Parameter UtilLib.getPubkeyRoot(bytes)._pubkey (PermissionlessPool.sol#561) is not in mixedCase



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {



```

```
Function IVaultFactory.NODE_REGISTRY_CONTRACT() (PermissionlessPool.sol#608) is not in mixedCase



    
608     function NODE_REGISTRY_CONTRACT() external view returns (bytes32);



```

```
Parameter PermissionlessPool.fullDepositOnBeaconChain(address,address,address,uint256,uint256)._DEPOSIT_SIZE (PermissionlessPool.sol#2589) is not in mixedCase



    
2589         uint256 _DEPOSIT_SIZE



```

```
Parameter PermissionlessPool.updateStaderConfig(address)._staderConfig (PermissionlessPool.sol#2553) is not in mixedCase



    
2553     function updateStaderConfig(address _staderConfig) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._poolId (PermissionlessPool.sol#523) is not in mixedCase



    
523         uint8 _poolId,



```

```
Parameter PermissionlessPool.fullDepositOnBeaconChain(address,address,address,uint256,uint256)._ethDepositContract (PermissionlessPool.sol#2587) is not in mixedCase



    
2587         address _ethDepositContract,



```

```
Function IStaderConfig.MANAGER() (PermissionlessPool.sol#66) is not in mixedCase



    
66     function MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.STADER_INSURANCE_FUND() (PermissionlessPool.sol#46) is not in mixedCase



    
46     function STADER_INSURANCE_FUND() external view returns (bytes32);



```

```
Function ContextUpgradeable.__Context_init() (PermissionlessPool.sol#1544-1545) is not in mixedCase



    
1544     function __Context_init() internal onlyInitializing {
1545     }



```

```
Function IStaderConfig.PERMISSIONLESS_NODE_REGISTRY() (PermissionlessPool.sol#50) is not in mixedCase



    
50     function PERMISSIONLESS_NODE_REGISTRY() external view returns (bytes32);



```

```
Parameter PermissionlessPool.setCommissionFees(uint256,uint256)._protocolFee (PermissionlessPool.sol#2409) is not in mixedCase



    
2409     function setCommissionFees(uint256 _protocolFee, uint256 _operatorFee) external {



```

```
Function ERC165Upgradeable.__ERC165_init() (PermissionlessPool.sol#2014-2015) is not in mixedCase



    
2014     function __ERC165_init() internal onlyInitializing {
2015     }



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._staderConfig (PermissionlessPool.sol#525) is not in mixedCase



    
525         IStaderConfig _staderConfig



```

```
Parameter UtilLib.checkNonZeroAddress(address)._address (PermissionlessPool.sol#448) is not in mixedCase



    
448     function checkNonZeroAddress(address _address) internal pure {



```

```
Parameter IDepositContract.deposit(bytes,bytes,bytes,bytes32).withdrawal_credentials (PermissionlessPool.sol#697) is not in mixedCase



    
697         bytes calldata withdrawal_credentials,



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._addr (PermissionlessPool.sol#512) is not in mixedCase



    
512         address _addr,



```

### PoolSelector.sol


```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._addr (PoolSelector.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.PERMISSIONED_NODE_REGISTRY() (PoolSelector.sol#48) is not in mixedCase



    
48     function PERMISSIONED_NODE_REGISTRY() external view returns (bytes32);



```

```
Parameter PoolSelector.poolAllocationForExcessETHDeposit(uint256)._excessETHAmount (PoolSelector.sol#2354) is not in mixedCase



    
2354     function poolAllocationForExcessETHDeposit(uint256 _excessETHAmount)



```

```
Function IStaderConfig.PERMISSIONLESS_SOCIALIZING_POOL() (PoolSelector.sol#54) is not in mixedCase



    
54     function PERMISSIONLESS_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._validatorId (PoolSelector.sol#511) is not in mixedCase



    
511         uint256 _validatorId,



```

```
Function IStaderConfig.VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() (PoolSelector.sol#58) is not in mixedCase



    
58     function VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._staderConfig (PoolSelector.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.POOL_SELECTOR() (PoolSelector.sol#22) is not in mixedCase



    
22     function POOL_SELECTOR() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._poolId (PoolSelector.sol#535) is not in mixedCase



    
535         uint8 _poolId,



```

```
Function IStaderConfig.ETHX_SUPPLY_POR_FEED() (PoolSelector.sol#63) is not in mixedCase



    
63     function ETHX_SUPPLY_POR_FEED() external view returns (bytes32);



```

```
Function IStaderConfig.POOL_UTILS() (PoolSelector.sol#20) is not in mixedCase



    
20     function POOL_UTILS() external view returns (bytes32);



```

```
Parameter PoolSelector.computePoolAllocationForDeposit(uint8,uint256)._newValidatorToRegister (PoolSelector.sol#2328) is not in mixedCase



    
2328     function computePoolAllocationForDeposit(uint8 _poolId, uint256 _newValidatorToRegister)



```

```
Function AccessControlUpgradeable.__AccessControl_init_unchained() (PoolSelector.sol#2084-2085) is not in mixedCase



    
2084     function __AccessControl_init_unchained() internal onlyInitializing {
2085     }



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._operatorId (PoolSelector.sol#536) is not in mixedCase



    
536         uint256 _operatorId,



```

```
Function IStaderConfig.OPERATOR_REWARD_COLLECTOR() (PoolSelector.sol#26) is not in mixedCase



    
26     function OPERATOR_REWARD_COLLECTOR() external view returns (bytes32);



```

```
Variable ContextUpgradeable.__gap (PoolSelector.sol#1570) is not in mixedCase



    
1570     uint256[50] private __gap;



```

```
Variable AccessControlUpgradeable.__gap (PoolSelector.sol#2289) is not in mixedCase



    
2289     uint256[49] private __gap;



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._staderConfig (PoolSelector.sol#537) is not in mixedCase



    
537         IStaderConfig _staderConfig



```

```
Parameter PoolSelector.updatePoolAllocationMaxSize(uint16)._poolAllocationMaxSize (PoolSelector.sol#2418) is not in mixedCase



    
2418     function updatePoolAllocationMaxSize(uint16 _poolAllocationMaxSize) external {



```

```
Parameter UtilLib.sendValue(address,uint256)._amount (PoolSelector.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Parameter PoolSelector.updateStaderConfig(address)._staderConfig (PoolSelector.sol#2425) is not in mixedCase



    
2425     function updateStaderConfig(address _staderConfig) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (PoolSelector.sol#494) is not in mixedCase



    
494         uint256 _validatorId,



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._validatorId (PoolSelector.sol#524) is not in mixedCase



    
524         uint256 _validatorId,



```

```
Function IStaderConfig.STADER_ORACLE() (PoolSelector.sol#30) is not in mixedCase



    
30     function STADER_ORACLE() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (PoolSelector.sol#496) is not in mixedCase



    
496         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._addr (PoolSelector.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._staderConfig (PoolSelector.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.AUCTION_CONTRACT() (PoolSelector.sol#32) is not in mixedCase



    
32     function AUCTION_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (PoolSelector.sol#478) is not in mixedCase



    
478         uint256 _validatorId,



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._staderConfig (PoolSelector.sol#468) is not in mixedCase



    
468         IStaderConfig _staderConfig,



```

```
Function IStaderConfig.USER_WITHDRAW_MANAGER() (PoolSelector.sol#44) is not in mixedCase



    
44     function USER_WITHDRAW_MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.NODE_EL_REWARD_VAULT_IMPLEMENTATION() (PoolSelector.sol#56) is not in mixedCase



    
56     function NODE_EL_REWARD_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._staderConfig (PoolSelector.sol#513) is not in mixedCase



    
513         IStaderConfig _staderConfig



```

```
Function IStaderConfig.VAULT_FACTORY() (PoolSelector.sol#28) is not in mixedCase



    
28     function VAULT_FACTORY() external view returns (bytes32);



```

```
Function IStaderConfig.STAKE_POOL_MANAGER() (PoolSelector.sol#38) is not in mixedCase



    
38     function STAKE_POOL_MANAGER() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._poolId (PoolSelector.sol#493) is not in mixedCase



    
493         uint8 _poolId,



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._contractName (PoolSelector.sol#469) is not in mixedCase



    
469         bytes32 _contractName



```

```
Function IStaderConfig.OPERATOR() (PoolSelector.sol#68) is not in mixedCase



    
68     function OPERATOR() external view returns (bytes32);



```

```
Parameter PoolSelector.computePoolAllocationForDeposit(uint8,uint256)._poolId (PoolSelector.sol#2328) is not in mixedCase



    
2328     function computePoolAllocationForDeposit(uint8 _poolId, uint256 _newValidatorToRegister)



```

```
Parameter PoolSelector.updatePoolWeights(uint256[])._poolTargets (PoolSelector.sol#2397) is not in mixedCase



    
2397     function updatePoolWeights(uint256[] calldata _poolTargets) external {



```

```
Function ERC165Upgradeable.__ERC165_init_unchained() (PoolSelector.sol#2025-2026) is not in mixedCase



    
2025     function __ERC165_init_unchained() internal onlyInitializing {
2026     }



```

```
Function ContextUpgradeable.__Context_init_unchained() (PoolSelector.sol#1555-1556) is not in mixedCase



    
1555     function __Context_init_unchained() internal onlyInitializing {
1556     }



```

```
Parameter PoolSelector.initialize(address,address)._staderConfig (PoolSelector.sol#2314) is not in mixedCase



    
2314     function initialize(address _admin, address _staderConfig) external initializer {



```

```
Function IStaderConfig.PERMISSIONED_POOL() (PoolSelector.sol#36) is not in mixedCase



    
36     function PERMISSIONED_POOL() external view returns (bytes32);



```

```
Function INodeRegistry.POOL_ID() (PoolSelector.sol#302) is not in mixedCase



    
302     function POOL_ID() external view returns (uint8);



```

```
Parameter UtilLib.sendValue(address,uint256)._receiver (PoolSelector.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Function IStaderConfig.PERMISSIONLESS_POOL() (PoolSelector.sol#42) is not in mixedCase



    
42     function PERMISSIONLESS_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._addr (PoolSelector.sol#479) is not in mixedCase



    
479         address _addr,



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (PoolSelector.sol#480) is not in mixedCase



    
480         IStaderConfig _staderConfig



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._staderConfig (PoolSelector.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._staderConfig (PoolSelector.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Parameter PoolSelector.initialize(address,address)._admin (PoolSelector.sol#2314) is not in mixedCase



    
2314     function initialize(address _admin, address _staderConfig) external initializer {



```

```
Function IStaderConfig.SD_COLLATERAL() (PoolSelector.sol#24) is not in mixedCase



    
24     function SD_COLLATERAL() external view returns (bytes32);



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._pubkey (PoolSelector.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function AccessControlUpgradeable.__AccessControl_init() (PoolSelector.sol#2081-2082) is not in mixedCase



    
2081     function __AccessControl_init() internal onlyInitializing {
2082     }



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._addr (PoolSelector.sol#495) is not in mixedCase



    
495         address _addr,



```

```
Parameter UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig)._staderConfig (PoolSelector.sol#585) is not in mixedCase



    
585         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._addr (PoolSelector.sol#467) is not in mixedCase



    
467         address _addr,



```

```
Function IStaderConfig.PERMISSIONED_SOCIALIZING_POOL() (PoolSelector.sol#52) is not in mixedCase



    
52     function PERMISSIONED_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Function IStaderConfig.PENALTY_CONTRACT() (PoolSelector.sol#34) is not in mixedCase



    
34     function PENALTY_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._poolId (PoolSelector.sol#477) is not in mixedCase



    
477         uint8 _poolId,



```

```
Variable ERC165Upgradeable.__gap (PoolSelector.sol#2039) is not in mixedCase



    
2039     uint256[50] private __gap;



```

```
Function IStaderConfig.ETH_DEPOSIT_CONTRACT() (PoolSelector.sol#40) is not in mixedCase



    
40     function ETH_DEPOSIT_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._operator (PoolSelector.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.ETH_BALANCE_POR_FEED() (PoolSelector.sol#61) is not in mixedCase



    
61     function ETH_BALANCE_POR_FEED() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._poolId (PoolSelector.sol#510) is not in mixedCase



    
510         uint8 _poolId,



```

```
Parameter UtilLib.getPubkeyRoot(bytes)._pubkey (PoolSelector.sol#561) is not in mixedCase



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._poolId (PoolSelector.sol#523) is not in mixedCase



    
523         uint8 _poolId,



```

```
Function IStaderConfig.MANAGER() (PoolSelector.sol#66) is not in mixedCase



    
66     function MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.STADER_INSURANCE_FUND() (PoolSelector.sol#46) is not in mixedCase



    
46     function STADER_INSURANCE_FUND() external view returns (bytes32);



```

```
Function ContextUpgradeable.__Context_init() (PoolSelector.sol#1552-1553) is not in mixedCase



    
1552     function __Context_init() internal onlyInitializing {
1553     }



```

```
Function IStaderConfig.PERMISSIONLESS_NODE_REGISTRY() (PoolSelector.sol#50) is not in mixedCase



    
50     function PERMISSIONLESS_NODE_REGISTRY() external view returns (bytes32);



```

```
Function ERC165Upgradeable.__ERC165_init() (PoolSelector.sol#2022-2023) is not in mixedCase



    
2022     function __ERC165_init() internal onlyInitializing {
2023     }



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._staderConfig (PoolSelector.sol#525) is not in mixedCase



    
525         IStaderConfig _staderConfig



```

```
Parameter UtilLib.checkNonZeroAddress(address)._address (PoolSelector.sol#448) is not in mixedCase



    
448     function checkNonZeroAddress(address _address) internal pure {



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._addr (PoolSelector.sol#512) is not in mixedCase



    
512         address _addr,



```

### PoolUtils.sol


```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._addr (PoolUtils.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.PERMISSIONED_NODE_REGISTRY() (PoolUtils.sol#48) is not in mixedCase



    
48     function PERMISSIONED_NODE_REGISTRY() external view returns (bytes32);



```

```
Function IStaderConfig.PERMISSIONLESS_SOCIALIZING_POOL() (PoolUtils.sol#54) is not in mixedCase



    
54     function PERMISSIONLESS_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._validatorId (PoolUtils.sol#511) is not in mixedCase



    
511         uint256 _validatorId,



```

```
Parameter PoolUtils.updatePoolAddress(uint8,address)._poolId (PoolUtils.sol#1912) is not in mixedCase



    
1912     function updatePoolAddress(uint8 _poolId, address _newPoolAddress)



```

```
Function IStaderConfig.VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() (PoolUtils.sol#58) is not in mixedCase



    
58     function VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter PoolUtils.addNewPool(uint8,address)._poolAddress (PoolUtils.sol#1897) is not in mixedCase



    
1897     function addNewPool(uint8 _poolId, address _poolAddress) external override {



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._staderConfig (PoolUtils.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.POOL_SELECTOR() (PoolUtils.sol#22) is not in mixedCase



    
22     function POOL_SELECTOR() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._poolId (PoolUtils.sol#535) is not in mixedCase



    
535         uint8 _poolId,



```

```
Parameter PoolUtils.getOperatorPoolId(address)._operAddr (PoolUtils.sol#2045) is not in mixedCase



    
2045     function getOperatorPoolId(address _operAddr) external view override returns (uint8) {



```

```
Function IStaderConfig.ETHX_SUPPLY_POR_FEED() (PoolUtils.sol#63) is not in mixedCase



    
63     function ETHX_SUPPLY_POR_FEED() external view returns (bytes32);



```

```
Parameter PoolUtils.onlyValidKeys(bytes,bytes,bytes)._pubkey (PoolUtils.sol#2083) is not in mixedCase



    
2083         bytes calldata _pubkey,



```

```
Function IStaderConfig.POOL_UTILS() (PoolUtils.sol#20) is not in mixedCase



    
20     function POOL_UTILS() external view returns (bytes32);



```

```
Function AccessControlUpgradeable.__AccessControl_init_unchained() (PoolUtils.sol#1661-1662) is not in mixedCase



    
1661     function __AccessControl_init_unchained() internal onlyInitializing {
1662     }



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._operatorId (PoolUtils.sol#536) is not in mixedCase



    
536         uint256 _operatorId,



```

```
Function IStaderConfig.OPERATOR_REWARD_COLLECTOR() (PoolUtils.sol#26) is not in mixedCase



    
26     function OPERATOR_REWARD_COLLECTOR() external view returns (bytes32);



```

```
Parameter PoolUtils.calculateRewardShare(uint8,uint256)._totalRewards (PoolUtils.sol#2102) is not in mixedCase



    
2102     function calculateRewardShare(uint8 _poolId, uint256 _totalRewards)



```

```
Variable ContextUpgradeable.__gap (PoolUtils.sol#1147) is not in mixedCase



    
1147     uint256[50] private __gap;



```

```
Parameter PoolUtils.getOperatorTotalNonTerminalKeys(uint8,address,uint256,uint256)._startIndex (PoolUtils.sol#2007) is not in mixedCase



    
2007         uint256 _startIndex,



```

```
Variable AccessControlUpgradeable.__gap (PoolUtils.sol#1866) is not in mixedCase



    
1866     uint256[49] private __gap;



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._staderConfig (PoolUtils.sol#537) is not in mixedCase



    
537         IStaderConfig _staderConfig



```

```
Parameter UtilLib.sendValue(address,uint256)._amount (PoolUtils.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Parameter PoolUtils.processValidatorExitList(bytes[])._pubkeys (PoolUtils.sol#1929) is not in mixedCase



    
1929     function processValidatorExitList(bytes[] calldata _pubkeys) external override {



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (PoolUtils.sol#494) is not in mixedCase



    
494         uint256 _validatorId,



```

```
Parameter PoolUtils.updateStaderConfig(address)._staderConfig (PoolUtils.sol#1941) is not in mixedCase



    
1941     function updateStaderConfig(address _staderConfig) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._validatorId (PoolUtils.sol#524) is not in mixedCase



    
524         uint256 _validatorId,



```

```
Function IStaderConfig.STADER_ORACLE() (PoolUtils.sol#30) is not in mixedCase



    
30     function STADER_ORACLE() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (PoolUtils.sol#496) is not in mixedCase



    
496         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._addr (PoolUtils.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Parameter PoolUtils.onlyValidName(string)._name (PoolUtils.sol#2072) is not in mixedCase



    
2072     function onlyValidName(string calldata _name) external view {



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._staderConfig (PoolUtils.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.AUCTION_CONTRACT() (PoolUtils.sol#32) is not in mixedCase



    
32     function AUCTION_CONTRACT() external view returns (bytes32);



```

```
Parameter PoolUtils.getNodeRegistry(uint8)._poolId (PoolUtils.sol#2019) is not in mixedCase



    
2019     function getNodeRegistry(uint8 _poolId) public view override onlyExistingPoolId(_poolId) returns (address) {



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (PoolUtils.sol#478) is not in mixedCase



    
478         uint256 _validatorId,



```

```
Parameter PoolUtils.addNewPool(uint8,address)._poolId (PoolUtils.sol#1897) is not in mixedCase



    
1897     function addNewPool(uint8 _poolId, address _poolAddress) external override {



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._staderConfig (PoolUtils.sol#468) is not in mixedCase



    
468         IStaderConfig _staderConfig,



```

```
Function IStaderConfig.USER_WITHDRAW_MANAGER() (PoolUtils.sol#44) is not in mixedCase



    
44     function USER_WITHDRAW_MANAGER() external view returns (bytes32);



```

```
Parameter PoolUtils.getSocializingPoolAddress(uint8)._poolId (PoolUtils.sol#1993) is not in mixedCase



    
1993     function getSocializingPoolAddress(uint8 _poolId)



```

```
Function IStaderConfig.NODE_EL_REWARD_VAULT_IMPLEMENTATION() (PoolUtils.sol#56) is not in mixedCase



    
56     function NODE_EL_REWARD_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._staderConfig (PoolUtils.sol#513) is not in mixedCase



    
513         IStaderConfig _staderConfig



```

```
Function IStaderConfig.VAULT_FACTORY() (PoolUtils.sol#28) is not in mixedCase



    
28     function VAULT_FACTORY() external view returns (bytes32);



```

```
Function IStaderConfig.STAKE_POOL_MANAGER() (PoolUtils.sol#38) is not in mixedCase



    
38     function STAKE_POOL_MANAGER() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._poolId (PoolUtils.sol#493) is not in mixedCase



    
493         uint8 _poolId,



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._contractName (PoolUtils.sol#469) is not in mixedCase



    
469         bytes32 _contractName



```

```
Parameter PoolUtils.isExistingOperator(address)._operAddr (PoolUtils.sol#2034) is not in mixedCase



    
2034     function isExistingOperator(address _operAddr) external view override returns (bool) {



```

```
Function IStaderConfig.OPERATOR() (PoolUtils.sol#68) is not in mixedCase



    
68     function OPERATOR() external view returns (bytes32);



```

```
Parameter PoolUtils.getOperatorTotalNonTerminalKeys(uint8,address,uint256,uint256)._endIndex (PoolUtils.sol#2008) is not in mixedCase



    
2008         uint256 _endIndex



```

```
Parameter PoolUtils.getActiveValidatorCountByPool(uint8)._poolId (PoolUtils.sol#1981) is not in mixedCase



    
1981     function getActiveValidatorCountByPool(uint8 _poolId)



```

```
Function ERC165Upgradeable.__ERC165_init_unchained() (PoolUtils.sol#1602-1603) is not in mixedCase



    
1602     function __ERC165_init_unchained() internal onlyInitializing {
1603     }



```

```
Function ContextUpgradeable.__Context_init_unchained() (PoolUtils.sol#1132-1133) is not in mixedCase



    
1132     function __Context_init_unchained() internal onlyInitializing {
1133     }



```

```
Function IStaderConfig.PERMISSIONED_POOL() (PoolUtils.sol#36) is not in mixedCase



    
36     function PERMISSIONED_POOL() external view returns (bytes32);



```

```
Function INodeRegistry.POOL_ID() (PoolUtils.sol#302) is not in mixedCase



    
302     function POOL_ID() external view returns (uint8);



```

```
Parameter PoolUtils.initialize(address,address)._staderConfig (PoolUtils.sol#1882) is not in mixedCase



    
1882     function initialize(address _admin, address _staderConfig) public initializer {



```

```
Parameter UtilLib.sendValue(address,uint256)._receiver (PoolUtils.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Parameter PoolUtils.getOperatorTotalNonTerminalKeys(uint8,address,uint256,uint256)._nodeOperator (PoolUtils.sol#2006) is not in mixedCase



    
2006         address _nodeOperator,



```

```
Parameter PoolUtils.onlyValidKeys(bytes,bytes,bytes)._depositSignature (PoolUtils.sol#2085) is not in mixedCase



    
2085         bytes calldata _depositSignature



```

```
Function IStaderConfig.PERMISSIONLESS_POOL() (PoolUtils.sol#42) is not in mixedCase



    
42     function PERMISSIONLESS_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._addr (PoolUtils.sol#479) is not in mixedCase



    
479         address _addr,



```

```
Parameter PoolUtils.getQueuedValidatorCountByPool(uint8)._poolId (PoolUtils.sol#1969) is not in mixedCase



    
1969     function getQueuedValidatorCountByPool(uint8 _poolId)



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (PoolUtils.sol#480) is not in mixedCase



    
480         IStaderConfig _staderConfig



```

```
Parameter PoolUtils.getValidatorPoolId(bytes)._pubkey (PoolUtils.sol#2056) is not in mixedCase



    
2056     function getValidatorPoolId(bytes calldata _pubkey) external view override returns (uint8) {



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._staderConfig (PoolUtils.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._staderConfig (PoolUtils.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.SD_COLLATERAL() (PoolUtils.sol#24) is not in mixedCase



    
24     function SD_COLLATERAL() external view returns (bytes32);



```

```
Parameter PoolUtils.verifyNewPool(uint8,address)._poolId (PoolUtils.sol#2138) is not in mixedCase



    
2138     function verifyNewPool(uint8 _poolId, address _poolAddress) internal view {



```

```
Parameter PoolUtils.getProtocolFee(uint8)._poolId (PoolUtils.sol#1948) is not in mixedCase



    
1948     function getProtocolFee(uint8 _poolId) public view override onlyExistingPoolId(_poolId) returns (uint256) {



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._pubkey (PoolUtils.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function AccessControlUpgradeable.__AccessControl_init() (PoolUtils.sol#1658-1659) is not in mixedCase



    
1658     function __AccessControl_init() internal onlyInitializing {
1659     }



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._addr (PoolUtils.sol#495) is not in mixedCase



    
495         address _addr,



```

```
Parameter UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig)._staderConfig (PoolUtils.sol#585) is not in mixedCase



    
585         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._addr (PoolUtils.sol#467) is not in mixedCase



    
467         address _addr,



```

```
Parameter PoolUtils.onlyValidKeys(bytes,bytes,bytes)._preDepositSignature (PoolUtils.sol#2084) is not in mixedCase



    
2084         bytes calldata _preDepositSignature,



```

```
Parameter PoolUtils.isExistingPubkey(bytes)._pubkey (PoolUtils.sol#2023) is not in mixedCase



    
2023     function isExistingPubkey(bytes calldata _pubkey) public view override returns (bool) {



```

```
Parameter PoolUtils.calculateRewardShare(uint8,uint256)._poolId (PoolUtils.sol#2102) is not in mixedCase



    
2102     function calculateRewardShare(uint8 _poolId, uint256 _totalRewards)



```

```
Function IStaderConfig.PERMISSIONED_SOCIALIZING_POOL() (PoolUtils.sol#52) is not in mixedCase



    
52     function PERMISSIONED_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Function IStaderConfig.PENALTY_CONTRACT() (PoolUtils.sol#34) is not in mixedCase



    
34     function PENALTY_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._poolId (PoolUtils.sol#477) is not in mixedCase



    
477         uint8 _poolId,



```

```
Variable ERC165Upgradeable.__gap (PoolUtils.sol#1616) is not in mixedCase



    
1616     uint256[50] private __gap;



```

```
Parameter PoolUtils.getOperatorFee(uint8)._poolId (PoolUtils.sol#1953) is not in mixedCase



    
1953     function getOperatorFee(uint8 _poolId) public view override onlyExistingPoolId(_poolId) returns (uint256) {



```

```
Parameter PoolUtils.getOperatorTotalNonTerminalKeys(uint8,address,uint256,uint256)._poolId (PoolUtils.sol#2005) is not in mixedCase



    
2005         uint8 _poolId,



```

```
Function IStaderConfig.ETH_DEPOSIT_CONTRACT() (PoolUtils.sol#40) is not in mixedCase



    
40     function ETH_DEPOSIT_CONTRACT() external view returns (bytes32);



```

```
Parameter PoolUtils.isExistingPoolId(uint8)._poolId (PoolUtils.sol#2128) is not in mixedCase



    
2128     function isExistingPoolId(uint8 _poolId) public view override returns (bool) {



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._operator (PoolUtils.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Parameter PoolUtils.initialize(address,address)._admin (PoolUtils.sol#1882) is not in mixedCase



    
1882     function initialize(address _admin, address _staderConfig) public initializer {



```

```
Parameter PoolUtils.updatePoolAddress(uint8,address)._newPoolAddress (PoolUtils.sol#1912) is not in mixedCase



    
1912     function updatePoolAddress(uint8 _poolId, address _newPoolAddress)



```

```
Parameter PoolUtils.verifyNewPool(uint8,address)._poolAddress (PoolUtils.sol#2138) is not in mixedCase



    
2138     function verifyNewPool(uint8 _poolId, address _poolAddress) internal view {



```

```
Function IStaderConfig.ETH_BALANCE_POR_FEED() (PoolUtils.sol#61) is not in mixedCase



    
61     function ETH_BALANCE_POR_FEED() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._poolId (PoolUtils.sol#510) is not in mixedCase



    
510         uint8 _poolId,



```

```
Parameter UtilLib.getPubkeyRoot(bytes)._pubkey (PoolUtils.sol#561) is not in mixedCase



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._poolId (PoolUtils.sol#523) is not in mixedCase



    
523         uint8 _poolId,



```

```
Function IStaderConfig.MANAGER() (PoolUtils.sol#66) is not in mixedCase



    
66     function MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.STADER_INSURANCE_FUND() (PoolUtils.sol#46) is not in mixedCase



    
46     function STADER_INSURANCE_FUND() external view returns (bytes32);



```

```
Function ContextUpgradeable.__Context_init() (PoolUtils.sol#1129-1130) is not in mixedCase



    
1129     function __Context_init() internal onlyInitializing {
1130     }



```

```
Function IStaderConfig.PERMISSIONLESS_NODE_REGISTRY() (PoolUtils.sol#50) is not in mixedCase



    
50     function PERMISSIONLESS_NODE_REGISTRY() external view returns (bytes32);



```

```
Parameter PoolUtils.getCollateralETH(uint8)._poolId (PoolUtils.sol#2014) is not in mixedCase



    
2014     function getCollateralETH(uint8 _poolId) public view override onlyExistingPoolId(_poolId) returns (uint256) {



```

```
Function ERC165Upgradeable.__ERC165_init() (PoolUtils.sol#1599-1600) is not in mixedCase



    
1599     function __ERC165_init() internal onlyInitializing {
1600     }



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._staderConfig (PoolUtils.sol#525) is not in mixedCase



    
525         IStaderConfig _staderConfig



```

```
Parameter UtilLib.checkNonZeroAddress(address)._address (PoolUtils.sol#448) is not in mixedCase



    
448     function checkNonZeroAddress(address _address) internal pure {



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._addr (PoolUtils.sol#512) is not in mixedCase



    
512         address _addr,



```

### SDCollateral.sol


```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._addr (SDCollateral.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.PERMISSIONED_NODE_REGISTRY() (SDCollateral.sol#48) is not in mixedCase



    
48     function PERMISSIONED_NODE_REGISTRY() external view returns (bytes32);



```

```
Function IStaderConfig.PERMISSIONLESS_SOCIALIZING_POOL() (SDCollateral.sol#54) is not in mixedCase



    
54     function PERMISSIONLESS_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Parameter SDCollateral.updateStaderConfig(address)._staderConfig (SDCollateral.sol#2815) is not in mixedCase



    
2815     function updateStaderConfig(address _staderConfig) external override onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._validatorId (SDCollateral.sol#511) is not in mixedCase



    
511         uint256 _validatorId,



```

```
Parameter SDCollateral.updatePoolThreshold(uint8,uint256,uint256,uint256,string)._withdrawThreshold (SDCollateral.sol#2828) is not in mixedCase



    
2828         uint256 _withdrawThreshold,



```

```
Parameter SDCollateral.getMinimumSDToBond(uint8,uint256)._poolId (SDCollateral.sol#2871) is not in mixedCase



    
2871     function getMinimumSDToBond(uint8 _poolId, uint256 _numValidator)



```

```
Function IStaderConfig.VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() (SDCollateral.sol#58) is not in mixedCase



    
58     function VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._staderConfig (SDCollateral.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Parameter SDCollateral.updatePoolThreshold(uint8,uint256,uint256,uint256,string)._maxThreshold (SDCollateral.sol#2827) is not in mixedCase



    
2827         uint256 _maxThreshold,



```

```
Function IStaderConfig.POOL_SELECTOR() (SDCollateral.sol#22) is not in mixedCase



    
22     function POOL_SELECTOR() external view returns (bytes32);



```

```
Parameter SDCollateral.getOperatorInfo(address)._operator (SDCollateral.sol#2919) is not in mixedCase



    
2919     function getOperatorInfo(address _operator)



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._poolId (SDCollateral.sol#535) is not in mixedCase



    
535         uint8 _poolId,



```

```
Function IStaderConfig.ETHX_SUPPLY_POR_FEED() (SDCollateral.sol#63) is not in mixedCase



    
63     function ETHX_SUPPLY_POR_FEED() external view returns (bytes32);



```

```
Function IStaderConfig.POOL_UTILS() (SDCollateral.sol#20) is not in mixedCase



    
20     function POOL_UTILS() external view returns (bytes32);



```

```
Function AccessControlUpgradeable.__AccessControl_init_unchained() (SDCollateral.sol#2359-2360) is not in mixedCase



    
2359     function __AccessControl_init_unchained() internal onlyInitializing {
2360     }



```

```
Parameter SDCollateral.convertSDToETH(uint256)._sdAmount (SDCollateral.sol#2909) is not in mixedCase



    
2909     function convertSDToETH(uint256 _sdAmount) public view override returns (uint256) {



```

```
Parameter SDCollateral.getRemainingSDToBond(address,uint8,uint256)._numValidator (SDCollateral.sol#2890) is not in mixedCase



    
2890         uint256 _numValidator



```

```
Parameter SDCollateral.withdraw(uint256)._requestedSD (SDCollateral.sol#2766) is not in mixedCase



    
2766     function withdraw(uint256 _requestedSD) external override {



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._operatorId (SDCollateral.sol#536) is not in mixedCase



    
536         uint256 _operatorId,



```

```
Function IStaderConfig.OPERATOR_REWARD_COLLECTOR() (SDCollateral.sol#26) is not in mixedCase



    
26     function OPERATOR_REWARD_COLLECTOR() external view returns (bytes32);



```

```
Variable ContextUpgradeable.__gap (SDCollateral.sol#1845) is not in mixedCase



    
1845     uint256[50] private __gap;



```

```
Parameter SDCollateral.depositSDAsCollateral(uint256)._sdAmount (SDCollateral.sol#2752) is not in mixedCase



    
2752     function depositSDAsCollateral(uint256 _sdAmount) external override {



```

```
Parameter SDCollateral.hasEnoughSDCollateral(address,uint8,uint256)._operator (SDCollateral.sol#2861) is not in mixedCase



    
2861         address _operator,



```

```
Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained() (SDCollateral.sol#2606-2608) is not in mixedCase



    
2606     function __ReentrancyGuard_init_unchained() internal onlyInitializing {
2607         _status = _NOT_ENTERED;
2608     }



```

```
Parameter SDCollateral.slashValidatorSD(uint256,uint8)._poolId (SDCollateral.sol#2785) is not in mixedCase



    
2785     function slashValidatorSD(uint256 _validatorId, uint8 _poolId) external override nonReentrant {



```

```
Variable AccessControlUpgradeable.__gap (SDCollateral.sol#2564) is not in mixedCase



    
2564     uint256[49] private __gap;



```

```
Parameter SDCollateral.getRewardEligibleSD(address)._operator (SDCollateral.sol#2897) is not in mixedCase



    
2897     function getRewardEligibleSD(address _operator) external view override returns (uint256 _rewardEligibleSD) {



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._staderConfig (SDCollateral.sol#537) is not in mixedCase



    
537         IStaderConfig _staderConfig



```

```
Parameter SDCollateral.hasEnoughSDCollateral(address,uint8,uint256)._numValidator (SDCollateral.sol#2863) is not in mixedCase



    
2863         uint256 _numValidator



```

```
Parameter SDCollateral.convertETHToSD(uint256)._ethAmount (SDCollateral.sol#2913) is not in mixedCase



    
2913     function convertETHToSD(uint256 _ethAmount) public view override returns (uint256) {



```

```
Parameter UtilLib.sendValue(address,uint256)._amount (SDCollateral.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (SDCollateral.sol#494) is not in mixedCase



    
494         uint256 _validatorId,



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._validatorId (SDCollateral.sol#524) is not in mixedCase



    
524         uint256 _validatorId,



```

```
Function IStaderConfig.STADER_ORACLE() (SDCollateral.sol#30) is not in mixedCase



    
30     function STADER_ORACLE() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (SDCollateral.sol#496) is not in mixedCase



    
496         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._addr (SDCollateral.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._staderConfig (SDCollateral.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.AUCTION_CONTRACT() (SDCollateral.sol#32) is not in mixedCase



    
32     function AUCTION_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (SDCollateral.sol#478) is not in mixedCase



    
478         uint256 _validatorId,



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._staderConfig (SDCollateral.sol#468) is not in mixedCase



    
468         IStaderConfig _staderConfig,



```

```
Function IStaderConfig.USER_WITHDRAW_MANAGER() (SDCollateral.sol#44) is not in mixedCase



    
44     function USER_WITHDRAW_MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.NODE_EL_REWARD_VAULT_IMPLEMENTATION() (SDCollateral.sol#56) is not in mixedCase



    
56     function NODE_EL_REWARD_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._staderConfig (SDCollateral.sol#513) is not in mixedCase



    
513         IStaderConfig _staderConfig



```

```
Function IStaderConfig.VAULT_FACTORY() (SDCollateral.sol#28) is not in mixedCase



    
28     function VAULT_FACTORY() external view returns (bytes32);



```

```
Function IStaderConfig.STAKE_POOL_MANAGER() (SDCollateral.sol#38) is not in mixedCase



    
38     function STAKE_POOL_MANAGER() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._poolId (SDCollateral.sol#493) is not in mixedCase



    
493         uint8 _poolId,



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._contractName (SDCollateral.sol#469) is not in mixedCase



    
469         bytes32 _contractName



```

```
Function IStaderConfig.OPERATOR() (SDCollateral.sol#68) is not in mixedCase



    
68     function OPERATOR() external view returns (bytes32);



```

```
Parameter SDCollateral.getMinimumSDToBond(uint8,uint256)._numValidator (SDCollateral.sol#2871) is not in mixedCase



    
2871     function getMinimumSDToBond(uint8 _poolId, uint256 _numValidator)



```

```
Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init() (SDCollateral.sol#2602-2604) is not in mixedCase



    
2602     function __ReentrancyGuard_init() internal onlyInitializing {
2603         __ReentrancyGuard_init_unchained();
2604     }



```

```
Parameter SDCollateral.getOperatorWithdrawThreshold(address)._operator (SDCollateral.sol#2849) is not in mixedCase



    
2849     function getOperatorWithdrawThreshold(address _operator) public view returns (uint256 operatorWithdrawThreshold) {



```

```
Function ERC165Upgradeable.__ERC165_init_unchained() (SDCollateral.sol#2300-2301) is not in mixedCase



    
2300     function __ERC165_init_unchained() internal onlyInitializing {
2301     }



```

```
Function ContextUpgradeable.__Context_init_unchained() (SDCollateral.sol#1830-1831) is not in mixedCase



    
1830     function __Context_init_unchained() internal onlyInitializing {
1831     }



```

```
Function IStaderConfig.PERMISSIONED_POOL() (SDCollateral.sol#36) is not in mixedCase



    
36     function PERMISSIONED_POOL() external view returns (bytes32);



```

```
Function INodeRegistry.POOL_ID() (SDCollateral.sol#302) is not in mixedCase



    
302     function POOL_ID() external view returns (uint8);



```

```
Parameter UtilLib.sendValue(address,uint256)._receiver (SDCollateral.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Function IStaderConfig.PERMISSIONLESS_POOL() (SDCollateral.sol#42) is not in mixedCase



    
42     function PERMISSIONLESS_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._addr (SDCollateral.sol#479) is not in mixedCase



    
479         address _addr,



```

```
Parameter SDCollateral.initialize(address,address)._admin (SDCollateral.sol#2735) is not in mixedCase



    
2735     function initialize(address _admin, address _staderConfig) public initializer {



```

```
Parameter SDCollateral.getRemainingSDToBond(address,uint8,uint256)._operator (SDCollateral.sol#2888) is not in mixedCase



    
2888         address _operator,



```

```
Parameter SDCollateral.slashValidatorSD(uint256,uint8)._validatorId (SDCollateral.sol#2785) is not in mixedCase



    
2785     function slashValidatorSD(uint256 _validatorId, uint8 _poolId) external override nonReentrant {



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (SDCollateral.sol#480) is not in mixedCase



    
480         IStaderConfig _staderConfig



```

```
Variable ReentrancyGuardUpgradeable.__gap (SDCollateral.sol#2642) is not in mixedCase



    
2642     uint256[49] private __gap;



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._staderConfig (SDCollateral.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._staderConfig (SDCollateral.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.SD_COLLATERAL() (SDCollateral.sol#24) is not in mixedCase



    
24     function SD_COLLATERAL() external view returns (bytes32);



```

```
Parameter SDCollateral.updatePoolThreshold(uint8,uint256,uint256,uint256,string)._poolId (SDCollateral.sol#2825) is not in mixedCase



    
2825         uint8 _poolId,



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._pubkey (SDCollateral.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function AccessControlUpgradeable.__AccessControl_init() (SDCollateral.sol#2356-2357) is not in mixedCase



    
2356     function __AccessControl_init() internal onlyInitializing {
2357     }



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._addr (SDCollateral.sol#495) is not in mixedCase



    
495         address _addr,



```

```
Parameter UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig)._staderConfig (SDCollateral.sol#585) is not in mixedCase



    
585         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._addr (SDCollateral.sol#467) is not in mixedCase



    
467         address _addr,



```

```
Function IStaderConfig.PERMISSIONED_SOCIALIZING_POOL() (SDCollateral.sol#52) is not in mixedCase



    
52     function PERMISSIONED_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Function IStaderConfig.PENALTY_CONTRACT() (SDCollateral.sol#34) is not in mixedCase



    
34     function PENALTY_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._poolId (SDCollateral.sol#477) is not in mixedCase



    
477         uint8 _poolId,



```

```
Variable ERC165Upgradeable.__gap (SDCollateral.sol#2314) is not in mixedCase



    
2314     uint256[50] private __gap;



```

```
Parameter SDCollateral.hasEnoughSDCollateral(address,uint8,uint256)._poolId (SDCollateral.sol#2862) is not in mixedCase



    
2862         uint8 _poolId,



```

```
Function IStaderConfig.ETH_DEPOSIT_CONTRACT() (SDCollateral.sol#40) is not in mixedCase



    
40     function ETH_DEPOSIT_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._operator (SDCollateral.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Parameter SDCollateral.isPoolThresholdValid(uint8)._poolId (SDCollateral.sol#2940) is not in mixedCase



    
2940     function isPoolThresholdValid(uint8 _poolId) internal view {



```

```
Function IStaderConfig.ETH_BALANCE_POR_FEED() (SDCollateral.sol#61) is not in mixedCase



    
61     function ETH_BALANCE_POR_FEED() external view returns (bytes32);



```

```
Parameter SDCollateral.getRemainingSDToBond(address,uint8,uint256)._poolId (SDCollateral.sol#2889) is not in mixedCase



    
2889         uint8 _poolId,



```

```
Parameter SDCollateral.updatePoolThreshold(uint8,uint256,uint256,uint256,string)._units (SDCollateral.sol#2829) is not in mixedCase



    
2829         string memory _units



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._poolId (SDCollateral.sol#510) is not in mixedCase



    
510         uint8 _poolId,



```

```
Parameter UtilLib.getPubkeyRoot(bytes)._pubkey (SDCollateral.sol#561) is not in mixedCase



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {



```

```
Parameter SDCollateral.updatePoolThreshold(uint8,uint256,uint256,uint256,string)._minThreshold (SDCollateral.sol#2826) is not in mixedCase



    
2826         uint256 _minThreshold,



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._poolId (SDCollateral.sol#523) is not in mixedCase



    
523         uint8 _poolId,



```

```
Function IStaderConfig.MANAGER() (SDCollateral.sol#66) is not in mixedCase



    
66     function MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.STADER_INSURANCE_FUND() (SDCollateral.sol#46) is not in mixedCase



    
46     function STADER_INSURANCE_FUND() external view returns (bytes32);



```

```
Parameter SDCollateral.slashSD(address,uint256)._operator (SDCollateral.sol#2796) is not in mixedCase



    
2796     function slashSD(address _operator, uint256 _sdToSlash) internal {



```

```
Function ContextUpgradeable.__Context_init() (SDCollateral.sol#1827-1828) is not in mixedCase



    
1827     function __Context_init() internal onlyInitializing {
1828     }



```

```
Function IStaderConfig.PERMISSIONLESS_NODE_REGISTRY() (SDCollateral.sol#50) is not in mixedCase



    
50     function PERMISSIONLESS_NODE_REGISTRY() external view returns (bytes32);



```

```
Parameter SDCollateral.slashSD(address,uint256)._sdToSlash (SDCollateral.sol#2796) is not in mixedCase



    
2796     function slashSD(address _operator, uint256 _sdToSlash) internal {



```

```
Function ERC165Upgradeable.__ERC165_init() (SDCollateral.sol#2297-2298) is not in mixedCase



    
2297     function __ERC165_init() internal onlyInitializing {
2298     }



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._staderConfig (SDCollateral.sol#525) is not in mixedCase



    
525         IStaderConfig _staderConfig



```

```
Parameter UtilLib.checkNonZeroAddress(address)._address (SDCollateral.sol#448) is not in mixedCase



    
448     function checkNonZeroAddress(address _address) internal pure {



```

```
Parameter SDCollateral.initialize(address,address)._staderConfig (SDCollateral.sol#2735) is not in mixedCase



    
2735     function initialize(address _admin, address _staderConfig) public initializer {



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._addr (SDCollateral.sol#512) is not in mixedCase



    
512         address _addr,



```

### SocializingPool.sol


```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._addr (SocializingPool.sol#460) is not in mixedCase



    
460     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.PERMISSIONED_NODE_REGISTRY() (SocializingPool.sol#49) is not in mixedCase



    
49     function PERMISSIONED_NODE_REGISTRY() external view returns (bytes32);



```

```
Function IStaderConfig.PERMISSIONLESS_SOCIALIZING_POOL() (SocializingPool.sol#55) is not in mixedCase



    
55     function PERMISSIONLESS_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._validatorId (SocializingPool.sol#512) is not in mixedCase



    
512         uint256 _validatorId,



```

```
Function IStaderConfig.VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() (SocializingPool.sol#59) is not in mixedCase



    
59     function VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._staderConfig (SocializingPool.sol#454) is not in mixedCase



    
454     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.POOL_SELECTOR() (SocializingPool.sol#23) is not in mixedCase



    
23     function POOL_SELECTOR() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._poolId (SocializingPool.sol#536) is not in mixedCase



    
536         uint8 _poolId,



```

```
Function IStaderConfig.ETHX_SUPPLY_POR_FEED() (SocializingPool.sol#64) is not in mixedCase



    
64     function ETHX_SUPPLY_POR_FEED() external view returns (bytes32);



```

```
Function IStaderConfig.POOL_UTILS() (SocializingPool.sol#21) is not in mixedCase



    
21     function POOL_UTILS() external view returns (bytes32);



```

```
Function AccessControlUpgradeable.__AccessControl_init_unchained() (SocializingPool.sol#1840-1841) is not in mixedCase



    
1840     function __AccessControl_init_unchained() internal onlyInitializing {
1841     }



```

```
Parameter SocializingPool.verifyProof(uint256,address,uint256,uint256,bytes32[])._amountSD (SocializingPool.sol#2677) is not in mixedCase



    
2677         uint256 _amountSD,



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._operatorId (SocializingPool.sol#537) is not in mixedCase



    
537         uint256 _operatorId,



```

```
Function IStaderConfig.OPERATOR_REWARD_COLLECTOR() (SocializingPool.sol#27) is not in mixedCase



    
27     function OPERATOR_REWARD_COLLECTOR() external view returns (bytes32);



```

```
Variable ContextUpgradeable.__gap (SocializingPool.sol#1326) is not in mixedCase



    
1326     uint256[50] private __gap;



```

```
Parameter SocializingPool.verifyProof(uint256,address,uint256,uint256,bytes32[])._operator (SocializingPool.sol#2676) is not in mixedCase



    
2676         address _operator,



```

```
Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained() (SocializingPool.sol#2199-2201) is not in mixedCase



    
2199     function __ReentrancyGuard_init_unchained() internal onlyInitializing {
2200         _status = _NOT_ENTERED;
2201     }



```

```
Variable AccessControlUpgradeable.__gap (SocializingPool.sol#2045) is not in mixedCase



    
2045     uint256[49] private __gap;



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._staderConfig (SocializingPool.sol#538) is not in mixedCase



    
538         IStaderConfig _staderConfig



```

```
Function IPermissionlessNodeRegistry.FRONT_RUN_PENALTY() (SocializingPool.sol#781) is not in mixedCase



    
781     function FRONT_RUN_PENALTY() external view returns (uint256);



```

```
Parameter UtilLib.sendValue(address,uint256)._amount (SocializingPool.sol#595) is not in mixedCase



    
595     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Parameter SocializingPool.claim(uint256[],uint256[],uint256[],bytes32[][])._amountSD (SocializingPool.sol#2620) is not in mixedCase



    
2620         uint256[] calldata _amountSD,



```

```
Parameter SocializingPool.handleRewards(RewardsData)._rewardsData (SocializingPool.sol#2572) is not in mixedCase



    
2572     function handleRewards(RewardsData calldata _rewardsData) external override nonReentrant {



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (SocializingPool.sol#495) is not in mixedCase



    
495         uint256 _validatorId,



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._validatorId (SocializingPool.sol#525) is not in mixedCase



    
525         uint256 _validatorId,



```

```
Function IStaderConfig.STADER_ORACLE() (SocializingPool.sol#31) is not in mixedCase



    
31     function STADER_ORACLE() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (SocializingPool.sol#497) is not in mixedCase



    
497         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._addr (SocializingPool.sol#454) is not in mixedCase



    
454     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Parameter SocializingPool.verifyProof(uint256,address,uint256,uint256,bytes32[])._amountETH (SocializingPool.sol#2678) is not in mixedCase



    
2678         uint256 _amountETH,



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._staderConfig (SocializingPool.sol#571) is not in mixedCase



    
571     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.AUCTION_CONTRACT() (SocializingPool.sol#33) is not in mixedCase



    
33     function AUCTION_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (SocializingPool.sol#479) is not in mixedCase



    
479         uint256 _validatorId,



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._staderConfig (SocializingPool.sol#469) is not in mixedCase



    
469         IStaderConfig _staderConfig,



```

```
Variable PausableUpgradeable.__gap (SocializingPool.sol#2157) is not in mixedCase



    
2157     uint256[49] private __gap;



```

```
Function IStaderConfig.USER_WITHDRAW_MANAGER() (SocializingPool.sol#45) is not in mixedCase



    
45     function USER_WITHDRAW_MANAGER() external view returns (bytes32);



```

```
Parameter SocializingPool.updateStaderConfig(address)._staderConfig (SocializingPool.sol#2690) is not in mixedCase



    
2690     function updateStaderConfig(address _staderConfig) external override onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Function IStaderConfig.NODE_EL_REWARD_VAULT_IMPLEMENTATION() (SocializingPool.sol#57) is not in mixedCase



    
57     function NODE_EL_REWARD_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._staderConfig (SocializingPool.sol#514) is not in mixedCase



    
514         IStaderConfig _staderConfig



```

```
Function IStaderConfig.VAULT_FACTORY() (SocializingPool.sol#29) is not in mixedCase



    
29     function VAULT_FACTORY() external view returns (bytes32);



```

```
Function IStaderConfig.STAKE_POOL_MANAGER() (SocializingPool.sol#39) is not in mixedCase



    
39     function STAKE_POOL_MANAGER() external view returns (bytes32);



```

```
Parameter SocializingPool.getRewardCycleDetails(uint256)._index (SocializingPool.sol#2717) is not in mixedCase



    
2717     function getRewardCycleDetails(uint256 _index) public view returns (uint256 _startBlock, uint256 _endBlock) {



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._poolId (SocializingPool.sol#494) is not in mixedCase



    
494         uint8 _poolId,



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._contractName (SocializingPool.sol#470) is not in mixedCase



    
470         bytes32 _contractName



```

```
Parameter SocializingPool.initialize(address,address)._admin (SocializingPool.sol#2550) is not in mixedCase



    
2550     function initialize(address _admin, address _staderConfig) public initializer {



```

```
Function IStaderConfig.OPERATOR() (SocializingPool.sol#69) is not in mixedCase



    
69     function OPERATOR() external view returns (bytes32);



```

```
Parameter SocializingPool.initialize(address,address)._staderConfig (SocializingPool.sol#2550) is not in mixedCase



    
2550     function initialize(address _admin, address _staderConfig) public initializer {



```

```
Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init() (SocializingPool.sol#2195-2197) is not in mixedCase



    
2195     function __ReentrancyGuard_init() internal onlyInitializing {
2196         __ReentrancyGuard_init_unchained();
2197     }



```

```
Function ERC165Upgradeable.__ERC165_init_unchained() (SocializingPool.sol#1781-1782) is not in mixedCase



    
1781     function __ERC165_init_unchained() internal onlyInitializing {
1782     }



```

```
Function ContextUpgradeable.__Context_init_unchained() (SocializingPool.sol#1311-1312) is not in mixedCase



    
1311     function __Context_init_unchained() internal onlyInitializing {
1312     }



```

```
Function IStaderConfig.PERMISSIONED_POOL() (SocializingPool.sol#37) is not in mixedCase



    
37     function PERMISSIONED_POOL() external view returns (bytes32);



```

```
Function INodeRegistry.POOL_ID() (SocializingPool.sol#303) is not in mixedCase



    
303     function POOL_ID() external view returns (uint8);



```

```
Parameter UtilLib.sendValue(address,uint256)._receiver (SocializingPool.sol#595) is not in mixedCase



    
595     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Function IStaderConfig.PERMISSIONLESS_POOL() (SocializingPool.sol#43) is not in mixedCase



    
43     function PERMISSIONLESS_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._addr (SocializingPool.sol#480) is not in mixedCase



    
480         address _addr,



```

```
Parameter SocializingPool.claim(uint256[],uint256[],uint256[],bytes32[][])._index (SocializingPool.sol#2619) is not in mixedCase



    
2619         uint256[] calldata _index,



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (SocializingPool.sol#481) is not in mixedCase



    
481         IStaderConfig _staderConfig



```

```
Parameter SocializingPool.verifyProof(uint256,address,uint256,uint256,bytes32[])._index (SocializingPool.sol#2675) is not in mixedCase



    
2675         uint256 _index,



```

```
Variable ReentrancyGuardUpgradeable.__gap (SocializingPool.sol#2235) is not in mixedCase



    
2235     uint256[49] private __gap;



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._staderConfig (SocializingPool.sol#546) is not in mixedCase



    
546     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._staderConfig (SocializingPool.sol#460) is not in mixedCase



    
460     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.SD_COLLATERAL() (SocializingPool.sol#25) is not in mixedCase



    
25     function SD_COLLATERAL() external view returns (bytes32);



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._pubkey (SocializingPool.sol#571) is not in mixedCase



    
571     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function AccessControlUpgradeable.__AccessControl_init() (SocializingPool.sol#1837-1838) is not in mixedCase



    
1837     function __AccessControl_init() internal onlyInitializing {
1838     }



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._addr (SocializingPool.sol#496) is not in mixedCase



    
496         address _addr,



```

```
Parameter UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig)._staderConfig (SocializingPool.sol#586) is not in mixedCase



    
586         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._addr (SocializingPool.sol#468) is not in mixedCase



    
468         address _addr,



```

```
Function IStaderConfig.PERMISSIONED_SOCIALIZING_POOL() (SocializingPool.sol#53) is not in mixedCase



    
53     function PERMISSIONED_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Parameter SocializingPool.verifyProof(uint256,address,uint256,uint256,bytes32[])._merkleProof (SocializingPool.sol#2679) is not in mixedCase



    
2679         bytes32[] calldata _merkleProof



```

```
Parameter SocializingPool.claim(uint256[],uint256[],uint256[],bytes32[][])._merkleProof (SocializingPool.sol#2622) is not in mixedCase



    
2622         bytes32[][] calldata _merkleProof



```

```
Function IStaderConfig.PENALTY_CONTRACT() (SocializingPool.sol#35) is not in mixedCase



    
35     function PENALTY_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._poolId (SocializingPool.sol#478) is not in mixedCase



    
478         uint8 _poolId,



```

```
Variable ERC165Upgradeable.__gap (SocializingPool.sol#1795) is not in mixedCase



    
1795     uint256[50] private __gap;



```

```
Function IStaderConfig.ETH_DEPOSIT_CONTRACT() (SocializingPool.sol#41) is not in mixedCase



    
41     function ETH_DEPOSIT_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._operator (SocializingPool.sol#546) is not in mixedCase



    
546     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Parameter SocializingPool.claim(uint256[],uint256[],uint256[],bytes32[][])._amountETH (SocializingPool.sol#2621) is not in mixedCase



    
2621         uint256[] calldata _amountETH,



```

```
Function IStaderConfig.ETH_BALANCE_POR_FEED() (SocializingPool.sol#62) is not in mixedCase



    
62     function ETH_BALANCE_POR_FEED() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._poolId (SocializingPool.sol#511) is not in mixedCase



    
511         uint8 _poolId,



```

```
Parameter UtilLib.getPubkeyRoot(bytes)._pubkey (SocializingPool.sol#562) is not in mixedCase



    
562     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {



```

```
Function PausableUpgradeable.__Pausable_init() (SocializingPool.sol#2075-2077) is not in mixedCase



    
2075     function __Pausable_init() internal onlyInitializing {
2076         __Pausable_init_unchained();
2077     }



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._poolId (SocializingPool.sol#524) is not in mixedCase



    
524         uint8 _poolId,



```

```
Function IStaderConfig.MANAGER() (SocializingPool.sol#67) is not in mixedCase



    
67     function MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.STADER_INSURANCE_FUND() (SocializingPool.sol#47) is not in mixedCase



    
47     function STADER_INSURANCE_FUND() external view returns (bytes32);



```

```
Function ContextUpgradeable.__Context_init() (SocializingPool.sol#1308-1309) is not in mixedCase



    
1308     function __Context_init() internal onlyInitializing {
1309     }



```

```
Function IStaderConfig.PERMISSIONLESS_NODE_REGISTRY() (SocializingPool.sol#51) is not in mixedCase



    
51     function PERMISSIONLESS_NODE_REGISTRY() external view returns (bytes32);



```

```
Function ERC165Upgradeable.__ERC165_init() (SocializingPool.sol#1778-1779) is not in mixedCase



    
1778     function __ERC165_init() internal onlyInitializing {
1779     }



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._staderConfig (SocializingPool.sol#526) is not in mixedCase



    
526         IStaderConfig _staderConfig



```

```
Parameter UtilLib.checkNonZeroAddress(address)._address (SocializingPool.sol#449) is not in mixedCase



    
449     function checkNonZeroAddress(address _address) internal pure {



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._addr (SocializingPool.sol#513) is not in mixedCase



    
513         address _addr,



```

```
Function PausableUpgradeable.__Pausable_init_unchained() (SocializingPool.sol#2079-2081) is not in mixedCase



    
2079     function __Pausable_init_unchained() internal onlyInitializing {
2080         _paused = false;
2081     }



```

### StaderConfig.sol


```
Parameter StaderConfig.updatePoolUtils(address)._poolUtils (StaderConfig.sol#2002) is not in mixedCase



    
2002     function updatePoolUtils(address _poolUtils) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._addr (StaderConfig.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.PERMISSIONED_NODE_REGISTRY() (StaderConfig.sol#48) is not in mixedCase



    
48     function PERMISSIONED_NODE_REGISTRY() external view returns (bytes32);



```

```
Function IStaderConfig.PERMISSIONLESS_SOCIALIZING_POOL() (StaderConfig.sol#54) is not in mixedCase



    
54     function PERMISSIONLESS_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._validatorId (StaderConfig.sol#511) is not in mixedCase



    
511         uint256 _validatorId,



```

```
Parameter StaderConfig.updatePenaltyContract(address)._penaltyContract (StaderConfig.sol#2030) is not in mixedCase



    
2030     function updatePenaltyContract(address _penaltyContract) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Function IStaderConfig.VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() (StaderConfig.sol#58) is not in mixedCase



    
58     function VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._staderConfig (StaderConfig.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.POOL_SELECTOR() (StaderConfig.sol#22) is not in mixedCase



    
22     function POOL_SELECTOR() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._poolId (StaderConfig.sol#535) is not in mixedCase



    
535         uint8 _poolId,



```

```
Function IStaderConfig.ETHX_SUPPLY_POR_FEED() (StaderConfig.sol#63) is not in mixedCase



    
63     function ETHX_SUPPLY_POR_FEED() external view returns (bytes32);



```

```
Function IStaderConfig.POOL_UTILS() (StaderConfig.sol#20) is not in mixedCase



    
20     function POOL_UTILS() external view returns (bytes32);



```

```
Parameter StaderConfig.updateWithdrawnKeysBatchSize(uint256)._withdrawnKeysBatchSize (StaderConfig.sol#1981) is not in mixedCase



    
1981     function updateWithdrawnKeysBatchSize(uint256 _withdrawnKeysBatchSize) external onlyRole(OPERATOR) {



```

```
Function AccessControlUpgradeable.__AccessControl_init_unchained() (StaderConfig.sol#1613-1614) is not in mixedCase



    
1613     function __AccessControl_init_unchained() internal onlyInitializing {
1614     }



```

```
Parameter StaderConfig.initialize(address,address)._admin (StaderConfig.sol#1896) is not in mixedCase



    
1896     function initialize(address _admin, address _ethDepositContract) external initializer {



```

```
Parameter StaderConfig.updateUserWithdrawManager(address)._userWithdrawManager (StaderConfig.sol#2046) is not in mixedCase



    
2046     function updateUserWithdrawManager(address _userWithdrawManager) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Parameter StaderConfig.initialize(address,address)._ethDepositContract (StaderConfig.sol#1896) is not in mixedCase



    
1896     function initialize(address _admin, address _ethDepositContract) external initializer {



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._operatorId (StaderConfig.sol#536) is not in mixedCase



    
536         uint256 _operatorId,



```

```
Function IStaderConfig.OPERATOR_REWARD_COLLECTOR() (StaderConfig.sol#26) is not in mixedCase



    
26     function OPERATOR_REWARD_COLLECTOR() external view returns (bytes32);



```

```
Variable ContextUpgradeable.__gap (StaderConfig.sol#1099) is not in mixedCase



    
1099     uint256[50] private __gap;



```

```
Parameter StaderConfig.updatePermissionlessNodeRegistry(address)._permissionlessNodeRegistry (StaderConfig.sol#2058) is not in mixedCase



    
2058     function updatePermissionlessNodeRegistry(address _permissionlessNodeRegistry)



```

```
Parameter StaderConfig.updateMinBlockDelayToFinalizeWithdrawRequest(uint256)._minBlockDelay (StaderConfig.sol#1969) is not in mixedCase



    
1969     function updateMinBlockDelayToFinalizeWithdrawRequest(uint256 _minBlockDelay)



```

```
Variable AccessControlUpgradeable.__gap (StaderConfig.sol#1818) is not in mixedCase



    
1818     uint256[49] private __gap;



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._staderConfig (StaderConfig.sol#537) is not in mixedCase



    
537         IStaderConfig _staderConfig



```

```
Parameter StaderConfig.updateMinDepositAmount(uint256)._minDepositAmount (StaderConfig.sol#1937) is not in mixedCase



    
1937     function updateMinDepositAmount(uint256 _minDepositAmount) external onlyRole(MANAGER) {



```

```
Parameter StaderConfig.updateETHBalancePORFeedProxy(address)._ethBalanceProxy (StaderConfig.sol#2090) is not in mixedCase



    
2090     function updateETHBalancePORFeedProxy(address _ethBalanceProxy) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Parameter UtilLib.sendValue(address,uint256)._amount (StaderConfig.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Parameter StaderConfig.updateMinWithdrawAmount(uint256)._minWithdrawAmount (StaderConfig.sol#1955) is not in mixedCase



    
1955     function updateMinWithdrawAmount(uint256 _minWithdrawAmount) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (StaderConfig.sol#494) is not in mixedCase



    
494         uint256 _validatorId,



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._validatorId (StaderConfig.sol#524) is not in mixedCase



    
524         uint256 _validatorId,



```

```
Function IStaderConfig.STADER_ORACLE() (StaderConfig.sol#30) is not in mixedCase



    
30     function STADER_ORACLE() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (StaderConfig.sol#496) is not in mixedCase



    
496         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._addr (StaderConfig.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._staderConfig (StaderConfig.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.AUCTION_CONTRACT() (StaderConfig.sol#32) is not in mixedCase



    
32     function AUCTION_CONTRACT() external view returns (bytes32);



```

```
Parameter StaderConfig.updateSocializingPoolCycleDuration(uint256)._socializingPoolCycleDuration (StaderConfig.sol#1918) is not in mixedCase



    
1918     function updateSocializingPoolCycleDuration(uint256 _socializingPoolCycleDuration) external onlyRole(MANAGER) {



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (StaderConfig.sol#478) is not in mixedCase



    
478         uint256 _validatorId,



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._staderConfig (StaderConfig.sol#468) is not in mixedCase



    
468         IStaderConfig _staderConfig,



```

```
Function IStaderConfig.USER_WITHDRAW_MANAGER() (StaderConfig.sol#44) is not in mixedCase



    
44     function USER_WITHDRAW_MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.NODE_EL_REWARD_VAULT_IMPLEMENTATION() (StaderConfig.sol#56) is not in mixedCase



    
56     function NODE_EL_REWARD_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter StaderConfig.updateStaderInsuranceFund(address)._staderInsuranceFund (StaderConfig.sol#2050) is not in mixedCase



    
2050     function updateStaderInsuranceFund(address _staderInsuranceFund) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._staderConfig (StaderConfig.sol#513) is not in mixedCase



    
513         IStaderConfig _staderConfig



```

```
Parameter StaderConfig.updatePermissionedNodeRegistry(address)._permissionedNodeRegistry (StaderConfig.sol#2054) is not in mixedCase



    
2054     function updatePermissionedNodeRegistry(address _permissionedNodeRegistry) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Function IStaderConfig.VAULT_FACTORY() (StaderConfig.sol#28) is not in mixedCase



    
28     function VAULT_FACTORY() external view returns (bytes32);



```

```
Function IStaderConfig.STAKE_POOL_MANAGER() (StaderConfig.sol#38) is not in mixedCase



    
38     function STAKE_POOL_MANAGER() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._poolId (StaderConfig.sol#493) is not in mixedCase



    
493         uint8 _poolId,



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._contractName (StaderConfig.sol#469) is not in mixedCase



    
469         bytes32 _contractName



```

```
Function IStaderConfig.OPERATOR() (StaderConfig.sol#68) is not in mixedCase



    
68     function OPERATOR() external view returns (bytes32);



```

```
Parameter StaderConfig.updateNodeELRewardImplementation(address)._nodeELRewardVaultImpl (StaderConfig.sol#2079) is not in mixedCase



    
2079     function updateNodeELRewardImplementation(address _nodeELRewardVaultImpl) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Parameter StaderConfig.updateAdmin(address)._admin (StaderConfig.sol#1987) is not in mixedCase



    
1987     function updateAdmin(address _admin) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Function ERC165Upgradeable.__ERC165_init_unchained() (StaderConfig.sol#1554-1555) is not in mixedCase



    
1554     function __ERC165_init_unchained() internal onlyInitializing {
1555     }



```

```
Function ContextUpgradeable.__Context_init_unchained() (StaderConfig.sol#1084-1085) is not in mixedCase



    
1084     function __Context_init_unchained() internal onlyInitializing {
1085     }



```

```
Function IStaderConfig.PERMISSIONED_POOL() (StaderConfig.sol#36) is not in mixedCase



    
36     function PERMISSIONED_POOL() external view returns (bytes32);



```

```
Function INodeRegistry.POOL_ID() (StaderConfig.sol#302) is not in mixedCase



    
302     function POOL_ID() external view returns (uint8);



```

```
Parameter UtilLib.sendValue(address,uint256)._receiver (StaderConfig.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Parameter StaderConfig.onlyStaderContract(address,bytes32)._contractName (StaderConfig.sol#2311) is not in mixedCase



    
2311     function onlyStaderContract(address _addr, bytes32 _contractName) external view returns (bool) {



```

```
Parameter StaderConfig.updateStaderOracle(address)._staderOracle (StaderConfig.sol#2026) is not in mixedCase



    
2026     function updateStaderOracle(address _staderOracle) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Parameter StaderConfig.updateETHXSupplyPORFeedProxy(address)._ethXSupplyProxy (StaderConfig.sol#2094) is not in mixedCase



    
2094     function updateETHXSupplyPORFeedProxy(address _ethXSupplyProxy) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Function IStaderConfig.PERMISSIONLESS_POOL() (StaderConfig.sol#42) is not in mixedCase



    
42     function PERMISSIONLESS_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._addr (StaderConfig.sol#479) is not in mixedCase



    
479         address _addr,



```

```
Parameter StaderConfig.updateVaultFactory(address)._vaultFactory (StaderConfig.sol#2018) is not in mixedCase



    
2018     function updateVaultFactory(address _vaultFactory) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Parameter StaderConfig.updateMaxDepositAmount(uint256)._maxDepositAmount (StaderConfig.sol#1946) is not in mixedCase



    
1946     function updateMaxDepositAmount(uint256 _maxDepositAmount) external onlyRole(MANAGER) {



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (StaderConfig.sol#480) is not in mixedCase



    
480         IStaderConfig _staderConfig



```

```
Parameter StaderConfig.updateMaxWithdrawAmount(uint256)._maxWithdrawAmount (StaderConfig.sol#1964) is not in mixedCase



    
1964     function updateMaxWithdrawAmount(uint256 _maxWithdrawAmount) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._staderConfig (StaderConfig.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Parameter StaderConfig.updateSDCollateral(address)._sdCollateral (StaderConfig.sol#2010) is not in mixedCase



    
2010     function updateSDCollateral(address _sdCollateral) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._staderConfig (StaderConfig.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.SD_COLLATERAL() (StaderConfig.sol#24) is not in mixedCase



    
24     function SD_COLLATERAL() external view returns (bytes32);



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._pubkey (StaderConfig.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Parameter StaderConfig.updateAuctionContract(address)._auctionContract (StaderConfig.sol#2022) is not in mixedCase



    
2022     function updateAuctionContract(address _auctionContract) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Parameter StaderConfig.updatePermissionlessPool(address)._permissionlessPool (StaderConfig.sol#2042) is not in mixedCase



    
2042     function updatePermissionlessPool(address _permissionlessPool) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Function AccessControlUpgradeable.__AccessControl_init() (StaderConfig.sol#1610-1611) is not in mixedCase



    
1610     function __AccessControl_init() internal onlyInitializing {
1611     }



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._addr (StaderConfig.sol#495) is not in mixedCase



    
495         address _addr,



```

```
Parameter UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig)._staderConfig (StaderConfig.sol#585) is not in mixedCase



    
585         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._addr (StaderConfig.sol#467) is not in mixedCase



    
467         address _addr,



```

```
Parameter StaderConfig.updateSocializingPoolOptInCoolingPeriod(uint256)._SocializePoolOptInCoolingPeriod (StaderConfig.sol#1922) is not in mixedCase



    
1922     function updateSocializingPoolOptInCoolingPeriod(uint256 _SocializePoolOptInCoolingPeriod)



```

```
Function IStaderConfig.PERMISSIONED_SOCIALIZING_POOL() (StaderConfig.sol#52) is not in mixedCase



    
52     function PERMISSIONED_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Function IStaderConfig.PENALTY_CONTRACT() (StaderConfig.sol#34) is not in mixedCase



    
34     function PENALTY_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._poolId (StaderConfig.sol#477) is not in mixedCase



    
477         uint8 _poolId,



```

```
Variable ERC165Upgradeable.__gap (StaderConfig.sol#1568) is not in mixedCase



    
1568     uint256[50] private __gap;



```

```
Parameter StaderConfig.updatePermissionlessSocializingPool(address)._permissionlessSocializePool (StaderConfig.sol#2072) is not in mixedCase



    
2072     function updatePermissionlessSocializingPool(address _permissionlessSocializePool)



```

```
Parameter StaderConfig.updateOperatorRewardsCollector(address)._operatorRewardsCollector (StaderConfig.sol#2014) is not in mixedCase



    
2014     function updateOperatorRewardsCollector(address _operatorRewardsCollector) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Function IStaderConfig.ETH_DEPOSIT_CONTRACT() (StaderConfig.sol#40) is not in mixedCase



    
40     function ETH_DEPOSIT_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._operator (StaderConfig.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Parameter StaderConfig.updateStaderTreasury(address)._staderTreasury (StaderConfig.sol#1996) is not in mixedCase



    
1996     function updateStaderTreasury(address _staderTreasury) external onlyRole(MANAGER) {



```

```
Parameter StaderConfig.updateRewardsThreshold(uint256)._rewardsThreshold (StaderConfig.sol#1929) is not in mixedCase



    
1929     function updateRewardsThreshold(uint256 _rewardsThreshold) external onlyRole(MANAGER) {



```

```
Function IStaderConfig.ETH_BALANCE_POR_FEED() (StaderConfig.sol#61) is not in mixedCase



    
61     function ETH_BALANCE_POR_FEED() external view returns (bytes32);



```

```
Parameter StaderConfig.updateValidatorWithdrawalVaultImplementation(address)._validatorWithdrawalVaultImpl (StaderConfig.sol#2083) is not in mixedCase



    
2083     function updateValidatorWithdrawalVaultImplementation(address _validatorWithdrawalVaultImpl)



```

```
Parameter StaderConfig.updatePermissionedPool(address)._permissionedPool (StaderConfig.sol#2034) is not in mixedCase



    
2034     function updatePermissionedPool(address _permissionedPool) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._poolId (StaderConfig.sol#510) is not in mixedCase



    
510         uint8 _poolId,



```

```
Parameter StaderConfig.onlyStaderContract(address,bytes32)._addr (StaderConfig.sol#2311) is not in mixedCase



    
2311     function onlyStaderContract(address _addr, bytes32 _contractName) external view returns (bool) {



```

```
Parameter UtilLib.getPubkeyRoot(bytes)._pubkey (StaderConfig.sol#561) is not in mixedCase



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {



```

```
Parameter StaderConfig.updateETHxToken(address)._ethX (StaderConfig.sol#2102) is not in mixedCase



    
2102     function updateETHxToken(address _ethX) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Parameter StaderConfig.updateStaderToken(address)._staderToken (StaderConfig.sol#2098) is not in mixedCase



    
2098     function updateStaderToken(address _staderToken) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._poolId (StaderConfig.sol#523) is not in mixedCase



    
523         uint8 _poolId,



```

```
Function IStaderConfig.MANAGER() (StaderConfig.sol#66) is not in mixedCase



    
66     function MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.STADER_INSURANCE_FUND() (StaderConfig.sol#46) is not in mixedCase



    
46     function STADER_INSURANCE_FUND() external view returns (bytes32);



```

```
Function ContextUpgradeable.__Context_init() (StaderConfig.sol#1081-1082) is not in mixedCase



    
1081     function __Context_init() internal onlyInitializing {
1082     }



```

```
Parameter StaderConfig.updatePermissionedSocializingPool(address)._permissionedSocializePool (StaderConfig.sol#2065) is not in mixedCase



    
2065     function updatePermissionedSocializingPool(address _permissionedSocializePool)



```

```
Function IStaderConfig.PERMISSIONLESS_NODE_REGISTRY() (StaderConfig.sol#50) is not in mixedCase



    
50     function PERMISSIONLESS_NODE_REGISTRY() external view returns (bytes32);



```

```
Parameter StaderConfig.updateStakePoolManager(address)._stakePoolManager (StaderConfig.sol#2038) is not in mixedCase



    
2038     function updateStakePoolManager(address _stakePoolManager) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Function ERC165Upgradeable.__ERC165_init() (StaderConfig.sol#1551-1552) is not in mixedCase



    
1551     function __ERC165_init() internal onlyInitializing {
1552     }



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._staderConfig (StaderConfig.sol#525) is not in mixedCase



    
525         IStaderConfig _staderConfig



```

```
Parameter UtilLib.checkNonZeroAddress(address)._address (StaderConfig.sol#448) is not in mixedCase



    
448     function checkNonZeroAddress(address _address) internal pure {



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._addr (StaderConfig.sol#512) is not in mixedCase



    
512         address _addr,



```

```
Parameter StaderConfig.updatePoolSelector(address)._poolSelector (StaderConfig.sol#2006) is not in mixedCase



    
2006     function updatePoolSelector(address _poolSelector) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

### StaderInsuranceFund.sol


```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._addr (StaderInsuranceFund.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.PERMISSIONED_NODE_REGISTRY() (StaderInsuranceFund.sol#48) is not in mixedCase



    
48     function PERMISSIONED_NODE_REGISTRY() external view returns (bytes32);



```

```
Function IStaderConfig.PERMISSIONLESS_SOCIALIZING_POOL() (StaderInsuranceFund.sol#54) is not in mixedCase



    
54     function PERMISSIONLESS_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._validatorId (StaderInsuranceFund.sol#511) is not in mixedCase



    
511         uint256 _validatorId,



```

```
Function IStaderConfig.VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() (StaderInsuranceFund.sol#58) is not in mixedCase



    
58     function VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._staderConfig (StaderInsuranceFund.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.POOL_SELECTOR() (StaderInsuranceFund.sol#22) is not in mixedCase



    
22     function POOL_SELECTOR() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._poolId (StaderInsuranceFund.sol#535) is not in mixedCase



    
535         uint8 _poolId,



```

```
Function IStaderConfig.ETHX_SUPPLY_POR_FEED() (StaderInsuranceFund.sol#63) is not in mixedCase



    
63     function ETHX_SUPPLY_POR_FEED() external view returns (bytes32);



```

```
Function IStaderConfig.POOL_UTILS() (StaderInsuranceFund.sol#20) is not in mixedCase



    
20     function POOL_UTILS() external view returns (bytes32);



```

```
Function AccessControlUpgradeable.__AccessControl_init_unchained() (StaderInsuranceFund.sol#1639-1640) is not in mixedCase



    
1639     function __AccessControl_init_unchained() internal onlyInitializing {
1640     }



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._operatorId (StaderInsuranceFund.sol#536) is not in mixedCase



    
536         uint256 _operatorId,



```

```
Function IStaderConfig.OPERATOR_REWARD_COLLECTOR() (StaderInsuranceFund.sol#26) is not in mixedCase



    
26     function OPERATOR_REWARD_COLLECTOR() external view returns (bytes32);



```

```
Variable ContextUpgradeable.__gap (StaderInsuranceFund.sol#1125) is not in mixedCase



    
1125     uint256[50] private __gap;



```

```
Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained() (StaderInsuranceFund.sol#1886-1888) is not in mixedCase



    
1886     function __ReentrancyGuard_init_unchained() internal onlyInitializing {
1887         _status = _NOT_ENTERED;
1888     }



```

```
Variable AccessControlUpgradeable.__gap (StaderInsuranceFund.sol#1844) is not in mixedCase



    
1844     uint256[49] private __gap;



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._staderConfig (StaderInsuranceFund.sol#537) is not in mixedCase



    
537         IStaderConfig _staderConfig



```

```
Parameter UtilLib.sendValue(address,uint256)._amount (StaderInsuranceFund.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (StaderInsuranceFund.sol#494) is not in mixedCase



    
494         uint256 _validatorId,



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._validatorId (StaderInsuranceFund.sol#524) is not in mixedCase



    
524         uint256 _validatorId,



```

```
Function IStaderConfig.STADER_ORACLE() (StaderInsuranceFund.sol#30) is not in mixedCase



    
30     function STADER_ORACLE() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (StaderInsuranceFund.sol#496) is not in mixedCase



    
496         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._addr (StaderInsuranceFund.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._staderConfig (StaderInsuranceFund.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.AUCTION_CONTRACT() (StaderInsuranceFund.sol#32) is not in mixedCase



    
32     function AUCTION_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (StaderInsuranceFund.sol#478) is not in mixedCase



    
478         uint256 _validatorId,



```

```
Parameter StaderInsuranceFund.initialize(address,address)._staderConfig (StaderInsuranceFund.sol#1938) is not in mixedCase



    
1938     function initialize(address _admin, address _staderConfig) public initializer {



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._staderConfig (StaderInsuranceFund.sol#468) is not in mixedCase



    
468         IStaderConfig _staderConfig,



```

```
Function IStaderConfig.USER_WITHDRAW_MANAGER() (StaderInsuranceFund.sol#44) is not in mixedCase



    
44     function USER_WITHDRAW_MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.NODE_EL_REWARD_VAULT_IMPLEMENTATION() (StaderInsuranceFund.sol#56) is not in mixedCase



    
56     function NODE_EL_REWARD_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._staderConfig (StaderInsuranceFund.sol#513) is not in mixedCase



    
513         IStaderConfig _staderConfig



```

```
Function IStaderConfig.VAULT_FACTORY() (StaderInsuranceFund.sol#28) is not in mixedCase



    
28     function VAULT_FACTORY() external view returns (bytes32);



```

```
Function IStaderConfig.STAKE_POOL_MANAGER() (StaderInsuranceFund.sol#38) is not in mixedCase



    
38     function STAKE_POOL_MANAGER() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._poolId (StaderInsuranceFund.sol#493) is not in mixedCase



    
493         uint8 _poolId,



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._contractName (StaderInsuranceFund.sol#469) is not in mixedCase



    
469         bytes32 _contractName



```

```
Function IStaderConfig.OPERATOR() (StaderInsuranceFund.sol#68) is not in mixedCase



    
68     function OPERATOR() external view returns (bytes32);



```

```
Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init() (StaderInsuranceFund.sol#1882-1884) is not in mixedCase



    
1882     function __ReentrancyGuard_init() internal onlyInitializing {
1883         __ReentrancyGuard_init_unchained();
1884     }



```

```
Function ERC165Upgradeable.__ERC165_init_unchained() (StaderInsuranceFund.sol#1580-1581) is not in mixedCase



    
1580     function __ERC165_init_unchained() internal onlyInitializing {
1581     }



```

```
Function ContextUpgradeable.__Context_init_unchained() (StaderInsuranceFund.sol#1110-1111) is not in mixedCase



    
1110     function __Context_init_unchained() internal onlyInitializing {
1111     }



```

```
Function IStaderConfig.PERMISSIONED_POOL() (StaderInsuranceFund.sol#36) is not in mixedCase



    
36     function PERMISSIONED_POOL() external view returns (bytes32);



```

```
Function INodeRegistry.POOL_ID() (StaderInsuranceFund.sol#302) is not in mixedCase



    
302     function POOL_ID() external view returns (uint8);



```

```
Parameter UtilLib.sendValue(address,uint256)._receiver (StaderInsuranceFund.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Function IStaderConfig.PERMISSIONLESS_POOL() (StaderInsuranceFund.sol#42) is not in mixedCase



    
42     function PERMISSIONLESS_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._addr (StaderInsuranceFund.sol#479) is not in mixedCase



    
479         address _addr,



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (StaderInsuranceFund.sol#480) is not in mixedCase



    
480         IStaderConfig _staderConfig



```

```
Variable ReentrancyGuardUpgradeable.__gap (StaderInsuranceFund.sol#1922) is not in mixedCase



    
1922     uint256[49] private __gap;



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._staderConfig (StaderInsuranceFund.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._staderConfig (StaderInsuranceFund.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.SD_COLLATERAL() (StaderInsuranceFund.sol#24) is not in mixedCase



    
24     function SD_COLLATERAL() external view returns (bytes32);



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._pubkey (StaderInsuranceFund.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function AccessControlUpgradeable.__AccessControl_init() (StaderInsuranceFund.sol#1636-1637) is not in mixedCase



    
1636     function __AccessControl_init() internal onlyInitializing {
1637     }



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._addr (StaderInsuranceFund.sol#495) is not in mixedCase



    
495         address _addr,



```

```
Parameter UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig)._staderConfig (StaderInsuranceFund.sol#585) is not in mixedCase



    
585         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._addr (StaderInsuranceFund.sol#467) is not in mixedCase



    
467         address _addr,



```

```
Function IStaderConfig.PERMISSIONED_SOCIALIZING_POOL() (StaderInsuranceFund.sol#52) is not in mixedCase



    
52     function PERMISSIONED_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Function IStaderConfig.PENALTY_CONTRACT() (StaderInsuranceFund.sol#34) is not in mixedCase



    
34     function PENALTY_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._poolId (StaderInsuranceFund.sol#477) is not in mixedCase



    
477         uint8 _poolId,



```

```
Variable ERC165Upgradeable.__gap (StaderInsuranceFund.sol#1594) is not in mixedCase



    
1594     uint256[50] private __gap;



```

```
Parameter StaderInsuranceFund.reimburseUserFund(uint256)._amount (StaderInsuranceFund.sol#1972) is not in mixedCase



    
1972     function reimburseUserFund(uint256 _amount) external override nonReentrant {



```

```
Function IStaderConfig.ETH_DEPOSIT_CONTRACT() (StaderInsuranceFund.sol#40) is not in mixedCase



    
40     function ETH_DEPOSIT_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._operator (StaderInsuranceFund.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Parameter StaderInsuranceFund.initialize(address,address)._admin (StaderInsuranceFund.sol#1938) is not in mixedCase



    
1938     function initialize(address _admin, address _staderConfig) public initializer {



```

```
Function IStaderConfig.ETH_BALANCE_POR_FEED() (StaderInsuranceFund.sol#61) is not in mixedCase



    
61     function ETH_BALANCE_POR_FEED() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._poolId (StaderInsuranceFund.sol#510) is not in mixedCase



    
510         uint8 _poolId,



```

```
Parameter UtilLib.getPubkeyRoot(bytes)._pubkey (StaderInsuranceFund.sol#561) is not in mixedCase



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._poolId (StaderInsuranceFund.sol#523) is not in mixedCase



    
523         uint8 _poolId,



```

```
Function IStaderConfig.MANAGER() (StaderInsuranceFund.sol#66) is not in mixedCase



    
66     function MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.STADER_INSURANCE_FUND() (StaderInsuranceFund.sol#46) is not in mixedCase



    
46     function STADER_INSURANCE_FUND() external view returns (bytes32);



```

```
Function ContextUpgradeable.__Context_init() (StaderInsuranceFund.sol#1107-1108) is not in mixedCase



    
1107     function __Context_init() internal onlyInitializing {
1108     }



```

```
Function IStaderConfig.PERMISSIONLESS_NODE_REGISTRY() (StaderInsuranceFund.sol#50) is not in mixedCase



    
50     function PERMISSIONLESS_NODE_REGISTRY() external view returns (bytes32);



```

```
Function ERC165Upgradeable.__ERC165_init() (StaderInsuranceFund.sol#1577-1578) is not in mixedCase



    
1577     function __ERC165_init() internal onlyInitializing {
1578     }



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._staderConfig (StaderInsuranceFund.sol#525) is not in mixedCase



    
525         IStaderConfig _staderConfig



```

```
Parameter UtilLib.checkNonZeroAddress(address)._address (StaderInsuranceFund.sol#448) is not in mixedCase



    
448     function checkNonZeroAddress(address _address) internal pure {



```

```
Parameter StaderInsuranceFund.updateStaderConfig(address)._staderConfig (StaderInsuranceFund.sol#1981) is not in mixedCase



    
1981     function updateStaderConfig(address _staderConfig) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Parameter StaderInsuranceFund.withdrawFund(uint256)._amount (StaderInsuranceFund.sol#1953) is not in mixedCase



    
1953     function withdrawFund(uint256 _amount) external override nonReentrant {



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._addr (StaderInsuranceFund.sol#512) is not in mixedCase



    
512         address _addr,



```

### StaderOracle.sol


```
Parameter StaderOracle.updateWithInLimitER(uint256,uint256,uint256)._newTotalETHXSupply (StaderOracle.sol#3112) is not in mixedCase



    
3112         uint256 _newTotalETHXSupply,



```

```
Parameter StaderOracle.setValidatorStatsUpdateFrequency(uint256)._updateFrequency (StaderOracle.sol#3001) is not in mixedCase



    
3001     function setValidatorStatsUpdateFrequency(uint256 _updateFrequency) external override {



```

```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._addr (StaderOracle.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.PERMISSIONED_NODE_REGISTRY() (StaderOracle.sol#48) is not in mixedCase



    
48     function PERMISSIONED_NODE_REGISTRY() external view returns (bytes32);



```

```
Function IStaderConfig.PERMISSIONLESS_SOCIALIZING_POOL() (StaderOracle.sol#54) is not in mixedCase



    
54     function PERMISSIONLESS_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._validatorId (StaderOracle.sol#511) is not in mixedCase



    
511         uint256 _validatorId,



```

```
Parameter StaderOracle.submitMissedAttestationPenalties(MissedAttestationPenaltyData)._mapd (StaderOracle.sol#2906) is not in mixedCase



    
2906     function submitMissedAttestationPenalties(MissedAttestationPenaltyData calldata _mapd)



```

```
Function IStaderConfig.VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() (StaderOracle.sol#58) is not in mixedCase



    
58     function VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._staderConfig (StaderOracle.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Parameter StaderOracle.setMissedAttestationPenaltyUpdateFrequency(uint256)._updateFrequency (StaderOracle.sol#3011) is not in mixedCase



    
3011     function setMissedAttestationPenaltyUpdateFrequency(uint256 _updateFrequency) external override {



```

```
Function IStaderConfig.POOL_SELECTOR() (StaderOracle.sol#22) is not in mixedCase



    
22     function POOL_SELECTOR() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._poolId (StaderOracle.sol#535) is not in mixedCase



    
535         uint8 _poolId,



```

```
Parameter StaderOracle.initialize(address,address)._admin (StaderOracle.sol#2519) is not in mixedCase



    
2519     function initialize(address _admin, address _staderConfig) public initializer {



```

```
Function IStaderConfig.ETHX_SUPPLY_POR_FEED() (StaderOracle.sol#63) is not in mixedCase



    
63     function ETHX_SUPPLY_POR_FEED() external view returns (bytes32);



```

```
Function IStaderConfig.POOL_UTILS() (StaderOracle.sol#20) is not in mixedCase



    
20     function POOL_UTILS() external view returns (bytes32);



```

```
Function AccessControlUpgradeable.__AccessControl_init_unchained() (StaderOracle.sol#2188-2189) is not in mixedCase



    
2188     function __AccessControl_init_unchained() internal onlyInitializing {
2189     }



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._operatorId (StaderOracle.sol#536) is not in mixedCase



    
536         uint256 _operatorId,



```

```
Function IStaderConfig.OPERATOR_REWARD_COLLECTOR() (StaderOracle.sol#26) is not in mixedCase



    
26     function OPERATOR_REWARD_COLLECTOR() external view returns (bytes32);



```

```
Parameter StaderOracle.updateWithInLimitER(uint256,uint256,uint256)._newTotalETHBalance (StaderOracle.sol#3111) is not in mixedCase



    
3111         uint256 _newTotalETHBalance,



```

```
Variable ContextUpgradeable.__gap (StaderOracle.sol#1476) is not in mixedCase



    
1476     uint256[50] private __gap;



```

```
Parameter StaderOracle.submitWithdrawnValidators(WithdrawnValidators)._withdrawnValidators (StaderOracle.sol#2849) is not in mixedCase



    
2849     function submitWithdrawnValidators(WithdrawnValidators calldata _withdrawnValidators)



```

```
Parameter StaderOracle.updateERChangeLimit(uint256)._erChangeLimit (StaderOracle.sol#2987) is not in mixedCase



    
2987     function updateERChangeLimit(uint256 _erChangeLimit) external override {



```

```
Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained() (StaderOracle.sol#2435-2437) is not in mixedCase



    
2435     function __ReentrancyGuard_init_unchained() internal onlyInitializing {
2436         _status = _NOT_ENTERED;
2437     }



```

```
Variable AccessControlUpgradeable.__gap (StaderOracle.sol#2393) is not in mixedCase



    
2393     uint256[49] private __gap;



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._staderConfig (StaderOracle.sol#537) is not in mixedCase



    
537         IStaderConfig _staderConfig



```

```
Parameter StaderOracle.setSDPriceUpdateFrequency(uint256)._updateFrequency (StaderOracle.sol#2996) is not in mixedCase



    
2996     function setSDPriceUpdateFrequency(uint256 _updateFrequency) external override {



```

```
Parameter UtilLib.sendValue(address,uint256)._amount (StaderOracle.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Parameter StaderOracle.removeTrustedNode(address)._nodeAddress (StaderOracle.sol#2551) is not in mixedCase



    
2551     function removeTrustedNode(address _nodeAddress) external override {



```

```
Parameter StaderOracle.getCurrentRewardsIndexByPoolId(uint8)._poolId (StaderOracle.sol#3063) is not in mixedCase



    
3063     function getCurrentRewardsIndexByPoolId(uint8 _poolId) public view returns (uint256) {



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (StaderOracle.sol#494) is not in mixedCase



    
494         uint256 _validatorId,



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._validatorId (StaderOracle.sol#524) is not in mixedCase



    
524         uint256 _validatorId,



```

```
Function IStaderConfig.STADER_ORACLE() (StaderOracle.sol#30) is not in mixedCase



    
30     function STADER_ORACLE() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (StaderOracle.sol#496) is not in mixedCase



    
496         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._addr (StaderOracle.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Parameter StaderOracle.attestSubmission(bytes32,bytes32)._nodeSubmissionKey (StaderOracle.sol#3077) is not in mixedCase



    
3077     function attestSubmission(bytes32 _nodeSubmissionKey, bytes32 _submissionCountKey)



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._staderConfig (StaderOracle.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.AUCTION_CONTRACT() (StaderOracle.sol#32) is not in mixedCase



    
32     function AUCTION_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (StaderOracle.sol#478) is not in mixedCase



    
478         uint256 _validatorId,



```

```
Parameter StaderOracle.submitExchangeRateData(ExchangeRate)._exchangeRate (StaderOracle.sol#2564) is not in mixedCase



    
2564     function submitExchangeRateData(ExchangeRate calldata _exchangeRate)



```

```
Parameter StaderOracle.getReportableBlockFor(bytes32)._key (StaderOracle.sol#3055) is not in mixedCase



    
3055     function getReportableBlockFor(bytes32 _key) internal view returns (uint256) {



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._staderConfig (StaderOracle.sol#468) is not in mixedCase



    
468         IStaderConfig _staderConfig,



```

```
Variable PausableUpgradeable.__gap (StaderOracle.sol#1586) is not in mixedCase



    
1586     uint256[49] private __gap;



```

```
Function IStaderConfig.USER_WITHDRAW_MANAGER() (StaderOracle.sol#44) is not in mixedCase



    
44     function USER_WITHDRAW_MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.NODE_EL_REWARD_VAULT_IMPLEMENTATION() (StaderOracle.sol#56) is not in mixedCase



    
56     function NODE_EL_REWARD_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._staderConfig (StaderOracle.sol#513) is not in mixedCase



    
513         IStaderConfig _staderConfig



```

```
Function IStaderConfig.VAULT_FACTORY() (StaderOracle.sol#28) is not in mixedCase



    
28     function VAULT_FACTORY() external view returns (bytes32);



```

```
Function IStaderConfig.STAKE_POOL_MANAGER() (StaderOracle.sol#38) is not in mixedCase



    
38     function STAKE_POOL_MANAGER() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._poolId (StaderOracle.sol#493) is not in mixedCase



    
493         uint8 _poolId,



```

```
Parameter StaderOracle.insertSDPrice(uint256)._sdPrice (StaderOracle.sol#2757) is not in mixedCase



    
2757     function insertSDPrice(uint256 _sdPrice) internal {



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._contractName (StaderOracle.sol#469) is not in mixedCase



    
469         bytes32 _contractName



```

```
Parameter StaderOracle.submitSocializingRewardsMerkleRoot(RewardsData)._rewardsData (StaderOracle.sol#2658) is not in mixedCase



    
2658     function submitSocializingRewardsMerkleRoot(RewardsData calldata _rewardsData)



```

```
Function IStaderConfig.OPERATOR() (StaderOracle.sol#68) is not in mixedCase



    
68     function OPERATOR() external view returns (bytes32);



```

```
Parameter StaderOracle.setWithdrawnValidatorsUpdateFrequency(uint256)._updateFrequency (StaderOracle.sol#3006) is not in mixedCase



    
3006     function setWithdrawnValidatorsUpdateFrequency(uint256 _updateFrequency) external override {



```

```
Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init() (StaderOracle.sol#2431-2433) is not in mixedCase



    
2431     function __ReentrancyGuard_init() internal onlyInitializing {
2432         __ReentrancyGuard_init_unchained();
2433     }



```

```
Parameter StaderOracle.updateStaderConfig(address)._staderConfig (StaderOracle.sol#2966) is not in mixedCase



    
2966     function updateStaderConfig(address _staderConfig) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Function ERC165Upgradeable.__ERC165_init_unchained() (StaderOracle.sol#2129-2130) is not in mixedCase



    
2129     function __ERC165_init_unchained() internal onlyInitializing {
2130     }



```

```
Function ContextUpgradeable.__Context_init_unchained() (StaderOracle.sol#1461-1462) is not in mixedCase



    
1461     function __Context_init_unchained() internal onlyInitializing {
1462     }



```

```
Function IStaderConfig.PERMISSIONED_POOL() (StaderOracle.sol#36) is not in mixedCase



    
36     function PERMISSIONED_POOL() external view returns (bytes32);



```

```
Function INodeRegistry.POOL_ID() (StaderOracle.sol#302) is not in mixedCase



    
302     function POOL_ID() external view returns (uint8);



```

```
Parameter StaderOracle.addTrustedNode(address)._nodeAddress (StaderOracle.sol#2538) is not in mixedCase



    
2538     function addTrustedNode(address _nodeAddress) external override {



```

```
Parameter UtilLib.sendValue(address,uint256)._receiver (StaderOracle.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Function IStaderConfig.PERMISSIONLESS_POOL() (StaderOracle.sol#42) is not in mixedCase



    
42     function PERMISSIONLESS_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._addr (StaderOracle.sol#479) is not in mixedCase



    
479         address _addr,



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (StaderOracle.sol#480) is not in mixedCase



    
480         IStaderConfig _staderConfig



```

```
Variable ReentrancyGuardUpgradeable.__gap (StaderOracle.sol#2471) is not in mixedCase



    
2471     uint256[49] private __gap;



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._staderConfig (StaderOracle.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._staderConfig (StaderOracle.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.SD_COLLATERAL() (StaderOracle.sol#24) is not in mixedCase



    
24     function SD_COLLATERAL() external view returns (bytes32);



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._pubkey (StaderOracle.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Parameter StaderOracle.submitSDPrice(SDPriceData)._sdPriceData (StaderOracle.sol#2727) is not in mixedCase



    
2727     function submitSDPrice(SDPriceData calldata _sdPriceData) external override trustedNodeOnly checkMinTrustedNodes {



```

```
Parameter StaderOracle.attestSubmission(bytes32,bytes32)._submissionCountKey (StaderOracle.sol#3077) is not in mixedCase



    
3077     function attestSubmission(bytes32 _nodeSubmissionKey, bytes32 _submissionCountKey)



```

```
Function AccessControlUpgradeable.__AccessControl_init() (StaderOracle.sol#2185-2186) is not in mixedCase



    
2185     function __AccessControl_init() internal onlyInitializing {
2186     }



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._addr (StaderOracle.sol#495) is not in mixedCase



    
495         address _addr,



```

```
Parameter UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig)._staderConfig (StaderOracle.sol#585) is not in mixedCase



    
585         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._addr (StaderOracle.sol#467) is not in mixedCase



    
467         address _addr,



```

```
Parameter StaderOracle.getMerkleRootReportableBlockByPoolId(uint8)._poolId (StaderOracle.sol#3032) is not in mixedCase



    
3032     function getMerkleRootReportableBlockByPoolId(uint8 _poolId) public view override returns (uint256) {



```

```
Parameter StaderOracle.setUpdateFrequency(bytes32,uint256)._key (StaderOracle.sol#3016) is not in mixedCase



    
3016     function setUpdateFrequency(bytes32 _key, uint256 _updateFrequency) internal {



```

```
Parameter StaderOracle.initialize(address,address)._staderConfig (StaderOracle.sol#2519) is not in mixedCase



    
2519     function initialize(address _admin, address _staderConfig) public initializer {



```

```
Function IStaderConfig.PERMISSIONED_SOCIALIZING_POOL() (StaderOracle.sol#52) is not in mixedCase



    
52     function PERMISSIONED_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Function IStaderConfig.PENALTY_CONTRACT() (StaderOracle.sol#34) is not in mixedCase



    
34     function PENALTY_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._poolId (StaderOracle.sol#477) is not in mixedCase



    
477         uint8 _poolId,



```

```
Parameter StaderOracle.updateWithInLimitER(uint256,uint256,uint256)._reportingBlockNumber (StaderOracle.sol#3113) is not in mixedCase



    
3113         uint256 _reportingBlockNumber



```

```
Variable ERC165Upgradeable.__gap (StaderOracle.sol#2143) is not in mixedCase



    
2143     uint256[50] private __gap;



```

```
Parameter StaderOracle.submitValidatorStats(ValidatorStats)._validatorStats (StaderOracle.sol#2775) is not in mixedCase



    
2775     function submitValidatorStats(ValidatorStats calldata _validatorStats)



```

```
Function IStaderConfig.ETH_DEPOSIT_CONTRACT() (StaderOracle.sol#40) is not in mixedCase



    
40     function ETH_DEPOSIT_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._operator (StaderOracle.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.ETH_BALANCE_POR_FEED() (StaderOracle.sol#61) is not in mixedCase



    
61     function ETH_BALANCE_POR_FEED() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._poolId (StaderOracle.sol#510) is not in mixedCase



    
510         uint8 _poolId,



```

```
Parameter UtilLib.getPubkeyRoot(bytes)._pubkey (StaderOracle.sol#561) is not in mixedCase



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {



```

```
Function PausableUpgradeable.__Pausable_init() (StaderOracle.sol#1504-1506) is not in mixedCase



    
1504     function __Pausable_init() internal onlyInitializing {
1505         __Pausable_init_unchained();
1506     }



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._poolId (StaderOracle.sol#523) is not in mixedCase



    
523         uint8 _poolId,



```

```
Function IStaderConfig.MANAGER() (StaderOracle.sol#66) is not in mixedCase



    
66     function MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.STADER_INSURANCE_FUND() (StaderOracle.sol#46) is not in mixedCase



    
46     function STADER_INSURANCE_FUND() external view returns (bytes32);



```

```
Function ContextUpgradeable.__Context_init() (StaderOracle.sol#1458-1459) is not in mixedCase



    
1458     function __Context_init() internal onlyInitializing {
1459     }



```

```
Function IStaderConfig.PERMISSIONLESS_NODE_REGISTRY() (StaderOracle.sol#50) is not in mixedCase



    
50     function PERMISSIONLESS_NODE_REGISTRY() external view returns (bytes32);



```

```
Parameter StaderOracle.setUpdateFrequency(bytes32,uint256)._updateFrequency (StaderOracle.sol#3016) is not in mixedCase



    
3016     function setUpdateFrequency(bytes32 _key, uint256 _updateFrequency) internal {



```

```
Function ERC165Upgradeable.__ERC165_init() (StaderOracle.sol#2126-2127) is not in mixedCase



    
2126     function __ERC165_init() internal onlyInitializing {
2127     }



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._staderConfig (StaderOracle.sol#525) is not in mixedCase



    
525         IStaderConfig _staderConfig



```

```
Parameter UtilLib.checkNonZeroAddress(address)._address (StaderOracle.sol#448) is not in mixedCase



    
448     function checkNonZeroAddress(address _address) internal pure {



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._addr (StaderOracle.sol#512) is not in mixedCase



    
512         address _addr,



```

```
Parameter StaderOracle.setERUpdateFrequency(uint256)._updateFrequency (StaderOracle.sol#2972) is not in mixedCase



    
2972     function setERUpdateFrequency(uint256 _updateFrequency) external override {



```

```
Function PausableUpgradeable.__Pausable_init_unchained() (StaderOracle.sol#1508-1510) is not in mixedCase



    
1508     function __Pausable_init_unchained() internal onlyInitializing {
1509         _paused = false;
1510     }



```

### StaderStakePoolsManager.sol


```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._addr (StaderStakePoolsManager.sol#460) is not in mixedCase



    
460     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.PERMISSIONED_NODE_REGISTRY() (StaderStakePoolsManager.sol#49) is not in mixedCase



    
49     function PERMISSIONED_NODE_REGISTRY() external view returns (bytes32);



```

```
Function IStaderConfig.PERMISSIONLESS_SOCIALIZING_POOL() (StaderStakePoolsManager.sol#55) is not in mixedCase



    
55     function PERMISSIONLESS_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._validatorId (StaderStakePoolsManager.sol#512) is not in mixedCase



    
512         uint256 _validatorId,



```

```
Function IStaderConfig.VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() (StaderStakePoolsManager.sol#59) is not in mixedCase



    
59     function VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._staderConfig (StaderStakePoolsManager.sol#454) is not in mixedCase



    
454     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Parameter StaderStakePoolsManager.receiveExcessEthFromPool(uint8)._poolId (StaderStakePoolsManager.sol#3680) is not in mixedCase



    
3680     function receiveExcessEthFromPool(uint8 _poolId) external payable override {



```

```
Function IStaderConfig.POOL_SELECTOR() (StaderStakePoolsManager.sol#23) is not in mixedCase



    
23     function POOL_SELECTOR() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._poolId (StaderStakePoolsManager.sol#536) is not in mixedCase



    
536         uint8 _poolId,



```

```
Parameter StaderStakePoolsManager.convertToShares(uint256)._assets (StaderStakePoolsManager.sol#3730) is not in mixedCase



    
3730     function convertToShares(uint256 _assets) public view override returns (uint256) {



```

```
Function IStaderConfig.ETHX_SUPPLY_POR_FEED() (StaderStakePoolsManager.sol#64) is not in mixedCase



    
64     function ETHX_SUPPLY_POR_FEED() external view returns (bytes32);



```

```
Parameter StaderStakePoolsManager.deposit(address)._receiver (StaderStakePoolsManager.sol#3759) is not in mixedCase



    
3759     function deposit(address _receiver) public payable override whenNotPaused returns (uint256) {



```

```
Function IStaderConfig.POOL_UTILS() (StaderStakePoolsManager.sol#21) is not in mixedCase



    
21     function POOL_UTILS() external view returns (bytes32);



```

```
Function AccessControlUpgradeable.__AccessControl_init_unchained() (StaderStakePoolsManager.sol#2112-2113) is not in mixedCase



    
2112     function __AccessControl_init_unchained() internal onlyInitializing {
2113     }



```

```
Parameter StaderStakePoolsManager.initialize(address,address)._admin (StaderStakePoolsManager.sol#3640) is not in mixedCase



    
3640     function initialize(address _admin, address _staderConfig) public initializer {



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._operatorId (StaderStakePoolsManager.sol#537) is not in mixedCase



    
537         uint256 _operatorId,



```

```
Function IStaderConfig.OPERATOR_REWARD_COLLECTOR() (StaderStakePoolsManager.sol#27) is not in mixedCase



    
27     function OPERATOR_REWARD_COLLECTOR() external view returns (bytes32);



```

```
Parameter StaderStakePoolsManager.initialConvertToAssets(uint256,Math.Rounding)._shares (StaderStakePoolsManager.sol#3896) is not in mixedCase



    
3896         uint256 _shares,



```

```
Variable ContextUpgradeable.__gap (StaderStakePoolsManager.sol#1118) is not in mixedCase



    
1118     uint256[50] private __gap;



```

```
Parameter ETHx.initialize(address,address)._admin (StaderStakePoolsManager.sol#2450) is not in mixedCase



    
2450     function initialize(address _admin, address _staderConfig) public initializer {



```

```
Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained() (StaderStakePoolsManager.sol#3573-3575) is not in mixedCase



    
3573     function __ReentrancyGuard_init_unchained() internal onlyInitializing {
3574         _status = _NOT_ENTERED;
3575     }



```

```
Variable AccessControlUpgradeable.__gap (StaderStakePoolsManager.sol#2317) is not in mixedCase



    
2317     uint256[49] private __gap;



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._staderConfig (StaderStakePoolsManager.sol#538) is not in mixedCase



    
538         IStaderConfig _staderConfig



```

```
Parameter StaderStakePoolsManager.validatorBatchDeposit(uint8)._poolId (StaderStakePoolsManager.sol#3773) is not in mixedCase



    
3773     function validatorBatchDeposit(uint8 _poolId) external override nonReentrant whenNotPaused {



```

```
Parameter UtilLib.sendValue(address,uint256)._amount (StaderStakePoolsManager.sol#595) is not in mixedCase



    
595     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (StaderStakePoolsManager.sol#495) is not in mixedCase



    
495         uint256 _validatorId,



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._validatorId (StaderStakePoolsManager.sol#525) is not in mixedCase



    
525         uint256 _validatorId,



```

```
Function IStaderConfig.STADER_ORACLE() (StaderStakePoolsManager.sol#31) is not in mixedCase



    
31     function STADER_ORACLE() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (StaderStakePoolsManager.sol#497) is not in mixedCase



    
497         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._addr (StaderStakePoolsManager.sol#454) is not in mixedCase



    
454     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._staderConfig (StaderStakePoolsManager.sol#571) is not in mixedCase



    
571     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.AUCTION_CONTRACT() (StaderStakePoolsManager.sol#33) is not in mixedCase



    
33     function AUCTION_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (StaderStakePoolsManager.sol#479) is not in mixedCase



    
479         uint256 _validatorId,



```

```
Parameter StaderStakePoolsManager.transferETHToUserWithdrawManager(uint256)._amount (StaderStakePoolsManager.sol#3689) is not in mixedCase



    
3689     function transferETHToUserWithdrawManager(uint256 _amount) external override nonReentrant whenNotPaused {



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._staderConfig (StaderStakePoolsManager.sol#469) is not in mixedCase



    
469         IStaderConfig _staderConfig,



```

```
Variable PausableUpgradeable.__gap (StaderStakePoolsManager.sol#2429) is not in mixedCase



    
2429     uint256[49] private __gap;



```

```
Function IStaderConfig.USER_WITHDRAW_MANAGER() (StaderStakePoolsManager.sol#45) is not in mixedCase



    
45     function USER_WITHDRAW_MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.NODE_EL_REWARD_VAULT_IMPLEMENTATION() (StaderStakePoolsManager.sol#57) is not in mixedCase



    
57     function NODE_EL_REWARD_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._staderConfig (StaderStakePoolsManager.sol#514) is not in mixedCase



    
514         IStaderConfig _staderConfig



```

```
Function IStaderConfig.VAULT_FACTORY() (StaderStakePoolsManager.sol#29) is not in mixedCase



    
29     function VAULT_FACTORY() external view returns (bytes32);



```

```
Function IStaderConfig.STAKE_POOL_MANAGER() (StaderStakePoolsManager.sol#39) is not in mixedCase



    
39     function STAKE_POOL_MANAGER() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._poolId (StaderStakePoolsManager.sol#494) is not in mixedCase



    
494         uint8 _poolId,



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._contractName (StaderStakePoolsManager.sol#470) is not in mixedCase



    
470         bytes32 _contractName



```

```
Function ERC20Upgradeable.__ERC20_init_unchained(string,string) (StaderStakePoolsManager.sol#1169-1172) is not in mixedCase



    
1169     function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {
1170         _name = name_;
1171         _symbol = symbol_;
1172     }



```

```
Function IStaderConfig.OPERATOR() (StaderStakePoolsManager.sol#69) is not in mixedCase



    
69     function OPERATOR() external view returns (bytes32);



```

```
Function ERC20Upgradeable.__ERC20_init(string,string) (StaderStakePoolsManager.sol#1165-1167) is not in mixedCase



    
1165     function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {
1166         __ERC20_init_unchained(name_, symbol_);
1167     }



```

```
Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init() (StaderStakePoolsManager.sol#3569-3571) is not in mixedCase



    
3569     function __ReentrancyGuard_init() internal onlyInitializing {
3570         __ReentrancyGuard_init_unchained();
3571     }



```

```
Function ERC165Upgradeable.__ERC165_init_unchained() (StaderStakePoolsManager.sol#2053-2054) is not in mixedCase



    
2053     function __ERC165_init_unchained() internal onlyInitializing {
2054     }



```

```
Function ContextUpgradeable.__Context_init_unchained() (StaderStakePoolsManager.sol#1103-1104) is not in mixedCase



    
1103     function __Context_init_unchained() internal onlyInitializing {
1104     }



```

```
Function IStaderConfig.PERMISSIONED_POOL() (StaderStakePoolsManager.sol#37) is not in mixedCase



    
37     function PERMISSIONED_POOL() external view returns (bytes32);



```

```
Function INodeRegistry.POOL_ID() (StaderStakePoolsManager.sol#303) is not in mixedCase



    
303     function POOL_ID() external view returns (uint8);



```

```
Parameter UtilLib.sendValue(address,uint256)._receiver (StaderStakePoolsManager.sol#595) is not in mixedCase



    
595     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Function IStaderConfig.PERMISSIONLESS_POOL() (StaderStakePoolsManager.sol#43) is not in mixedCase



    
43     function PERMISSIONLESS_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._addr (StaderStakePoolsManager.sol#480) is not in mixedCase



    
480         address _addr,



```

```
Variable ERC20Upgradeable.__gap (StaderStakePoolsManager.sol#1510) is not in mixedCase



    
1510     uint256[45] private __gap;



```

```
Parameter ETHx.initialize(address,address)._staderConfig (StaderStakePoolsManager.sol#2450) is not in mixedCase



    
2450     function initialize(address _admin, address _staderConfig) public initializer {



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (StaderStakePoolsManager.sol#481) is not in mixedCase



    
481         IStaderConfig _staderConfig



```

```
Variable ReentrancyGuardUpgradeable.__gap (StaderStakePoolsManager.sol#3609) is not in mixedCase



    
3609     uint256[49] private __gap;



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._staderConfig (StaderStakePoolsManager.sol#546) is not in mixedCase



    
546     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._staderConfig (StaderStakePoolsManager.sol#460) is not in mixedCase



    
460     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Parameter ETHx.updateStaderConfig(address)._staderConfig (StaderStakePoolsManager.sol#2506) is not in mixedCase



    
2506     function updateStaderConfig(address _staderConfig) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Function IStaderConfig.SD_COLLATERAL() (StaderStakePoolsManager.sol#25) is not in mixedCase



    
25     function SD_COLLATERAL() external view returns (bytes32);



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._pubkey (StaderStakePoolsManager.sol#571) is not in mixedCase



    
571     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function AccessControlUpgradeable.__AccessControl_init() (StaderStakePoolsManager.sol#2109-2110) is not in mixedCase



    
2109     function __AccessControl_init() internal onlyInitializing {
2110     }



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._addr (StaderStakePoolsManager.sol#496) is not in mixedCase



    
496         address _addr,



```

```
Parameter UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig)._staderConfig (StaderStakePoolsManager.sol#586) is not in mixedCase



    
586         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._addr (StaderStakePoolsManager.sol#468) is not in mixedCase



    
468         address _addr,



```

```
Parameter StaderStakePoolsManager.initialConvertToShares(uint256,Math.Rounding)._assets (StaderStakePoolsManager.sol#3875) is not in mixedCase



    
3875         uint256 _assets,



```

```
Function IStaderConfig.PERMISSIONED_SOCIALIZING_POOL() (StaderStakePoolsManager.sol#53) is not in mixedCase



    
53     function PERMISSIONED_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Function IStaderConfig.PENALTY_CONTRACT() (StaderStakePoolsManager.sol#35) is not in mixedCase



    
35     function PENALTY_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._poolId (StaderStakePoolsManager.sol#478) is not in mixedCase



    
478         uint8 _poolId,



```

```
Parameter StaderStakePoolsManager.updateStaderConfig(address)._staderConfig (StaderStakePoolsManager.sol#3706) is not in mixedCase



    
3706     function updateStaderConfig(address _staderConfig) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Variable ERC165Upgradeable.__gap (StaderStakePoolsManager.sol#2067) is not in mixedCase



    
2067     uint256[50] private __gap;



```

```
Parameter StaderStakePoolsManager.previewDeposit(uint256)._assets (StaderStakePoolsManager.sol#3749) is not in mixedCase



    
3749     function previewDeposit(uint256 _assets) public view override returns (uint256) {



```

```
Parameter StaderStakePoolsManager.initialize(address,address)._staderConfig (StaderStakePoolsManager.sol#3640) is not in mixedCase



    
3640     function initialize(address _admin, address _staderConfig) public initializer {



```

```
Function IStaderConfig.ETH_DEPOSIT_CONTRACT() (StaderStakePoolsManager.sol#41) is not in mixedCase



    
41     function ETH_DEPOSIT_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._operator (StaderStakePoolsManager.sol#546) is not in mixedCase



    
546     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.ETH_BALANCE_POR_FEED() (StaderStakePoolsManager.sol#62) is not in mixedCase



    
62     function ETH_BALANCE_POR_FEED() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._poolId (StaderStakePoolsManager.sol#511) is not in mixedCase



    
511         uint8 _poolId,



```

```
Parameter UtilLib.getPubkeyRoot(bytes)._pubkey (StaderStakePoolsManager.sol#562) is not in mixedCase



    
562     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {



```

```
Function PausableUpgradeable.__Pausable_init() (StaderStakePoolsManager.sol#2347-2349) is not in mixedCase



    
2347     function __Pausable_init() internal onlyInitializing {
2348         __Pausable_init_unchained();
2349     }



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._poolId (StaderStakePoolsManager.sol#524) is not in mixedCase



    
524         uint8 _poolId,



```

```
Parameter StaderStakePoolsManager.previewWithdraw(uint256)._shares (StaderStakePoolsManager.sol#3754) is not in mixedCase



    
3754     function previewWithdraw(uint256 _shares) public view override returns (uint256) {



```

```
Function IStaderConfig.MANAGER() (StaderStakePoolsManager.sol#67) is not in mixedCase



    
67     function MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.STADER_INSURANCE_FUND() (StaderStakePoolsManager.sol#47) is not in mixedCase



    
47     function STADER_INSURANCE_FUND() external view returns (bytes32);



```

```
Function ContextUpgradeable.__Context_init() (StaderStakePoolsManager.sol#1100-1101) is not in mixedCase



    
1100     function __Context_init() internal onlyInitializing {
1101     }



```

```
Function IStaderConfig.PERMISSIONLESS_NODE_REGISTRY() (StaderStakePoolsManager.sol#51) is not in mixedCase



    
51     function PERMISSIONLESS_NODE_REGISTRY() external view returns (bytes32);



```

```
Function ERC165Upgradeable.__ERC165_init() (StaderStakePoolsManager.sol#2050-2051) is not in mixedCase



    
2050     function __ERC165_init() internal onlyInitializing {
2051     }



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._staderConfig (StaderStakePoolsManager.sol#526) is not in mixedCase



    
526         IStaderConfig _staderConfig



```

```
Parameter UtilLib.checkNonZeroAddress(address)._address (StaderStakePoolsManager.sol#449) is not in mixedCase



    
449     function checkNonZeroAddress(address _address) internal pure {



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._addr (StaderStakePoolsManager.sol#513) is not in mixedCase



    
513         address _addr,



```

```
Parameter StaderStakePoolsManager.updateExcessETHDepositCoolDown(uint256)._excessETHDepositCoolDown (StaderStakePoolsManager.sol#3699) is not in mixedCase



    
3699     function updateExcessETHDepositCoolDown(uint256 _excessETHDepositCoolDown) external {



```

```
Parameter StaderStakePoolsManager.convertToAssets(uint256)._shares (StaderStakePoolsManager.sol#3735) is not in mixedCase



    
3735     function convertToAssets(uint256 _shares) public view override returns (uint256) {



```

```
Function PausableUpgradeable.__Pausable_init_unchained() (StaderStakePoolsManager.sol#2351-2353) is not in mixedCase



    
2351     function __Pausable_init_unchained() internal onlyInitializing {
2352         _paused = false;
2353     }



```

### UserWithdrawalManager.sol


```
Parameter UserWithdrawalManager.claim(uint256)._requestId (UserWithdrawalManager.sol#3631) is not in mixedCase



    
3631     function claim(uint256 _requestId) external override nonReentrant {



```

```
Parameter UserWithdrawalManager.updateFinalizationBatchLimit(uint256)._finalizationBatchLimit (UserWithdrawalManager.sol#3543) is not in mixedCase



    
3543     function updateFinalizationBatchLimit(uint256 _finalizationBatchLimit) external override {



```

```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._addr (UserWithdrawalManager.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.PERMISSIONED_NODE_REGISTRY() (UserWithdrawalManager.sol#48) is not in mixedCase



    
48     function PERMISSIONED_NODE_REGISTRY() external view returns (bytes32);



```

```
Function IStaderConfig.PERMISSIONLESS_SOCIALIZING_POOL() (UserWithdrawalManager.sol#54) is not in mixedCase



    
54     function PERMISSIONLESS_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._validatorId (UserWithdrawalManager.sol#511) is not in mixedCase



    
511         uint256 _validatorId,



```

```
Function IStaderConfig.VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() (UserWithdrawalManager.sol#58) is not in mixedCase



    
58     function VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._staderConfig (UserWithdrawalManager.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IERC20PermitUpgradeable.DOMAIN_SEPARATOR() (UserWithdrawalManager.sol#3295) is not in mixedCase



    
3295     function DOMAIN_SEPARATOR() external view returns (bytes32);



```

```
Function IStaderConfig.POOL_SELECTOR() (UserWithdrawalManager.sol#22) is not in mixedCase



    
22     function POOL_SELECTOR() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._poolId (UserWithdrawalManager.sol#535) is not in mixedCase



    
535         uint8 _poolId,



```

```
Function IStaderConfig.ETHX_SUPPLY_POR_FEED() (UserWithdrawalManager.sol#63) is not in mixedCase



    
63     function ETHX_SUPPLY_POR_FEED() external view returns (bytes32);



```

```
Function IStaderConfig.POOL_UTILS() (UserWithdrawalManager.sol#20) is not in mixedCase



    
20     function POOL_UTILS() external view returns (bytes32);



```

```
Function AccessControlUpgradeable.__AccessControl_init_unchained() (UserWithdrawalManager.sol#2111-2112) is not in mixedCase



    
2111     function __AccessControl_init_unchained() internal onlyInitializing {
2112     }



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._operatorId (UserWithdrawalManager.sol#536) is not in mixedCase



    
536         uint256 _operatorId,



```

```
Function IStaderConfig.OPERATOR_REWARD_COLLECTOR() (UserWithdrawalManager.sol#26) is not in mixedCase



    
26     function OPERATOR_REWARD_COLLECTOR() external view returns (bytes32);



```

```
Variable ContextUpgradeable.__gap (UserWithdrawalManager.sol#1117) is not in mixedCase



    
1117     uint256[50] private __gap;



```

```
Parameter ETHx.initialize(address,address)._admin (UserWithdrawalManager.sol#2449) is not in mixedCase



    
2449     function initialize(address _admin, address _staderConfig) public initializer {



```

```
Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained() (UserWithdrawalManager.sol#3445-3447) is not in mixedCase



    
3445     function __ReentrancyGuard_init_unchained() internal onlyInitializing {
3446         _status = _NOT_ENTERED;
3447     }



```

```
Variable AccessControlUpgradeable.__gap (UserWithdrawalManager.sol#2316) is not in mixedCase



    
2316     uint256[49] private __gap;



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._staderConfig (UserWithdrawalManager.sol#537) is not in mixedCase



    
537         IStaderConfig _staderConfig



```

```
Parameter UtilLib.sendValue(address,uint256)._amount (UserWithdrawalManager.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (UserWithdrawalManager.sol#494) is not in mixedCase



    
494         uint256 _validatorId,



```

```
Parameter UserWithdrawalManager.updateStaderConfig(address)._staderConfig (UserWithdrawalManager.sol#3550) is not in mixedCase



    
3550     function updateStaderConfig(address _staderConfig) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._validatorId (UserWithdrawalManager.sol#524) is not in mixedCase



    
524         uint256 _validatorId,



```

```
Function IStaderConfig.STADER_ORACLE() (UserWithdrawalManager.sol#30) is not in mixedCase



    
30     function STADER_ORACLE() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (UserWithdrawalManager.sol#496) is not in mixedCase



    
496         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._addr (UserWithdrawalManager.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._staderConfig (UserWithdrawalManager.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.AUCTION_CONTRACT() (UserWithdrawalManager.sol#32) is not in mixedCase



    
32     function AUCTION_CONTRACT() external view returns (bytes32);



```

```
Parameter UserWithdrawalManager.getRequestIdsByUser(address)._owner (UserWithdrawalManager.sol#3650) is not in mixedCase



    
3650     function getRequestIdsByUser(address _owner) external view override returns (uint256[] memory) {



```

```
Parameter UserWithdrawalManager.deleteRequestId(uint256,address)._owner (UserWithdrawalManager.sol#3672) is not in mixedCase



    
3672     function deleteRequestId(uint256 _requestId, address _owner) internal {



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (UserWithdrawalManager.sol#478) is not in mixedCase



    
478         uint256 _validatorId,



```

```
Parameter UserWithdrawalManager.requestWithdraw(uint256,address)._ethXAmount (UserWithdrawalManager.sol#3561) is not in mixedCase



    
3561     function requestWithdraw(uint256 _ethXAmount, address _owner) external override whenNotPaused returns (uint256) {



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._staderConfig (UserWithdrawalManager.sol#468) is not in mixedCase



    
468         IStaderConfig _staderConfig,



```

```
Variable PausableUpgradeable.__gap (UserWithdrawalManager.sol#2428) is not in mixedCase



    
2428     uint256[49] private __gap;



```

```
Function IStaderConfig.USER_WITHDRAW_MANAGER() (UserWithdrawalManager.sol#44) is not in mixedCase



    
44     function USER_WITHDRAW_MANAGER() external view returns (bytes32);



```

```
Parameter UserWithdrawalManager.initialize(address,address)._admin (UserWithdrawalManager.sol#3520) is not in mixedCase



    
3520     function initialize(address _admin, address _staderConfig) public initializer {



```

```
Function IStaderConfig.NODE_EL_REWARD_VAULT_IMPLEMENTATION() (UserWithdrawalManager.sol#56) is not in mixedCase



    
56     function NODE_EL_REWARD_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._staderConfig (UserWithdrawalManager.sol#513) is not in mixedCase



    
513         IStaderConfig _staderConfig



```

```
Function IStaderConfig.VAULT_FACTORY() (UserWithdrawalManager.sol#28) is not in mixedCase



    
28     function VAULT_FACTORY() external view returns (bytes32);



```

```
Function IStaderConfig.STAKE_POOL_MANAGER() (UserWithdrawalManager.sol#38) is not in mixedCase



    
38     function STAKE_POOL_MANAGER() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._poolId (UserWithdrawalManager.sol#493) is not in mixedCase



    
493         uint8 _poolId,



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._contractName (UserWithdrawalManager.sol#469) is not in mixedCase



    
469         bytes32 _contractName



```

```
Function ERC20Upgradeable.__ERC20_init_unchained(string,string) (UserWithdrawalManager.sol#1168-1171) is not in mixedCase



    
1168     function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {
1169         _name = name_;
1170         _symbol = symbol_;
1171     }



```

```
Function IStaderConfig.OPERATOR() (UserWithdrawalManager.sol#68) is not in mixedCase



    
68     function OPERATOR() external view returns (bytes32);



```

```
Function ERC20Upgradeable.__ERC20_init(string,string) (UserWithdrawalManager.sol#1164-1166) is not in mixedCase



    
1164     function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {
1165         __ERC20_init_unchained(name_, symbol_);
1166     }



```

```
Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init() (UserWithdrawalManager.sol#3441-3443) is not in mixedCase



    
3441     function __ReentrancyGuard_init() internal onlyInitializing {
3442         __ReentrancyGuard_init_unchained();
3443     }



```

```
Function ERC165Upgradeable.__ERC165_init_unchained() (UserWithdrawalManager.sol#2052-2053) is not in mixedCase



    
2052     function __ERC165_init_unchained() internal onlyInitializing {
2053     }



```

```
Function ContextUpgradeable.__Context_init_unchained() (UserWithdrawalManager.sol#1102-1103) is not in mixedCase



    
1102     function __Context_init_unchained() internal onlyInitializing {
1103     }



```

```
Function IStaderConfig.PERMISSIONED_POOL() (UserWithdrawalManager.sol#36) is not in mixedCase



    
36     function PERMISSIONED_POOL() external view returns (bytes32);



```

```
Function INodeRegistry.POOL_ID() (UserWithdrawalManager.sol#302) is not in mixedCase



    
302     function POOL_ID() external view returns (uint8);



```

```
Parameter UserWithdrawalManager.requestWithdraw(uint256,address)._owner (UserWithdrawalManager.sol#3561) is not in mixedCase



    
3561     function requestWithdraw(uint256 _ethXAmount, address _owner) external override whenNotPaused returns (uint256) {



```

```
Parameter UtilLib.sendValue(address,uint256)._receiver (UserWithdrawalManager.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Function IStaderConfig.PERMISSIONLESS_POOL() (UserWithdrawalManager.sol#42) is not in mixedCase



    
42     function PERMISSIONLESS_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._addr (UserWithdrawalManager.sol#479) is not in mixedCase



    
479         address _addr,



```

```
Parameter UserWithdrawalManager.deleteRequestId(uint256,address)._requestId (UserWithdrawalManager.sol#3672) is not in mixedCase



    
3672     function deleteRequestId(uint256 _requestId, address _owner) internal {



```

```
Variable ERC20Upgradeable.__gap (UserWithdrawalManager.sol#1509) is not in mixedCase



    
1509     uint256[45] private __gap;



```

```
Parameter ETHx.initialize(address,address)._staderConfig (UserWithdrawalManager.sol#2449) is not in mixedCase



    
2449     function initialize(address _admin, address _staderConfig) public initializer {



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (UserWithdrawalManager.sol#480) is not in mixedCase



    
480         IStaderConfig _staderConfig



```

```
Variable ReentrancyGuardUpgradeable.__gap (UserWithdrawalManager.sol#3481) is not in mixedCase



    
3481     uint256[49] private __gap;



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._staderConfig (UserWithdrawalManager.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._staderConfig (UserWithdrawalManager.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Parameter ETHx.updateStaderConfig(address)._staderConfig (UserWithdrawalManager.sol#2505) is not in mixedCase



    
2505     function updateStaderConfig(address _staderConfig) external onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Function IStaderConfig.SD_COLLATERAL() (UserWithdrawalManager.sol#24) is not in mixedCase



    
24     function SD_COLLATERAL() external view returns (bytes32);



```

```
Parameter UserWithdrawalManager.initialize(address,address)._staderConfig (UserWithdrawalManager.sol#3520) is not in mixedCase



    
3520     function initialize(address _admin, address _staderConfig) public initializer {



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._pubkey (UserWithdrawalManager.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function AccessControlUpgradeable.__AccessControl_init() (UserWithdrawalManager.sol#2108-2109) is not in mixedCase



    
2108     function __AccessControl_init() internal onlyInitializing {
2109     }



```

```
Parameter UserWithdrawalManager.sendValue(address,uint256)._recipient (UserWithdrawalManager.sol#3689) is not in mixedCase



    
3689     function sendValue(address payable _recipient, uint256 _amount) internal {



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._addr (UserWithdrawalManager.sol#495) is not in mixedCase



    
495         address _addr,



```

```
Parameter UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig)._staderConfig (UserWithdrawalManager.sol#585) is not in mixedCase



    
585         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._addr (UserWithdrawalManager.sol#467) is not in mixedCase



    
467         address _addr,



```

```
Function IStaderConfig.PERMISSIONED_SOCIALIZING_POOL() (UserWithdrawalManager.sol#52) is not in mixedCase



    
52     function PERMISSIONED_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Function IStaderConfig.PENALTY_CONTRACT() (UserWithdrawalManager.sol#34) is not in mixedCase



    
34     function PENALTY_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._poolId (UserWithdrawalManager.sol#477) is not in mixedCase



    
477         uint8 _poolId,



```

```
Variable ERC165Upgradeable.__gap (UserWithdrawalManager.sol#2066) is not in mixedCase



    
2066     uint256[50] private __gap;



```

```
Function IStaderConfig.ETH_DEPOSIT_CONTRACT() (UserWithdrawalManager.sol#40) is not in mixedCase



    
40     function ETH_DEPOSIT_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._operator (UserWithdrawalManager.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.ETH_BALANCE_POR_FEED() (UserWithdrawalManager.sol#61) is not in mixedCase



    
61     function ETH_BALANCE_POR_FEED() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._poolId (UserWithdrawalManager.sol#510) is not in mixedCase



    
510         uint8 _poolId,



```

```
Parameter UtilLib.getPubkeyRoot(bytes)._pubkey (UserWithdrawalManager.sol#561) is not in mixedCase



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {



```

```
Function PausableUpgradeable.__Pausable_init() (UserWithdrawalManager.sol#2346-2348) is not in mixedCase



    
2346     function __Pausable_init() internal onlyInitializing {
2347         __Pausable_init_unchained();
2348     }



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._poolId (UserWithdrawalManager.sol#523) is not in mixedCase



    
523         uint8 _poolId,



```

```
Function IStaderConfig.MANAGER() (UserWithdrawalManager.sol#66) is not in mixedCase



    
66     function MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.STADER_INSURANCE_FUND() (UserWithdrawalManager.sol#46) is not in mixedCase



    
46     function STADER_INSURANCE_FUND() external view returns (bytes32);



```

```
Function ContextUpgradeable.__Context_init() (UserWithdrawalManager.sol#1099-1100) is not in mixedCase



    
1099     function __Context_init() internal onlyInitializing {
1100     }



```

```
Function IStaderConfig.PERMISSIONLESS_NODE_REGISTRY() (UserWithdrawalManager.sol#50) is not in mixedCase



    
50     function PERMISSIONLESS_NODE_REGISTRY() external view returns (bytes32);



```

```
Function ERC165Upgradeable.__ERC165_init() (UserWithdrawalManager.sol#2049-2050) is not in mixedCase



    
2049     function __ERC165_init() internal onlyInitializing {
2050     }



```

```
Parameter UserWithdrawalManager.sendValue(address,uint256)._amount (UserWithdrawalManager.sol#3689) is not in mixedCase



    
3689     function sendValue(address payable _recipient, uint256 _amount) internal {



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._staderConfig (UserWithdrawalManager.sol#525) is not in mixedCase



    
525         IStaderConfig _staderConfig



```

```
Parameter UtilLib.checkNonZeroAddress(address)._address (UserWithdrawalManager.sol#448) is not in mixedCase



    
448     function checkNonZeroAddress(address _address) internal pure {



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._addr (UserWithdrawalManager.sol#512) is not in mixedCase



    
512         address _addr,



```

```
Function PausableUpgradeable.__Pausable_init_unchained() (UserWithdrawalManager.sol#2350-2352) is not in mixedCase



    
2350     function __Pausable_init_unchained() internal onlyInitializing {
2351         _paused = false;
2352     }



```

### UtilLib.sol


```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._addr (UtilLib.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.PERMISSIONED_NODE_REGISTRY() (UtilLib.sol#48) is not in mixedCase



    
48     function PERMISSIONED_NODE_REGISTRY() external view returns (bytes32);



```

```
Function IStaderConfig.PERMISSIONLESS_SOCIALIZING_POOL() (UtilLib.sol#54) is not in mixedCase



    
54     function PERMISSIONLESS_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._validatorId (UtilLib.sol#511) is not in mixedCase



    
511         uint256 _validatorId,



```

```
Function IStaderConfig.VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() (UtilLib.sol#58) is not in mixedCase



    
58     function VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._staderConfig (UtilLib.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.POOL_SELECTOR() (UtilLib.sol#22) is not in mixedCase



    
22     function POOL_SELECTOR() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._poolId (UtilLib.sol#535) is not in mixedCase



    
535         uint8 _poolId,



```

```
Function IStaderConfig.ETHX_SUPPLY_POR_FEED() (UtilLib.sol#63) is not in mixedCase



    
63     function ETHX_SUPPLY_POR_FEED() external view returns (bytes32);



```

```
Function IStaderConfig.POOL_UTILS() (UtilLib.sol#20) is not in mixedCase



    
20     function POOL_UTILS() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._operatorId (UtilLib.sol#536) is not in mixedCase



    
536         uint256 _operatorId,



```

```
Function IStaderConfig.OPERATOR_REWARD_COLLECTOR() (UtilLib.sol#26) is not in mixedCase



    
26     function OPERATOR_REWARD_COLLECTOR() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._staderConfig (UtilLib.sol#537) is not in mixedCase



    
537         IStaderConfig _staderConfig



```

```
Parameter UtilLib.sendValue(address,uint256)._amount (UtilLib.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (UtilLib.sol#494) is not in mixedCase



    
494         uint256 _validatorId,



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._validatorId (UtilLib.sol#524) is not in mixedCase



    
524         uint256 _validatorId,



```

```
Function IStaderConfig.STADER_ORACLE() (UtilLib.sol#30) is not in mixedCase



    
30     function STADER_ORACLE() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (UtilLib.sol#496) is not in mixedCase



    
496         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._addr (UtilLib.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._staderConfig (UtilLib.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.AUCTION_CONTRACT() (UtilLib.sol#32) is not in mixedCase



    
32     function AUCTION_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (UtilLib.sol#478) is not in mixedCase



    
478         uint256 _validatorId,



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._staderConfig (UtilLib.sol#468) is not in mixedCase



    
468         IStaderConfig _staderConfig,



```

```
Function IStaderConfig.USER_WITHDRAW_MANAGER() (UtilLib.sol#44) is not in mixedCase



    
44     function USER_WITHDRAW_MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.NODE_EL_REWARD_VAULT_IMPLEMENTATION() (UtilLib.sol#56) is not in mixedCase



    
56     function NODE_EL_REWARD_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._staderConfig (UtilLib.sol#513) is not in mixedCase



    
513         IStaderConfig _staderConfig



```

```
Function IStaderConfig.VAULT_FACTORY() (UtilLib.sol#28) is not in mixedCase



    
28     function VAULT_FACTORY() external view returns (bytes32);



```

```
Function IStaderConfig.STAKE_POOL_MANAGER() (UtilLib.sol#38) is not in mixedCase



    
38     function STAKE_POOL_MANAGER() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._poolId (UtilLib.sol#493) is not in mixedCase



    
493         uint8 _poolId,



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._contractName (UtilLib.sol#469) is not in mixedCase



    
469         bytes32 _contractName



```

```
Function IStaderConfig.OPERATOR() (UtilLib.sol#68) is not in mixedCase



    
68     function OPERATOR() external view returns (bytes32);



```

```
Function IStaderConfig.PERMISSIONED_POOL() (UtilLib.sol#36) is not in mixedCase



    
36     function PERMISSIONED_POOL() external view returns (bytes32);



```

```
Function INodeRegistry.POOL_ID() (UtilLib.sol#302) is not in mixedCase



    
302     function POOL_ID() external view returns (uint8);



```

```
Parameter UtilLib.sendValue(address,uint256)._receiver (UtilLib.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Function IStaderConfig.PERMISSIONLESS_POOL() (UtilLib.sol#42) is not in mixedCase



    
42     function PERMISSIONLESS_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._addr (UtilLib.sol#479) is not in mixedCase



    
479         address _addr,



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (UtilLib.sol#480) is not in mixedCase



    
480         IStaderConfig _staderConfig



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._staderConfig (UtilLib.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._staderConfig (UtilLib.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.SD_COLLATERAL() (UtilLib.sol#24) is not in mixedCase



    
24     function SD_COLLATERAL() external view returns (bytes32);



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._pubkey (UtilLib.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._addr (UtilLib.sol#495) is not in mixedCase



    
495         address _addr,



```

```
Parameter UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig)._staderConfig (UtilLib.sol#585) is not in mixedCase



    
585         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._addr (UtilLib.sol#467) is not in mixedCase



    
467         address _addr,



```

```
Function IStaderConfig.PERMISSIONED_SOCIALIZING_POOL() (UtilLib.sol#52) is not in mixedCase



    
52     function PERMISSIONED_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Function IStaderConfig.PENALTY_CONTRACT() (UtilLib.sol#34) is not in mixedCase



    
34     function PENALTY_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._poolId (UtilLib.sol#477) is not in mixedCase



    
477         uint8 _poolId,



```

```
Function IStaderConfig.ETH_DEPOSIT_CONTRACT() (UtilLib.sol#40) is not in mixedCase



    
40     function ETH_DEPOSIT_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._operator (UtilLib.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.ETH_BALANCE_POR_FEED() (UtilLib.sol#61) is not in mixedCase



    
61     function ETH_BALANCE_POR_FEED() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._poolId (UtilLib.sol#510) is not in mixedCase



    
510         uint8 _poolId,



```

```
Parameter UtilLib.getPubkeyRoot(bytes)._pubkey (UtilLib.sol#561) is not in mixedCase



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._poolId (UtilLib.sol#523) is not in mixedCase



    
523         uint8 _poolId,



```

```
Function IStaderConfig.MANAGER() (UtilLib.sol#66) is not in mixedCase



    
66     function MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.STADER_INSURANCE_FUND() (UtilLib.sol#46) is not in mixedCase



    
46     function STADER_INSURANCE_FUND() external view returns (bytes32);



```

```
Function IStaderConfig.PERMISSIONLESS_NODE_REGISTRY() (UtilLib.sol#50) is not in mixedCase



    
50     function PERMISSIONLESS_NODE_REGISTRY() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._staderConfig (UtilLib.sol#525) is not in mixedCase



    
525         IStaderConfig _staderConfig



```

```
Parameter UtilLib.checkNonZeroAddress(address)._address (UtilLib.sol#448) is not in mixedCase



    
448     function checkNonZeroAddress(address _address) internal pure {



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._addr (UtilLib.sol#512) is not in mixedCase



    
512         address _addr,



```

### ValidatorWithdrawalVault.sol


```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._addr (ValidatorWithdrawalVault.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.PERMISSIONED_NODE_REGISTRY() (ValidatorWithdrawalVault.sol#48) is not in mixedCase



    
48     function PERMISSIONED_NODE_REGISTRY() external view returns (bytes32);



```

```
Function IStaderConfig.PERMISSIONLESS_SOCIALIZING_POOL() (ValidatorWithdrawalVault.sol#54) is not in mixedCase



    
54     function PERMISSIONLESS_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._validatorId (ValidatorWithdrawalVault.sol#511) is not in mixedCase



    
511         uint256 _validatorId,



```

```
Function IStaderConfig.VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() (ValidatorWithdrawalVault.sol#58) is not in mixedCase



    
58     function VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._staderConfig (ValidatorWithdrawalVault.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.POOL_SELECTOR() (ValidatorWithdrawalVault.sol#22) is not in mixedCase



    
22     function POOL_SELECTOR() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._poolId (ValidatorWithdrawalVault.sol#535) is not in mixedCase



    
535         uint8 _poolId,



```

```
Function IStaderConfig.ETHX_SUPPLY_POR_FEED() (ValidatorWithdrawalVault.sol#63) is not in mixedCase



    
63     function ETHX_SUPPLY_POR_FEED() external view returns (bytes32);



```

```
Function IStaderConfig.POOL_UTILS() (ValidatorWithdrawalVault.sol#20) is not in mixedCase



    
20     function POOL_UTILS() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._operatorId (ValidatorWithdrawalVault.sol#536) is not in mixedCase



    
536         uint256 _operatorId,



```

```
Function IStaderConfig.OPERATOR_REWARD_COLLECTOR() (ValidatorWithdrawalVault.sol#26) is not in mixedCase



    
26     function OPERATOR_REWARD_COLLECTOR() external view returns (bytes32);



```

```
Parameter ValidatorWithdrawalVault.getOperatorAddress(uint8,uint256,IStaderConfig)._poolId (ValidatorWithdrawalVault.sol#1283) is not in mixedCase



    
1283         uint8 _poolId,



```

```
Parameter ValidatorWithdrawalVault.getCollateralETH(uint8,IStaderConfig)._poolId (ValidatorWithdrawalVault.sol#1278) is not in mixedCase



    
1278     function getCollateralETH(uint8 _poolId, IStaderConfig _staderConfig) internal view returns (uint256) {



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._staderConfig (ValidatorWithdrawalVault.sol#537) is not in mixedCase



    
537         IStaderConfig _staderConfig



```

```
Parameter UtilLib.sendValue(address,uint256)._amount (ValidatorWithdrawalVault.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Parameter ValidatorWithdrawalVault.getUpdatedPenaltyAmount(uint8,uint256,IStaderConfig)._validatorId (ValidatorWithdrawalVault.sol#1292) is not in mixedCase



    
1292         uint256 _validatorId,



```

```
Parameter ValidatorWithdrawalVault.getUpdatedPenaltyAmount(uint8,uint256,IStaderConfig)._poolId (ValidatorWithdrawalVault.sol#1291) is not in mixedCase



    
1291         uint8 _poolId,



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (ValidatorWithdrawalVault.sol#494) is not in mixedCase



    
494         uint256 _validatorId,



```

```
Parameter ValidatorWithdrawalVault.getCollateralETH(uint8,IStaderConfig)._staderConfig (ValidatorWithdrawalVault.sol#1278) is not in mixedCase



    
1278     function getCollateralETH(uint8 _poolId, IStaderConfig _staderConfig) internal view returns (uint256) {



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._validatorId (ValidatorWithdrawalVault.sol#524) is not in mixedCase



    
524         uint256 _validatorId,



```

```
Function IStaderConfig.STADER_ORACLE() (ValidatorWithdrawalVault.sol#30) is not in mixedCase



    
30     function STADER_ORACLE() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (ValidatorWithdrawalVault.sol#496) is not in mixedCase



    
496         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._addr (ValidatorWithdrawalVault.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._staderConfig (ValidatorWithdrawalVault.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.AUCTION_CONTRACT() (ValidatorWithdrawalVault.sol#32) is not in mixedCase



    
32     function AUCTION_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (ValidatorWithdrawalVault.sol#478) is not in mixedCase



    
478         uint256 _validatorId,



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._staderConfig (ValidatorWithdrawalVault.sol#468) is not in mixedCase



    
468         IStaderConfig _staderConfig,



```

```
Function IStaderConfig.USER_WITHDRAW_MANAGER() (ValidatorWithdrawalVault.sol#44) is not in mixedCase



    
44     function USER_WITHDRAW_MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.NODE_EL_REWARD_VAULT_IMPLEMENTATION() (ValidatorWithdrawalVault.sol#56) is not in mixedCase



    
56     function NODE_EL_REWARD_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._staderConfig (ValidatorWithdrawalVault.sol#513) is not in mixedCase



    
513         IStaderConfig _staderConfig



```

```
Function IStaderConfig.VAULT_FACTORY() (ValidatorWithdrawalVault.sol#28) is not in mixedCase



    
28     function VAULT_FACTORY() external view returns (bytes32);



```

```
Function IStaderConfig.STAKE_POOL_MANAGER() (ValidatorWithdrawalVault.sol#38) is not in mixedCase



    
38     function STAKE_POOL_MANAGER() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._poolId (ValidatorWithdrawalVault.sol#493) is not in mixedCase



    
493         uint8 _poolId,



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._contractName (ValidatorWithdrawalVault.sol#469) is not in mixedCase



    
469         bytes32 _contractName



```

```
Parameter VaultProxy.initialise(bool,uint8,uint256,address)._poolId (ValidatorWithdrawalVault.sol#617) is not in mixedCase



    
617         uint8 _poolId,



```

```
Function IStaderConfig.OPERATOR() (ValidatorWithdrawalVault.sol#68) is not in mixedCase



    
68     function OPERATOR() external view returns (bytes32);



```

```
Function IStaderConfig.PERMISSIONED_POOL() (ValidatorWithdrawalVault.sol#36) is not in mixedCase



    
36     function PERMISSIONED_POOL() external view returns (bytes32);



```

```
Parameter VaultProxy.fallback(bytes)._input (ValidatorWithdrawalVault.sol#636) is not in mixedCase



    
636     fallback(bytes calldata _input) external payable returns (bytes memory) {



```

```
Function INodeRegistry.POOL_ID() (ValidatorWithdrawalVault.sol#302) is not in mixedCase



    
302     function POOL_ID() external view returns (uint8);



```

```
Parameter UtilLib.sendValue(address,uint256)._receiver (ValidatorWithdrawalVault.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Parameter VaultProxy.initialise(bool,uint8,uint256,address)._staderConfig (ValidatorWithdrawalVault.sol#619) is not in mixedCase



    
619         address _staderConfig



```

```
Function IStaderConfig.PERMISSIONLESS_POOL() (ValidatorWithdrawalVault.sol#42) is not in mixedCase



    
42     function PERMISSIONLESS_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._addr (ValidatorWithdrawalVault.sol#479) is not in mixedCase



    
479         address _addr,



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (ValidatorWithdrawalVault.sol#480) is not in mixedCase



    
480         IStaderConfig _staderConfig



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._staderConfig (ValidatorWithdrawalVault.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._staderConfig (ValidatorWithdrawalVault.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.SD_COLLATERAL() (ValidatorWithdrawalVault.sol#24) is not in mixedCase



    
24     function SD_COLLATERAL() external view returns (bytes32);



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._pubkey (ValidatorWithdrawalVault.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Parameter ValidatorWithdrawalVault.getUpdatedPenaltyAmount(uint8,uint256,IStaderConfig)._staderConfig (ValidatorWithdrawalVault.sol#1293) is not in mixedCase



    
1293         IStaderConfig _staderConfig



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._addr (ValidatorWithdrawalVault.sol#495) is not in mixedCase



    
495         address _addr,



```

```
Parameter UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig)._staderConfig (ValidatorWithdrawalVault.sol#585) is not in mixedCase



    
585         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._addr (ValidatorWithdrawalVault.sol#467) is not in mixedCase



    
467         address _addr,



```

```
Parameter VaultProxy.updateOwner(address)._owner (ValidatorWithdrawalVault.sol#663) is not in mixedCase



    
663     function updateOwner(address _owner) external override onlyOwner {



```

```
Function IStaderConfig.PERMISSIONED_SOCIALIZING_POOL() (ValidatorWithdrawalVault.sol#52) is not in mixedCase



    
52     function PERMISSIONED_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Function IStaderConfig.PENALTY_CONTRACT() (ValidatorWithdrawalVault.sol#34) is not in mixedCase



    
34     function PENALTY_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._poolId (ValidatorWithdrawalVault.sol#477) is not in mixedCase



    
477         uint8 _poolId,



```

```
Parameter VaultProxy.initialise(bool,uint8,uint256,address)._isValidatorWithdrawalVault (ValidatorWithdrawalVault.sol#616) is not in mixedCase



    
616         bool _isValidatorWithdrawalVault,



```

```
Function IStaderConfig.ETH_DEPOSIT_CONTRACT() (ValidatorWithdrawalVault.sol#40) is not in mixedCase



    
40     function ETH_DEPOSIT_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._operator (ValidatorWithdrawalVault.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Parameter ValidatorWithdrawalVault.getOperatorAddress(uint8,uint256,IStaderConfig)._validatorId (ValidatorWithdrawalVault.sol#1284) is not in mixedCase



    
1284         uint256 _validatorId,



```

```
Function IStaderConfig.ETH_BALANCE_POR_FEED() (ValidatorWithdrawalVault.sol#61) is not in mixedCase



    
61     function ETH_BALANCE_POR_FEED() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._poolId (ValidatorWithdrawalVault.sol#510) is not in mixedCase



    
510         uint8 _poolId,



```

```
Parameter UtilLib.getPubkeyRoot(bytes)._pubkey (ValidatorWithdrawalVault.sol#561) is not in mixedCase



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._poolId (ValidatorWithdrawalVault.sol#523) is not in mixedCase



    
523         uint8 _poolId,



```

```
Function IStaderConfig.MANAGER() (ValidatorWithdrawalVault.sol#66) is not in mixedCase



    
66     function MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.STADER_INSURANCE_FUND() (ValidatorWithdrawalVault.sol#46) is not in mixedCase



    
46     function STADER_INSURANCE_FUND() external view returns (bytes32);



```

```
Function IStaderConfig.PERMISSIONLESS_NODE_REGISTRY() (ValidatorWithdrawalVault.sol#50) is not in mixedCase



    
50     function PERMISSIONLESS_NODE_REGISTRY() external view returns (bytes32);



```

```
Parameter VaultProxy.initialise(bool,uint8,uint256,address)._id (ValidatorWithdrawalVault.sol#618) is not in mixedCase



    
618         uint256 _id,



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._staderConfig (ValidatorWithdrawalVault.sol#525) is not in mixedCase



    
525         IStaderConfig _staderConfig



```

```
Parameter UtilLib.checkNonZeroAddress(address)._address (ValidatorWithdrawalVault.sol#448) is not in mixedCase



    
448     function checkNonZeroAddress(address _address) internal pure {



```

```
Parameter ValidatorWithdrawalVault.getOperatorAddress(uint8,uint256,IStaderConfig)._staderConfig (ValidatorWithdrawalVault.sol#1285) is not in mixedCase



    
1285         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._addr (ValidatorWithdrawalVault.sol#512) is not in mixedCase



    
512         address _addr,



```

```
Parameter VaultProxy.updateStaderConfig(address)._staderConfig (ValidatorWithdrawalVault.sol#652) is not in mixedCase



    
652     function updateStaderConfig(address _staderConfig) external override onlyOwner {



```

### VaultFactory.sol


```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._addr (VaultFactory.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.PERMISSIONED_NODE_REGISTRY() (VaultFactory.sol#48) is not in mixedCase



    
48     function PERMISSIONED_NODE_REGISTRY() external view returns (bytes32);



```

```
Function IStaderConfig.PERMISSIONLESS_SOCIALIZING_POOL() (VaultFactory.sol#54) is not in mixedCase



    
54     function PERMISSIONLESS_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._validatorId (VaultFactory.sol#511) is not in mixedCase



    
511         uint256 _validatorId,



```

```
Function IStaderConfig.VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() (VaultFactory.sol#58) is not in mixedCase



    
58     function VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._staderConfig (VaultFactory.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.POOL_SELECTOR() (VaultFactory.sol#22) is not in mixedCase



    
22     function POOL_SELECTOR() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._poolId (VaultFactory.sol#535) is not in mixedCase



    
535         uint8 _poolId,



```

```
Parameter VaultFactory.computeNodeELRewardVaultAddress(uint8,uint256)._poolId (VaultFactory.sol#2075) is not in mixedCase



    
2075     function computeNodeELRewardVaultAddress(uint8 _poolId, uint256 _operatorId)



```

```
Parameter VaultFactory.initialize(address,address)._admin (VaultFactory.sol#2027) is not in mixedCase



    
2027     function initialize(address _admin, address _staderConfig) external initializer {



```

```
Function IStaderConfig.ETHX_SUPPLY_POR_FEED() (VaultFactory.sol#63) is not in mixedCase



    
63     function ETHX_SUPPLY_POR_FEED() external view returns (bytes32);



```

```
Function IStaderConfig.POOL_UTILS() (VaultFactory.sol#20) is not in mixedCase



    
20     function POOL_UTILS() external view returns (bytes32);



```

```
Function AccessControlUpgradeable.__AccessControl_init_unchained() (VaultFactory.sol#1808-1809) is not in mixedCase



    
1808     function __AccessControl_init_unchained() internal onlyInitializing {
1809     }



```

```
Parameter VaultFactory.deployNodeELRewardVault(uint8,uint256)._poolId (VaultFactory.sol#2052) is not in mixedCase



    
2052     function deployNodeELRewardVault(uint8 _poolId, uint256 _operatorId)



```

```
Parameter VaultFactory.getValidatorWithdrawCredential(address)._withdrawVault (VaultFactory.sol#2085) is not in mixedCase



    
2085     function getValidatorWithdrawCredential(address _withdrawVault) external pure override returns (bytes memory) {



```

```
Parameter VaultFactory.computeWithdrawVaultAddress(uint8,uint256,uint256)._operatorId (VaultFactory.sol#2068) is not in mixedCase



    
2068         uint256 _operatorId,



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._operatorId (VaultFactory.sol#536) is not in mixedCase



    
536         uint256 _operatorId,



```

```
Function IStaderConfig.OPERATOR_REWARD_COLLECTOR() (VaultFactory.sol#26) is not in mixedCase



    
26     function OPERATOR_REWARD_COLLECTOR() external view returns (bytes32);



```

```
Variable ContextUpgradeable.__gap (VaultFactory.sol#1294) is not in mixedCase



    
1294     uint256[50] private __gap;



```

```
Variable AccessControlUpgradeable.__gap (VaultFactory.sol#2013) is not in mixedCase



    
2013     uint256[49] private __gap;



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._staderConfig (VaultFactory.sol#537) is not in mixedCase



    
537         IStaderConfig _staderConfig



```

```
Parameter UtilLib.sendValue(address,uint256)._amount (VaultFactory.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (VaultFactory.sol#494) is not in mixedCase



    
494         uint256 _validatorId,



```

```
Parameter VaultFactory.updateStaderConfig(address)._staderConfig (VaultFactory.sol#2090) is not in mixedCase



    
2090     function updateStaderConfig(address _staderConfig) external override onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._validatorId (VaultFactory.sol#524) is not in mixedCase



    
524         uint256 _validatorId,



```

```
Function IStaderConfig.STADER_ORACLE() (VaultFactory.sol#30) is not in mixedCase



    
30     function STADER_ORACLE() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (VaultFactory.sol#496) is not in mixedCase



    
496         IStaderConfig _staderConfig



```

```
Parameter VaultFactory.deployWithdrawVault(uint8,uint256,uint256,uint256)._validatorCount (VaultFactory.sol#2041) is not in mixedCase



    
2041         uint256 _validatorCount,



```

```
Parameter VaultFactory.deployWithdrawVault(uint8,uint256,uint256,uint256)._poolId (VaultFactory.sol#2039) is not in mixedCase



    
2039         uint8 _poolId,



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._addr (VaultFactory.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Parameter VaultFactory.initialize(address,address)._staderConfig (VaultFactory.sol#2027) is not in mixedCase



    
2027     function initialize(address _admin, address _staderConfig) external initializer {



```

```
Parameter VaultFactory.computeNodeELRewardVaultAddress(uint8,uint256)._operatorId (VaultFactory.sol#2075) is not in mixedCase



    
2075     function computeNodeELRewardVaultAddress(uint8 _poolId, uint256 _operatorId)



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._staderConfig (VaultFactory.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.AUCTION_CONTRACT() (VaultFactory.sol#32) is not in mixedCase



    
32     function AUCTION_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (VaultFactory.sol#478) is not in mixedCase



    
478         uint256 _validatorId,



```

```
Parameter VaultFactory.updateVaultProxyAddress(address)._vaultProxyImpl (VaultFactory.sol#2097) is not in mixedCase



    
2097     function updateVaultProxyAddress(address _vaultProxyImpl) external override onlyRole(DEFAULT_ADMIN_ROLE) {



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._staderConfig (VaultFactory.sol#468) is not in mixedCase



    
468         IStaderConfig _staderConfig,



```

```
Function IStaderConfig.USER_WITHDRAW_MANAGER() (VaultFactory.sol#44) is not in mixedCase



    
44     function USER_WITHDRAW_MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.NODE_EL_REWARD_VAULT_IMPLEMENTATION() (VaultFactory.sol#56) is not in mixedCase



    
56     function NODE_EL_REWARD_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._staderConfig (VaultFactory.sol#513) is not in mixedCase



    
513         IStaderConfig _staderConfig



```

```
Function IStaderConfig.VAULT_FACTORY() (VaultFactory.sol#28) is not in mixedCase



    
28     function VAULT_FACTORY() external view returns (bytes32);



```

```
Function IStaderConfig.STAKE_POOL_MANAGER() (VaultFactory.sol#38) is not in mixedCase



    
38     function STAKE_POOL_MANAGER() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._poolId (VaultFactory.sol#493) is not in mixedCase



    
493         uint8 _poolId,



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._contractName (VaultFactory.sol#469) is not in mixedCase



    
469         bytes32 _contractName



```

```
Parameter VaultProxy.initialise(bool,uint8,uint256,address)._poolId (VaultFactory.sol#617) is not in mixedCase



    
617         uint8 _poolId,



```

```
Parameter VaultFactory.computeWithdrawVaultAddress(uint8,uint256,uint256)._validatorCount (VaultFactory.sol#2069) is not in mixedCase



    
2069         uint256 _validatorCount



```

```
Function IStaderConfig.OPERATOR() (VaultFactory.sol#68) is not in mixedCase



    
68     function OPERATOR() external view returns (bytes32);



```

```
Parameter VaultFactory.deployWithdrawVault(uint8,uint256,uint256,uint256)._operatorId (VaultFactory.sol#2040) is not in mixedCase



    
2040         uint256 _operatorId,



```

```
Function ERC165Upgradeable.__ERC165_init_unchained() (VaultFactory.sol#1749-1750) is not in mixedCase



    
1749     function __ERC165_init_unchained() internal onlyInitializing {
1750     }



```

```
Function ContextUpgradeable.__Context_init_unchained() (VaultFactory.sol#1279-1280) is not in mixedCase



    
1279     function __Context_init_unchained() internal onlyInitializing {
1280     }



```

```
Function IStaderConfig.PERMISSIONED_POOL() (VaultFactory.sol#36) is not in mixedCase



    
36     function PERMISSIONED_POOL() external view returns (bytes32);



```

```
Parameter VaultProxy.fallback(bytes)._input (VaultFactory.sol#636) is not in mixedCase



    
636     fallback(bytes calldata _input) external payable returns (bytes memory) {



```

```
Function INodeRegistry.POOL_ID() (VaultFactory.sol#302) is not in mixedCase



    
302     function POOL_ID() external view returns (uint8);



```

```
Parameter UtilLib.sendValue(address,uint256)._receiver (VaultFactory.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Parameter VaultProxy.initialise(bool,uint8,uint256,address)._staderConfig (VaultFactory.sol#619) is not in mixedCase



    
619         address _staderConfig



```

```
Function IStaderConfig.PERMISSIONLESS_POOL() (VaultFactory.sol#42) is not in mixedCase



    
42     function PERMISSIONLESS_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._addr (VaultFactory.sol#479) is not in mixedCase



    
479         address _addr,



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (VaultFactory.sol#480) is not in mixedCase



    
480         IStaderConfig _staderConfig



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._staderConfig (VaultFactory.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._staderConfig (VaultFactory.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.SD_COLLATERAL() (VaultFactory.sol#24) is not in mixedCase



    
24     function SD_COLLATERAL() external view returns (bytes32);



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._pubkey (VaultFactory.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function AccessControlUpgradeable.__AccessControl_init() (VaultFactory.sol#1805-1806) is not in mixedCase



    
1805     function __AccessControl_init() internal onlyInitializing {
1806     }



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._addr (VaultFactory.sol#495) is not in mixedCase



    
495         address _addr,



```

```
Parameter UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig)._staderConfig (VaultFactory.sol#585) is not in mixedCase



    
585         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._addr (VaultFactory.sol#467) is not in mixedCase



    
467         address _addr,



```

```
Parameter VaultProxy.updateOwner(address)._owner (VaultFactory.sol#663) is not in mixedCase



    
663     function updateOwner(address _owner) external override onlyOwner {



```

```
Function IStaderConfig.PERMISSIONED_SOCIALIZING_POOL() (VaultFactory.sol#52) is not in mixedCase



    
52     function PERMISSIONED_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Function IStaderConfig.PENALTY_CONTRACT() (VaultFactory.sol#34) is not in mixedCase



    
34     function PENALTY_CONTRACT() external view returns (bytes32);



```

```
Parameter VaultFactory.deployWithdrawVault(uint8,uint256,uint256,uint256)._validatorId (VaultFactory.sol#2042) is not in mixedCase



    
2042         uint256 _validatorId



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._poolId (VaultFactory.sol#477) is not in mixedCase



    
477         uint8 _poolId,



```

```
Variable ERC165Upgradeable.__gap (VaultFactory.sol#1763) is not in mixedCase



    
1763     uint256[50] private __gap;



```

```
Parameter VaultProxy.initialise(bool,uint8,uint256,address)._isValidatorWithdrawalVault (VaultFactory.sol#616) is not in mixedCase



    
616         bool _isValidatorWithdrawalVault,



```

```
Function IStaderConfig.ETH_DEPOSIT_CONTRACT() (VaultFactory.sol#40) is not in mixedCase



    
40     function ETH_DEPOSIT_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._operator (VaultFactory.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.ETH_BALANCE_POR_FEED() (VaultFactory.sol#61) is not in mixedCase



    
61     function ETH_BALANCE_POR_FEED() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._poolId (VaultFactory.sol#510) is not in mixedCase



    
510         uint8 _poolId,



```

```
Parameter UtilLib.getPubkeyRoot(bytes)._pubkey (VaultFactory.sol#561) is not in mixedCase



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {



```

```
Function IVaultFactory.NODE_REGISTRY_CONTRACT() (VaultFactory.sol#684) is not in mixedCase



    
684     function NODE_REGISTRY_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._poolId (VaultFactory.sol#523) is not in mixedCase



    
523         uint8 _poolId,



```

```
Function IStaderConfig.MANAGER() (VaultFactory.sol#66) is not in mixedCase



    
66     function MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.STADER_INSURANCE_FUND() (VaultFactory.sol#46) is not in mixedCase



    
46     function STADER_INSURANCE_FUND() external view returns (bytes32);



```

```
Parameter VaultFactory.computeWithdrawVaultAddress(uint8,uint256,uint256)._poolId (VaultFactory.sol#2067) is not in mixedCase



    
2067         uint8 _poolId,



```

```
Function ContextUpgradeable.__Context_init() (VaultFactory.sol#1276-1277) is not in mixedCase



    
1276     function __Context_init() internal onlyInitializing {
1277     }



```

```
Parameter VaultFactory.deployNodeELRewardVault(uint8,uint256)._operatorId (VaultFactory.sol#2052) is not in mixedCase



    
2052     function deployNodeELRewardVault(uint8 _poolId, uint256 _operatorId)



```

```
Function IStaderConfig.PERMISSIONLESS_NODE_REGISTRY() (VaultFactory.sol#50) is not in mixedCase



    
50     function PERMISSIONLESS_NODE_REGISTRY() external view returns (bytes32);



```

```
Parameter VaultProxy.initialise(bool,uint8,uint256,address)._id (VaultFactory.sol#618) is not in mixedCase



    
618         uint256 _id,



```

```
Function ERC165Upgradeable.__ERC165_init() (VaultFactory.sol#1746-1747) is not in mixedCase



    
1746     function __ERC165_init() internal onlyInitializing {
1747     }



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._staderConfig (VaultFactory.sol#525) is not in mixedCase



    
525         IStaderConfig _staderConfig



```

```
Parameter UtilLib.checkNonZeroAddress(address)._address (VaultFactory.sol#448) is not in mixedCase



    
448     function checkNonZeroAddress(address _address) internal pure {



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._addr (VaultFactory.sol#512) is not in mixedCase



    
512         address _addr,



```

```
Parameter VaultProxy.updateStaderConfig(address)._staderConfig (VaultFactory.sol#652) is not in mixedCase



    
652     function updateStaderConfig(address _staderConfig) external override onlyOwner {



```

### VaultProxy.sol


```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._addr (VaultProxy.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.PERMISSIONED_NODE_REGISTRY() (VaultProxy.sol#48) is not in mixedCase



    
48     function PERMISSIONED_NODE_REGISTRY() external view returns (bytes32);



```

```
Function IStaderConfig.PERMISSIONLESS_SOCIALIZING_POOL() (VaultProxy.sol#54) is not in mixedCase



    
54     function PERMISSIONLESS_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._validatorId (VaultProxy.sol#511) is not in mixedCase



    
511         uint256 _validatorId,



```

```
Function IStaderConfig.VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() (VaultProxy.sol#58) is not in mixedCase



    
58     function VALIDATOR_WITHDRAWAL_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._staderConfig (VaultProxy.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.POOL_SELECTOR() (VaultProxy.sol#22) is not in mixedCase



    
22     function POOL_SELECTOR() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._poolId (VaultProxy.sol#535) is not in mixedCase



    
535         uint8 _poolId,



```

```
Function IStaderConfig.ETHX_SUPPLY_POR_FEED() (VaultProxy.sol#63) is not in mixedCase



    
63     function ETHX_SUPPLY_POR_FEED() external view returns (bytes32);



```

```
Function IStaderConfig.POOL_UTILS() (VaultProxy.sol#20) is not in mixedCase



    
20     function POOL_UTILS() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._operatorId (VaultProxy.sol#536) is not in mixedCase



    
536         uint256 _operatorId,



```

```
Function IStaderConfig.OPERATOR_REWARD_COLLECTOR() (VaultProxy.sol#26) is not in mixedCase



    
26     function OPERATOR_REWARD_COLLECTOR() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorAddressByOperatorId(uint8,uint256,IStaderConfig)._staderConfig (VaultProxy.sol#537) is not in mixedCase



    
537         IStaderConfig _staderConfig



```

```
Parameter UtilLib.sendValue(address,uint256)._amount (VaultProxy.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (VaultProxy.sol#494) is not in mixedCase



    
494         uint256 _validatorId,



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._validatorId (VaultProxy.sol#524) is not in mixedCase



    
524         uint256 _validatorId,



```

```
Function IStaderConfig.STADER_ORACLE() (VaultProxy.sol#30) is not in mixedCase



    
30     function STADER_ORACLE() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (VaultProxy.sol#496) is not in mixedCase



    
496         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyManagerRole(address,IStaderConfig)._addr (VaultProxy.sol#453) is not in mixedCase



    
453     function onlyManagerRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._staderConfig (VaultProxy.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.AUCTION_CONTRACT() (VaultProxy.sol#32) is not in mixedCase



    
32     function AUCTION_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._validatorId (VaultProxy.sol#478) is not in mixedCase



    
478         uint256 _validatorId,



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._staderConfig (VaultProxy.sol#468) is not in mixedCase



    
468         IStaderConfig _staderConfig,



```

```
Function IStaderConfig.USER_WITHDRAW_MANAGER() (VaultProxy.sol#44) is not in mixedCase



    
44     function USER_WITHDRAW_MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.NODE_EL_REWARD_VAULT_IMPLEMENTATION() (VaultProxy.sol#56) is not in mixedCase



    
56     function NODE_EL_REWARD_VAULT_IMPLEMENTATION() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._staderConfig (VaultProxy.sol#513) is not in mixedCase



    
513         IStaderConfig _staderConfig



```

```
Function IStaderConfig.VAULT_FACTORY() (VaultProxy.sol#28) is not in mixedCase



    
28     function VAULT_FACTORY() external view returns (bytes32);



```

```
Function IStaderConfig.STAKE_POOL_MANAGER() (VaultProxy.sol#38) is not in mixedCase



    
38     function STAKE_POOL_MANAGER() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._poolId (VaultProxy.sol#493) is not in mixedCase



    
493         uint8 _poolId,



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._contractName (VaultProxy.sol#469) is not in mixedCase



    
469         bytes32 _contractName



```

```
Parameter VaultProxy.initialise(bool,uint8,uint256,address)._poolId (VaultProxy.sol#617) is not in mixedCase



    
617         uint8 _poolId,



```

```
Function IStaderConfig.OPERATOR() (VaultProxy.sol#68) is not in mixedCase



    
68     function OPERATOR() external view returns (bytes32);



```

```
Function IStaderConfig.PERMISSIONED_POOL() (VaultProxy.sol#36) is not in mixedCase



    
36     function PERMISSIONED_POOL() external view returns (bytes32);



```

```
Parameter VaultProxy.fallback(bytes)._input (VaultProxy.sol#636) is not in mixedCase



    
636     fallback(bytes calldata _input) external payable returns (bytes memory) {



```

```
Function INodeRegistry.POOL_ID() (VaultProxy.sol#302) is not in mixedCase



    
302     function POOL_ID() external view returns (uint8);



```

```
Parameter UtilLib.sendValue(address,uint256)._receiver (VaultProxy.sol#594) is not in mixedCase



    
594     function sendValue(address _receiver, uint256 _amount) internal {



```

```
Parameter VaultProxy.initialise(bool,uint8,uint256,address)._staderConfig (VaultProxy.sol#619) is not in mixedCase



    
619         address _staderConfig



```

```
Function IStaderConfig.PERMISSIONLESS_POOL() (VaultProxy.sol#42) is not in mixedCase



    
42     function PERMISSIONLESS_POOL() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._addr (VaultProxy.sol#479) is not in mixedCase



    
479         address _addr,



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._staderConfig (VaultProxy.sol#480) is not in mixedCase



    
480         IStaderConfig _staderConfig



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._staderConfig (VaultProxy.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Parameter UtilLib.onlyOperatorRole(address,IStaderConfig)._staderConfig (VaultProxy.sol#459) is not in mixedCase



    
459     function onlyOperatorRole(address _addr, IStaderConfig _staderConfig) internal view {



```

```
Function IStaderConfig.SD_COLLATERAL() (VaultProxy.sol#24) is not in mixedCase



    
24     function SD_COLLATERAL() external view returns (bytes32);



```

```
Parameter UtilLib.getValidatorSettleStatus(bytes,IStaderConfig)._pubkey (VaultProxy.sol#570) is not in mixedCase



    
570     function getValidatorSettleStatus(bytes calldata _pubkey, IStaderConfig _staderConfig)



```

```
Parameter UtilLib.getOperatorForValidSender(uint8,uint256,address,IStaderConfig)._addr (VaultProxy.sol#495) is not in mixedCase



    
495         address _addr,



```

```
Parameter UtilLib.computeExchangeRate(uint256,uint256,IStaderConfig)._staderConfig (VaultProxy.sol#585) is not in mixedCase



    
585         IStaderConfig _staderConfig



```

```
Parameter UtilLib.onlyStaderContract(address,IStaderConfig,bytes32)._addr (VaultProxy.sol#467) is not in mixedCase



    
467         address _addr,



```

```
Parameter VaultProxy.updateOwner(address)._owner (VaultProxy.sol#663) is not in mixedCase



    
663     function updateOwner(address _owner) external override onlyOwner {



```

```
Function IStaderConfig.PERMISSIONED_SOCIALIZING_POOL() (VaultProxy.sol#52) is not in mixedCase



    
52     function PERMISSIONED_SOCIALIZING_POOL() external view returns (bytes32);



```

```
Function IStaderConfig.PENALTY_CONTRACT() (VaultProxy.sol#34) is not in mixedCase



    
34     function PENALTY_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getPubkeyForValidSender(uint8,uint256,address,IStaderConfig)._poolId (VaultProxy.sol#477) is not in mixedCase



    
477         uint8 _poolId,



```

```
Parameter VaultProxy.initialise(bool,uint8,uint256,address)._isValidatorWithdrawalVault (VaultProxy.sol#616) is not in mixedCase



    
616         bool _isValidatorWithdrawalVault,



```

```
Function IStaderConfig.ETH_DEPOSIT_CONTRACT() (VaultProxy.sol#40) is not in mixedCase



    
40     function ETH_DEPOSIT_CONTRACT() external view returns (bytes32);



```

```
Parameter UtilLib.getOperatorRewardAddress(address,IStaderConfig)._operator (VaultProxy.sol#545) is not in mixedCase



    
545     function getOperatorRewardAddress(address _operator, IStaderConfig _staderConfig)



```

```
Function IStaderConfig.ETH_BALANCE_POR_FEED() (VaultProxy.sol#61) is not in mixedCase



    
61     function ETH_BALANCE_POR_FEED() external view returns (bytes32);



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._poolId (VaultProxy.sol#510) is not in mixedCase



    
510         uint8 _poolId,



```

```
Parameter UtilLib.getPubkeyRoot(bytes)._pubkey (VaultProxy.sol#561) is not in mixedCase



    
561     function getPubkeyRoot(bytes calldata _pubkey) internal pure returns (bytes32) {



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._poolId (VaultProxy.sol#523) is not in mixedCase



    
523         uint8 _poolId,



```

```
Function IStaderConfig.MANAGER() (VaultProxy.sol#66) is not in mixedCase



    
66     function MANAGER() external view returns (bytes32);



```

```
Function IStaderConfig.STADER_INSURANCE_FUND() (VaultProxy.sol#46) is not in mixedCase



    
46     function STADER_INSURANCE_FUND() external view returns (bytes32);



```

```
Function IStaderConfig.PERMISSIONLESS_NODE_REGISTRY() (VaultProxy.sol#50) is not in mixedCase



    
50     function PERMISSIONLESS_NODE_REGISTRY() external view returns (bytes32);



```

```
Parameter VaultProxy.initialise(bool,uint8,uint256,address)._id (VaultProxy.sol#618) is not in mixedCase



    
618         uint256 _id,



```

```
Parameter UtilLib.getOperatorAddressByValidatorId(uint8,uint256,IStaderConfig)._staderConfig (VaultProxy.sol#525) is not in mixedCase



    
525         IStaderConfig _staderConfig



```

```
Parameter UtilLib.checkNonZeroAddress(address)._address (VaultProxy.sol#448) is not in mixedCase



    
448     function checkNonZeroAddress(address _address) internal pure {



```

```
Parameter UtilLib.onlyValidatorWithdrawVault(uint8,uint256,address,IStaderConfig)._addr (VaultProxy.sol#512) is not in mixedCase



    
512         address _addr,



```

```
Parameter VaultProxy.updateStaderConfig(address)._staderConfig (VaultProxy.sol#652) is not in mixedCase



    
652     function updateStaderConfig(address _staderConfig) external override onlyOwner {



```

## costly-loop
### Severity: Informational

### PermissionedNodeRegistry.sol


```
PermissionedNodeRegistry.allocateValidatorsAndUpdateOperatorId(uint256) (PermissionedNodeRegistry.sol#2622-2673) has costly operations inside a loop:
	- operatorIdForExcessDeposit = i_scope_0 (PermissionedNodeRegistry.sol#2668)



    
2668                     operatorIdForExcessDeposit = i;



```

```
PermissionedNodeRegistry._deactivateNodeOperator(uint256) (PermissionedNodeRegistry.sol#3190-3194) has costly operations inside a loop:
	- totalActiveOperatorCount -- (PermissionedNodeRegistry.sol#3192)



    
3192         totalActiveOperatorCount--;



```

```
PermissionedNodeRegistry.addValidatorKeys(bytes[],bytes[],bytes[]) (PermissionedNodeRegistry.sol#2570-2611) has costly operations inside a loop:
	- nextValidatorId ++ (PermissionedNodeRegistry.sol#2606)



    
2606             nextValidatorId++;



```

### PermissionedPool.sol


```
PermissionedPool.increasePreDepositValidatorCount(uint256) (PermissionedPool.sol#2635-2637) has costly operations inside a loop:
	- preDepositValidatorCount += _count (PermissionedPool.sol#2636)



    
2636         preDepositValidatorCount += _count;



```

### PermissionlessNodeRegistry.sol


```
PermissionlessNodeRegistry.markKeyReadyToDeposit(uint256) (PermissionlessNodeRegistry.sol#2879-2883) has costly operations inside a loop:
	- validatorQueueSize ++ (PermissionlessNodeRegistry.sol#2882)



    
2882         validatorQueueSize++;



```

```
PermissionlessNodeRegistry.addValidatorKeys(bytes[],bytes[],bytes[]) (PermissionlessNodeRegistry.sol#2386-2433) has costly operations inside a loop:
	- nextValidatorId ++ (PermissionlessNodeRegistry.sol#2423)



    
2423             nextValidatorId++;



```

### PoolSelector.sol


```
PoolSelector.poolAllocationForExcessETHDeposit(uint256) (PoolSelector.sol#2354-2389) has costly operations inside a loop:
	- poolIdArrayIndexForExcessDeposit = i (PoolSelector.sol#2382)



    
2382                 poolIdArrayIndexForExcessDeposit = i;



```

### StaderStakePoolsManager.sol


```
StaderStakePoolsManager.depositETHOverTargetWeight() (StaderStakePoolsManager.sol#3805-3836) has costly operations inside a loop:
	- lastExcessETHDepositBlock = block.number (StaderStakePoolsManager.sol#3831)



    
3831             lastExcessETHDepositBlock = block.number;



```

### UserWithdrawalManager.sol


```
UserWithdrawalManager.finalizeUserWithdrawalRequest() (UserWithdrawalManager.sol#3583-3625) has costly operations inside a loop:
	- ethRequestedForWithdraw -= requiredEth (UserWithdrawalManager.sol#3611)



    
3611             ethRequestedForWithdraw -= requiredEth;



```

## similar-names
### Severity: Informational

### PermissionlessNodeRegistry.sol


```
Variable PermissionlessNodeRegistry.markValidatorReadyToDeposit(bytes[],bytes[],bytes[]).validatorId_scope_1 (PermissionlessNodeRegistry.sol#2477) is too similar to PermissionlessNodeRegistry.markValidatorReadyToDeposit(bytes[],bytes[],bytes[]).validatorId_scope_3 (PermissionlessNodeRegistry.sol#2487)



    
2477             uint256 validatorId = validatorIdByPubkey[_frontRunPubkey[i]];



```

### StaderConfig.sol


```
Variable StaderConfig.PENALTY_CONTRACT (StaderConfig.sol#1858) is too similar to StaderConfig.updatePenaltyContract(address)._penaltyContract (StaderConfig.sol#2030)



    
1858     bytes32 public constant override PENALTY_CONTRACT = keccak256('PENALTY_CONTRACT');



```

```
Variable StaderConfig.PERMISSIONED_POOL (StaderConfig.sol#1859) is too similar to StaderConfig.updatePermissionedPool(address)._permissionedPool (StaderConfig.sol#2034)



    
1859     bytes32 public constant override PERMISSIONED_POOL = keccak256('PERMISSIONED_POOL');



```

```
Variable StaderConfig.POOL_SELECTOR (StaderConfig.sol#1852) is too similar to StaderConfig.updatePoolSelector(address)._poolSelector (StaderConfig.sol#2006)



    
1852     bytes32 public constant override POOL_SELECTOR = keccak256('POOL_SELECTOR');



```

```
Variable StaderConfig.AUCTION_CONTRACT (StaderConfig.sol#1857) is too similar to StaderConfig.updateAuctionContract(address)._auctionContract (StaderConfig.sol#2022)



    
1857     bytes32 public constant override AUCTION_CONTRACT = keccak256('AuctionContract');



```

```
Variable StaderConfig.PERMISSIONLESS_POOL (StaderConfig.sol#1862) is too similar to StaderConfig.updatePermissionlessPool(address)._permissionlessPool (StaderConfig.sol#2042)



    
1862     bytes32 public constant override PERMISSIONLESS_POOL = keccak256('PERMISSIONLESS_POOL');



```

```
Variable StaderConfig.OPERATOR_REWARD_COLLECTOR (StaderConfig.sol#1854) is too similar to StaderConfig.updateOperatorRewardsCollector(address)._operatorRewardsCollector (StaderConfig.sol#2014)



    
1854     bytes32 public constant override OPERATOR_REWARD_COLLECTOR = keccak256('OPERATOR_REWARD_COLLECTOR');



```

```
Variable StaderConfig.STADER_TREASURY (StaderConfig.sol#1849) is too similar to StaderConfig.updateStaderTreasury(address)._staderTreasury (StaderConfig.sol#1996)



    
1849     bytes32 public constant STADER_TREASURY = keccak256('STADER_TREASURY');



```

```
Variable StaderConfig.VAULT_FACTORY (StaderConfig.sol#1855) is too similar to StaderConfig.updateVaultFactory(address)._vaultFactory (StaderConfig.sol#2018)



    
1855     bytes32 public constant override VAULT_FACTORY = keccak256('VAULT_FACTORY');



```

```
Variable StaderConfig.SD_COLLATERAL (StaderConfig.sol#1853) is too similar to StaderConfig.updateSDCollateral(address)._sdCollateral (StaderConfig.sol#2010)



    
1853     bytes32 public constant override SD_COLLATERAL = keccak256('SD_COLLATERAL');



```

```
Variable StaderConfig.STADER_ORACLE (StaderConfig.sol#1856) is too similar to StaderConfig.updateStaderOracle(address)._staderOracle (StaderConfig.sol#2026)



    
1856     bytes32 public constant override STADER_ORACLE = keccak256('STADER_ORACLE');



```

### StaderOracle.sol


```
Variable StaderOracle.attestSubmission(bytes32,bytes32)._submissionCountKey (StaderOracle.sol#3077) is too similar to StaderOracle.submissionCountKeys (StaderOracle.sol#2503)



    
3077     function attestSubmission(bytes32 _nodeSubmissionKey, bytes32 _submissionCountKey)



```

```
Variable StaderOracle.attestSubmission(bytes32,bytes32)._nodeSubmissionKey (StaderOracle.sol#3077) is too similar to StaderOracle.nodeSubmissionKeys (StaderOracle.sol#2502)



    
3077     function attestSubmission(bytes32 _nodeSubmissionKey, bytes32 _submissionCountKey)



```

## too-many-digits
### Severity: Informational

### VaultFactory.sol


```
ClonesUpgradeable.clone(address) (VaultFactory.sol#731-742) uses literals with too many digits:
	- mstore(uint256,uint256)(0x00,implementation << 0x60 >> 0xe8 | 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000) (VaultFactory.sol#736)



    
736             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))



```

```
ClonesUpgradeable.cloneDeterministic(address,bytes32) (VaultFactory.sol#751-762) uses literals with too many digits:
	- mstore(uint256,uint256)(0x00,implementation << 0x60 >> 0xe8 | 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000) (VaultFactory.sol#756)



    
756             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))



```

## constable-states
### Severity: Optimization

### ValidatorWithdrawalVault.sol


```
VaultProxy.vaultSettleStatus (ValidatorWithdrawalVault.sol#604) should be constant 



    
604     bool public override vaultSettleStatus;



```

### VaultFactory.sol


```
VaultProxy.vaultSettleStatus (VaultFactory.sol#604) should be constant 



    
604     bool public override vaultSettleStatus;



```

### VaultProxy.sol


```
VaultProxy.vaultSettleStatus (VaultProxy.sol#604) should be constant 



    
604     bool public override vaultSettleStatus;



```
