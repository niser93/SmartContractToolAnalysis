
# SLITHER ANALYSIS

## controlled-delegatecall
### Severity: High

### LlamaAbsolutePeerReview.sol


```
LlamaExecutor.execute(address,uint256,bool,bytes) (LlamaAbsolutePeerReview.sol#688-694) uses delegatecall to a input-controlled function id
	- (success,result) = target.delegatecall(data) (LlamaAbsolutePeerReview.sol#693)



    
693     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



```

### LlamaAbsoluteQuorum.sol


```
LlamaExecutor.execute(address,uint256,bool,bytes) (LlamaAbsoluteQuorum.sol#688-694) uses delegatecall to a input-controlled function id
	- (success,result) = target.delegatecall(data) (LlamaAbsoluteQuorum.sol#693)



    
693     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



```

### LlamaAccount.sol


```
LlamaAccount.execute(address,bool,bytes) (LlamaAccount.sol#5213-5247) uses delegatecall to a input-controlled function id
	- (success,result) = target.delegatecall(callData) (LlamaAccount.sol#5239)



    
5239       (success, result) = target.delegatecall(callData);



```

```
LlamaExecutor.execute(address,uint256,bool,bytes) (LlamaAccount.sol#2863-2869) uses delegatecall to a input-controlled function id
	- (success,result) = target.delegatecall(data) (LlamaAccount.sol#2868)



    
2868     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



```

### LlamaCore.sol


```
LlamaExecutor.execute(address,uint256,bool,bytes) (LlamaCore.sol#1925-1931) uses delegatecall to a input-controlled function id
	- (success,result) = target.delegatecall(data) (LlamaCore.sol#1930)



    
1930     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



```

### LlamaExecutor.sol


```
LlamaExecutor.execute(address,uint256,bool,bytes) (LlamaExecutor.sol#29-35) uses delegatecall to a input-controlled function id
	- (success,result) = target.delegatecall(data) (LlamaExecutor.sol#34)



    
34     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



```

### LlamaFactory.sol


```
LlamaExecutor.execute(address,uint256,bool,bytes) (LlamaFactory.sol#435-441) uses delegatecall to a input-controlled function id
	- (success,result) = target.delegatecall(data) (LlamaFactory.sol#440)



    
440     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



```

### LlamaGovernanceScript.sol


```
LlamaExecutor.execute(address,uint256,bool,bytes) (LlamaGovernanceScript.sol#456-462) uses delegatecall to a input-controlled function id
	- (success,result) = target.delegatecall(data) (LlamaGovernanceScript.sol#461)



    
461     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



```

### LlamaPolicy.sol


```
LlamaExecutor.execute(address,uint256,bool,bytes) (LlamaPolicy.sol#1960-1966) uses delegatecall to a input-controlled function id
	- (success,result) = target.delegatecall(data) (LlamaPolicy.sol#1965)



    
1965     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



```

### LlamaPolicyMetadataParamRegistry.sol


```
LlamaExecutor.execute(address,uint256,bool,bytes) (LlamaPolicyMetadataParamRegistry.sol#29-35) uses delegatecall to a input-controlled function id
	- (success,result) = target.delegatecall(data) (LlamaPolicyMetadataParamRegistry.sol#34)



    
34     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



```

### LlamaRelativeQuorum.sol


```
LlamaExecutor.execute(address,uint256,bool,bytes) (LlamaRelativeQuorum.sol#688-694) uses delegatecall to a input-controlled function id
	- (success,result) = target.delegatecall(data) (LlamaRelativeQuorum.sol#693)



    
693     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



```

## incorrect-shift
### Severity: High

### LlamaAbsolutePeerReview.sol


```
LibString.escapeHTML(string) (LlamaAbsolutePeerReview.sol#1611-1642) contains an incorrect shift operation: ! 1 << c_escapeHTML_asm_0 & 0x500000c400000000 (LlamaAbsolutePeerReview.sol#1627-1631)



    
1627                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
1628                     mstore8(result, c)
1629                     result := add(result, 1)
1630                     continue
1631                 }



```

```
LibString.escapeJSON(string) (LlamaAbsolutePeerReview.sol#1645-1691) contains an incorrect shift operation: ! 1 << c_escapeJSON_asm_0 & 0x3700 (LlamaAbsolutePeerReview.sol#1673-1680)



    
1673                 if iszero(and(shl(c, 1), 0x3700)) {
1674                     // Not in `["\b","\t","\n","\f","\d"]`.
1675                     mstore8(0x1d, mload(shr(4, c))) // Hex value.
1676                     mstore8(0x1e, mload(and(c, 15))) // Hex value.
1677                     mstore(result, mload(0x19)) // "\\u00XX".
1678                     result := add(result, 6)
1679                     continue
1680                 }



```

```
LibString.escapeJSON(string) (LlamaAbsolutePeerReview.sol#1645-1691) contains an incorrect shift operation: ! 1 << c_escapeJSON_asm_0 & e_escapeJSON_asm_0 (LlamaAbsolutePeerReview.sol#1662-1667)



    
1662                     if iszero(and(shl(c, 1), e)) {
1663                         // Not in `["\"","\\"]`.
1664                         mstore8(result, c)
1665                         result := add(result, 1)
1666                         continue
1667                     }



```

```
LibString.toCase(string,bool) (LlamaAbsolutePeerReview.sol#1570-1596) contains an incorrect shift operation: flags_toCase_asm_0 = 0x3ffffff << 70 + toUpper << 5 (LlamaAbsolutePeerReview.sol#1581)



    
1581                 let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)



```

### LlamaAbsoluteQuorum.sol


```
LibString.escapeHTML(string) (LlamaAbsoluteQuorum.sol#1611-1642) contains an incorrect shift operation: ! 1 << c_escapeHTML_asm_0 & 0x500000c400000000 (LlamaAbsoluteQuorum.sol#1627-1631)



    
1627                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
1628                     mstore8(result, c)
1629                     result := add(result, 1)
1630                     continue
1631                 }



```

```
LibString.escapeJSON(string) (LlamaAbsoluteQuorum.sol#1645-1691) contains an incorrect shift operation: ! 1 << c_escapeJSON_asm_0 & 0x3700 (LlamaAbsoluteQuorum.sol#1673-1680)



    
1673                 if iszero(and(shl(c, 1), 0x3700)) {
1674                     // Not in `["\b","\t","\n","\f","\d"]`.
1675                     mstore8(0x1d, mload(shr(4, c))) // Hex value.
1676                     mstore8(0x1e, mload(and(c, 15))) // Hex value.
1677                     mstore(result, mload(0x19)) // "\\u00XX".
1678                     result := add(result, 6)
1679                     continue
1680                 }



```

```
LibString.escapeJSON(string) (LlamaAbsoluteQuorum.sol#1645-1691) contains an incorrect shift operation: ! 1 << c_escapeJSON_asm_0 & e_escapeJSON_asm_0 (LlamaAbsoluteQuorum.sol#1662-1667)



    
1662                     if iszero(and(shl(c, 1), e)) {
1663                         // Not in `["\"","\\"]`.
1664                         mstore8(result, c)
1665                         result := add(result, 1)
1666                         continue
1667                     }



```

```
LibString.toCase(string,bool) (LlamaAbsoluteQuorum.sol#1570-1596) contains an incorrect shift operation: flags_toCase_asm_0 = 0x3ffffff << 70 + toUpper << 5 (LlamaAbsoluteQuorum.sol#1581)



    
1581                 let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)



```

### LlamaAccount.sol


```
LibString.escapeJSON(string) (LlamaAccount.sol#2205-2251) contains an incorrect shift operation: ! 1 << c_escapeJSON_asm_0 & 0x3700 (LlamaAccount.sol#2233-2240)



    
2233                 if iszero(and(shl(c, 1), 0x3700)) {
2234                     // Not in `["\b","\t","\n","\f","\d"]`.
2235                     mstore8(0x1d, mload(shr(4, c))) // Hex value.
2236                     mstore8(0x1e, mload(and(c, 15))) // Hex value.
2237                     mstore(result, mload(0x19)) // "\\u00XX".
2238                     result := add(result, 6)
2239                     continue
2240                 }



```

```
LibString.escapeHTML(string) (LlamaAccount.sol#2171-2202) contains an incorrect shift operation: ! 1 << c_escapeHTML_asm_0 & 0x500000c400000000 (LlamaAccount.sol#2187-2191)



    
2187                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
2188                     mstore8(result, c)
2189                     result := add(result, 1)
2190                     continue
2191                 }



```

```
LibString.escapeJSON(string) (LlamaAccount.sol#2205-2251) contains an incorrect shift operation: ! 1 << c_escapeJSON_asm_0 & e_escapeJSON_asm_0 (LlamaAccount.sol#2222-2227)



    
2222                     if iszero(and(shl(c, 1), e)) {
2223                         // Not in `["\"","\\"]`.
2224                         mstore8(result, c)
2225                         result := add(result, 1)
2226                         continue
2227                     }



```

```
LibString.toCase(string,bool) (LlamaAccount.sol#2130-2156) contains an incorrect shift operation: flags_toCase_asm_0 = 0x3ffffff << 70 + toUpper << 5 (LlamaAccount.sol#2141)



    
2141                 let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)



```

### LlamaCore.sol


```
LibString.escapeJSON(string) (LlamaCore.sol#1242-1288) contains an incorrect shift operation: ! 1 << c_escapeJSON_asm_0 & e_escapeJSON_asm_0 (LlamaCore.sol#1259-1264)



    
1259                     if iszero(and(shl(c, 1), e)) {
1260                         // Not in `["\"","\\"]`.
1261                         mstore8(result, c)
1262                         result := add(result, 1)
1263                         continue
1264                     }



```

```
LibString.toCase(string,bool) (LlamaCore.sol#1167-1193) contains an incorrect shift operation: flags_toCase_asm_0 = 0x3ffffff << 70 + toUpper << 5 (LlamaCore.sol#1178)



    
1178                 let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)



```

```
LibString.escapeJSON(string) (LlamaCore.sol#1242-1288) contains an incorrect shift operation: ! 1 << c_escapeJSON_asm_0 & 0x3700 (LlamaCore.sol#1270-1277)



    
1270                 if iszero(and(shl(c, 1), 0x3700)) {
1271                     // Not in `["\b","\t","\n","\f","\d"]`.
1272                     mstore8(0x1d, mload(shr(4, c))) // Hex value.
1273                     mstore8(0x1e, mload(and(c, 15))) // Hex value.
1274                     mstore(result, mload(0x19)) // "\\u00XX".
1275                     result := add(result, 6)
1276                     continue
1277                 }



```

```
LibString.escapeHTML(string) (LlamaCore.sol#1208-1239) contains an incorrect shift operation: ! 1 << c_escapeHTML_asm_0 & 0x500000c400000000 (LlamaCore.sol#1224-1228)



    
1224                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
1225                     mstore8(result, c)
1226                     result := add(result, 1)
1227                     continue
1228                 }



```

### LlamaFactory.sol


```
LibString.escapeHTML(string) (LlamaFactory.sol#1355-1386) contains an incorrect shift operation: ! 1 << c_escapeHTML_asm_0 & 0x500000c400000000 (LlamaFactory.sol#1371-1375)



    
1371                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
1372                     mstore8(result, c)
1373                     result := add(result, 1)
1374                     continue
1375                 }



```

```
LibString.escapeJSON(string) (LlamaFactory.sol#1389-1435) contains an incorrect shift operation: ! 1 << c_escapeJSON_asm_0 & 0x3700 (LlamaFactory.sol#1417-1424)



    
1417                 if iszero(and(shl(c, 1), 0x3700)) {
1418                     // Not in `["\b","\t","\n","\f","\d"]`.
1419                     mstore8(0x1d, mload(shr(4, c))) // Hex value.
1420                     mstore8(0x1e, mload(and(c, 15))) // Hex value.
1421                     mstore(result, mload(0x19)) // "\\u00XX".
1422                     result := add(result, 6)
1423                     continue
1424                 }



```

```
LibString.toCase(string,bool) (LlamaFactory.sol#1314-1340) contains an incorrect shift operation: flags_toCase_asm_0 = 0x3ffffff << 70 + toUpper << 5 (LlamaFactory.sol#1325)



    
1325                 let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)



```

```
LibString.escapeJSON(string) (LlamaFactory.sol#1389-1435) contains an incorrect shift operation: ! 1 << c_escapeJSON_asm_0 & e_escapeJSON_asm_0 (LlamaFactory.sol#1406-1411)



    
1406                     if iszero(and(shl(c, 1), e)) {
1407                         // Not in `["\"","\\"]`.
1408                         mstore8(result, c)
1409                         result := add(result, 1)
1410                         continue
1411                     }



```

### LlamaGovernanceScript.sol


```
LibString.escapeJSON(string) (LlamaGovernanceScript.sol#1413-1459) contains an incorrect shift operation: ! 1 << c_escapeJSON_asm_0 & e_escapeJSON_asm_0 (LlamaGovernanceScript.sol#1430-1435)



    
1430                     if iszero(and(shl(c, 1), e)) {
1431                         // Not in `["\"","\\"]`.
1432                         mstore8(result, c)
1433                         result := add(result, 1)
1434                         continue
1435                     }



```

```
LibString.escapeHTML(string) (LlamaGovernanceScript.sol#1379-1410) contains an incorrect shift operation: ! 1 << c_escapeHTML_asm_0 & 0x500000c400000000 (LlamaGovernanceScript.sol#1395-1399)



    
1395                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
1396                     mstore8(result, c)
1397                     result := add(result, 1)
1398                     continue
1399                 }



```

```
LibString.toCase(string,bool) (LlamaGovernanceScript.sol#1338-1364) contains an incorrect shift operation: flags_toCase_asm_0 = 0x3ffffff << 70 + toUpper << 5 (LlamaGovernanceScript.sol#1349)



    
1349                 let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)



```

```
LibString.escapeJSON(string) (LlamaGovernanceScript.sol#1413-1459) contains an incorrect shift operation: ! 1 << c_escapeJSON_asm_0 & 0x3700 (LlamaGovernanceScript.sol#1441-1448)



    
1441                 if iszero(and(shl(c, 1), 0x3700)) {
1442                     // Not in `["\b","\t","\n","\f","\d"]`.
1443                     mstore8(0x1d, mload(shr(4, c))) // Hex value.
1444                     mstore8(0x1e, mload(and(c, 15))) // Hex value.
1445                     mstore(result, mload(0x19)) // "\\u00XX".
1446                     result := add(result, 6)
1447                     continue
1448                 }



```

### LlamaPolicy.sol


```
LibString.escapeJSON(string) (LlamaPolicy.sol#949-995) contains an incorrect shift operation: ! 1 << c_escapeJSON_asm_0 & 0x3700 (LlamaPolicy.sol#977-984)



    
977                 if iszero(and(shl(c, 1), 0x3700)) {
978                     // Not in `["\b","\t","\n","\f","\d"]`.
979                     mstore8(0x1d, mload(shr(4, c))) // Hex value.
980                     mstore8(0x1e, mload(and(c, 15))) // Hex value.
981                     mstore(result, mload(0x19)) // "\\u00XX".
982                     result := add(result, 6)
983                     continue
984                 }



```

```
LibString.escapeJSON(string) (LlamaPolicy.sol#949-995) contains an incorrect shift operation: ! 1 << c_escapeJSON_asm_0 & e_escapeJSON_asm_0 (LlamaPolicy.sol#966-971)



    
966                     if iszero(and(shl(c, 1), e)) {
967                         // Not in `["\"","\\"]`.
968                         mstore8(result, c)
969                         result := add(result, 1)
970                         continue
971                     }



```

```
LibString.escapeHTML(string) (LlamaPolicy.sol#915-946) contains an incorrect shift operation: ! 1 << c_escapeHTML_asm_0 & 0x500000c400000000 (LlamaPolicy.sol#931-935)



    
931                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
932                     mstore8(result, c)
933                     result := add(result, 1)
934                     continue
935                 }



```

```
LibString.toCase(string,bool) (LlamaPolicy.sol#874-900) contains an incorrect shift operation: flags_toCase_asm_0 = 0x3ffffff << 70 + toUpper << 5 (LlamaPolicy.sol#885)



    
885                 let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)



```

### LlamaPolicyMetadata.sol


```
LibString.escapeJSON(string) (LlamaPolicyMetadata.sol#1037-1083) contains an incorrect shift operation: ! 1 << c_escapeJSON_asm_0 & e_escapeJSON_asm_0 (LlamaPolicyMetadata.sol#1054-1059)



    
1054                     if iszero(and(shl(c, 1), e)) {
1055                         // Not in `["\"","\\"]`.
1056                         mstore8(result, c)
1057                         result := add(result, 1)
1058                         continue
1059                     }



```

```
LibString.toCase(string,bool) (LlamaPolicyMetadata.sol#962-988) contains an incorrect shift operation: flags_toCase_asm_0 = 0x3ffffff << 70 + toUpper << 5 (LlamaPolicyMetadata.sol#973)



    
973                 let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)



```

```
LibString.escapeHTML(string) (LlamaPolicyMetadata.sol#1003-1034) contains an incorrect shift operation: ! 1 << c_escapeHTML_asm_0 & 0x500000c400000000 (LlamaPolicyMetadata.sol#1019-1023)



    
1019                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
1020                     mstore8(result, c)
1021                     result := add(result, 1)
1022                     continue
1023                 }



```

```
LibString.escapeJSON(string) (LlamaPolicyMetadata.sol#1037-1083) contains an incorrect shift operation: ! 1 << c_escapeJSON_asm_0 & 0x3700 (LlamaPolicyMetadata.sol#1065-1072)



    
1065                 if iszero(and(shl(c, 1), 0x3700)) {
1066                     // Not in `["\b","\t","\n","\f","\d"]`.
1067                     mstore8(0x1d, mload(shr(4, c))) // Hex value.
1068                     mstore8(0x1e, mload(and(c, 15))) // Hex value.
1069                     mstore(result, mload(0x19)) // "\\u00XX".
1070                     result := add(result, 6)
1071                     continue
1072                 }



```

### LlamaRelativeQuorum.sol


```
LibString.escapeHTML(string) (LlamaRelativeQuorum.sol#1611-1642) contains an incorrect shift operation: ! 1 << c_escapeHTML_asm_0 & 0x500000c400000000 (LlamaRelativeQuorum.sol#1627-1631)



    
1627                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
1628                     mstore8(result, c)
1629                     result := add(result, 1)
1630                     continue
1631                 }



```

```
LibString.escapeJSON(string) (LlamaRelativeQuorum.sol#1645-1691) contains an incorrect shift operation: ! 1 << c_escapeJSON_asm_0 & 0x3700 (LlamaRelativeQuorum.sol#1673-1680)



    
1673                 if iszero(and(shl(c, 1), 0x3700)) {
1674                     // Not in `["\b","\t","\n","\f","\d"]`.
1675                     mstore8(0x1d, mload(shr(4, c))) // Hex value.
1676                     mstore8(0x1e, mload(and(c, 15))) // Hex value.
1677                     mstore(result, mload(0x19)) // "\\u00XX".
1678                     result := add(result, 6)
1679                     continue
1680                 }



```

```
LibString.escapeJSON(string) (LlamaRelativeQuorum.sol#1645-1691) contains an incorrect shift operation: ! 1 << c_escapeJSON_asm_0 & e_escapeJSON_asm_0 (LlamaRelativeQuorum.sol#1662-1667)



    
1662                     if iszero(and(shl(c, 1), e)) {
1663                         // Not in `["\"","\\"]`.
1664                         mstore8(result, c)
1665                         result := add(result, 1)
1666                         continue
1667                     }



```

```
LibString.toCase(string,bool) (LlamaRelativeQuorum.sol#1570-1596) contains an incorrect shift operation: flags_toCase_asm_0 = 0x3ffffff << 70 + toUpper << 5 (LlamaRelativeQuorum.sol#1581)



    
1581                 let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)



```

## divide-before-multiply
### Severity: Medium

### LlamaAbsolutePeerReview.sol


```
FixedPointMathLib.rpow(uint256,uint256,uint256) (LlamaAbsolutePeerReview.sol#254-341) performs a multiplication on the result of a division:
	- x = xxRound_rpow_asm_0 / scalar (LlamaAbsolutePeerReview.sol#312)
	- zx_rpow_asm_0 = z * x (LlamaAbsolutePeerReview.sol#317)



    
312                     x := div(xxRound, scalar)



    
317                         let zx := mul(z, x)



```

```
Base64.encode(bytes) (LlamaAbsolutePeerReview.sol#2811-2882) performs a multiplication on the result of a division:
	- result = new string(4 * ((data.length + 2) / 3)) (LlamaAbsolutePeerReview.sol#2827)



    
2827         string memory result = new string(4 * ((data.length + 2) / 3));



```

### LlamaAbsoluteQuorum.sol


```
FixedPointMathLib.rpow(uint256,uint256,uint256) (LlamaAbsoluteQuorum.sol#254-341) performs a multiplication on the result of a division:
	- x = xxRound_rpow_asm_0 / scalar (LlamaAbsoluteQuorum.sol#312)
	- zx_rpow_asm_0 = z * x (LlamaAbsoluteQuorum.sol#317)



    
312                     x := div(xxRound, scalar)



    
317                         let zx := mul(z, x)



```

```
Base64.encode(bytes) (LlamaAbsoluteQuorum.sol#2811-2882) performs a multiplication on the result of a division:
	- result = new string(4 * ((data.length + 2) / 3)) (LlamaAbsoluteQuorum.sol#2827)



    
2827         string memory result = new string(4 * ((data.length + 2) / 3));



```

### LlamaAccount.sol


```
Base64.encode(bytes) (LlamaAccount.sol#2886-2957) performs a multiplication on the result of a division:
	- result = new string(4 * ((data.length + 2) / 3)) (LlamaAccount.sol#2902)



    
2902         string memory result = new string(4 * ((data.length + 2) / 3));



```

### LlamaCore.sol


```
Base64.encode(bytes) (LlamaCore.sol#1948-2019) performs a multiplication on the result of a division:
	- result = new string(4 * ((data.length + 2) / 3)) (LlamaCore.sol#1964)



    
1964         string memory result = new string(4 * ((data.length + 2) / 3));



```

### LlamaFactory.sol


```
Base64.encode(bytes) (LlamaFactory.sol#3448-3519) performs a multiplication on the result of a division:
	- result = new string(4 * ((data.length + 2) / 3)) (LlamaFactory.sol#3464)



    
3464         string memory result = new string(4 * ((data.length + 2) / 3));



```

### LlamaGovernanceScript.sol


```
Base64.encode(bytes) (LlamaGovernanceScript.sol#2579-2650) performs a multiplication on the result of a division:
	- result = new string(4 * ((data.length + 2) / 3)) (LlamaGovernanceScript.sol#2595)



    
2595         string memory result = new string(4 * ((data.length + 2) / 3));



```

### LlamaPolicy.sol


```
Base64.encode(bytes) (LlamaPolicy.sol#1986-2057) performs a multiplication on the result of a division:
	- result = new string(4 * ((data.length + 2) / 3)) (LlamaPolicy.sol#2002)



    
2002         string memory result = new string(4 * ((data.length + 2) / 3));



```

### LlamaPolicyMetadata.sol


```
Base64.encode(bytes) (LlamaPolicyMetadata.sol#18-89) performs a multiplication on the result of a division:
	- result = new string(4 * ((data.length + 2) / 3)) (LlamaPolicyMetadata.sol#34)



    
34         string memory result = new string(4 * ((data.length + 2) / 3));



```

### LlamaRelativeQuorum.sol


```
FixedPointMathLib.rpow(uint256,uint256,uint256) (LlamaRelativeQuorum.sol#254-341) performs a multiplication on the result of a division:
	- x = xxRound_rpow_asm_0 / scalar (LlamaRelativeQuorum.sol#312)
	- zx_rpow_asm_0 = z * x (LlamaRelativeQuorum.sol#317)



    
312                     x := div(xxRound, scalar)



    
317                         let zx := mul(z, x)



```

```
Base64.encode(bytes) (LlamaRelativeQuorum.sol#2811-2882) performs a multiplication on the result of a division:
	- result = new string(4 * ((data.length + 2) / 3)) (LlamaRelativeQuorum.sol#2827)



    
2827         string memory result = new string(4 * ((data.length + 2) / 3));



```

## incorrect-equality
### Severity: Medium

### LlamaAbsolutePeerReview.sol


```
Checkpoints._insert(Checkpoints.Checkpoint[],uint64,uint64,uint128) (LlamaAbsolutePeerReview.sol#1920-1948) uses a dangerous strict equality:
	- last.timestamp == timestamp (LlamaAbsolutePeerReview.sol#1936)



    
1936             if (last.timestamp == timestamp) {



```

```
LlamaPolicy._assertNoActionCreationsAtCurrentTimestamp() (LlamaAbsolutePeerReview.sol#2663-2668) uses a dangerous strict equality:
	- lastActionCreation == block.timestamp (LlamaAbsolutePeerReview.sol#2667)



    
2667     if (lastActionCreation == block.timestamp) revert ActionCreationAtSameTimestamp();



```

### LlamaAbsoluteQuorum.sol


```
Checkpoints._insert(Checkpoints.Checkpoint[],uint64,uint64,uint128) (LlamaAbsoluteQuorum.sol#1920-1948) uses a dangerous strict equality:
	- last.timestamp == timestamp (LlamaAbsoluteQuorum.sol#1936)



    
1936             if (last.timestamp == timestamp) {



```

```
LlamaPolicy._assertNoActionCreationsAtCurrentTimestamp() (LlamaAbsoluteQuorum.sol#2663-2668) uses a dangerous strict equality:
	- lastActionCreation == block.timestamp (LlamaAbsoluteQuorum.sol#2667)



    
2667     if (lastActionCreation == block.timestamp) revert ActionCreationAtSameTimestamp();



```

### LlamaAccount.sol


```
LlamaPolicy._assertNoActionCreationsAtCurrentTimestamp() (LlamaAccount.sol#3821-3826) uses a dangerous strict equality:
	- lastActionCreation == block.timestamp (LlamaAccount.sol#3825)



    
3825     if (lastActionCreation == block.timestamp) revert ActionCreationAtSameTimestamp();



```

```
Checkpoints._insert(Checkpoints.Checkpoint[],uint64,uint64,uint128) (LlamaAccount.sol#2480-2508) uses a dangerous strict equality:
	- last.timestamp == timestamp (LlamaAccount.sol#2496)



    
2496             if (last.timestamp == timestamp) {



```

### LlamaCore.sol


```
LlamaPolicy._assertNoActionCreationsAtCurrentTimestamp() (LlamaCore.sol#2883-2888) uses a dangerous strict equality:
	- lastActionCreation == block.timestamp (LlamaCore.sol#2887)



    
2887     if (lastActionCreation == block.timestamp) revert ActionCreationAtSameTimestamp();



```

```
Checkpoints._insert(Checkpoints.Checkpoint[],uint64,uint64,uint128) (LlamaCore.sol#1542-1570) uses a dangerous strict equality:
	- last.timestamp == timestamp (LlamaCore.sol#1558)



    
1558             if (last.timestamp == timestamp) {



```

### LlamaFactory.sol


```
Checkpoints._insert(Checkpoints.Checkpoint[],uint64,uint64,uint128) (LlamaFactory.sol#1664-1692) uses a dangerous strict equality:
	- last.timestamp == timestamp (LlamaFactory.sol#1680)



    
1680             if (last.timestamp == timestamp) {



```

```
LlamaPolicy._assertNoActionCreationsAtCurrentTimestamp() (LlamaFactory.sol#2410-2415) uses a dangerous strict equality:
	- lastActionCreation == block.timestamp (LlamaFactory.sol#2414)



    
2414     if (lastActionCreation == block.timestamp) revert ActionCreationAtSameTimestamp();



```

### LlamaGovernanceScript.sol


```
Checkpoints._insert(Checkpoints.Checkpoint[],uint64,uint64,uint128) (LlamaGovernanceScript.sol#1688-1716) uses a dangerous strict equality:
	- last.timestamp == timestamp (LlamaGovernanceScript.sol#1704)



    
1704             if (last.timestamp == timestamp) {



```

```
LlamaPolicy._assertNoActionCreationsAtCurrentTimestamp() (LlamaGovernanceScript.sol#2431-2436) uses a dangerous strict equality:
	- lastActionCreation == block.timestamp (LlamaGovernanceScript.sol#2435)



    
2435     if (lastActionCreation == block.timestamp) revert ActionCreationAtSameTimestamp();



```

### LlamaPolicy.sol


```
Checkpoints._insert(Checkpoints.Checkpoint[],uint64,uint64,uint128) (LlamaPolicy.sol#1249-1277) uses a dangerous strict equality:
	- last.timestamp == timestamp (LlamaPolicy.sol#1265)



    
1265             if (last.timestamp == timestamp) {



```

```
LlamaPolicy._assertNoActionCreationsAtCurrentTimestamp() (LlamaPolicy.sol#3861-3866) uses a dangerous strict equality:
	- lastActionCreation == block.timestamp (LlamaPolicy.sol#3865)



    
3865     if (lastActionCreation == block.timestamp) revert ActionCreationAtSameTimestamp();



```

### LlamaRelativeQuorum.sol


```
Checkpoints._insert(Checkpoints.Checkpoint[],uint64,uint64,uint128) (LlamaRelativeQuorum.sol#1920-1948) uses a dangerous strict equality:
	- last.timestamp == timestamp (LlamaRelativeQuorum.sol#1936)



    
1936             if (last.timestamp == timestamp) {



```

```
LlamaPolicy._assertNoActionCreationsAtCurrentTimestamp() (LlamaRelativeQuorum.sol#2663-2668) uses a dangerous strict equality:
	- lastActionCreation == block.timestamp (LlamaRelativeQuorum.sol#2667)



    
2667     if (lastActionCreation == block.timestamp) revert ActionCreationAtSameTimestamp();



```

## locked-ether
### Severity: Medium

### LlamaAbsolutePeerReview.sol


```
Contract locking ether found:
	Contract LlamaCore (LlamaAbsolutePeerReview.sol#3361-4144) has payable functions:
	 - LlamaCore.executeAction(ActionInfo) (LlamaAbsolutePeerReview.sol#3658-3684)
	But does not have a function to withdraw the ether



    
3361 contract LlamaCore is Initializable {
3362   // ======================================
3363   // ======== Errors and Modifiers ========
3364   // ======================================
3365 
3366   /// @dev Policyholder cannot cast if it has 0 quantity of role.
3367   /// @param policyholder Address of policyholder.
3368   /// @param role The role being used in the cast.
3369   error CannotCastWithZeroQuantity(address policyholder, uint8 role);
3370 
3371   /// @dev An action's target contract cannot be the executor.
3372   error CannotSetExecutorAsTarget();
3373 
3374   /// @dev Address cannot be used.
3375   error RestrictedAddress();
3376 
3377   /// @dev Policyholders can only cast once.
3378   error DuplicateCast();
3379 
3380   /// @dev Action execution failed.
3381   /// @param reason Data returned by the function called by the action.
3382   error FailedActionExecution(bytes reason);
3383 
3384   /// @dev `ActionInfo` does not hash to the correct value.
3385   error InfoHashMismatch();
3386 
3387   /// @dev `msg.value` does not equal the action's value.
3388   error IncorrectMsgValue();
3389 
3390   /// @dev The action is not in the expected state.
3391   /// @param current The current state of the action.
3392   error InvalidActionState(ActionState current);
3393 
3394   /// @dev The policyholder does not have the role at action creation time.
3395   error InvalidPolicyholder();
3396 
3397   /// @dev The recovered signer does not match the expected policyholder.
3398   error InvalidSignature();
3399 
3400   /// @dev The provided address does not map to a deployed strategy.
3401   error InvalidStrategy();
3402 
3403   /// @dev An action cannot queue successfully if it's `minExecutionTime` is less than `block.timestamp`.
3404   error MinExecutionTimeCannotBeInThePast();
3405 
3406   /// @dev Only callable by a Llama instance's executor.
3407   error OnlyLlama();
3408 
3409   /// @dev Policyholder does not have the permission ID to create the action.
3410   error PolicyholderDoesNotHavePermission();
3411 
3412   /// @dev If `block.timestamp` is less than `minExecutionTime`, the action cannot be executed.
3413   error MinExecutionTimeNotReached();
3414 
3415   /// @dev Strategies can only be created with valid logic contracts.
3416   error UnauthorizedStrategyLogic();
3417 
3418   /// @dev Accounts can only be created with valid logic contracts.
3419   error UnauthorizedAccountLogic();
3420 
3421   /// @dev Checks that the caller is the Llama Executor and reverts if not.
3422   modifier onlyLlama() {
3423     if (msg.sender != address(executor)) revert OnlyLlama();
3424     _;
3425   }
3426 
3427   // ========================
3428   // ======== Events ========
3429   // ========================
3430 
3431   /// @dev Emitted when an action is created.
3432   event ActionCreated(
3433     uint256 id,
3434     address indexed creator,
3435     uint8 role,
3436     ILlamaStrategy indexed strategy,
3437     address indexed target,
3438     uint256 value,
3439     bytes data,
3440     string description
3441   );
3442 
3443   /// @dev Emitted when an action is canceled.
3444   event ActionCanceled(uint256 id);
3445 
3446   /// @dev Emitted when an action guard is set.
3447   event ActionGuardSet(address indexed target, bytes4 indexed selector, ILlamaActionGuard actionGuard);
3448 
3449   /// @dev Emitted when an action is queued.
3450   event ActionQueued(
3451     uint256 id,
3452     address indexed caller,
3453     ILlamaStrategy indexed strategy,
3454     address indexed creator,
3455     uint256 minExecutionTime
3456   );
3457 
3458   /// @dev Emitted when an action is executed.
3459   event ActionExecuted(
3460     uint256 id, address indexed caller, ILlamaStrategy indexed strategy, address indexed creator, bytes result
3461   );
3462 
3463   /// @dev Emitted when an approval is cast.
3464   event ApprovalCast(uint256 id, address indexed policyholder, uint8 indexed role, uint256 quantity, string reason);
3465 
3466   /// @dev Emitted when a disapproval is cast.
3467   event DisapprovalCast(uint256 id, address indexed policyholder, uint8 indexed role, uint256 quantity, string reason);
3468 
3469   /// @dev Emitted when a strategy is created and authorized.
3470   event StrategyCreated(ILlamaStrategy strategy, ILlamaStrategy indexed strategyLogic, bytes initializationData);
3471 
3472   /// @dev Emitted when an account is created.
3473   event AccountCreated(ILlamaAccount account, ILlamaAccount indexed accountLogic, bytes initializationData);
3474 
3475   /// @dev Emitted when a script is authorized.
3476   event ScriptAuthorized(address script, bool authorized);
3477 
3478   // =================================================
3479   // ======== Constants and Storage Variables ========
3480   // =================================================
3481 
3482   /// @dev EIP-712 base typehash.
3483   bytes32 internal constant EIP712_DOMAIN_TYPEHASH =
3484     keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");
3485 
3486   /// @dev EIP-712 createAction typehash.
3487   bytes32 internal constant CREATE_ACTION_TYPEHASH = keccak256(
3488     "CreateAction(address policyholder,uint8 role,address strategy,address target,uint256 value,bytes data,string description,uint256 nonce)"
3489   );
3490 
3491   /// @dev EIP-712 castApproval typehash.
3492   bytes32 internal constant CAST_APPROVAL_TYPEHASH = keccak256(
3493     "CastApproval(address policyholder,uint8 role,ActionInfo actionInfo,string reason,uint256 nonce)ActionInfo(uint256 id,address creator,uint8 creatorRole,address strategy,address target,uint256 value,bytes data)"
3494   );
3495 
3496   /// @dev EIP-712 castDisapproval typehash.
3497   bytes32 internal constant CAST_DISAPPROVAL_TYPEHASH = keccak256(
3498     "CastDisapproval(address policyholder,uint8 role,ActionInfo actionInfo,string reason,uint256 nonce)ActionInfo(uint256 id,address creator,uint8 creatorRole,address strategy,address target,uint256 value,bytes data)"
3499   );
3500 
3501   /// @dev EIP-712 actionInfo typehash.
3502   bytes32 internal constant ACTION_INFO_TYPEHASH = keccak256(
3503     "ActionInfo(uint256 id,address creator,uint8 creatorRole,address strategy,address target,uint256 value,bytes data)"
3504   );
3505 
3506   /// @dev Mapping of actionIds to Actions.
3507   /// @dev Making this `public` results in stack too deep with no optimizer, but this data can be
3508   /// accessed with the `getAction` function so this is ok. We want the contracts to compile
3509   /// without the optimizer so `forge coverage` can be used.
3510   mapping(uint256 => Action) internal actions;
3511 
3512   /// @notice The contract that executes actions for this Llama instance.
3513   LlamaExecutor public executor;
3514 
3515   /// @notice The ERC721 contract that defines the policies for this Llama instance.
3516   /// @dev We intentionally put this first so it's packed with the `Initializable` storage
3517   // variables, which are the key variables we want to check before and after a delegatecall.
3518   LlamaPolicy public policy;
3519 
3520   /// @notice The `LlamaFactory` contract that deployed this Llama instance.
3521   LlamaFactory public factory;
3522 
3523   /// @notice Name of this Llama instance.
3524   string public name;
3525 
3526   /// @notice The current number of actions created.
3527   uint256 public actionsCount;
3528 
3529   /// @notice Mapping of actionIds to policyholders to approvals.
3530   mapping(uint256 => mapping(address => bool)) public approvals;
3531 
3532   /// @notice Mapping of actionIds to policyholders to disapprovals.
3533   mapping(uint256 => mapping(address => bool)) public disapprovals;
3534 
3535   /// @notice Mapping of all authorized strategies.
3536   mapping(ILlamaStrategy => bool) public strategies;
3537 
3538   /// @notice Mapping of all authorized scripts.
3539   mapping(address => bool) public authorizedScripts;
3540 
3541   /// @notice Mapping of policyholders to function selectors to current nonces for EIP-712 signatures.
3542   /// @dev This is used to prevent replay attacks by incrementing the nonce for each operation (`createAction`,
3543   /// `castApproval` and `castDisapproval`) signed by the policyholder.
3544   mapping(address => mapping(bytes4 => uint256)) public nonces;
3545 
3546   /// @notice Mapping of target to selector to actionGuard address.
3547   mapping(address target => mapping(bytes4 selector => ILlamaActionGuard)) public actionGuard;
3548 
3549   // ======================================================
3550   // ======== Contract Creation and Initialization ========
3551   // ======================================================
3552 
3553   constructor() {
3554     _disableInitializers();
3555   }
3556 
3557   /// @notice Initializes a new `LlamaCore` clone.
3558   /// @param _name The name of the `LlamaCore` clone.
3559   /// @param _policy This Llama instance's policy contract.
3560   /// @param _llamaStrategyLogic The Llama Strategy implementation (logic) contract.
3561   /// @param _llamaAccountLogic The Llama Account implementation (logic) contract.
3562   /// @param initialStrategies Array of initial strategy configurations.
3563   /// @param initialAccounts Array of initial account configurations.
3564   /// @return bootstrapPermissionId The permission ID that's used to set role permissions.
3565   function initialize(
3566     string memory _name,
3567     LlamaPolicy _policy,
3568     ILlamaStrategy _llamaStrategyLogic,
3569     ILlamaAccount _llamaAccountLogic,
3570     bytes[] calldata initialStrategies,
3571     bytes[] calldata initialAccounts
3572   ) external initializer returns (bytes32 bootstrapPermissionId) {
3573     factory = LlamaFactory(msg.sender);
3574     name = _name;
3575     executor = new LlamaExecutor();
3576     policy = _policy;
3577 
3578     ILlamaStrategy bootstrapStrategy = _deployStrategies(_llamaStrategyLogic, initialStrategies);
3579     _deployAccounts(_llamaAccountLogic, initialAccounts);
3580 
3581     // Now we compute the permission ID used to set role permissions and return it.
3582     bytes4 selector = LlamaPolicy.setRolePermission.selector;
3583     return keccak256(abi.encode(PermissionData(address(policy), bytes4(selector), bootstrapStrategy)));
3584   }
3585 
3586   // ===========================================
3587   // ======== External and Public Logic ========
3588   // ===========================================
3589 
3590   /// @notice Creates an action. The creator needs to hold a policy with the permission ID of the provided
3591   /// `(target, selector, strategy)`.
3592   /// @dev Use `""` for `description` if there is no description.
3593   /// @param role The role that will be used to determine the permission ID of the policyholder.
3594   /// @param strategy The strategy contract that will determine how the action is executed.
3595   /// @param target The contract called when the action is executed.
3596   /// @param value The value in wei to be sent when the action is executed.
3597   /// @param data Data to be called on the target when the action is executed.
3598   /// @param description A human readable description of the action and the changes it will enact.
3599   /// @return actionId Action ID of the newly created action.
3600   function createAction(
3601     uint8 role,
3602     ILlamaStrategy strategy,
3603     address target,
3604     uint256 value,
3605     bytes calldata data,
3606     string memory description
3607   ) external returns (uint256 actionId) {
3608     actionId = _createAction(msg.sender, role, strategy, target, value, data, description);
3609   }
3610 
3611   /// @notice Creates an action via an off-chain signature. The creator needs to hold a policy with the permission ID
3612   /// of the provided `(target, selector, strategy)`.
3613   /// @dev Use `""` for `description` if there is no description.
3614   /// @param policyholder The policyholder that signed the message.
3615   /// @param role The role that will be used to determine the permission ID of the policyholder.
3616   /// @param strategy The strategy contract that will determine how the action is executed.
3617   /// @param target The contract called when the action is executed.
3618   /// @param value The value in wei to be sent when the action is executed.
3619   /// @param data Data to be called on the target when the action is executed.
3620   /// @param description A human readable description of the action and the changes it will enact.
3621   /// @param v ECDSA signature component: Parity of the `y` coordinate of point `R`
3622   /// @param r ECDSA signature component: x-coordinate of `R`
3623   /// @param s ECDSA signature component: `s` value of the signature
3624   /// @return actionId Action ID of the newly created action.
3625   function createActionBySig(
3626     address policyholder,
3627     uint8 role,
3628     ILlamaStrategy strategy,
3629     address target,
3630     uint256 value,
3631     bytes calldata data,
3632     string memory description,
3633     uint8 v,
3634     bytes32 r,
3635     bytes32 s
3636   ) external returns (uint256 actionId) {
3637     bytes32 digest = _getCreateActionTypedDataHash(policyholder, role, strategy, target, value, data, description);
3638     address signer = ecrecover(digest, v, r, s);
3639     if (signer == address(0) || signer != policyholder) revert InvalidSignature();
3640     actionId = _createAction(signer, role, strategy, target, value, data, description);
3641   }
3642 
3643   /// @notice Queue an action by its `actionInfo` struct if it's in Approved state.
3644   /// @param actionInfo Data required to create an action.
3645   function queueAction(ActionInfo calldata actionInfo) external {
3646     Action storage action = actions[actionInfo.id];
3647     ActionState currentState = getActionState(actionInfo);
3648     if (currentState != ActionState.Approved) revert InvalidActionState(currentState);
3649 
3650     uint64 minExecutionTime = actionInfo.strategy.minExecutionTime(actionInfo);
3651     if (minExecutionTime < block.timestamp) revert MinExecutionTimeCannotBeInThePast();
3652     action.minExecutionTime = minExecutionTime;
3653     emit ActionQueued(actionInfo.id, msg.sender, actionInfo.strategy, actionInfo.creator, minExecutionTime);
3654   }
3655 
3656   /// @notice Execute an action by its `actionInfo` struct if it's in Queued state and `minExecutionTime` has passed.
3657   /// @param actionInfo Data required to create an action.
3658   function executeAction(ActionInfo calldata actionInfo) external payable {
3659     // Initial checks that action is ready to execute.
3660     Action storage action = actions[actionInfo.id];
3661     ActionState currentState = getActionState(actionInfo);
3662 
3663     if (currentState != ActionState.Queued) revert InvalidActionState(currentState);
3664     if (block.timestamp < action.minExecutionTime) revert MinExecutionTimeNotReached();
3665     if (msg.value != actionInfo.value) revert IncorrectMsgValue();
3666 
3667     action.executed = true;
3668 
3669     // Check pre-execution action guard.
3670     ILlamaActionGuard guard = actionGuard[actionInfo.target][bytes4(actionInfo.data)];
3671     if (guard != ILlamaActionGuard(address(0))) guard.validatePreActionExecution(actionInfo);
3672 
3673     // Execute action.
3674     (bool success, bytes memory result) =
3675       executor.execute(actionInfo.target, actionInfo.value, action.isScript, actionInfo.data);
3676 
3677     if (!success) revert FailedActionExecution(result);
3678 
3679     // Check post-execution action guard.
3680     if (guard != ILlamaActionGuard(address(0))) guard.validatePostActionExecution(actionInfo);
3681 
3682     // Action successfully executed.
3683     emit ActionExecuted(actionInfo.id, msg.sender, actionInfo.strategy, actionInfo.creator, result);
3684   }
3685 
3686   /// @notice Cancels an action by its `actionInfo` struct.
3687   /// @dev Rules for cancelation are defined by the strategy.
3688   /// @param actionInfo Data required to create an action.
3689   function cancelAction(ActionInfo calldata actionInfo) external {
3690     Action storage action = actions[actionInfo.id];
3691     _validateActionInfoHash(action.infoHash, actionInfo);
3692 
3693     // We don't need an explicit check on action existence because if it doesn't exist the strategy will be the zero
3694     // address, and Solidity will revert since there is no code at the zero address.
3695     actionInfo.strategy.validateActionCancelation(actionInfo, msg.sender);
3696 
3697     action.canceled = true;
3698     emit ActionCanceled(actionInfo.id);
3699   }
3700 
3701   /// @notice How policyholders add their support of the approval of an action with a reason.
3702   /// @dev Use `""` for `reason` if there is no reason.
3703   /// @param role The role the policyholder uses to cast their approval.
3704   /// @param actionInfo Data required to create an action.
3705   /// @param reason The reason given for the approval by the policyholder.
3706   function castApproval(uint8 role, ActionInfo calldata actionInfo, string calldata reason) external {
3707     return _castApproval(msg.sender, role, actionInfo, reason);
3708   }
3709 
3710   /// @notice How policyholders add their support of the approval of an action via an off-chain signature.
3711   /// @dev Use `""` for `reason` if there is no reason.
3712   /// @param policyholder The policyholder that signed the message.
3713   /// @param role The role the policyholder uses to cast their approval.
3714   /// @param actionInfo Data required to create an action.
3715   /// @param reason The reason given for the approval by the policyholder.
3716   /// @param v ECDSA signature component: Parity of the `y` coordinate of point `R`
3717   /// @param r ECDSA signature component: x-coordinate of `R`
3718   /// @param s ECDSA signature component: `s` value of the signature
3719   function castApprovalBySig(
3720     address policyholder,
3721     uint8 role,
3722     ActionInfo calldata actionInfo,
3723     string calldata reason,
3724     uint8 v,
3725     bytes32 r,
3726     bytes32 s
3727   ) external {
3728     bytes32 digest = _getCastApprovalTypedDataHash(policyholder, role, actionInfo, reason);
3729     address signer = ecrecover(digest, v, r, s);
3730     if (signer == address(0) || signer != policyholder) revert InvalidSignature();
3731     return _castApproval(signer, role, actionInfo, reason);
3732   }
3733 
3734   /// @notice How policyholders add their support of the disapproval of an action with a reason.
3735   /// @dev Use `""` for `reason` if there is no reason.
3736   /// @param role The role the policyholder uses to cast their disapproval.
3737   /// @param actionInfo Data required to create an action.
3738   /// @param reason The reason given for the disapproval by the policyholder.
3739   function castDisapproval(uint8 role, ActionInfo calldata actionInfo, string calldata reason) external {
3740     return _castDisapproval(msg.sender, role, actionInfo, reason);
3741   }
3742 
3743   /// @notice How policyholders add their support of the disapproval of an action via an off-chain signature.
3744   /// @dev Use `""` for `reason` if there is no reason.
3745   /// @param policyholder The policyholder that signed the message.
3746   /// @param role The role the policyholder uses to cast their disapproval.
3747   /// @param actionInfo Data required to create an action.
3748   /// @param reason The reason given for the approval by the policyholder.
3749   /// @param v ECDSA signature component: Parity of the `y` coordinate of point `R`
3750   /// @param r ECDSA signature component: x-coordinate of `R`
3751   /// @param s ECDSA signature component: `s` value of the signature
3752   function castDisapprovalBySig(
3753     address policyholder,
3754     uint8 role,
3755     ActionInfo calldata actionInfo,
3756     string calldata reason,
3757     uint8 v,
3758     bytes32 r,
3759     bytes32 s
3760   ) external {
3761     bytes32 digest = _getCastDisapprovalTypedDataHash(policyholder, role, actionInfo, reason);
3762     address signer = ecrecover(digest, v, r, s);
3763     if (signer == address(0) || signer != policyholder) revert InvalidSignature();
3764     return _castDisapproval(signer, role, actionInfo, reason);
3765   }
3766 
3767   /// @notice Deploy new strategies and add them to the mapping of authorized strategies.
3768   /// @param llamaStrategyLogic address of the Llama strategy logic contract.
3769   /// @param strategyConfigs Array of new strategy configurations.
3770   function createStrategies(ILlamaStrategy llamaStrategyLogic, bytes[] calldata strategyConfigs) external onlyLlama {
3771     _deployStrategies(llamaStrategyLogic, strategyConfigs);
3772   }
3773 
3774   /// @notice Deploy new accounts.
3775   /// @param llamaAccountLogic address of the Llama account logic contract.
3776   /// @param accountConfigs Array of new account configurations.
3777   function createAccounts(ILlamaAccount llamaAccountLogic, bytes[] calldata accountConfigs) external onlyLlama {
3778     _deployAccounts(llamaAccountLogic, accountConfigs);
3779   }
3780 
3781   /// @notice Sets `guard` as the action guard for the given `target` and `selector`.
3782   /// @param target The target contract where the `guard` will apply.
3783   /// @param selector The function selector where the `guard` will apply.
3784   /// @dev To remove a guard, set `guard` to the zero address.
3785   function setGuard(address target, bytes4 selector, ILlamaActionGuard guard) external onlyLlama {
3786     if (target == address(this) || target == address(policy)) revert RestrictedAddress();
3787     actionGuard[target][selector] = guard;
3788     emit ActionGuardSet(target, selector, guard);
3789   }
3790 
3791   /// @notice Authorizes `script` to be eligible to be delegatecalled from the executor.
3792   /// @param script The address of the script contract.
3793   /// @param authorized The boolean that determines if the `script` is being authorized or unauthorized.
3794   /// @dev To remove a `script`, set `authorized` to `false`.
3795   function authorizeScript(address script, bool authorized) external onlyLlama {
3796     if (script == address(this) || script == address(policy)) revert RestrictedAddress();
3797     authorizedScripts[script] = authorized;
3798     emit ScriptAuthorized(script, authorized);
3799   }
3800 
3801   /// @notice Increments the caller's nonce for the given `selector`. This is useful for revoking
3802   /// signatures that have not been used yet.
3803   /// @param selector The function selector to increment the nonce for.
3804   function incrementNonce(bytes4 selector) external {
3805     // Safety: Can never overflow a uint256 by incrementing.
3806     nonces[msg.sender][selector] = LlamaUtils.uncheckedIncrement(nonces[msg.sender][selector]);
3807   }
3808 
3809   /// @notice Get an Action struct by `actionId`.
3810   /// @param actionId ID of the action.
3811   /// @return The Action struct.
3812   function getAction(uint256 actionId) external view returns (Action memory) {
3813     return actions[actionId];
3814   }
3815 
3816   /// @notice Returns the timestamp of most recently created action.
3817   /// @dev Used by `LlamaPolicy` to ensure policy management does not occur immediately after action
3818   /// creation in the same timestamp, as this could result in invalid role supply counts being used.
3819   function getLastActionTimestamp() external view returns (uint256 timestamp) {
3820     return actionsCount == 0 ? 0 : actions[actionsCount - 1].creationTime;
3821   }
3822 
3823   /// @notice Get the current action state of an action by its `actionInfo` struct.
3824   /// @param actionInfo Data required to create an action.
3825   /// @return The current action state of the action.
3826   function getActionState(ActionInfo calldata actionInfo) public view returns (ActionState) {
3827     // We don't need an explicit check on the action ID to make sure it exists, because if the
3828     // action does not exist, the expected payload hash from storage will be `bytes32(0)`, so
3829     // bypassing this check by providing a non-existent actionId would require finding a collision
3830     // to get a hash of zero.
3831     Action storage action = actions[actionInfo.id];
3832     _validateActionInfoHash(action.infoHash, actionInfo);
3833 
3834     if (action.canceled) return ActionState.Canceled;
3835 
3836     if (action.executed) return ActionState.Executed;
3837 
3838     if (actionInfo.strategy.isActive(actionInfo)) return ActionState.Active;
3839 
3840     if (!actionInfo.strategy.isActionApproved(actionInfo)) return ActionState.Failed;
3841 
3842     if (action.minExecutionTime == 0) return ActionState.Approved;
3843 
3844     if (actionInfo.strategy.isActionDisapproved(actionInfo)) return ActionState.Failed;
3845 
3846     if (actionInfo.strategy.isActionExpired(actionInfo)) return ActionState.Expired;
3847 
3848     return ActionState.Queued;
3849   }
3850 
3851   // ================================
3852   // ======== Internal Logic ========
3853   // ================================
3854 
3855   /// @dev Creates an action. The creator needs to hold a policy with the permission ID of the provided
3856   /// `(target, selector, strategy)`.
3857   function _createAction(
3858     address policyholder,
3859     uint8 role,
3860     ILlamaStrategy strategy,
3861     address target,
3862     uint256 value,
3863     bytes calldata data,
3864     string memory description
3865   ) internal returns (uint256 actionId) {
3866     if (target == address(executor)) revert CannotSetExecutorAsTarget();
3867     if (!strategies[strategy]) revert InvalidStrategy();
3868 
3869     PermissionData memory permission = PermissionData(target, bytes4(data), strategy);
3870     bytes32 permissionId = keccak256(abi.encode(permission));
3871 
3872     // Typically (such as in Governor contracts) this should check that the caller has permission
3873     // at `block.number|timestamp - 1` but here we're just checking if the caller *currently* has
3874     // permission. Technically this introduces a race condition if e.g. an action to revoke a role
3875     // from someone (or revoke a permission from a role) is ready to be executed at the same time as
3876     // an action is created, as the order of transactions in the block then affects if action
3877     // creation would succeed. However, we are ok with this tradeoff because it means we don't need
3878     // to checkpoint the `canCreateAction` mapping which is simpler and cheaper, and in practice
3879     // this race condition is unlikely to matter.
3880     if (!policy.hasPermissionId(policyholder, role, permissionId)) revert PolicyholderDoesNotHavePermission();
3881 
3882     // Validate action creation.
3883     actionId = actionsCount;
3884 
3885     ActionInfo memory actionInfo = ActionInfo(actionId, policyholder, role, strategy, target, value, data);
3886     strategy.validateActionCreation(actionInfo);
3887 
3888     // Scope to avoid stack too deep
3889     {
3890       ILlamaActionGuard guard = actionGuard[target][bytes4(data)];
3891       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);
3892 
3893       // Save action.
3894       Action storage newAction = actions[actionId];
3895       newAction.infoHash = _infoHash(actionId, policyholder, role, strategy, target, value, data);
3896       newAction.creationTime = LlamaUtils.toUint64(block.timestamp);
3897       newAction.isScript = authorizedScripts[target];
3898     }
3899 
3900     actionsCount = LlamaUtils.uncheckedIncrement(actionsCount); // Safety: Can never overflow a uint256 by incrementing.
3901 
3902     emit ActionCreated(actionId, policyholder, role, strategy, target, value, data, description);
3903   }
3904 
3905   /// @dev How policyholders that have the right role contribute towards the approval of an action with a reason.
3906   function _castApproval(address policyholder, uint8 role, ActionInfo calldata actionInfo, string memory reason)
3907     internal
3908   {
3909     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Active);
3910 
3911     action.totalApprovals = _newCastCount(action.totalApprovals, quantity);
3912     approvals[actionInfo.id][policyholder] = true;
3913     emit ApprovalCast(actionInfo.id, policyholder, role, quantity, reason);
3914   }
3915 
3916   /// @dev How policyholders that have the right role contribute towards the disapproval of an action with a reason.
3917   function _castDisapproval(address policyholder, uint8 role, ActionInfo calldata actionInfo, string memory reason)
3918     internal
3919   {
3920     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Queued);
3921 
3922     action.totalDisapprovals = _newCastCount(action.totalDisapprovals, quantity);
3923     disapprovals[actionInfo.id][policyholder] = true;
3924     emit DisapprovalCast(actionInfo.id, policyholder, role, quantity, reason);
3925   }
3926 
3927   /// @dev The only `expectedState` values allowed to be passed into this method are Active or Queued.
3928   function _preCastAssertions(
3929     ActionInfo calldata actionInfo,
3930     address policyholder,
3931     uint8 role,
3932     ActionState expectedState
3933   ) internal returns (Action storage action, uint128 quantity) {
3934     action = actions[actionInfo.id];
3935     ActionState currentState = getActionState(actionInfo);
3936     if (currentState != expectedState) revert InvalidActionState(currentState);
3937 
3938     bool isApproval = expectedState == ActionState.Active;
3939     bool alreadyCast = isApproval ? approvals[actionInfo.id][policyholder] : disapprovals[actionInfo.id][policyholder];
3940     if (alreadyCast) revert DuplicateCast();
3941 
3942     bool hasRole = policy.hasRole(policyholder, role, action.creationTime);
3943     if (!hasRole) revert InvalidPolicyholder();
3944 
3945     if (isApproval) {
3946       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);
3947       quantity = actionInfo.strategy.getApprovalQuantityAt(policyholder, role, action.creationTime);
3948       if (quantity == 0) revert CannotCastWithZeroQuantity(policyholder, role);
3949     } else {
3950       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);
3951       quantity = actionInfo.strategy.getDisapprovalQuantityAt(policyholder, role, action.creationTime);
3952       if (quantity == 0) revert CannotCastWithZeroQuantity(policyholder, role);
3953     }
3954   }
3955 
3956   /// @dev Returns the new total count of approvals or disapprovals.
3957   function _newCastCount(uint128 currentCount, uint128 quantity) internal pure returns (uint128) {
3958     if (currentCount == type(uint128).max || quantity == type(uint128).max) return type(uint128).max;
3959     return currentCount + quantity;
3960   }
3961 
3962   /// @dev Deploys new strategies. Takes in the strategy logic contract to be used and an array of configurations to
3963   /// initialize the new strategies with. Returns the address of the first strategy, which is only used during the
3964   /// `LlamaCore` initialization so that we can ensure someone (specifically, policyholders with role ID 1) has the
3965   /// permission to assign role permissions.
3966   function _deployStrategies(ILlamaStrategy llamaStrategyLogic, bytes[] calldata strategyConfigs)
3967     internal
3968     returns (ILlamaStrategy firstStrategy)
3969   {
3970     if (address(factory).code.length > 0 && !factory.authorizedStrategyLogics(llamaStrategyLogic)) {
3971       // The only edge case where this check is skipped is if `_deployStrategies()` is called by root llama instance
3972       // during Llama Factory construction. This is because there is no code at the Llama Factory address yet.
3973       revert UnauthorizedStrategyLogic();
3974     }
3975 
3976     uint256 strategyLength = strategyConfigs.length;
3977     for (uint256 i = 0; i < strategyLength; i = LlamaUtils.uncheckedIncrement(i)) {
3978       bytes32 salt = bytes32(keccak256(strategyConfigs[i]));
3979       ILlamaStrategy strategy = ILlamaStrategy(Clones.cloneDeterministic(address(llamaStrategyLogic), salt));
3980       strategy.initialize(strategyConfigs[i]);
3981       strategies[strategy] = true;
3982       emit StrategyCreated(strategy, llamaStrategyLogic, strategyConfigs[i]);
3983       if (i == 0) firstStrategy = strategy;
3984     }
3985   }
3986 
3987   /// @dev Deploys new accounts. Takes in the account logic contract to be used and an array of configurations to
3988   /// initialize the new accounts with.
3989   function _deployAccounts(ILlamaAccount llamaAccountLogic, bytes[] calldata accountConfigs) internal {
3990     if (address(factory).code.length > 0 && !factory.authorizedAccountLogics(llamaAccountLogic)) {
3991       // The only edge case where this check is skipped is if `_deployAccounts()` is called by root llama instance
3992       // during Llama Factory construction. This is because there is no code at the Llama Factory address yet.
3993       revert UnauthorizedAccountLogic();
3994     }
3995 
3996     uint256 accountLength = accountConfigs.length;
3997     for (uint256 i = 0; i < accountLength; i = LlamaUtils.uncheckedIncrement(i)) {
3998       bytes32 salt = bytes32(keccak256(accountConfigs[i]));
3999       ILlamaAccount account = ILlamaAccount(Clones.cloneDeterministic(address(llamaAccountLogic), salt));
4000       account.initialize(accountConfigs[i]);
4001       emit AccountCreated(account, llamaAccountLogic, accountConfigs[i]);
4002     }
4003   }
4004 
4005   /// @dev Returns the hash of the `createAction` parameters using the `actionInfo` struct.
4006   function _infoHash(ActionInfo calldata actionInfo) internal pure returns (bytes32) {
4007     return _infoHash(
4008       actionInfo.id,
4009       actionInfo.creator,
4010       actionInfo.creatorRole,
4011       actionInfo.strategy,
4012       actionInfo.target,
4013       actionInfo.value,
4014       actionInfo.data
4015     );
4016   }
4017 
4018   /// @dev Returns the hash of the `createAction` parameters.
4019   function _infoHash(
4020     uint256 id,
4021     address creator,
4022     uint8 creatorRole,
4023     ILlamaStrategy strategy,
4024     address target,
4025     uint256 value,
4026     bytes calldata data
4027   ) internal pure returns (bytes32) {
4028     return keccak256(abi.encodePacked(id, creator, creatorRole, strategy, target, value, data));
4029   }
4030 
4031   /// @dev Validates that the hash of the `actionInfo` struct matches the provided hash.
4032   function _validateActionInfoHash(bytes32 actualHash, ActionInfo calldata actionInfo) internal pure {
4033     bytes32 expectedHash = _infoHash(actionInfo);
4034     if (actualHash != expectedHash) revert InfoHashMismatch();
4035   }
4036 
4037   /// @dev Returns the current nonce for a given policyholder and selector, and increments it. Used to prevent
4038   /// replay attacks.
4039   function _useNonce(address policyholder, bytes4 selector) internal returns (uint256 nonce) {
4040     nonce = nonces[policyholder][selector];
4041     nonces[policyholder][selector] = LlamaUtils.uncheckedIncrement(nonce);
4042   }
4043 
4044   // -------- EIP-712 Getters --------
4045 
4046   /// @dev Returns the EIP-712 domain separator.
4047   function _getDomainHash() internal view returns (bytes32) {
4048     return keccak256(
4049       abi.encode(EIP712_DOMAIN_TYPEHASH, keccak256(bytes(name)), keccak256(bytes("1")), block.chainid, address(this))
4050     );
4051   }
4052 
4053   /// @dev Returns the hash of the ABI-encoded EIP-712 message for the `CreateAction` domain, which can be used to
4054   /// recover the signer.
4055   function _getCreateActionTypedDataHash(
4056     address policyholder,
4057     uint8 role,
4058     ILlamaStrategy strategy,
4059     address target,
4060     uint256 value,
4061     bytes calldata data,
4062     string memory description
4063   ) internal returns (bytes32) {
4064     // Calculating and storing nonce in memory and using that below, instead of calculating in place to prevent stack
4065     // too deep error.
4066     uint256 nonce = _useNonce(policyholder, msg.sig);
4067 
4068     bytes32 createActionHash = keccak256(
4069       abi.encode(
4070         CREATE_ACTION_TYPEHASH,
4071         policyholder,
4072         role,
4073         address(strategy),
4074         target,
4075         value,
4076         keccak256(data),
4077         keccak256(bytes(description)),
4078         nonce
4079       )
4080     );
4081 
4082     return keccak256(abi.encodePacked("\x19\x01", _getDomainHash(), createActionHash));
4083   }
4084 
4085   /// @dev Returns the hash of the ABI-encoded EIP-712 message for the `CastApproval` domain, which can be used to
4086   /// recover the signer.
4087   function _getCastApprovalTypedDataHash(
4088     address policyholder,
4089     uint8 role,
4090     ActionInfo calldata actionInfo,
4091     string calldata reason
4092   ) internal returns (bytes32) {
4093     bytes32 castApprovalHash = keccak256(
4094       abi.encode(
4095         CAST_APPROVAL_TYPEHASH,
4096         policyholder,
4097         role,
4098         _getActionInfoHash(actionInfo),
4099         keccak256(bytes(reason)),
4100         _useNonce(policyholder, msg.sig)
4101       )
4102     );
4103 
4104     return keccak256(abi.encodePacked("\x19\x01", _getDomainHash(), castApprovalHash));
4105   }
4106 
4107   /// @dev Returns the hash of the ABI-encoded EIP-712 message for the `CastDisapproval` domain, which can be used to
4108   /// recover the signer.
4109   function _getCastDisapprovalTypedDataHash(
4110     address policyholder,
4111     uint8 role,
4112     ActionInfo calldata actionInfo,
4113     string calldata reason
4114   ) internal returns (bytes32) {
4115     bytes32 castDisapprovalHash = keccak256(
4116       abi.encode(
4117         CAST_DISAPPROVAL_TYPEHASH,
4118         policyholder,
4119         role,
4120         _getActionInfoHash(actionInfo),
4121         keccak256(bytes(reason)),
4122         _useNonce(policyholder, msg.sig)
4123       )
4124     );
4125 
4126     return keccak256(abi.encodePacked("\x19\x01", _getDomainHash(), castDisapprovalHash));
4127   }
4128 
4129   /// @dev Returns the hash of `actionInfo`.
4130   function _getActionInfoHash(ActionInfo calldata actionInfo) internal pure returns (bytes32) {
4131     return keccak256(
4132       abi.encode(
4133         ACTION_INFO_TYPEHASH,
4134         actionInfo.id,
4135         actionInfo.creator,
4136         actionInfo.creatorRole,
4137         address(actionInfo.strategy),
4138         actionInfo.target,
4139         actionInfo.value,
4140         keccak256(actionInfo.data)
4141       )
4142     );
4143   }
4144 }



```

### LlamaAbsoluteQuorum.sol


```
Contract locking ether found:
	Contract LlamaCore (LlamaAbsoluteQuorum.sol#3361-4144) has payable functions:
	 - LlamaCore.executeAction(ActionInfo) (LlamaAbsoluteQuorum.sol#3658-3684)
	But does not have a function to withdraw the ether



    
3361 contract LlamaCore is Initializable {
3362   // ======================================
3363   // ======== Errors and Modifiers ========
3364   // ======================================
3365 
3366   /// @dev Policyholder cannot cast if it has 0 quantity of role.
3367   /// @param policyholder Address of policyholder.
3368   /// @param role The role being used in the cast.
3369   error CannotCastWithZeroQuantity(address policyholder, uint8 role);
3370 
3371   /// @dev An action's target contract cannot be the executor.
3372   error CannotSetExecutorAsTarget();
3373 
3374   /// @dev Address cannot be used.
3375   error RestrictedAddress();
3376 
3377   /// @dev Policyholders can only cast once.
3378   error DuplicateCast();
3379 
3380   /// @dev Action execution failed.
3381   /// @param reason Data returned by the function called by the action.
3382   error FailedActionExecution(bytes reason);
3383 
3384   /// @dev `ActionInfo` does not hash to the correct value.
3385   error InfoHashMismatch();
3386 
3387   /// @dev `msg.value` does not equal the action's value.
3388   error IncorrectMsgValue();
3389 
3390   /// @dev The action is not in the expected state.
3391   /// @param current The current state of the action.
3392   error InvalidActionState(ActionState current);
3393 
3394   /// @dev The policyholder does not have the role at action creation time.
3395   error InvalidPolicyholder();
3396 
3397   /// @dev The recovered signer does not match the expected policyholder.
3398   error InvalidSignature();
3399 
3400   /// @dev The provided address does not map to a deployed strategy.
3401   error InvalidStrategy();
3402 
3403   /// @dev An action cannot queue successfully if it's `minExecutionTime` is less than `block.timestamp`.
3404   error MinExecutionTimeCannotBeInThePast();
3405 
3406   /// @dev Only callable by a Llama instance's executor.
3407   error OnlyLlama();
3408 
3409   /// @dev Policyholder does not have the permission ID to create the action.
3410   error PolicyholderDoesNotHavePermission();
3411 
3412   /// @dev If `block.timestamp` is less than `minExecutionTime`, the action cannot be executed.
3413   error MinExecutionTimeNotReached();
3414 
3415   /// @dev Strategies can only be created with valid logic contracts.
3416   error UnauthorizedStrategyLogic();
3417 
3418   /// @dev Accounts can only be created with valid logic contracts.
3419   error UnauthorizedAccountLogic();
3420 
3421   /// @dev Checks that the caller is the Llama Executor and reverts if not.
3422   modifier onlyLlama() {
3423     if (msg.sender != address(executor)) revert OnlyLlama();
3424     _;
3425   }
3426 
3427   // ========================
3428   // ======== Events ========
3429   // ========================
3430 
3431   /// @dev Emitted when an action is created.
3432   event ActionCreated(
3433     uint256 id,
3434     address indexed creator,
3435     uint8 role,
3436     ILlamaStrategy indexed strategy,
3437     address indexed target,
3438     uint256 value,
3439     bytes data,
3440     string description
3441   );
3442 
3443   /// @dev Emitted when an action is canceled.
3444   event ActionCanceled(uint256 id);
3445 
3446   /// @dev Emitted when an action guard is set.
3447   event ActionGuardSet(address indexed target, bytes4 indexed selector, ILlamaActionGuard actionGuard);
3448 
3449   /// @dev Emitted when an action is queued.
3450   event ActionQueued(
3451     uint256 id,
3452     address indexed caller,
3453     ILlamaStrategy indexed strategy,
3454     address indexed creator,
3455     uint256 minExecutionTime
3456   );
3457 
3458   /// @dev Emitted when an action is executed.
3459   event ActionExecuted(
3460     uint256 id, address indexed caller, ILlamaStrategy indexed strategy, address indexed creator, bytes result
3461   );
3462 
3463   /// @dev Emitted when an approval is cast.
3464   event ApprovalCast(uint256 id, address indexed policyholder, uint8 indexed role, uint256 quantity, string reason);
3465 
3466   /// @dev Emitted when a disapproval is cast.
3467   event DisapprovalCast(uint256 id, address indexed policyholder, uint8 indexed role, uint256 quantity, string reason);
3468 
3469   /// @dev Emitted when a strategy is created and authorized.
3470   event StrategyCreated(ILlamaStrategy strategy, ILlamaStrategy indexed strategyLogic, bytes initializationData);
3471 
3472   /// @dev Emitted when an account is created.
3473   event AccountCreated(ILlamaAccount account, ILlamaAccount indexed accountLogic, bytes initializationData);
3474 
3475   /// @dev Emitted when a script is authorized.
3476   event ScriptAuthorized(address script, bool authorized);
3477 
3478   // =================================================
3479   // ======== Constants and Storage Variables ========
3480   // =================================================
3481 
3482   /// @dev EIP-712 base typehash.
3483   bytes32 internal constant EIP712_DOMAIN_TYPEHASH =
3484     keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");
3485 
3486   /// @dev EIP-712 createAction typehash.
3487   bytes32 internal constant CREATE_ACTION_TYPEHASH = keccak256(
3488     "CreateAction(address policyholder,uint8 role,address strategy,address target,uint256 value,bytes data,string description,uint256 nonce)"
3489   );
3490 
3491   /// @dev EIP-712 castApproval typehash.
3492   bytes32 internal constant CAST_APPROVAL_TYPEHASH = keccak256(
3493     "CastApproval(address policyholder,uint8 role,ActionInfo actionInfo,string reason,uint256 nonce)ActionInfo(uint256 id,address creator,uint8 creatorRole,address strategy,address target,uint256 value,bytes data)"
3494   );
3495 
3496   /// @dev EIP-712 castDisapproval typehash.
3497   bytes32 internal constant CAST_DISAPPROVAL_TYPEHASH = keccak256(
3498     "CastDisapproval(address policyholder,uint8 role,ActionInfo actionInfo,string reason,uint256 nonce)ActionInfo(uint256 id,address creator,uint8 creatorRole,address strategy,address target,uint256 value,bytes data)"
3499   );
3500 
3501   /// @dev EIP-712 actionInfo typehash.
3502   bytes32 internal constant ACTION_INFO_TYPEHASH = keccak256(
3503     "ActionInfo(uint256 id,address creator,uint8 creatorRole,address strategy,address target,uint256 value,bytes data)"
3504   );
3505 
3506   /// @dev Mapping of actionIds to Actions.
3507   /// @dev Making this `public` results in stack too deep with no optimizer, but this data can be
3508   /// accessed with the `getAction` function so this is ok. We want the contracts to compile
3509   /// without the optimizer so `forge coverage` can be used.
3510   mapping(uint256 => Action) internal actions;
3511 
3512   /// @notice The contract that executes actions for this Llama instance.
3513   LlamaExecutor public executor;
3514 
3515   /// @notice The ERC721 contract that defines the policies for this Llama instance.
3516   /// @dev We intentionally put this first so it's packed with the `Initializable` storage
3517   // variables, which are the key variables we want to check before and after a delegatecall.
3518   LlamaPolicy public policy;
3519 
3520   /// @notice The `LlamaFactory` contract that deployed this Llama instance.
3521   LlamaFactory public factory;
3522 
3523   /// @notice Name of this Llama instance.
3524   string public name;
3525 
3526   /// @notice The current number of actions created.
3527   uint256 public actionsCount;
3528 
3529   /// @notice Mapping of actionIds to policyholders to approvals.
3530   mapping(uint256 => mapping(address => bool)) public approvals;
3531 
3532   /// @notice Mapping of actionIds to policyholders to disapprovals.
3533   mapping(uint256 => mapping(address => bool)) public disapprovals;
3534 
3535   /// @notice Mapping of all authorized strategies.
3536   mapping(ILlamaStrategy => bool) public strategies;
3537 
3538   /// @notice Mapping of all authorized scripts.
3539   mapping(address => bool) public authorizedScripts;
3540 
3541   /// @notice Mapping of policyholders to function selectors to current nonces for EIP-712 signatures.
3542   /// @dev This is used to prevent replay attacks by incrementing the nonce for each operation (`createAction`,
3543   /// `castApproval` and `castDisapproval`) signed by the policyholder.
3544   mapping(address => mapping(bytes4 => uint256)) public nonces;
3545 
3546   /// @notice Mapping of target to selector to actionGuard address.
3547   mapping(address target => mapping(bytes4 selector => ILlamaActionGuard)) public actionGuard;
3548 
3549   // ======================================================
3550   // ======== Contract Creation and Initialization ========
3551   // ======================================================
3552 
3553   constructor() {
3554     _disableInitializers();
3555   }
3556 
3557   /// @notice Initializes a new `LlamaCore` clone.
3558   /// @param _name The name of the `LlamaCore` clone.
3559   /// @param _policy This Llama instance's policy contract.
3560   /// @param _llamaStrategyLogic The Llama Strategy implementation (logic) contract.
3561   /// @param _llamaAccountLogic The Llama Account implementation (logic) contract.
3562   /// @param initialStrategies Array of initial strategy configurations.
3563   /// @param initialAccounts Array of initial account configurations.
3564   /// @return bootstrapPermissionId The permission ID that's used to set role permissions.
3565   function initialize(
3566     string memory _name,
3567     LlamaPolicy _policy,
3568     ILlamaStrategy _llamaStrategyLogic,
3569     ILlamaAccount _llamaAccountLogic,
3570     bytes[] calldata initialStrategies,
3571     bytes[] calldata initialAccounts
3572   ) external initializer returns (bytes32 bootstrapPermissionId) {
3573     factory = LlamaFactory(msg.sender);
3574     name = _name;
3575     executor = new LlamaExecutor();
3576     policy = _policy;
3577 
3578     ILlamaStrategy bootstrapStrategy = _deployStrategies(_llamaStrategyLogic, initialStrategies);
3579     _deployAccounts(_llamaAccountLogic, initialAccounts);
3580 
3581     // Now we compute the permission ID used to set role permissions and return it.
3582     bytes4 selector = LlamaPolicy.setRolePermission.selector;
3583     return keccak256(abi.encode(PermissionData(address(policy), bytes4(selector), bootstrapStrategy)));
3584   }
3585 
3586   // ===========================================
3587   // ======== External and Public Logic ========
3588   // ===========================================
3589 
3590   /// @notice Creates an action. The creator needs to hold a policy with the permission ID of the provided
3591   /// `(target, selector, strategy)`.
3592   /// @dev Use `""` for `description` if there is no description.
3593   /// @param role The role that will be used to determine the permission ID of the policyholder.
3594   /// @param strategy The strategy contract that will determine how the action is executed.
3595   /// @param target The contract called when the action is executed.
3596   /// @param value The value in wei to be sent when the action is executed.
3597   /// @param data Data to be called on the target when the action is executed.
3598   /// @param description A human readable description of the action and the changes it will enact.
3599   /// @return actionId Action ID of the newly created action.
3600   function createAction(
3601     uint8 role,
3602     ILlamaStrategy strategy,
3603     address target,
3604     uint256 value,
3605     bytes calldata data,
3606     string memory description
3607   ) external returns (uint256 actionId) {
3608     actionId = _createAction(msg.sender, role, strategy, target, value, data, description);
3609   }
3610 
3611   /// @notice Creates an action via an off-chain signature. The creator needs to hold a policy with the permission ID
3612   /// of the provided `(target, selector, strategy)`.
3613   /// @dev Use `""` for `description` if there is no description.
3614   /// @param policyholder The policyholder that signed the message.
3615   /// @param role The role that will be used to determine the permission ID of the policyholder.
3616   /// @param strategy The strategy contract that will determine how the action is executed.
3617   /// @param target The contract called when the action is executed.
3618   /// @param value The value in wei to be sent when the action is executed.
3619   /// @param data Data to be called on the target when the action is executed.
3620   /// @param description A human readable description of the action and the changes it will enact.
3621   /// @param v ECDSA signature component: Parity of the `y` coordinate of point `R`
3622   /// @param r ECDSA signature component: x-coordinate of `R`
3623   /// @param s ECDSA signature component: `s` value of the signature
3624   /// @return actionId Action ID of the newly created action.
3625   function createActionBySig(
3626     address policyholder,
3627     uint8 role,
3628     ILlamaStrategy strategy,
3629     address target,
3630     uint256 value,
3631     bytes calldata data,
3632     string memory description,
3633     uint8 v,
3634     bytes32 r,
3635     bytes32 s
3636   ) external returns (uint256 actionId) {
3637     bytes32 digest = _getCreateActionTypedDataHash(policyholder, role, strategy, target, value, data, description);
3638     address signer = ecrecover(digest, v, r, s);
3639     if (signer == address(0) || signer != policyholder) revert InvalidSignature();
3640     actionId = _createAction(signer, role, strategy, target, value, data, description);
3641   }
3642 
3643   /// @notice Queue an action by its `actionInfo` struct if it's in Approved state.
3644   /// @param actionInfo Data required to create an action.
3645   function queueAction(ActionInfo calldata actionInfo) external {
3646     Action storage action = actions[actionInfo.id];
3647     ActionState currentState = getActionState(actionInfo);
3648     if (currentState != ActionState.Approved) revert InvalidActionState(currentState);
3649 
3650     uint64 minExecutionTime = actionInfo.strategy.minExecutionTime(actionInfo);
3651     if (minExecutionTime < block.timestamp) revert MinExecutionTimeCannotBeInThePast();
3652     action.minExecutionTime = minExecutionTime;
3653     emit ActionQueued(actionInfo.id, msg.sender, actionInfo.strategy, actionInfo.creator, minExecutionTime);
3654   }
3655 
3656   /// @notice Execute an action by its `actionInfo` struct if it's in Queued state and `minExecutionTime` has passed.
3657   /// @param actionInfo Data required to create an action.
3658   function executeAction(ActionInfo calldata actionInfo) external payable {
3659     // Initial checks that action is ready to execute.
3660     Action storage action = actions[actionInfo.id];
3661     ActionState currentState = getActionState(actionInfo);
3662 
3663     if (currentState != ActionState.Queued) revert InvalidActionState(currentState);
3664     if (block.timestamp < action.minExecutionTime) revert MinExecutionTimeNotReached();
3665     if (msg.value != actionInfo.value) revert IncorrectMsgValue();
3666 
3667     action.executed = true;
3668 
3669     // Check pre-execution action guard.
3670     ILlamaActionGuard guard = actionGuard[actionInfo.target][bytes4(actionInfo.data)];
3671     if (guard != ILlamaActionGuard(address(0))) guard.validatePreActionExecution(actionInfo);
3672 
3673     // Execute action.
3674     (bool success, bytes memory result) =
3675       executor.execute(actionInfo.target, actionInfo.value, action.isScript, actionInfo.data);
3676 
3677     if (!success) revert FailedActionExecution(result);
3678 
3679     // Check post-execution action guard.
3680     if (guard != ILlamaActionGuard(address(0))) guard.validatePostActionExecution(actionInfo);
3681 
3682     // Action successfully executed.
3683     emit ActionExecuted(actionInfo.id, msg.sender, actionInfo.strategy, actionInfo.creator, result);
3684   }
3685 
3686   /// @notice Cancels an action by its `actionInfo` struct.
3687   /// @dev Rules for cancelation are defined by the strategy.
3688   /// @param actionInfo Data required to create an action.
3689   function cancelAction(ActionInfo calldata actionInfo) external {
3690     Action storage action = actions[actionInfo.id];
3691     _validateActionInfoHash(action.infoHash, actionInfo);
3692 
3693     // We don't need an explicit check on action existence because if it doesn't exist the strategy will be the zero
3694     // address, and Solidity will revert since there is no code at the zero address.
3695     actionInfo.strategy.validateActionCancelation(actionInfo, msg.sender);
3696 
3697     action.canceled = true;
3698     emit ActionCanceled(actionInfo.id);
3699   }
3700 
3701   /// @notice How policyholders add their support of the approval of an action with a reason.
3702   /// @dev Use `""` for `reason` if there is no reason.
3703   /// @param role The role the policyholder uses to cast their approval.
3704   /// @param actionInfo Data required to create an action.
3705   /// @param reason The reason given for the approval by the policyholder.
3706   function castApproval(uint8 role, ActionInfo calldata actionInfo, string calldata reason) external {
3707     return _castApproval(msg.sender, role, actionInfo, reason);
3708   }
3709 
3710   /// @notice How policyholders add their support of the approval of an action via an off-chain signature.
3711   /// @dev Use `""` for `reason` if there is no reason.
3712   /// @param policyholder The policyholder that signed the message.
3713   /// @param role The role the policyholder uses to cast their approval.
3714   /// @param actionInfo Data required to create an action.
3715   /// @param reason The reason given for the approval by the policyholder.
3716   /// @param v ECDSA signature component: Parity of the `y` coordinate of point `R`
3717   /// @param r ECDSA signature component: x-coordinate of `R`
3718   /// @param s ECDSA signature component: `s` value of the signature
3719   function castApprovalBySig(
3720     address policyholder,
3721     uint8 role,
3722     ActionInfo calldata actionInfo,
3723     string calldata reason,
3724     uint8 v,
3725     bytes32 r,
3726     bytes32 s
3727   ) external {
3728     bytes32 digest = _getCastApprovalTypedDataHash(policyholder, role, actionInfo, reason);
3729     address signer = ecrecover(digest, v, r, s);
3730     if (signer == address(0) || signer != policyholder) revert InvalidSignature();
3731     return _castApproval(signer, role, actionInfo, reason);
3732   }
3733 
3734   /// @notice How policyholders add their support of the disapproval of an action with a reason.
3735   /// @dev Use `""` for `reason` if there is no reason.
3736   /// @param role The role the policyholder uses to cast their disapproval.
3737   /// @param actionInfo Data required to create an action.
3738   /// @param reason The reason given for the disapproval by the policyholder.
3739   function castDisapproval(uint8 role, ActionInfo calldata actionInfo, string calldata reason) external {
3740     return _castDisapproval(msg.sender, role, actionInfo, reason);
3741   }
3742 
3743   /// @notice How policyholders add their support of the disapproval of an action via an off-chain signature.
3744   /// @dev Use `""` for `reason` if there is no reason.
3745   /// @param policyholder The policyholder that signed the message.
3746   /// @param role The role the policyholder uses to cast their disapproval.
3747   /// @param actionInfo Data required to create an action.
3748   /// @param reason The reason given for the approval by the policyholder.
3749   /// @param v ECDSA signature component: Parity of the `y` coordinate of point `R`
3750   /// @param r ECDSA signature component: x-coordinate of `R`
3751   /// @param s ECDSA signature component: `s` value of the signature
3752   function castDisapprovalBySig(
3753     address policyholder,
3754     uint8 role,
3755     ActionInfo calldata actionInfo,
3756     string calldata reason,
3757     uint8 v,
3758     bytes32 r,
3759     bytes32 s
3760   ) external {
3761     bytes32 digest = _getCastDisapprovalTypedDataHash(policyholder, role, actionInfo, reason);
3762     address signer = ecrecover(digest, v, r, s);
3763     if (signer == address(0) || signer != policyholder) revert InvalidSignature();
3764     return _castDisapproval(signer, role, actionInfo, reason);
3765   }
3766 
3767   /// @notice Deploy new strategies and add them to the mapping of authorized strategies.
3768   /// @param llamaStrategyLogic address of the Llama strategy logic contract.
3769   /// @param strategyConfigs Array of new strategy configurations.
3770   function createStrategies(ILlamaStrategy llamaStrategyLogic, bytes[] calldata strategyConfigs) external onlyLlama {
3771     _deployStrategies(llamaStrategyLogic, strategyConfigs);
3772   }
3773 
3774   /// @notice Deploy new accounts.
3775   /// @param llamaAccountLogic address of the Llama account logic contract.
3776   /// @param accountConfigs Array of new account configurations.
3777   function createAccounts(ILlamaAccount llamaAccountLogic, bytes[] calldata accountConfigs) external onlyLlama {
3778     _deployAccounts(llamaAccountLogic, accountConfigs);
3779   }
3780 
3781   /// @notice Sets `guard` as the action guard for the given `target` and `selector`.
3782   /// @param target The target contract where the `guard` will apply.
3783   /// @param selector The function selector where the `guard` will apply.
3784   /// @dev To remove a guard, set `guard` to the zero address.
3785   function setGuard(address target, bytes4 selector, ILlamaActionGuard guard) external onlyLlama {
3786     if (target == address(this) || target == address(policy)) revert RestrictedAddress();
3787     actionGuard[target][selector] = guard;
3788     emit ActionGuardSet(target, selector, guard);
3789   }
3790 
3791   /// @notice Authorizes `script` to be eligible to be delegatecalled from the executor.
3792   /// @param script The address of the script contract.
3793   /// @param authorized The boolean that determines if the `script` is being authorized or unauthorized.
3794   /// @dev To remove a `script`, set `authorized` to `false`.
3795   function authorizeScript(address script, bool authorized) external onlyLlama {
3796     if (script == address(this) || script == address(policy)) revert RestrictedAddress();
3797     authorizedScripts[script] = authorized;
3798     emit ScriptAuthorized(script, authorized);
3799   }
3800 
3801   /// @notice Increments the caller's nonce for the given `selector`. This is useful for revoking
3802   /// signatures that have not been used yet.
3803   /// @param selector The function selector to increment the nonce for.
3804   function incrementNonce(bytes4 selector) external {
3805     // Safety: Can never overflow a uint256 by incrementing.
3806     nonces[msg.sender][selector] = LlamaUtils.uncheckedIncrement(nonces[msg.sender][selector]);
3807   }
3808 
3809   /// @notice Get an Action struct by `actionId`.
3810   /// @param actionId ID of the action.
3811   /// @return The Action struct.
3812   function getAction(uint256 actionId) external view returns (Action memory) {
3813     return actions[actionId];
3814   }
3815 
3816   /// @notice Returns the timestamp of most recently created action.
3817   /// @dev Used by `LlamaPolicy` to ensure policy management does not occur immediately after action
3818   /// creation in the same timestamp, as this could result in invalid role supply counts being used.
3819   function getLastActionTimestamp() external view returns (uint256 timestamp) {
3820     return actionsCount == 0 ? 0 : actions[actionsCount - 1].creationTime;
3821   }
3822 
3823   /// @notice Get the current action state of an action by its `actionInfo` struct.
3824   /// @param actionInfo Data required to create an action.
3825   /// @return The current action state of the action.
3826   function getActionState(ActionInfo calldata actionInfo) public view returns (ActionState) {
3827     // We don't need an explicit check on the action ID to make sure it exists, because if the
3828     // action does not exist, the expected payload hash from storage will be `bytes32(0)`, so
3829     // bypassing this check by providing a non-existent actionId would require finding a collision
3830     // to get a hash of zero.
3831     Action storage action = actions[actionInfo.id];
3832     _validateActionInfoHash(action.infoHash, actionInfo);
3833 
3834     if (action.canceled) return ActionState.Canceled;
3835 
3836     if (action.executed) return ActionState.Executed;
3837 
3838     if (actionInfo.strategy.isActive(actionInfo)) return ActionState.Active;
3839 
3840     if (!actionInfo.strategy.isActionApproved(actionInfo)) return ActionState.Failed;
3841 
3842     if (action.minExecutionTime == 0) return ActionState.Approved;
3843 
3844     if (actionInfo.strategy.isActionDisapproved(actionInfo)) return ActionState.Failed;
3845 
3846     if (actionInfo.strategy.isActionExpired(actionInfo)) return ActionState.Expired;
3847 
3848     return ActionState.Queued;
3849   }
3850 
3851   // ================================
3852   // ======== Internal Logic ========
3853   // ================================
3854 
3855   /// @dev Creates an action. The creator needs to hold a policy with the permission ID of the provided
3856   /// `(target, selector, strategy)`.
3857   function _createAction(
3858     address policyholder,
3859     uint8 role,
3860     ILlamaStrategy strategy,
3861     address target,
3862     uint256 value,
3863     bytes calldata data,
3864     string memory description
3865   ) internal returns (uint256 actionId) {
3866     if (target == address(executor)) revert CannotSetExecutorAsTarget();
3867     if (!strategies[strategy]) revert InvalidStrategy();
3868 
3869     PermissionData memory permission = PermissionData(target, bytes4(data), strategy);
3870     bytes32 permissionId = keccak256(abi.encode(permission));
3871 
3872     // Typically (such as in Governor contracts) this should check that the caller has permission
3873     // at `block.number|timestamp - 1` but here we're just checking if the caller *currently* has
3874     // permission. Technically this introduces a race condition if e.g. an action to revoke a role
3875     // from someone (or revoke a permission from a role) is ready to be executed at the same time as
3876     // an action is created, as the order of transactions in the block then affects if action
3877     // creation would succeed. However, we are ok with this tradeoff because it means we don't need
3878     // to checkpoint the `canCreateAction` mapping which is simpler and cheaper, and in practice
3879     // this race condition is unlikely to matter.
3880     if (!policy.hasPermissionId(policyholder, role, permissionId)) revert PolicyholderDoesNotHavePermission();
3881 
3882     // Validate action creation.
3883     actionId = actionsCount;
3884 
3885     ActionInfo memory actionInfo = ActionInfo(actionId, policyholder, role, strategy, target, value, data);
3886     strategy.validateActionCreation(actionInfo);
3887 
3888     // Scope to avoid stack too deep
3889     {
3890       ILlamaActionGuard guard = actionGuard[target][bytes4(data)];
3891       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);
3892 
3893       // Save action.
3894       Action storage newAction = actions[actionId];
3895       newAction.infoHash = _infoHash(actionId, policyholder, role, strategy, target, value, data);
3896       newAction.creationTime = LlamaUtils.toUint64(block.timestamp);
3897       newAction.isScript = authorizedScripts[target];
3898     }
3899 
3900     actionsCount = LlamaUtils.uncheckedIncrement(actionsCount); // Safety: Can never overflow a uint256 by incrementing.
3901 
3902     emit ActionCreated(actionId, policyholder, role, strategy, target, value, data, description);
3903   }
3904 
3905   /// @dev How policyholders that have the right role contribute towards the approval of an action with a reason.
3906   function _castApproval(address policyholder, uint8 role, ActionInfo calldata actionInfo, string memory reason)
3907     internal
3908   {
3909     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Active);
3910 
3911     action.totalApprovals = _newCastCount(action.totalApprovals, quantity);
3912     approvals[actionInfo.id][policyholder] = true;
3913     emit ApprovalCast(actionInfo.id, policyholder, role, quantity, reason);
3914   }
3915 
3916   /// @dev How policyholders that have the right role contribute towards the disapproval of an action with a reason.
3917   function _castDisapproval(address policyholder, uint8 role, ActionInfo calldata actionInfo, string memory reason)
3918     internal
3919   {
3920     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Queued);
3921 
3922     action.totalDisapprovals = _newCastCount(action.totalDisapprovals, quantity);
3923     disapprovals[actionInfo.id][policyholder] = true;
3924     emit DisapprovalCast(actionInfo.id, policyholder, role, quantity, reason);
3925   }
3926 
3927   /// @dev The only `expectedState` values allowed to be passed into this method are Active or Queued.
3928   function _preCastAssertions(
3929     ActionInfo calldata actionInfo,
3930     address policyholder,
3931     uint8 role,
3932     ActionState expectedState
3933   ) internal returns (Action storage action, uint128 quantity) {
3934     action = actions[actionInfo.id];
3935     ActionState currentState = getActionState(actionInfo);
3936     if (currentState != expectedState) revert InvalidActionState(currentState);
3937 
3938     bool isApproval = expectedState == ActionState.Active;
3939     bool alreadyCast = isApproval ? approvals[actionInfo.id][policyholder] : disapprovals[actionInfo.id][policyholder];
3940     if (alreadyCast) revert DuplicateCast();
3941 
3942     bool hasRole = policy.hasRole(policyholder, role, action.creationTime);
3943     if (!hasRole) revert InvalidPolicyholder();
3944 
3945     if (isApproval) {
3946       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);
3947       quantity = actionInfo.strategy.getApprovalQuantityAt(policyholder, role, action.creationTime);
3948       if (quantity == 0) revert CannotCastWithZeroQuantity(policyholder, role);
3949     } else {
3950       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);
3951       quantity = actionInfo.strategy.getDisapprovalQuantityAt(policyholder, role, action.creationTime);
3952       if (quantity == 0) revert CannotCastWithZeroQuantity(policyholder, role);
3953     }
3954   }
3955 
3956   /// @dev Returns the new total count of approvals or disapprovals.
3957   function _newCastCount(uint128 currentCount, uint128 quantity) internal pure returns (uint128) {
3958     if (currentCount == type(uint128).max || quantity == type(uint128).max) return type(uint128).max;
3959     return currentCount + quantity;
3960   }
3961 
3962   /// @dev Deploys new strategies. Takes in the strategy logic contract to be used and an array of configurations to
3963   /// initialize the new strategies with. Returns the address of the first strategy, which is only used during the
3964   /// `LlamaCore` initialization so that we can ensure someone (specifically, policyholders with role ID 1) has the
3965   /// permission to assign role permissions.
3966   function _deployStrategies(ILlamaStrategy llamaStrategyLogic, bytes[] calldata strategyConfigs)
3967     internal
3968     returns (ILlamaStrategy firstStrategy)
3969   {
3970     if (address(factory).code.length > 0 && !factory.authorizedStrategyLogics(llamaStrategyLogic)) {
3971       // The only edge case where this check is skipped is if `_deployStrategies()` is called by root llama instance
3972       // during Llama Factory construction. This is because there is no code at the Llama Factory address yet.
3973       revert UnauthorizedStrategyLogic();
3974     }
3975 
3976     uint256 strategyLength = strategyConfigs.length;
3977     for (uint256 i = 0; i < strategyLength; i = LlamaUtils.uncheckedIncrement(i)) {
3978       bytes32 salt = bytes32(keccak256(strategyConfigs[i]));
3979       ILlamaStrategy strategy = ILlamaStrategy(Clones.cloneDeterministic(address(llamaStrategyLogic), salt));
3980       strategy.initialize(strategyConfigs[i]);
3981       strategies[strategy] = true;
3982       emit StrategyCreated(strategy, llamaStrategyLogic, strategyConfigs[i]);
3983       if (i == 0) firstStrategy = strategy;
3984     }
3985   }
3986 
3987   /// @dev Deploys new accounts. Takes in the account logic contract to be used and an array of configurations to
3988   /// initialize the new accounts with.
3989   function _deployAccounts(ILlamaAccount llamaAccountLogic, bytes[] calldata accountConfigs) internal {
3990     if (address(factory).code.length > 0 && !factory.authorizedAccountLogics(llamaAccountLogic)) {
3991       // The only edge case where this check is skipped is if `_deployAccounts()` is called by root llama instance
3992       // during Llama Factory construction. This is because there is no code at the Llama Factory address yet.
3993       revert UnauthorizedAccountLogic();
3994     }
3995 
3996     uint256 accountLength = accountConfigs.length;
3997     for (uint256 i = 0; i < accountLength; i = LlamaUtils.uncheckedIncrement(i)) {
3998       bytes32 salt = bytes32(keccak256(accountConfigs[i]));
3999       ILlamaAccount account = ILlamaAccount(Clones.cloneDeterministic(address(llamaAccountLogic), salt));
4000       account.initialize(accountConfigs[i]);
4001       emit AccountCreated(account, llamaAccountLogic, accountConfigs[i]);
4002     }
4003   }
4004 
4005   /// @dev Returns the hash of the `createAction` parameters using the `actionInfo` struct.
4006   function _infoHash(ActionInfo calldata actionInfo) internal pure returns (bytes32) {
4007     return _infoHash(
4008       actionInfo.id,
4009       actionInfo.creator,
4010       actionInfo.creatorRole,
4011       actionInfo.strategy,
4012       actionInfo.target,
4013       actionInfo.value,
4014       actionInfo.data
4015     );
4016   }
4017 
4018   /// @dev Returns the hash of the `createAction` parameters.
4019   function _infoHash(
4020     uint256 id,
4021     address creator,
4022     uint8 creatorRole,
4023     ILlamaStrategy strategy,
4024     address target,
4025     uint256 value,
4026     bytes calldata data
4027   ) internal pure returns (bytes32) {
4028     return keccak256(abi.encodePacked(id, creator, creatorRole, strategy, target, value, data));
4029   }
4030 
4031   /// @dev Validates that the hash of the `actionInfo` struct matches the provided hash.
4032   function _validateActionInfoHash(bytes32 actualHash, ActionInfo calldata actionInfo) internal pure {
4033     bytes32 expectedHash = _infoHash(actionInfo);
4034     if (actualHash != expectedHash) revert InfoHashMismatch();
4035   }
4036 
4037   /// @dev Returns the current nonce for a given policyholder and selector, and increments it. Used to prevent
4038   /// replay attacks.
4039   function _useNonce(address policyholder, bytes4 selector) internal returns (uint256 nonce) {
4040     nonce = nonces[policyholder][selector];
4041     nonces[policyholder][selector] = LlamaUtils.uncheckedIncrement(nonce);
4042   }
4043 
4044   // -------- EIP-712 Getters --------
4045 
4046   /// @dev Returns the EIP-712 domain separator.
4047   function _getDomainHash() internal view returns (bytes32) {
4048     return keccak256(
4049       abi.encode(EIP712_DOMAIN_TYPEHASH, keccak256(bytes(name)), keccak256(bytes("1")), block.chainid, address(this))
4050     );
4051   }
4052 
4053   /// @dev Returns the hash of the ABI-encoded EIP-712 message for the `CreateAction` domain, which can be used to
4054   /// recover the signer.
4055   function _getCreateActionTypedDataHash(
4056     address policyholder,
4057     uint8 role,
4058     ILlamaStrategy strategy,
4059     address target,
4060     uint256 value,
4061     bytes calldata data,
4062     string memory description
4063   ) internal returns (bytes32) {
4064     // Calculating and storing nonce in memory and using that below, instead of calculating in place to prevent stack
4065     // too deep error.
4066     uint256 nonce = _useNonce(policyholder, msg.sig);
4067 
4068     bytes32 createActionHash = keccak256(
4069       abi.encode(
4070         CREATE_ACTION_TYPEHASH,
4071         policyholder,
4072         role,
4073         address(strategy),
4074         target,
4075         value,
4076         keccak256(data),
4077         keccak256(bytes(description)),
4078         nonce
4079       )
4080     );
4081 
4082     return keccak256(abi.encodePacked("\x19\x01", _getDomainHash(), createActionHash));
4083   }
4084 
4085   /// @dev Returns the hash of the ABI-encoded EIP-712 message for the `CastApproval` domain, which can be used to
4086   /// recover the signer.
4087   function _getCastApprovalTypedDataHash(
4088     address policyholder,
4089     uint8 role,
4090     ActionInfo calldata actionInfo,
4091     string calldata reason
4092   ) internal returns (bytes32) {
4093     bytes32 castApprovalHash = keccak256(
4094       abi.encode(
4095         CAST_APPROVAL_TYPEHASH,
4096         policyholder,
4097         role,
4098         _getActionInfoHash(actionInfo),
4099         keccak256(bytes(reason)),
4100         _useNonce(policyholder, msg.sig)
4101       )
4102     );
4103 
4104     return keccak256(abi.encodePacked("\x19\x01", _getDomainHash(), castApprovalHash));
4105   }
4106 
4107   /// @dev Returns the hash of the ABI-encoded EIP-712 message for the `CastDisapproval` domain, which can be used to
4108   /// recover the signer.
4109   function _getCastDisapprovalTypedDataHash(
4110     address policyholder,
4111     uint8 role,
4112     ActionInfo calldata actionInfo,
4113     string calldata reason
4114   ) internal returns (bytes32) {
4115     bytes32 castDisapprovalHash = keccak256(
4116       abi.encode(
4117         CAST_DISAPPROVAL_TYPEHASH,
4118         policyholder,
4119         role,
4120         _getActionInfoHash(actionInfo),
4121         keccak256(bytes(reason)),
4122         _useNonce(policyholder, msg.sig)
4123       )
4124     );
4125 
4126     return keccak256(abi.encodePacked("\x19\x01", _getDomainHash(), castDisapprovalHash));
4127   }
4128 
4129   /// @dev Returns the hash of `actionInfo`.
4130   function _getActionInfoHash(ActionInfo calldata actionInfo) internal pure returns (bytes32) {
4131     return keccak256(
4132       abi.encode(
4133         ACTION_INFO_TYPEHASH,
4134         actionInfo.id,
4135         actionInfo.creator,
4136         actionInfo.creatorRole,
4137         address(actionInfo.strategy),
4138         actionInfo.target,
4139         actionInfo.value,
4140         keccak256(actionInfo.data)
4141       )
4142     );
4143   }
4144 }



```

### LlamaAccount.sol


```
Contract locking ether found:
	Contract LlamaCore (LlamaAccount.sol#4148-4931) has payable functions:
	 - LlamaCore.executeAction(ActionInfo) (LlamaAccount.sol#4445-4471)
	But does not have a function to withdraw the ether



    
4148 contract LlamaCore is Initializable {
4149   // ======================================
4150   // ======== Errors and Modifiers ========
4151   // ======================================
4152 
4153   /// @dev Policyholder cannot cast if it has 0 quantity of role.
4154   /// @param policyholder Address of policyholder.
4155   /// @param role The role being used in the cast.
4156   error CannotCastWithZeroQuantity(address policyholder, uint8 role);
4157 
4158   /// @dev An action's target contract cannot be the executor.
4159   error CannotSetExecutorAsTarget();
4160 
4161   /// @dev Address cannot be used.
4162   error RestrictedAddress();
4163 
4164   /// @dev Policyholders can only cast once.
4165   error DuplicateCast();
4166 
4167   /// @dev Action execution failed.
4168   /// @param reason Data returned by the function called by the action.
4169   error FailedActionExecution(bytes reason);
4170 
4171   /// @dev `ActionInfo` does not hash to the correct value.
4172   error InfoHashMismatch();
4173 
4174   /// @dev `msg.value` does not equal the action's value.
4175   error IncorrectMsgValue();
4176 
4177   /// @dev The action is not in the expected state.
4178   /// @param current The current state of the action.
4179   error InvalidActionState(ActionState current);
4180 
4181   /// @dev The policyholder does not have the role at action creation time.
4182   error InvalidPolicyholder();
4183 
4184   /// @dev The recovered signer does not match the expected policyholder.
4185   error InvalidSignature();
4186 
4187   /// @dev The provided address does not map to a deployed strategy.
4188   error InvalidStrategy();
4189 
4190   /// @dev An action cannot queue successfully if it's `minExecutionTime` is less than `block.timestamp`.
4191   error MinExecutionTimeCannotBeInThePast();
4192 
4193   /// @dev Only callable by a Llama instance's executor.
4194   error OnlyLlama();
4195 
4196   /// @dev Policyholder does not have the permission ID to create the action.
4197   error PolicyholderDoesNotHavePermission();
4198 
4199   /// @dev If `block.timestamp` is less than `minExecutionTime`, the action cannot be executed.
4200   error MinExecutionTimeNotReached();
4201 
4202   /// @dev Strategies can only be created with valid logic contracts.
4203   error UnauthorizedStrategyLogic();
4204 
4205   /// @dev Accounts can only be created with valid logic contracts.
4206   error UnauthorizedAccountLogic();
4207 
4208   /// @dev Checks that the caller is the Llama Executor and reverts if not.
4209   modifier onlyLlama() {
4210     if (msg.sender != address(executor)) revert OnlyLlama();
4211     _;
4212   }
4213 
4214   // ========================
4215   // ======== Events ========
4216   // ========================
4217 
4218   /// @dev Emitted when an action is created.
4219   event ActionCreated(
4220     uint256 id,
4221     address indexed creator,
4222     uint8 role,
4223     ILlamaStrategy indexed strategy,
4224     address indexed target,
4225     uint256 value,
4226     bytes data,
4227     string description
4228   );
4229 
4230   /// @dev Emitted when an action is canceled.
4231   event ActionCanceled(uint256 id);
4232 
4233   /// @dev Emitted when an action guard is set.
4234   event ActionGuardSet(address indexed target, bytes4 indexed selector, ILlamaActionGuard actionGuard);
4235 
4236   /// @dev Emitted when an action is queued.
4237   event ActionQueued(
4238     uint256 id,
4239     address indexed caller,
4240     ILlamaStrategy indexed strategy,
4241     address indexed creator,
4242     uint256 minExecutionTime
4243   );
4244 
4245   /// @dev Emitted when an action is executed.
4246   event ActionExecuted(
4247     uint256 id, address indexed caller, ILlamaStrategy indexed strategy, address indexed creator, bytes result
4248   );
4249 
4250   /// @dev Emitted when an approval is cast.
4251   event ApprovalCast(uint256 id, address indexed policyholder, uint8 indexed role, uint256 quantity, string reason);
4252 
4253   /// @dev Emitted when a disapproval is cast.
4254   event DisapprovalCast(uint256 id, address indexed policyholder, uint8 indexed role, uint256 quantity, string reason);
4255 
4256   /// @dev Emitted when a strategy is created and authorized.
4257   event StrategyCreated(ILlamaStrategy strategy, ILlamaStrategy indexed strategyLogic, bytes initializationData);
4258 
4259   /// @dev Emitted when an account is created.
4260   event AccountCreated(ILlamaAccount account, ILlamaAccount indexed accountLogic, bytes initializationData);
4261 
4262   /// @dev Emitted when a script is authorized.
4263   event ScriptAuthorized(address script, bool authorized);
4264 
4265   // =================================================
4266   // ======== Constants and Storage Variables ========
4267   // =================================================
4268 
4269   /// @dev EIP-712 base typehash.
4270   bytes32 internal constant EIP712_DOMAIN_TYPEHASH =
4271     keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");
4272 
4273   /// @dev EIP-712 createAction typehash.
4274   bytes32 internal constant CREATE_ACTION_TYPEHASH = keccak256(
4275     "CreateAction(address policyholder,uint8 role,address strategy,address target,uint256 value,bytes data,string description,uint256 nonce)"
4276   );
4277 
4278   /// @dev EIP-712 castApproval typehash.
4279   bytes32 internal constant CAST_APPROVAL_TYPEHASH = keccak256(
4280     "CastApproval(address policyholder,uint8 role,ActionInfo actionInfo,string reason,uint256 nonce)ActionInfo(uint256 id,address creator,uint8 creatorRole,address strategy,address target,uint256 value,bytes data)"
4281   );
4282 
4283   /// @dev EIP-712 castDisapproval typehash.
4284   bytes32 internal constant CAST_DISAPPROVAL_TYPEHASH = keccak256(
4285     "CastDisapproval(address policyholder,uint8 role,ActionInfo actionInfo,string reason,uint256 nonce)ActionInfo(uint256 id,address creator,uint8 creatorRole,address strategy,address target,uint256 value,bytes data)"
4286   );
4287 
4288   /// @dev EIP-712 actionInfo typehash.
4289   bytes32 internal constant ACTION_INFO_TYPEHASH = keccak256(
4290     "ActionInfo(uint256 id,address creator,uint8 creatorRole,address strategy,address target,uint256 value,bytes data)"
4291   );
4292 
4293   /// @dev Mapping of actionIds to Actions.
4294   /// @dev Making this `public` results in stack too deep with no optimizer, but this data can be
4295   /// accessed with the `getAction` function so this is ok. We want the contracts to compile
4296   /// without the optimizer so `forge coverage` can be used.
4297   mapping(uint256 => Action) internal actions;
4298 
4299   /// @notice The contract that executes actions for this Llama instance.
4300   LlamaExecutor public executor;
4301 
4302   /// @notice The ERC721 contract that defines the policies for this Llama instance.
4303   /// @dev We intentionally put this first so it's packed with the `Initializable` storage
4304   // variables, which are the key variables we want to check before and after a delegatecall.
4305   LlamaPolicy public policy;
4306 
4307   /// @notice The `LlamaFactory` contract that deployed this Llama instance.
4308   LlamaFactory public factory;
4309 
4310   /// @notice Name of this Llama instance.
4311   string public name;
4312 
4313   /// @notice The current number of actions created.
4314   uint256 public actionsCount;
4315 
4316   /// @notice Mapping of actionIds to policyholders to approvals.
4317   mapping(uint256 => mapping(address => bool)) public approvals;
4318 
4319   /// @notice Mapping of actionIds to policyholders to disapprovals.
4320   mapping(uint256 => mapping(address => bool)) public disapprovals;
4321 
4322   /// @notice Mapping of all authorized strategies.
4323   mapping(ILlamaStrategy => bool) public strategies;
4324 
4325   /// @notice Mapping of all authorized scripts.
4326   mapping(address => bool) public authorizedScripts;
4327 
4328   /// @notice Mapping of policyholders to function selectors to current nonces for EIP-712 signatures.
4329   /// @dev This is used to prevent replay attacks by incrementing the nonce for each operation (`createAction`,
4330   /// `castApproval` and `castDisapproval`) signed by the policyholder.
4331   mapping(address => mapping(bytes4 => uint256)) public nonces;
4332 
4333   /// @notice Mapping of target to selector to actionGuard address.
4334   mapping(address target => mapping(bytes4 selector => ILlamaActionGuard)) public actionGuard;
4335 
4336   // ======================================================
4337   // ======== Contract Creation and Initialization ========
4338   // ======================================================
4339 
4340   constructor() {
4341     _disableInitializers();
4342   }
4343 
4344   /// @notice Initializes a new `LlamaCore` clone.
4345   /// @param _name The name of the `LlamaCore` clone.
4346   /// @param _policy This Llama instance's policy contract.
4347   /// @param _llamaStrategyLogic The Llama Strategy implementation (logic) contract.
4348   /// @param _llamaAccountLogic The Llama Account implementation (logic) contract.
4349   /// @param initialStrategies Array of initial strategy configurations.
4350   /// @param initialAccounts Array of initial account configurations.
4351   /// @return bootstrapPermissionId The permission ID that's used to set role permissions.
4352   function initialize(
4353     string memory _name,
4354     LlamaPolicy _policy,
4355     ILlamaStrategy _llamaStrategyLogic,
4356     ILlamaAccount _llamaAccountLogic,
4357     bytes[] calldata initialStrategies,
4358     bytes[] calldata initialAccounts
4359   ) external initializer returns (bytes32 bootstrapPermissionId) {
4360     factory = LlamaFactory(msg.sender);
4361     name = _name;
4362     executor = new LlamaExecutor();
4363     policy = _policy;
4364 
4365     ILlamaStrategy bootstrapStrategy = _deployStrategies(_llamaStrategyLogic, initialStrategies);
4366     _deployAccounts(_llamaAccountLogic, initialAccounts);
4367 
4368     // Now we compute the permission ID used to set role permissions and return it.
4369     bytes4 selector = LlamaPolicy.setRolePermission.selector;
4370     return keccak256(abi.encode(PermissionData(address(policy), bytes4(selector), bootstrapStrategy)));
4371   }
4372 
4373   // ===========================================
4374   // ======== External and Public Logic ========
4375   // ===========================================
4376 
4377   /// @notice Creates an action. The creator needs to hold a policy with the permission ID of the provided
4378   /// `(target, selector, strategy)`.
4379   /// @dev Use `""` for `description` if there is no description.
4380   /// @param role The role that will be used to determine the permission ID of the policyholder.
4381   /// @param strategy The strategy contract that will determine how the action is executed.
4382   /// @param target The contract called when the action is executed.
4383   /// @param value The value in wei to be sent when the action is executed.
4384   /// @param data Data to be called on the target when the action is executed.
4385   /// @param description A human readable description of the action and the changes it will enact.
4386   /// @return actionId Action ID of the newly created action.
4387   function createAction(
4388     uint8 role,
4389     ILlamaStrategy strategy,
4390     address target,
4391     uint256 value,
4392     bytes calldata data,
4393     string memory description
4394   ) external returns (uint256 actionId) {
4395     actionId = _createAction(msg.sender, role, strategy, target, value, data, description);
4396   }
4397 
4398   /// @notice Creates an action via an off-chain signature. The creator needs to hold a policy with the permission ID
4399   /// of the provided `(target, selector, strategy)`.
4400   /// @dev Use `""` for `description` if there is no description.
4401   /// @param policyholder The policyholder that signed the message.
4402   /// @param role The role that will be used to determine the permission ID of the policyholder.
4403   /// @param strategy The strategy contract that will determine how the action is executed.
4404   /// @param target The contract called when the action is executed.
4405   /// @param value The value in wei to be sent when the action is executed.
4406   /// @param data Data to be called on the target when the action is executed.
4407   /// @param description A human readable description of the action and the changes it will enact.
4408   /// @param v ECDSA signature component: Parity of the `y` coordinate of point `R`
4409   /// @param r ECDSA signature component: x-coordinate of `R`
4410   /// @param s ECDSA signature component: `s` value of the signature
4411   /// @return actionId Action ID of the newly created action.
4412   function createActionBySig(
4413     address policyholder,
4414     uint8 role,
4415     ILlamaStrategy strategy,
4416     address target,
4417     uint256 value,
4418     bytes calldata data,
4419     string memory description,
4420     uint8 v,
4421     bytes32 r,
4422     bytes32 s
4423   ) external returns (uint256 actionId) {
4424     bytes32 digest = _getCreateActionTypedDataHash(policyholder, role, strategy, target, value, data, description);
4425     address signer = ecrecover(digest, v, r, s);
4426     if (signer == address(0) || signer != policyholder) revert InvalidSignature();
4427     actionId = _createAction(signer, role, strategy, target, value, data, description);
4428   }
4429 
4430   /// @notice Queue an action by its `actionInfo` struct if it's in Approved state.
4431   /// @param actionInfo Data required to create an action.
4432   function queueAction(ActionInfo calldata actionInfo) external {
4433     Action storage action = actions[actionInfo.id];
4434     ActionState currentState = getActionState(actionInfo);
4435     if (currentState != ActionState.Approved) revert InvalidActionState(currentState);
4436 
4437     uint64 minExecutionTime = actionInfo.strategy.minExecutionTime(actionInfo);
4438     if (minExecutionTime < block.timestamp) revert MinExecutionTimeCannotBeInThePast();
4439     action.minExecutionTime = minExecutionTime;
4440     emit ActionQueued(actionInfo.id, msg.sender, actionInfo.strategy, actionInfo.creator, minExecutionTime);
4441   }
4442 
4443   /// @notice Execute an action by its `actionInfo` struct if it's in Queued state and `minExecutionTime` has passed.
4444   /// @param actionInfo Data required to create an action.
4445   function executeAction(ActionInfo calldata actionInfo) external payable {
4446     // Initial checks that action is ready to execute.
4447     Action storage action = actions[actionInfo.id];
4448     ActionState currentState = getActionState(actionInfo);
4449 
4450     if (currentState != ActionState.Queued) revert InvalidActionState(currentState);
4451     if (block.timestamp < action.minExecutionTime) revert MinExecutionTimeNotReached();
4452     if (msg.value != actionInfo.value) revert IncorrectMsgValue();
4453 
4454     action.executed = true;
4455 
4456     // Check pre-execution action guard.
4457     ILlamaActionGuard guard = actionGuard[actionInfo.target][bytes4(actionInfo.data)];
4458     if (guard != ILlamaActionGuard(address(0))) guard.validatePreActionExecution(actionInfo);
4459 
4460     // Execute action.
4461     (bool success, bytes memory result) =
4462       executor.execute(actionInfo.target, actionInfo.value, action.isScript, actionInfo.data);
4463 
4464     if (!success) revert FailedActionExecution(result);
4465 
4466     // Check post-execution action guard.
4467     if (guard != ILlamaActionGuard(address(0))) guard.validatePostActionExecution(actionInfo);
4468 
4469     // Action successfully executed.
4470     emit ActionExecuted(actionInfo.id, msg.sender, actionInfo.strategy, actionInfo.creator, result);
4471   }
4472 
4473   /// @notice Cancels an action by its `actionInfo` struct.
4474   /// @dev Rules for cancelation are defined by the strategy.
4475   /// @param actionInfo Data required to create an action.
4476   function cancelAction(ActionInfo calldata actionInfo) external {
4477     Action storage action = actions[actionInfo.id];
4478     _validateActionInfoHash(action.infoHash, actionInfo);
4479 
4480     // We don't need an explicit check on action existence because if it doesn't exist the strategy will be the zero
4481     // address, and Solidity will revert since there is no code at the zero address.
4482     actionInfo.strategy.validateActionCancelation(actionInfo, msg.sender);
4483 
4484     action.canceled = true;
4485     emit ActionCanceled(actionInfo.id);
4486   }
4487 
4488   /// @notice How policyholders add their support of the approval of an action with a reason.
4489   /// @dev Use `""` for `reason` if there is no reason.
4490   /// @param role The role the policyholder uses to cast their approval.
4491   /// @param actionInfo Data required to create an action.
4492   /// @param reason The reason given for the approval by the policyholder.
4493   function castApproval(uint8 role, ActionInfo calldata actionInfo, string calldata reason) external {
4494     return _castApproval(msg.sender, role, actionInfo, reason);
4495   }
4496 
4497   /// @notice How policyholders add their support of the approval of an action via an off-chain signature.
4498   /// @dev Use `""` for `reason` if there is no reason.
4499   /// @param policyholder The policyholder that signed the message.
4500   /// @param role The role the policyholder uses to cast their approval.
4501   /// @param actionInfo Data required to create an action.
4502   /// @param reason The reason given for the approval by the policyholder.
4503   /// @param v ECDSA signature component: Parity of the `y` coordinate of point `R`
4504   /// @param r ECDSA signature component: x-coordinate of `R`
4505   /// @param s ECDSA signature component: `s` value of the signature
4506   function castApprovalBySig(
4507     address policyholder,
4508     uint8 role,
4509     ActionInfo calldata actionInfo,
4510     string calldata reason,
4511     uint8 v,
4512     bytes32 r,
4513     bytes32 s
4514   ) external {
4515     bytes32 digest = _getCastApprovalTypedDataHash(policyholder, role, actionInfo, reason);
4516     address signer = ecrecover(digest, v, r, s);
4517     if (signer == address(0) || signer != policyholder) revert InvalidSignature();
4518     return _castApproval(signer, role, actionInfo, reason);
4519   }
4520 
4521   /// @notice How policyholders add their support of the disapproval of an action with a reason.
4522   /// @dev Use `""` for `reason` if there is no reason.
4523   /// @param role The role the policyholder uses to cast their disapproval.
4524   /// @param actionInfo Data required to create an action.
4525   /// @param reason The reason given for the disapproval by the policyholder.
4526   function castDisapproval(uint8 role, ActionInfo calldata actionInfo, string calldata reason) external {
4527     return _castDisapproval(msg.sender, role, actionInfo, reason);
4528   }
4529 
4530   /// @notice How policyholders add their support of the disapproval of an action via an off-chain signature.
4531   /// @dev Use `""` for `reason` if there is no reason.
4532   /// @param policyholder The policyholder that signed the message.
4533   /// @param role The role the policyholder uses to cast their disapproval.
4534   /// @param actionInfo Data required to create an action.
4535   /// @param reason The reason given for the approval by the policyholder.
4536   /// @param v ECDSA signature component: Parity of the `y` coordinate of point `R`
4537   /// @param r ECDSA signature component: x-coordinate of `R`
4538   /// @param s ECDSA signature component: `s` value of the signature
4539   function castDisapprovalBySig(
4540     address policyholder,
4541     uint8 role,
4542     ActionInfo calldata actionInfo,
4543     string calldata reason,
4544     uint8 v,
4545     bytes32 r,
4546     bytes32 s
4547   ) external {
4548     bytes32 digest = _getCastDisapprovalTypedDataHash(policyholder, role, actionInfo, reason);
4549     address signer = ecrecover(digest, v, r, s);
4550     if (signer == address(0) || signer != policyholder) revert InvalidSignature();
4551     return _castDisapproval(signer, role, actionInfo, reason);
4552   }
4553 
4554   /// @notice Deploy new strategies and add them to the mapping of authorized strategies.
4555   /// @param llamaStrategyLogic address of the Llama strategy logic contract.
4556   /// @param strategyConfigs Array of new strategy configurations.
4557   function createStrategies(ILlamaStrategy llamaStrategyLogic, bytes[] calldata strategyConfigs) external onlyLlama {
4558     _deployStrategies(llamaStrategyLogic, strategyConfigs);
4559   }
4560 
4561   /// @notice Deploy new accounts.
4562   /// @param llamaAccountLogic address of the Llama account logic contract.
4563   /// @param accountConfigs Array of new account configurations.
4564   function createAccounts(ILlamaAccount llamaAccountLogic, bytes[] calldata accountConfigs) external onlyLlama {
4565     _deployAccounts(llamaAccountLogic, accountConfigs);
4566   }
4567 
4568   /// @notice Sets `guard` as the action guard for the given `target` and `selector`.
4569   /// @param target The target contract where the `guard` will apply.
4570   /// @param selector The function selector where the `guard` will apply.
4571   /// @dev To remove a guard, set `guard` to the zero address.
4572   function setGuard(address target, bytes4 selector, ILlamaActionGuard guard) external onlyLlama {
4573     if (target == address(this) || target == address(policy)) revert RestrictedAddress();
4574     actionGuard[target][selector] = guard;
4575     emit ActionGuardSet(target, selector, guard);
4576   }
4577 
4578   /// @notice Authorizes `script` to be eligible to be delegatecalled from the executor.
4579   /// @param script The address of the script contract.
4580   /// @param authorized The boolean that determines if the `script` is being authorized or unauthorized.
4581   /// @dev To remove a `script`, set `authorized` to `false`.
4582   function authorizeScript(address script, bool authorized) external onlyLlama {
4583     if (script == address(this) || script == address(policy)) revert RestrictedAddress();
4584     authorizedScripts[script] = authorized;
4585     emit ScriptAuthorized(script, authorized);
4586   }
4587 
4588   /// @notice Increments the caller's nonce for the given `selector`. This is useful for revoking
4589   /// signatures that have not been used yet.
4590   /// @param selector The function selector to increment the nonce for.
4591   function incrementNonce(bytes4 selector) external {
4592     // Safety: Can never overflow a uint256 by incrementing.
4593     nonces[msg.sender][selector] = LlamaUtils.uncheckedIncrement(nonces[msg.sender][selector]);
4594   }
4595 
4596   /// @notice Get an Action struct by `actionId`.
4597   /// @param actionId ID of the action.
4598   /// @return The Action struct.
4599   function getAction(uint256 actionId) external view returns (Action memory) {
4600     return actions[actionId];
4601   }
4602 
4603   /// @notice Returns the timestamp of most recently created action.
4604   /// @dev Used by `LlamaPolicy` to ensure policy management does not occur immediately after action
4605   /// creation in the same timestamp, as this could result in invalid role supply counts being used.
4606   function getLastActionTimestamp() external view returns (uint256 timestamp) {
4607     return actionsCount == 0 ? 0 : actions[actionsCount - 1].creationTime;
4608   }
4609 
4610   /// @notice Get the current action state of an action by its `actionInfo` struct.
4611   /// @param actionInfo Data required to create an action.
4612   /// @return The current action state of the action.
4613   function getActionState(ActionInfo calldata actionInfo) public view returns (ActionState) {
4614     // We don't need an explicit check on the action ID to make sure it exists, because if the
4615     // action does not exist, the expected payload hash from storage will be `bytes32(0)`, so
4616     // bypassing this check by providing a non-existent actionId would require finding a collision
4617     // to get a hash of zero.
4618     Action storage action = actions[actionInfo.id];
4619     _validateActionInfoHash(action.infoHash, actionInfo);
4620 
4621     if (action.canceled) return ActionState.Canceled;
4622 
4623     if (action.executed) return ActionState.Executed;
4624 
4625     if (actionInfo.strategy.isActive(actionInfo)) return ActionState.Active;
4626 
4627     if (!actionInfo.strategy.isActionApproved(actionInfo)) return ActionState.Failed;
4628 
4629     if (action.minExecutionTime == 0) return ActionState.Approved;
4630 
4631     if (actionInfo.strategy.isActionDisapproved(actionInfo)) return ActionState.Failed;
4632 
4633     if (actionInfo.strategy.isActionExpired(actionInfo)) return ActionState.Expired;
4634 
4635     return ActionState.Queued;
4636   }
4637 
4638   // ================================
4639   // ======== Internal Logic ========
4640   // ================================
4641 
4642   /// @dev Creates an action. The creator needs to hold a policy with the permission ID of the provided
4643   /// `(target, selector, strategy)`.
4644   function _createAction(
4645     address policyholder,
4646     uint8 role,
4647     ILlamaStrategy strategy,
4648     address target,
4649     uint256 value,
4650     bytes calldata data,
4651     string memory description
4652   ) internal returns (uint256 actionId) {
4653     if (target == address(executor)) revert CannotSetExecutorAsTarget();
4654     if (!strategies[strategy]) revert InvalidStrategy();
4655 
4656     PermissionData memory permission = PermissionData(target, bytes4(data), strategy);
4657     bytes32 permissionId = keccak256(abi.encode(permission));
4658 
4659     // Typically (such as in Governor contracts) this should check that the caller has permission
4660     // at `block.number|timestamp - 1` but here we're just checking if the caller *currently* has
4661     // permission. Technically this introduces a race condition if e.g. an action to revoke a role
4662     // from someone (or revoke a permission from a role) is ready to be executed at the same time as
4663     // an action is created, as the order of transactions in the block then affects if action
4664     // creation would succeed. However, we are ok with this tradeoff because it means we don't need
4665     // to checkpoint the `canCreateAction` mapping which is simpler and cheaper, and in practice
4666     // this race condition is unlikely to matter.
4667     if (!policy.hasPermissionId(policyholder, role, permissionId)) revert PolicyholderDoesNotHavePermission();
4668 
4669     // Validate action creation.
4670     actionId = actionsCount;
4671 
4672     ActionInfo memory actionInfo = ActionInfo(actionId, policyholder, role, strategy, target, value, data);
4673     strategy.validateActionCreation(actionInfo);
4674 
4675     // Scope to avoid stack too deep
4676     {
4677       ILlamaActionGuard guard = actionGuard[target][bytes4(data)];
4678       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);
4679 
4680       // Save action.
4681       Action storage newAction = actions[actionId];
4682       newAction.infoHash = _infoHash(actionId, policyholder, role, strategy, target, value, data);
4683       newAction.creationTime = LlamaUtils.toUint64(block.timestamp);
4684       newAction.isScript = authorizedScripts[target];
4685     }
4686 
4687     actionsCount = LlamaUtils.uncheckedIncrement(actionsCount); // Safety: Can never overflow a uint256 by incrementing.
4688 
4689     emit ActionCreated(actionId, policyholder, role, strategy, target, value, data, description);
4690   }
4691 
4692   /// @dev How policyholders that have the right role contribute towards the approval of an action with a reason.
4693   function _castApproval(address policyholder, uint8 role, ActionInfo calldata actionInfo, string memory reason)
4694     internal
4695   {
4696     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Active);
4697 
4698     action.totalApprovals = _newCastCount(action.totalApprovals, quantity);
4699     approvals[actionInfo.id][policyholder] = true;
4700     emit ApprovalCast(actionInfo.id, policyholder, role, quantity, reason);
4701   }
4702 
4703   /// @dev How policyholders that have the right role contribute towards the disapproval of an action with a reason.
4704   function _castDisapproval(address policyholder, uint8 role, ActionInfo calldata actionInfo, string memory reason)
4705     internal
4706   {
4707     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Queued);
4708 
4709     action.totalDisapprovals = _newCastCount(action.totalDisapprovals, quantity);
4710     disapprovals[actionInfo.id][policyholder] = true;
4711     emit DisapprovalCast(actionInfo.id, policyholder, role, quantity, reason);
4712   }
4713 
4714   /// @dev The only `expectedState` values allowed to be passed into this method are Active or Queued.
4715   function _preCastAssertions(
4716     ActionInfo calldata actionInfo,
4717     address policyholder,
4718     uint8 role,
4719     ActionState expectedState
4720   ) internal returns (Action storage action, uint128 quantity) {
4721     action = actions[actionInfo.id];
4722     ActionState currentState = getActionState(actionInfo);
4723     if (currentState != expectedState) revert InvalidActionState(currentState);
4724 
4725     bool isApproval = expectedState == ActionState.Active;
4726     bool alreadyCast = isApproval ? approvals[actionInfo.id][policyholder] : disapprovals[actionInfo.id][policyholder];
4727     if (alreadyCast) revert DuplicateCast();
4728 
4729     bool hasRole = policy.hasRole(policyholder, role, action.creationTime);
4730     if (!hasRole) revert InvalidPolicyholder();
4731 
4732     if (isApproval) {
4733       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);
4734       quantity = actionInfo.strategy.getApprovalQuantityAt(policyholder, role, action.creationTime);
4735       if (quantity == 0) revert CannotCastWithZeroQuantity(policyholder, role);
4736     } else {
4737       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);
4738       quantity = actionInfo.strategy.getDisapprovalQuantityAt(policyholder, role, action.creationTime);
4739       if (quantity == 0) revert CannotCastWithZeroQuantity(policyholder, role);
4740     }
4741   }
4742 
4743   /// @dev Returns the new total count of approvals or disapprovals.
4744   function _newCastCount(uint128 currentCount, uint128 quantity) internal pure returns (uint128) {
4745     if (currentCount == type(uint128).max || quantity == type(uint128).max) return type(uint128).max;
4746     return currentCount + quantity;
4747   }
4748 
4749   /// @dev Deploys new strategies. Takes in the strategy logic contract to be used and an array of configurations to
4750   /// initialize the new strategies with. Returns the address of the first strategy, which is only used during the
4751   /// `LlamaCore` initialization so that we can ensure someone (specifically, policyholders with role ID 1) has the
4752   /// permission to assign role permissions.
4753   function _deployStrategies(ILlamaStrategy llamaStrategyLogic, bytes[] calldata strategyConfigs)
4754     internal
4755     returns (ILlamaStrategy firstStrategy)
4756   {
4757     if (address(factory).code.length > 0 && !factory.authorizedStrategyLogics(llamaStrategyLogic)) {
4758       // The only edge case where this check is skipped is if `_deployStrategies()` is called by root llama instance
4759       // during Llama Factory construction. This is because there is no code at the Llama Factory address yet.
4760       revert UnauthorizedStrategyLogic();
4761     }
4762 
4763     uint256 strategyLength = strategyConfigs.length;
4764     for (uint256 i = 0; i < strategyLength; i = LlamaUtils.uncheckedIncrement(i)) {
4765       bytes32 salt = bytes32(keccak256(strategyConfigs[i]));
4766       ILlamaStrategy strategy = ILlamaStrategy(Clones.cloneDeterministic(address(llamaStrategyLogic), salt));
4767       strategy.initialize(strategyConfigs[i]);
4768       strategies[strategy] = true;
4769       emit StrategyCreated(strategy, llamaStrategyLogic, strategyConfigs[i]);
4770       if (i == 0) firstStrategy = strategy;
4771     }
4772   }
4773 
4774   /// @dev Deploys new accounts. Takes in the account logic contract to be used and an array of configurations to
4775   /// initialize the new accounts with.
4776   function _deployAccounts(ILlamaAccount llamaAccountLogic, bytes[] calldata accountConfigs) internal {
4777     if (address(factory).code.length > 0 && !factory.authorizedAccountLogics(llamaAccountLogic)) {
4778       // The only edge case where this check is skipped is if `_deployAccounts()` is called by root llama instance
4779       // during Llama Factory construction. This is because there is no code at the Llama Factory address yet.
4780       revert UnauthorizedAccountLogic();
4781     }
4782 
4783     uint256 accountLength = accountConfigs.length;
4784     for (uint256 i = 0; i < accountLength; i = LlamaUtils.uncheckedIncrement(i)) {
4785       bytes32 salt = bytes32(keccak256(accountConfigs[i]));
4786       ILlamaAccount account = ILlamaAccount(Clones.cloneDeterministic(address(llamaAccountLogic), salt));
4787       account.initialize(accountConfigs[i]);
4788       emit AccountCreated(account, llamaAccountLogic, accountConfigs[i]);
4789     }
4790   }
4791 
4792   /// @dev Returns the hash of the `createAction` parameters using the `actionInfo` struct.
4793   function _infoHash(ActionInfo calldata actionInfo) internal pure returns (bytes32) {
4794     return _infoHash(
4795       actionInfo.id,
4796       actionInfo.creator,
4797       actionInfo.creatorRole,
4798       actionInfo.strategy,
4799       actionInfo.target,
4800       actionInfo.value,
4801       actionInfo.data
4802     );
4803   }
4804 
4805   /// @dev Returns the hash of the `createAction` parameters.
4806   function _infoHash(
4807     uint256 id,
4808     address creator,
4809     uint8 creatorRole,
4810     ILlamaStrategy strategy,
4811     address target,
4812     uint256 value,
4813     bytes calldata data
4814   ) internal pure returns (bytes32) {
4815     return keccak256(abi.encodePacked(id, creator, creatorRole, strategy, target, value, data));
4816   }
4817 
4818   /// @dev Validates that the hash of the `actionInfo` struct matches the provided hash.
4819   function _validateActionInfoHash(bytes32 actualHash, ActionInfo calldata actionInfo) internal pure {
4820     bytes32 expectedHash = _infoHash(actionInfo);
4821     if (actualHash != expectedHash) revert InfoHashMismatch();
4822   }
4823 
4824   /// @dev Returns the current nonce for a given policyholder and selector, and increments it. Used to prevent
4825   /// replay attacks.
4826   function _useNonce(address policyholder, bytes4 selector) internal returns (uint256 nonce) {
4827     nonce = nonces[policyholder][selector];
4828     nonces[policyholder][selector] = LlamaUtils.uncheckedIncrement(nonce);
4829   }
4830 
4831   // -------- EIP-712 Getters --------
4832 
4833   /// @dev Returns the EIP-712 domain separator.
4834   function _getDomainHash() internal view returns (bytes32) {
4835     return keccak256(
4836       abi.encode(EIP712_DOMAIN_TYPEHASH, keccak256(bytes(name)), keccak256(bytes("1")), block.chainid, address(this))
4837     );
4838   }
4839 
4840   /// @dev Returns the hash of the ABI-encoded EIP-712 message for the `CreateAction` domain, which can be used to
4841   /// recover the signer.
4842   function _getCreateActionTypedDataHash(
4843     address policyholder,
4844     uint8 role,
4845     ILlamaStrategy strategy,
4846     address target,
4847     uint256 value,
4848     bytes calldata data,
4849     string memory description
4850   ) internal returns (bytes32) {
4851     // Calculating and storing nonce in memory and using that below, instead of calculating in place to prevent stack
4852     // too deep error.
4853     uint256 nonce = _useNonce(policyholder, msg.sig);
4854 
4855     bytes32 createActionHash = keccak256(
4856       abi.encode(
4857         CREATE_ACTION_TYPEHASH,
4858         policyholder,
4859         role,
4860         address(strategy),
4861         target,
4862         value,
4863         keccak256(data),
4864         keccak256(bytes(description)),
4865         nonce
4866       )
4867     );
4868 
4869     return keccak256(abi.encodePacked("\x19\x01", _getDomainHash(), createActionHash));
4870   }
4871 
4872   /// @dev Returns the hash of the ABI-encoded EIP-712 message for the `CastApproval` domain, which can be used to
4873   /// recover the signer.
4874   function _getCastApprovalTypedDataHash(
4875     address policyholder,
4876     uint8 role,
4877     ActionInfo calldata actionInfo,
4878     string calldata reason
4879   ) internal returns (bytes32) {
4880     bytes32 castApprovalHash = keccak256(
4881       abi.encode(
4882         CAST_APPROVAL_TYPEHASH,
4883         policyholder,
4884         role,
4885         _getActionInfoHash(actionInfo),
4886         keccak256(bytes(reason)),
4887         _useNonce(policyholder, msg.sig)
4888       )
4889     );
4890 
4891     return keccak256(abi.encodePacked("\x19\x01", _getDomainHash(), castApprovalHash));
4892   }
4893 
4894   /// @dev Returns the hash of the ABI-encoded EIP-712 message for the `CastDisapproval` domain, which can be used to
4895   /// recover the signer.
4896   function _getCastDisapprovalTypedDataHash(
4897     address policyholder,
4898     uint8 role,
4899     ActionInfo calldata actionInfo,
4900     string calldata reason
4901   ) internal returns (bytes32) {
4902     bytes32 castDisapprovalHash = keccak256(
4903       abi.encode(
4904         CAST_DISAPPROVAL_TYPEHASH,
4905         policyholder,
4906         role,
4907         _getActionInfoHash(actionInfo),
4908         keccak256(bytes(reason)),
4909         _useNonce(policyholder, msg.sig)
4910       )
4911     );
4912 
4913     return keccak256(abi.encodePacked("\x19\x01", _getDomainHash(), castDisapprovalHash));
4914   }
4915 
4916   /// @dev Returns the hash of `actionInfo`.
4917   function _getActionInfoHash(ActionInfo calldata actionInfo) internal pure returns (bytes32) {
4918     return keccak256(
4919       abi.encode(
4920         ACTION_INFO_TYPEHASH,
4921         actionInfo.id,
4922         actionInfo.creator,
4923         actionInfo.creatorRole,
4924         address(actionInfo.strategy),
4925         actionInfo.target,
4926         actionInfo.value,
4927         keccak256(actionInfo.data)
4928       )
4929     );
4930   }
4931 }



```

### LlamaCore.sol


```
Contract locking ether found:
	Contract LlamaCore (LlamaCore.sol#3210-3993) has payable functions:
	 - LlamaCore.executeAction(ActionInfo) (LlamaCore.sol#3507-3533)
	But does not have a function to withdraw the ether



    
3210 contract LlamaCore is Initializable {
3211   // ======================================
3212   // ======== Errors and Modifiers ========
3213   // ======================================
3214 
3215   /// @dev Policyholder cannot cast if it has 0 quantity of role.
3216   /// @param policyholder Address of policyholder.
3217   /// @param role The role being used in the cast.
3218   error CannotCastWithZeroQuantity(address policyholder, uint8 role);
3219 
3220   /// @dev An action's target contract cannot be the executor.
3221   error CannotSetExecutorAsTarget();
3222 
3223   /// @dev Address cannot be used.
3224   error RestrictedAddress();
3225 
3226   /// @dev Policyholders can only cast once.
3227   error DuplicateCast();
3228 
3229   /// @dev Action execution failed.
3230   /// @param reason Data returned by the function called by the action.
3231   error FailedActionExecution(bytes reason);
3232 
3233   /// @dev `ActionInfo` does not hash to the correct value.
3234   error InfoHashMismatch();
3235 
3236   /// @dev `msg.value` does not equal the action's value.
3237   error IncorrectMsgValue();
3238 
3239   /// @dev The action is not in the expected state.
3240   /// @param current The current state of the action.
3241   error InvalidActionState(ActionState current);
3242 
3243   /// @dev The policyholder does not have the role at action creation time.
3244   error InvalidPolicyholder();
3245 
3246   /// @dev The recovered signer does not match the expected policyholder.
3247   error InvalidSignature();
3248 
3249   /// @dev The provided address does not map to a deployed strategy.
3250   error InvalidStrategy();
3251 
3252   /// @dev An action cannot queue successfully if it's `minExecutionTime` is less than `block.timestamp`.
3253   error MinExecutionTimeCannotBeInThePast();
3254 
3255   /// @dev Only callable by a Llama instance's executor.
3256   error OnlyLlama();
3257 
3258   /// @dev Policyholder does not have the permission ID to create the action.
3259   error PolicyholderDoesNotHavePermission();
3260 
3261   /// @dev If `block.timestamp` is less than `minExecutionTime`, the action cannot be executed.
3262   error MinExecutionTimeNotReached();
3263 
3264   /// @dev Strategies can only be created with valid logic contracts.
3265   error UnauthorizedStrategyLogic();
3266 
3267   /// @dev Accounts can only be created with valid logic contracts.
3268   error UnauthorizedAccountLogic();
3269 
3270   /// @dev Checks that the caller is the Llama Executor and reverts if not.
3271   modifier onlyLlama() {
3272     if (msg.sender != address(executor)) revert OnlyLlama();
3273     _;
3274   }
3275 
3276   // ========================
3277   // ======== Events ========
3278   // ========================
3279 
3280   /// @dev Emitted when an action is created.
3281   event ActionCreated(
3282     uint256 id,
3283     address indexed creator,
3284     uint8 role,
3285     ILlamaStrategy indexed strategy,
3286     address indexed target,
3287     uint256 value,
3288     bytes data,
3289     string description
3290   );
3291 
3292   /// @dev Emitted when an action is canceled.
3293   event ActionCanceled(uint256 id);
3294 
3295   /// @dev Emitted when an action guard is set.
3296   event ActionGuardSet(address indexed target, bytes4 indexed selector, ILlamaActionGuard actionGuard);
3297 
3298   /// @dev Emitted when an action is queued.
3299   event ActionQueued(
3300     uint256 id,
3301     address indexed caller,
3302     ILlamaStrategy indexed strategy,
3303     address indexed creator,
3304     uint256 minExecutionTime
3305   );
3306 
3307   /// @dev Emitted when an action is executed.
3308   event ActionExecuted(
3309     uint256 id, address indexed caller, ILlamaStrategy indexed strategy, address indexed creator, bytes result
3310   );
3311 
3312   /// @dev Emitted when an approval is cast.
3313   event ApprovalCast(uint256 id, address indexed policyholder, uint8 indexed role, uint256 quantity, string reason);
3314 
3315   /// @dev Emitted when a disapproval is cast.
3316   event DisapprovalCast(uint256 id, address indexed policyholder, uint8 indexed role, uint256 quantity, string reason);
3317 
3318   /// @dev Emitted when a strategy is created and authorized.
3319   event StrategyCreated(ILlamaStrategy strategy, ILlamaStrategy indexed strategyLogic, bytes initializationData);
3320 
3321   /// @dev Emitted when an account is created.
3322   event AccountCreated(ILlamaAccount account, ILlamaAccount indexed accountLogic, bytes initializationData);
3323 
3324   /// @dev Emitted when a script is authorized.
3325   event ScriptAuthorized(address script, bool authorized);
3326 
3327   // =================================================
3328   // ======== Constants and Storage Variables ========
3329   // =================================================
3330 
3331   /// @dev EIP-712 base typehash.
3332   bytes32 internal constant EIP712_DOMAIN_TYPEHASH =
3333     keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");
3334 
3335   /// @dev EIP-712 createAction typehash.
3336   bytes32 internal constant CREATE_ACTION_TYPEHASH = keccak256(
3337     "CreateAction(address policyholder,uint8 role,address strategy,address target,uint256 value,bytes data,string description,uint256 nonce)"
3338   );
3339 
3340   /// @dev EIP-712 castApproval typehash.
3341   bytes32 internal constant CAST_APPROVAL_TYPEHASH = keccak256(
3342     "CastApproval(address policyholder,uint8 role,ActionInfo actionInfo,string reason,uint256 nonce)ActionInfo(uint256 id,address creator,uint8 creatorRole,address strategy,address target,uint256 value,bytes data)"
3343   );
3344 
3345   /// @dev EIP-712 castDisapproval typehash.
3346   bytes32 internal constant CAST_DISAPPROVAL_TYPEHASH = keccak256(
3347     "CastDisapproval(address policyholder,uint8 role,ActionInfo actionInfo,string reason,uint256 nonce)ActionInfo(uint256 id,address creator,uint8 creatorRole,address strategy,address target,uint256 value,bytes data)"
3348   );
3349 
3350   /// @dev EIP-712 actionInfo typehash.
3351   bytes32 internal constant ACTION_INFO_TYPEHASH = keccak256(
3352     "ActionInfo(uint256 id,address creator,uint8 creatorRole,address strategy,address target,uint256 value,bytes data)"
3353   );
3354 
3355   /// @dev Mapping of actionIds to Actions.
3356   /// @dev Making this `public` results in stack too deep with no optimizer, but this data can be
3357   /// accessed with the `getAction` function so this is ok. We want the contracts to compile
3358   /// without the optimizer so `forge coverage` can be used.
3359   mapping(uint256 => Action) internal actions;
3360 
3361   /// @notice The contract that executes actions for this Llama instance.
3362   LlamaExecutor public executor;
3363 
3364   /// @notice The ERC721 contract that defines the policies for this Llama instance.
3365   /// @dev We intentionally put this first so it's packed with the `Initializable` storage
3366   // variables, which are the key variables we want to check before and after a delegatecall.
3367   LlamaPolicy public policy;
3368 
3369   /// @notice The `LlamaFactory` contract that deployed this Llama instance.
3370   LlamaFactory public factory;
3371 
3372   /// @notice Name of this Llama instance.
3373   string public name;
3374 
3375   /// @notice The current number of actions created.
3376   uint256 public actionsCount;
3377 
3378   /// @notice Mapping of actionIds to policyholders to approvals.
3379   mapping(uint256 => mapping(address => bool)) public approvals;
3380 
3381   /// @notice Mapping of actionIds to policyholders to disapprovals.
3382   mapping(uint256 => mapping(address => bool)) public disapprovals;
3383 
3384   /// @notice Mapping of all authorized strategies.
3385   mapping(ILlamaStrategy => bool) public strategies;
3386 
3387   /// @notice Mapping of all authorized scripts.
3388   mapping(address => bool) public authorizedScripts;
3389 
3390   /// @notice Mapping of policyholders to function selectors to current nonces for EIP-712 signatures.
3391   /// @dev This is used to prevent replay attacks by incrementing the nonce for each operation (`createAction`,
3392   /// `castApproval` and `castDisapproval`) signed by the policyholder.
3393   mapping(address => mapping(bytes4 => uint256)) public nonces;
3394 
3395   /// @notice Mapping of target to selector to actionGuard address.
3396   mapping(address target => mapping(bytes4 selector => ILlamaActionGuard)) public actionGuard;
3397 
3398   // ======================================================
3399   // ======== Contract Creation and Initialization ========
3400   // ======================================================
3401 
3402   constructor() {
3403     _disableInitializers();
3404   }
3405 
3406   /// @notice Initializes a new `LlamaCore` clone.
3407   /// @param _name The name of the `LlamaCore` clone.
3408   /// @param _policy This Llama instance's policy contract.
3409   /// @param _llamaStrategyLogic The Llama Strategy implementation (logic) contract.
3410   /// @param _llamaAccountLogic The Llama Account implementation (logic) contract.
3411   /// @param initialStrategies Array of initial strategy configurations.
3412   /// @param initialAccounts Array of initial account configurations.
3413   /// @return bootstrapPermissionId The permission ID that's used to set role permissions.
3414   function initialize(
3415     string memory _name,
3416     LlamaPolicy _policy,
3417     ILlamaStrategy _llamaStrategyLogic,
3418     ILlamaAccount _llamaAccountLogic,
3419     bytes[] calldata initialStrategies,
3420     bytes[] calldata initialAccounts
3421   ) external initializer returns (bytes32 bootstrapPermissionId) {
3422     factory = LlamaFactory(msg.sender);
3423     name = _name;
3424     executor = new LlamaExecutor();
3425     policy = _policy;
3426 
3427     ILlamaStrategy bootstrapStrategy = _deployStrategies(_llamaStrategyLogic, initialStrategies);
3428     _deployAccounts(_llamaAccountLogic, initialAccounts);
3429 
3430     // Now we compute the permission ID used to set role permissions and return it.
3431     bytes4 selector = LlamaPolicy.setRolePermission.selector;
3432     return keccak256(abi.encode(PermissionData(address(policy), bytes4(selector), bootstrapStrategy)));
3433   }
3434 
3435   // ===========================================
3436   // ======== External and Public Logic ========
3437   // ===========================================
3438 
3439   /// @notice Creates an action. The creator needs to hold a policy with the permission ID of the provided
3440   /// `(target, selector, strategy)`.
3441   /// @dev Use `""` for `description` if there is no description.
3442   /// @param role The role that will be used to determine the permission ID of the policyholder.
3443   /// @param strategy The strategy contract that will determine how the action is executed.
3444   /// @param target The contract called when the action is executed.
3445   /// @param value The value in wei to be sent when the action is executed.
3446   /// @param data Data to be called on the target when the action is executed.
3447   /// @param description A human readable description of the action and the changes it will enact.
3448   /// @return actionId Action ID of the newly created action.
3449   function createAction(
3450     uint8 role,
3451     ILlamaStrategy strategy,
3452     address target,
3453     uint256 value,
3454     bytes calldata data,
3455     string memory description
3456   ) external returns (uint256 actionId) {
3457     actionId = _createAction(msg.sender, role, strategy, target, value, data, description);
3458   }
3459 
3460   /// @notice Creates an action via an off-chain signature. The creator needs to hold a policy with the permission ID
3461   /// of the provided `(target, selector, strategy)`.
3462   /// @dev Use `""` for `description` if there is no description.
3463   /// @param policyholder The policyholder that signed the message.
3464   /// @param role The role that will be used to determine the permission ID of the policyholder.
3465   /// @param strategy The strategy contract that will determine how the action is executed.
3466   /// @param target The contract called when the action is executed.
3467   /// @param value The value in wei to be sent when the action is executed.
3468   /// @param data Data to be called on the target when the action is executed.
3469   /// @param description A human readable description of the action and the changes it will enact.
3470   /// @param v ECDSA signature component: Parity of the `y` coordinate of point `R`
3471   /// @param r ECDSA signature component: x-coordinate of `R`
3472   /// @param s ECDSA signature component: `s` value of the signature
3473   /// @return actionId Action ID of the newly created action.
3474   function createActionBySig(
3475     address policyholder,
3476     uint8 role,
3477     ILlamaStrategy strategy,
3478     address target,
3479     uint256 value,
3480     bytes calldata data,
3481     string memory description,
3482     uint8 v,
3483     bytes32 r,
3484     bytes32 s
3485   ) external returns (uint256 actionId) {
3486     bytes32 digest = _getCreateActionTypedDataHash(policyholder, role, strategy, target, value, data, description);
3487     address signer = ecrecover(digest, v, r, s);
3488     if (signer == address(0) || signer != policyholder) revert InvalidSignature();
3489     actionId = _createAction(signer, role, strategy, target, value, data, description);
3490   }
3491 
3492   /// @notice Queue an action by its `actionInfo` struct if it's in Approved state.
3493   /// @param actionInfo Data required to create an action.
3494   function queueAction(ActionInfo calldata actionInfo) external {
3495     Action storage action = actions[actionInfo.id];
3496     ActionState currentState = getActionState(actionInfo);
3497     if (currentState != ActionState.Approved) revert InvalidActionState(currentState);
3498 
3499     uint64 minExecutionTime = actionInfo.strategy.minExecutionTime(actionInfo);
3500     if (minExecutionTime < block.timestamp) revert MinExecutionTimeCannotBeInThePast();
3501     action.minExecutionTime = minExecutionTime;
3502     emit ActionQueued(actionInfo.id, msg.sender, actionInfo.strategy, actionInfo.creator, minExecutionTime);
3503   }
3504 
3505   /// @notice Execute an action by its `actionInfo` struct if it's in Queued state and `minExecutionTime` has passed.
3506   /// @param actionInfo Data required to create an action.
3507   function executeAction(ActionInfo calldata actionInfo) external payable {
3508     // Initial checks that action is ready to execute.
3509     Action storage action = actions[actionInfo.id];
3510     ActionState currentState = getActionState(actionInfo);
3511 
3512     if (currentState != ActionState.Queued) revert InvalidActionState(currentState);
3513     if (block.timestamp < action.minExecutionTime) revert MinExecutionTimeNotReached();
3514     if (msg.value != actionInfo.value) revert IncorrectMsgValue();
3515 
3516     action.executed = true;
3517 
3518     // Check pre-execution action guard.
3519     ILlamaActionGuard guard = actionGuard[actionInfo.target][bytes4(actionInfo.data)];
3520     if (guard != ILlamaActionGuard(address(0))) guard.validatePreActionExecution(actionInfo);
3521 
3522     // Execute action.
3523     (bool success, bytes memory result) =
3524       executor.execute(actionInfo.target, actionInfo.value, action.isScript, actionInfo.data);
3525 
3526     if (!success) revert FailedActionExecution(result);
3527 
3528     // Check post-execution action guard.
3529     if (guard != ILlamaActionGuard(address(0))) guard.validatePostActionExecution(actionInfo);
3530 
3531     // Action successfully executed.
3532     emit ActionExecuted(actionInfo.id, msg.sender, actionInfo.strategy, actionInfo.creator, result);
3533   }
3534 
3535   /// @notice Cancels an action by its `actionInfo` struct.
3536   /// @dev Rules for cancelation are defined by the strategy.
3537   /// @param actionInfo Data required to create an action.
3538   function cancelAction(ActionInfo calldata actionInfo) external {
3539     Action storage action = actions[actionInfo.id];
3540     _validateActionInfoHash(action.infoHash, actionInfo);
3541 
3542     // We don't need an explicit check on action existence because if it doesn't exist the strategy will be the zero
3543     // address, and Solidity will revert since there is no code at the zero address.
3544     actionInfo.strategy.validateActionCancelation(actionInfo, msg.sender);
3545 
3546     action.canceled = true;
3547     emit ActionCanceled(actionInfo.id);
3548   }
3549 
3550   /// @notice How policyholders add their support of the approval of an action with a reason.
3551   /// @dev Use `""` for `reason` if there is no reason.
3552   /// @param role The role the policyholder uses to cast their approval.
3553   /// @param actionInfo Data required to create an action.
3554   /// @param reason The reason given for the approval by the policyholder.
3555   function castApproval(uint8 role, ActionInfo calldata actionInfo, string calldata reason) external {
3556     return _castApproval(msg.sender, role, actionInfo, reason);
3557   }
3558 
3559   /// @notice How policyholders add their support of the approval of an action via an off-chain signature.
3560   /// @dev Use `""` for `reason` if there is no reason.
3561   /// @param policyholder The policyholder that signed the message.
3562   /// @param role The role the policyholder uses to cast their approval.
3563   /// @param actionInfo Data required to create an action.
3564   /// @param reason The reason given for the approval by the policyholder.
3565   /// @param v ECDSA signature component: Parity of the `y` coordinate of point `R`
3566   /// @param r ECDSA signature component: x-coordinate of `R`
3567   /// @param s ECDSA signature component: `s` value of the signature
3568   function castApprovalBySig(
3569     address policyholder,
3570     uint8 role,
3571     ActionInfo calldata actionInfo,
3572     string calldata reason,
3573     uint8 v,
3574     bytes32 r,
3575     bytes32 s
3576   ) external {
3577     bytes32 digest = _getCastApprovalTypedDataHash(policyholder, role, actionInfo, reason);
3578     address signer = ecrecover(digest, v, r, s);
3579     if (signer == address(0) || signer != policyholder) revert InvalidSignature();
3580     return _castApproval(signer, role, actionInfo, reason);
3581   }
3582 
3583   /// @notice How policyholders add their support of the disapproval of an action with a reason.
3584   /// @dev Use `""` for `reason` if there is no reason.
3585   /// @param role The role the policyholder uses to cast their disapproval.
3586   /// @param actionInfo Data required to create an action.
3587   /// @param reason The reason given for the disapproval by the policyholder.
3588   function castDisapproval(uint8 role, ActionInfo calldata actionInfo, string calldata reason) external {
3589     return _castDisapproval(msg.sender, role, actionInfo, reason);
3590   }
3591 
3592   /// @notice How policyholders add their support of the disapproval of an action via an off-chain signature.
3593   /// @dev Use `""` for `reason` if there is no reason.
3594   /// @param policyholder The policyholder that signed the message.
3595   /// @param role The role the policyholder uses to cast their disapproval.
3596   /// @param actionInfo Data required to create an action.
3597   /// @param reason The reason given for the approval by the policyholder.
3598   /// @param v ECDSA signature component: Parity of the `y` coordinate of point `R`
3599   /// @param r ECDSA signature component: x-coordinate of `R`
3600   /// @param s ECDSA signature component: `s` value of the signature
3601   function castDisapprovalBySig(
3602     address policyholder,
3603     uint8 role,
3604     ActionInfo calldata actionInfo,
3605     string calldata reason,
3606     uint8 v,
3607     bytes32 r,
3608     bytes32 s
3609   ) external {
3610     bytes32 digest = _getCastDisapprovalTypedDataHash(policyholder, role, actionInfo, reason);
3611     address signer = ecrecover(digest, v, r, s);
3612     if (signer == address(0) || signer != policyholder) revert InvalidSignature();
3613     return _castDisapproval(signer, role, actionInfo, reason);
3614   }
3615 
3616   /// @notice Deploy new strategies and add them to the mapping of authorized strategies.
3617   /// @param llamaStrategyLogic address of the Llama strategy logic contract.
3618   /// @param strategyConfigs Array of new strategy configurations.
3619   function createStrategies(ILlamaStrategy llamaStrategyLogic, bytes[] calldata strategyConfigs) external onlyLlama {
3620     _deployStrategies(llamaStrategyLogic, strategyConfigs);
3621   }
3622 
3623   /// @notice Deploy new accounts.
3624   /// @param llamaAccountLogic address of the Llama account logic contract.
3625   /// @param accountConfigs Array of new account configurations.
3626   function createAccounts(ILlamaAccount llamaAccountLogic, bytes[] calldata accountConfigs) external onlyLlama {
3627     _deployAccounts(llamaAccountLogic, accountConfigs);
3628   }
3629 
3630   /// @notice Sets `guard` as the action guard for the given `target` and `selector`.
3631   /// @param target The target contract where the `guard` will apply.
3632   /// @param selector The function selector where the `guard` will apply.
3633   /// @dev To remove a guard, set `guard` to the zero address.
3634   function setGuard(address target, bytes4 selector, ILlamaActionGuard guard) external onlyLlama {
3635     if (target == address(this) || target == address(policy)) revert RestrictedAddress();
3636     actionGuard[target][selector] = guard;
3637     emit ActionGuardSet(target, selector, guard);
3638   }
3639 
3640   /// @notice Authorizes `script` to be eligible to be delegatecalled from the executor.
3641   /// @param script The address of the script contract.
3642   /// @param authorized The boolean that determines if the `script` is being authorized or unauthorized.
3643   /// @dev To remove a `script`, set `authorized` to `false`.
3644   function authorizeScript(address script, bool authorized) external onlyLlama {
3645     if (script == address(this) || script == address(policy)) revert RestrictedAddress();
3646     authorizedScripts[script] = authorized;
3647     emit ScriptAuthorized(script, authorized);
3648   }
3649 
3650   /// @notice Increments the caller's nonce for the given `selector`. This is useful for revoking
3651   /// signatures that have not been used yet.
3652   /// @param selector The function selector to increment the nonce for.
3653   function incrementNonce(bytes4 selector) external {
3654     // Safety: Can never overflow a uint256 by incrementing.
3655     nonces[msg.sender][selector] = LlamaUtils.uncheckedIncrement(nonces[msg.sender][selector]);
3656   }
3657 
3658   /// @notice Get an Action struct by `actionId`.
3659   /// @param actionId ID of the action.
3660   /// @return The Action struct.
3661   function getAction(uint256 actionId) external view returns (Action memory) {
3662     return actions[actionId];
3663   }
3664 
3665   /// @notice Returns the timestamp of most recently created action.
3666   /// @dev Used by `LlamaPolicy` to ensure policy management does not occur immediately after action
3667   /// creation in the same timestamp, as this could result in invalid role supply counts being used.
3668   function getLastActionTimestamp() external view returns (uint256 timestamp) {
3669     return actionsCount == 0 ? 0 : actions[actionsCount - 1].creationTime;
3670   }
3671 
3672   /// @notice Get the current action state of an action by its `actionInfo` struct.
3673   /// @param actionInfo Data required to create an action.
3674   /// @return The current action state of the action.
3675   function getActionState(ActionInfo calldata actionInfo) public view returns (ActionState) {
3676     // We don't need an explicit check on the action ID to make sure it exists, because if the
3677     // action does not exist, the expected payload hash from storage will be `bytes32(0)`, so
3678     // bypassing this check by providing a non-existent actionId would require finding a collision
3679     // to get a hash of zero.
3680     Action storage action = actions[actionInfo.id];
3681     _validateActionInfoHash(action.infoHash, actionInfo);
3682 
3683     if (action.canceled) return ActionState.Canceled;
3684 
3685     if (action.executed) return ActionState.Executed;
3686 
3687     if (actionInfo.strategy.isActive(actionInfo)) return ActionState.Active;
3688 
3689     if (!actionInfo.strategy.isActionApproved(actionInfo)) return ActionState.Failed;
3690 
3691     if (action.minExecutionTime == 0) return ActionState.Approved;
3692 
3693     if (actionInfo.strategy.isActionDisapproved(actionInfo)) return ActionState.Failed;
3694 
3695     if (actionInfo.strategy.isActionExpired(actionInfo)) return ActionState.Expired;
3696 
3697     return ActionState.Queued;
3698   }
3699 
3700   // ================================
3701   // ======== Internal Logic ========
3702   // ================================
3703 
3704   /// @dev Creates an action. The creator needs to hold a policy with the permission ID of the provided
3705   /// `(target, selector, strategy)`.
3706   function _createAction(
3707     address policyholder,
3708     uint8 role,
3709     ILlamaStrategy strategy,
3710     address target,
3711     uint256 value,
3712     bytes calldata data,
3713     string memory description
3714   ) internal returns (uint256 actionId) {
3715     if (target == address(executor)) revert CannotSetExecutorAsTarget();
3716     if (!strategies[strategy]) revert InvalidStrategy();
3717 
3718     PermissionData memory permission = PermissionData(target, bytes4(data), strategy);
3719     bytes32 permissionId = keccak256(abi.encode(permission));
3720 
3721     // Typically (such as in Governor contracts) this should check that the caller has permission
3722     // at `block.number|timestamp - 1` but here we're just checking if the caller *currently* has
3723     // permission. Technically this introduces a race condition if e.g. an action to revoke a role
3724     // from someone (or revoke a permission from a role) is ready to be executed at the same time as
3725     // an action is created, as the order of transactions in the block then affects if action
3726     // creation would succeed. However, we are ok with this tradeoff because it means we don't need
3727     // to checkpoint the `canCreateAction` mapping which is simpler and cheaper, and in practice
3728     // this race condition is unlikely to matter.
3729     if (!policy.hasPermissionId(policyholder, role, permissionId)) revert PolicyholderDoesNotHavePermission();
3730 
3731     // Validate action creation.
3732     actionId = actionsCount;
3733 
3734     ActionInfo memory actionInfo = ActionInfo(actionId, policyholder, role, strategy, target, value, data);
3735     strategy.validateActionCreation(actionInfo);
3736 
3737     // Scope to avoid stack too deep
3738     {
3739       ILlamaActionGuard guard = actionGuard[target][bytes4(data)];
3740       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);
3741 
3742       // Save action.
3743       Action storage newAction = actions[actionId];
3744       newAction.infoHash = _infoHash(actionId, policyholder, role, strategy, target, value, data);
3745       newAction.creationTime = LlamaUtils.toUint64(block.timestamp);
3746       newAction.isScript = authorizedScripts[target];
3747     }
3748 
3749     actionsCount = LlamaUtils.uncheckedIncrement(actionsCount); // Safety: Can never overflow a uint256 by incrementing.
3750 
3751     emit ActionCreated(actionId, policyholder, role, strategy, target, value, data, description);
3752   }
3753 
3754   /// @dev How policyholders that have the right role contribute towards the approval of an action with a reason.
3755   function _castApproval(address policyholder, uint8 role, ActionInfo calldata actionInfo, string memory reason)
3756     internal
3757   {
3758     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Active);
3759 
3760     action.totalApprovals = _newCastCount(action.totalApprovals, quantity);
3761     approvals[actionInfo.id][policyholder] = true;
3762     emit ApprovalCast(actionInfo.id, policyholder, role, quantity, reason);
3763   }
3764 
3765   /// @dev How policyholders that have the right role contribute towards the disapproval of an action with a reason.
3766   function _castDisapproval(address policyholder, uint8 role, ActionInfo calldata actionInfo, string memory reason)
3767     internal
3768   {
3769     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Queued);
3770 
3771     action.totalDisapprovals = _newCastCount(action.totalDisapprovals, quantity);
3772     disapprovals[actionInfo.id][policyholder] = true;
3773     emit DisapprovalCast(actionInfo.id, policyholder, role, quantity, reason);
3774   }
3775 
3776   /// @dev The only `expectedState` values allowed to be passed into this method are Active or Queued.
3777   function _preCastAssertions(
3778     ActionInfo calldata actionInfo,
3779     address policyholder,
3780     uint8 role,
3781     ActionState expectedState
3782   ) internal returns (Action storage action, uint128 quantity) {
3783     action = actions[actionInfo.id];
3784     ActionState currentState = getActionState(actionInfo);
3785     if (currentState != expectedState) revert InvalidActionState(currentState);
3786 
3787     bool isApproval = expectedState == ActionState.Active;
3788     bool alreadyCast = isApproval ? approvals[actionInfo.id][policyholder] : disapprovals[actionInfo.id][policyholder];
3789     if (alreadyCast) revert DuplicateCast();
3790 
3791     bool hasRole = policy.hasRole(policyholder, role, action.creationTime);
3792     if (!hasRole) revert InvalidPolicyholder();
3793 
3794     if (isApproval) {
3795       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);
3796       quantity = actionInfo.strategy.getApprovalQuantityAt(policyholder, role, action.creationTime);
3797       if (quantity == 0) revert CannotCastWithZeroQuantity(policyholder, role);
3798     } else {
3799       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);
3800       quantity = actionInfo.strategy.getDisapprovalQuantityAt(policyholder, role, action.creationTime);
3801       if (quantity == 0) revert CannotCastWithZeroQuantity(policyholder, role);
3802     }
3803   }
3804 
3805   /// @dev Returns the new total count of approvals or disapprovals.
3806   function _newCastCount(uint128 currentCount, uint128 quantity) internal pure returns (uint128) {
3807     if (currentCount == type(uint128).max || quantity == type(uint128).max) return type(uint128).max;
3808     return currentCount + quantity;
3809   }
3810 
3811   /// @dev Deploys new strategies. Takes in the strategy logic contract to be used and an array of configurations to
3812   /// initialize the new strategies with. Returns the address of the first strategy, which is only used during the
3813   /// `LlamaCore` initialization so that we can ensure someone (specifically, policyholders with role ID 1) has the
3814   /// permission to assign role permissions.
3815   function _deployStrategies(ILlamaStrategy llamaStrategyLogic, bytes[] calldata strategyConfigs)
3816     internal
3817     returns (ILlamaStrategy firstStrategy)
3818   {
3819     if (address(factory).code.length > 0 && !factory.authorizedStrategyLogics(llamaStrategyLogic)) {
3820       // The only edge case where this check is skipped is if `_deployStrategies()` is called by root llama instance
3821       // during Llama Factory construction. This is because there is no code at the Llama Factory address yet.
3822       revert UnauthorizedStrategyLogic();
3823     }
3824 
3825     uint256 strategyLength = strategyConfigs.length;
3826     for (uint256 i = 0; i < strategyLength; i = LlamaUtils.uncheckedIncrement(i)) {
3827       bytes32 salt = bytes32(keccak256(strategyConfigs[i]));
3828       ILlamaStrategy strategy = ILlamaStrategy(Clones.cloneDeterministic(address(llamaStrategyLogic), salt));
3829       strategy.initialize(strategyConfigs[i]);
3830       strategies[strategy] = true;
3831       emit StrategyCreated(strategy, llamaStrategyLogic, strategyConfigs[i]);
3832       if (i == 0) firstStrategy = strategy;
3833     }
3834   }
3835 
3836   /// @dev Deploys new accounts. Takes in the account logic contract to be used and an array of configurations to
3837   /// initialize the new accounts with.
3838   function _deployAccounts(ILlamaAccount llamaAccountLogic, bytes[] calldata accountConfigs) internal {
3839     if (address(factory).code.length > 0 && !factory.authorizedAccountLogics(llamaAccountLogic)) {
3840       // The only edge case where this check is skipped is if `_deployAccounts()` is called by root llama instance
3841       // during Llama Factory construction. This is because there is no code at the Llama Factory address yet.
3842       revert UnauthorizedAccountLogic();
3843     }
3844 
3845     uint256 accountLength = accountConfigs.length;
3846     for (uint256 i = 0; i < accountLength; i = LlamaUtils.uncheckedIncrement(i)) {
3847       bytes32 salt = bytes32(keccak256(accountConfigs[i]));
3848       ILlamaAccount account = ILlamaAccount(Clones.cloneDeterministic(address(llamaAccountLogic), salt));
3849       account.initialize(accountConfigs[i]);
3850       emit AccountCreated(account, llamaAccountLogic, accountConfigs[i]);
3851     }
3852   }
3853 
3854   /// @dev Returns the hash of the `createAction` parameters using the `actionInfo` struct.
3855   function _infoHash(ActionInfo calldata actionInfo) internal pure returns (bytes32) {
3856     return _infoHash(
3857       actionInfo.id,
3858       actionInfo.creator,
3859       actionInfo.creatorRole,
3860       actionInfo.strategy,
3861       actionInfo.target,
3862       actionInfo.value,
3863       actionInfo.data
3864     );
3865   }
3866 
3867   /// @dev Returns the hash of the `createAction` parameters.
3868   function _infoHash(
3869     uint256 id,
3870     address creator,
3871     uint8 creatorRole,
3872     ILlamaStrategy strategy,
3873     address target,
3874     uint256 value,
3875     bytes calldata data
3876   ) internal pure returns (bytes32) {
3877     return keccak256(abi.encodePacked(id, creator, creatorRole, strategy, target, value, data));
3878   }
3879 
3880   /// @dev Validates that the hash of the `actionInfo` struct matches the provided hash.
3881   function _validateActionInfoHash(bytes32 actualHash, ActionInfo calldata actionInfo) internal pure {
3882     bytes32 expectedHash = _infoHash(actionInfo);
3883     if (actualHash != expectedHash) revert InfoHashMismatch();
3884   }
3885 
3886   /// @dev Returns the current nonce for a given policyholder and selector, and increments it. Used to prevent
3887   /// replay attacks.
3888   function _useNonce(address policyholder, bytes4 selector) internal returns (uint256 nonce) {
3889     nonce = nonces[policyholder][selector];
3890     nonces[policyholder][selector] = LlamaUtils.uncheckedIncrement(nonce);
3891   }
3892 
3893   // -------- EIP-712 Getters --------
3894 
3895   /// @dev Returns the EIP-712 domain separator.
3896   function _getDomainHash() internal view returns (bytes32) {
3897     return keccak256(
3898       abi.encode(EIP712_DOMAIN_TYPEHASH, keccak256(bytes(name)), keccak256(bytes("1")), block.chainid, address(this))
3899     );
3900   }
3901 
3902   /// @dev Returns the hash of the ABI-encoded EIP-712 message for the `CreateAction` domain, which can be used to
3903   /// recover the signer.
3904   function _getCreateActionTypedDataHash(
3905     address policyholder,
3906     uint8 role,
3907     ILlamaStrategy strategy,
3908     address target,
3909     uint256 value,
3910     bytes calldata data,
3911     string memory description
3912   ) internal returns (bytes32) {
3913     // Calculating and storing nonce in memory and using that below, instead of calculating in place to prevent stack
3914     // too deep error.
3915     uint256 nonce = _useNonce(policyholder, msg.sig);
3916 
3917     bytes32 createActionHash = keccak256(
3918       abi.encode(
3919         CREATE_ACTION_TYPEHASH,
3920         policyholder,
3921         role,
3922         address(strategy),
3923         target,
3924         value,
3925         keccak256(data),
3926         keccak256(bytes(description)),
3927         nonce
3928       )
3929     );
3930 
3931     return keccak256(abi.encodePacked("\x19\x01", _getDomainHash(), createActionHash));
3932   }
3933 
3934   /// @dev Returns the hash of the ABI-encoded EIP-712 message for the `CastApproval` domain, which can be used to
3935   /// recover the signer.
3936   function _getCastApprovalTypedDataHash(
3937     address policyholder,
3938     uint8 role,
3939     ActionInfo calldata actionInfo,
3940     string calldata reason
3941   ) internal returns (bytes32) {
3942     bytes32 castApprovalHash = keccak256(
3943       abi.encode(
3944         CAST_APPROVAL_TYPEHASH,
3945         policyholder,
3946         role,
3947         _getActionInfoHash(actionInfo),
3948         keccak256(bytes(reason)),
3949         _useNonce(policyholder, msg.sig)
3950       )
3951     );
3952 
3953     return keccak256(abi.encodePacked("\x19\x01", _getDomainHash(), castApprovalHash));
3954   }
3955 
3956   /// @dev Returns the hash of the ABI-encoded EIP-712 message for the `CastDisapproval` domain, which can be used to
3957   /// recover the signer.
3958   function _getCastDisapprovalTypedDataHash(
3959     address policyholder,
3960     uint8 role,
3961     ActionInfo calldata actionInfo,
3962     string calldata reason
3963   ) internal returns (bytes32) {
3964     bytes32 castDisapprovalHash = keccak256(
3965       abi.encode(
3966         CAST_DISAPPROVAL_TYPEHASH,
3967         policyholder,
3968         role,
3969         _getActionInfoHash(actionInfo),
3970         keccak256(bytes(reason)),
3971         _useNonce(policyholder, msg.sig)
3972       )
3973     );
3974 
3975     return keccak256(abi.encodePacked("\x19\x01", _getDomainHash(), castDisapprovalHash));
3976   }
3977 
3978   /// @dev Returns the hash of `actionInfo`.
3979   function _getActionInfoHash(ActionInfo calldata actionInfo) internal pure returns (bytes32) {
3980     return keccak256(
3981       abi.encode(
3982         ACTION_INFO_TYPEHASH,
3983         actionInfo.id,
3984         actionInfo.creator,
3985         actionInfo.creatorRole,
3986         address(actionInfo.strategy),
3987         actionInfo.target,
3988         actionInfo.value,
3989         keccak256(actionInfo.data)
3990       )
3991     );
3992   }
3993 }



```

### LlamaFactory.sol


```
Contract locking ether found:
	Contract LlamaCore (LlamaFactory.sol#2547-3330) has payable functions:
	 - LlamaCore.executeAction(ActionInfo) (LlamaFactory.sol#2844-2870)
	But does not have a function to withdraw the ether



    
2547 contract LlamaCore is Initializable {
2548   // ======================================
2549   // ======== Errors and Modifiers ========
2550   // ======================================
2551 
2552   /// @dev Policyholder cannot cast if it has 0 quantity of role.
2553   /// @param policyholder Address of policyholder.
2554   /// @param role The role being used in the cast.
2555   error CannotCastWithZeroQuantity(address policyholder, uint8 role);
2556 
2557   /// @dev An action's target contract cannot be the executor.
2558   error CannotSetExecutorAsTarget();
2559 
2560   /// @dev Address cannot be used.
2561   error RestrictedAddress();
2562 
2563   /// @dev Policyholders can only cast once.
2564   error DuplicateCast();
2565 
2566   /// @dev Action execution failed.
2567   /// @param reason Data returned by the function called by the action.
2568   error FailedActionExecution(bytes reason);
2569 
2570   /// @dev `ActionInfo` does not hash to the correct value.
2571   error InfoHashMismatch();
2572 
2573   /// @dev `msg.value` does not equal the action's value.
2574   error IncorrectMsgValue();
2575 
2576   /// @dev The action is not in the expected state.
2577   /// @param current The current state of the action.
2578   error InvalidActionState(ActionState current);
2579 
2580   /// @dev The policyholder does not have the role at action creation time.
2581   error InvalidPolicyholder();
2582 
2583   /// @dev The recovered signer does not match the expected policyholder.
2584   error InvalidSignature();
2585 
2586   /// @dev The provided address does not map to a deployed strategy.
2587   error InvalidStrategy();
2588 
2589   /// @dev An action cannot queue successfully if it's `minExecutionTime` is less than `block.timestamp`.
2590   error MinExecutionTimeCannotBeInThePast();
2591 
2592   /// @dev Only callable by a Llama instance's executor.
2593   error OnlyLlama();
2594 
2595   /// @dev Policyholder does not have the permission ID to create the action.
2596   error PolicyholderDoesNotHavePermission();
2597 
2598   /// @dev If `block.timestamp` is less than `minExecutionTime`, the action cannot be executed.
2599   error MinExecutionTimeNotReached();
2600 
2601   /// @dev Strategies can only be created with valid logic contracts.
2602   error UnauthorizedStrategyLogic();
2603 
2604   /// @dev Accounts can only be created with valid logic contracts.
2605   error UnauthorizedAccountLogic();
2606 
2607   /// @dev Checks that the caller is the Llama Executor and reverts if not.
2608   modifier onlyLlama() {
2609     if (msg.sender != address(executor)) revert OnlyLlama();
2610     _;
2611   }
2612 
2613   // ========================
2614   // ======== Events ========
2615   // ========================
2616 
2617   /// @dev Emitted when an action is created.
2618   event ActionCreated(
2619     uint256 id,
2620     address indexed creator,
2621     uint8 role,
2622     ILlamaStrategy indexed strategy,
2623     address indexed target,
2624     uint256 value,
2625     bytes data,
2626     string description
2627   );
2628 
2629   /// @dev Emitted when an action is canceled.
2630   event ActionCanceled(uint256 id);
2631 
2632   /// @dev Emitted when an action guard is set.
2633   event ActionGuardSet(address indexed target, bytes4 indexed selector, ILlamaActionGuard actionGuard);
2634 
2635   /// @dev Emitted when an action is queued.
2636   event ActionQueued(
2637     uint256 id,
2638     address indexed caller,
2639     ILlamaStrategy indexed strategy,
2640     address indexed creator,
2641     uint256 minExecutionTime
2642   );
2643 
2644   /// @dev Emitted when an action is executed.
2645   event ActionExecuted(
2646     uint256 id, address indexed caller, ILlamaStrategy indexed strategy, address indexed creator, bytes result
2647   );
2648 
2649   /// @dev Emitted when an approval is cast.
2650   event ApprovalCast(uint256 id, address indexed policyholder, uint8 indexed role, uint256 quantity, string reason);
2651 
2652   /// @dev Emitted when a disapproval is cast.
2653   event DisapprovalCast(uint256 id, address indexed policyholder, uint8 indexed role, uint256 quantity, string reason);
2654 
2655   /// @dev Emitted when a strategy is created and authorized.
2656   event StrategyCreated(ILlamaStrategy strategy, ILlamaStrategy indexed strategyLogic, bytes initializationData);
2657 
2658   /// @dev Emitted when an account is created.
2659   event AccountCreated(ILlamaAccount account, ILlamaAccount indexed accountLogic, bytes initializationData);
2660 
2661   /// @dev Emitted when a script is authorized.
2662   event ScriptAuthorized(address script, bool authorized);
2663 
2664   // =================================================
2665   // ======== Constants and Storage Variables ========
2666   // =================================================
2667 
2668   /// @dev EIP-712 base typehash.
2669   bytes32 internal constant EIP712_DOMAIN_TYPEHASH =
2670     keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");
2671 
2672   /// @dev EIP-712 createAction typehash.
2673   bytes32 internal constant CREATE_ACTION_TYPEHASH = keccak256(
2674     "CreateAction(address policyholder,uint8 role,address strategy,address target,uint256 value,bytes data,string description,uint256 nonce)"
2675   );
2676 
2677   /// @dev EIP-712 castApproval typehash.
2678   bytes32 internal constant CAST_APPROVAL_TYPEHASH = keccak256(
2679     "CastApproval(address policyholder,uint8 role,ActionInfo actionInfo,string reason,uint256 nonce)ActionInfo(uint256 id,address creator,uint8 creatorRole,address strategy,address target,uint256 value,bytes data)"
2680   );
2681 
2682   /// @dev EIP-712 castDisapproval typehash.
2683   bytes32 internal constant CAST_DISAPPROVAL_TYPEHASH = keccak256(
2684     "CastDisapproval(address policyholder,uint8 role,ActionInfo actionInfo,string reason,uint256 nonce)ActionInfo(uint256 id,address creator,uint8 creatorRole,address strategy,address target,uint256 value,bytes data)"
2685   );
2686 
2687   /// @dev EIP-712 actionInfo typehash.
2688   bytes32 internal constant ACTION_INFO_TYPEHASH = keccak256(
2689     "ActionInfo(uint256 id,address creator,uint8 creatorRole,address strategy,address target,uint256 value,bytes data)"
2690   );
2691 
2692   /// @dev Mapping of actionIds to Actions.
2693   /// @dev Making this `public` results in stack too deep with no optimizer, but this data can be
2694   /// accessed with the `getAction` function so this is ok. We want the contracts to compile
2695   /// without the optimizer so `forge coverage` can be used.
2696   mapping(uint256 => Action) internal actions;
2697 
2698   /// @notice The contract that executes actions for this Llama instance.
2699   LlamaExecutor public executor;
2700 
2701   /// @notice The ERC721 contract that defines the policies for this Llama instance.
2702   /// @dev We intentionally put this first so it's packed with the `Initializable` storage
2703   // variables, which are the key variables we want to check before and after a delegatecall.
2704   LlamaPolicy public policy;
2705 
2706   /// @notice The `LlamaFactory` contract that deployed this Llama instance.
2707   LlamaFactory public factory;
2708 
2709   /// @notice Name of this Llama instance.
2710   string public name;
2711 
2712   /// @notice The current number of actions created.
2713   uint256 public actionsCount;
2714 
2715   /// @notice Mapping of actionIds to policyholders to approvals.
2716   mapping(uint256 => mapping(address => bool)) public approvals;
2717 
2718   /// @notice Mapping of actionIds to policyholders to disapprovals.
2719   mapping(uint256 => mapping(address => bool)) public disapprovals;
2720 
2721   /// @notice Mapping of all authorized strategies.
2722   mapping(ILlamaStrategy => bool) public strategies;
2723 
2724   /// @notice Mapping of all authorized scripts.
2725   mapping(address => bool) public authorizedScripts;
2726 
2727   /// @notice Mapping of policyholders to function selectors to current nonces for EIP-712 signatures.
2728   /// @dev This is used to prevent replay attacks by incrementing the nonce for each operation (`createAction`,
2729   /// `castApproval` and `castDisapproval`) signed by the policyholder.
2730   mapping(address => mapping(bytes4 => uint256)) public nonces;
2731 
2732   /// @notice Mapping of target to selector to actionGuard address.
2733   mapping(address target => mapping(bytes4 selector => ILlamaActionGuard)) public actionGuard;
2734 
2735   // ======================================================
2736   // ======== Contract Creation and Initialization ========
2737   // ======================================================
2738 
2739   constructor() {
2740     _disableInitializers();
2741   }
2742 
2743   /// @notice Initializes a new `LlamaCore` clone.
2744   /// @param _name The name of the `LlamaCore` clone.
2745   /// @param _policy This Llama instance's policy contract.
2746   /// @param _llamaStrategyLogic The Llama Strategy implementation (logic) contract.
2747   /// @param _llamaAccountLogic The Llama Account implementation (logic) contract.
2748   /// @param initialStrategies Array of initial strategy configurations.
2749   /// @param initialAccounts Array of initial account configurations.
2750   /// @return bootstrapPermissionId The permission ID that's used to set role permissions.
2751   function initialize(
2752     string memory _name,
2753     LlamaPolicy _policy,
2754     ILlamaStrategy _llamaStrategyLogic,
2755     ILlamaAccount _llamaAccountLogic,
2756     bytes[] calldata initialStrategies,
2757     bytes[] calldata initialAccounts
2758   ) external initializer returns (bytes32 bootstrapPermissionId) {
2759     factory = LlamaFactory(msg.sender);
2760     name = _name;
2761     executor = new LlamaExecutor();
2762     policy = _policy;
2763 
2764     ILlamaStrategy bootstrapStrategy = _deployStrategies(_llamaStrategyLogic, initialStrategies);
2765     _deployAccounts(_llamaAccountLogic, initialAccounts);
2766 
2767     // Now we compute the permission ID used to set role permissions and return it.
2768     bytes4 selector = LlamaPolicy.setRolePermission.selector;
2769     return keccak256(abi.encode(PermissionData(address(policy), bytes4(selector), bootstrapStrategy)));
2770   }
2771 
2772   // ===========================================
2773   // ======== External and Public Logic ========
2774   // ===========================================
2775 
2776   /// @notice Creates an action. The creator needs to hold a policy with the permission ID of the provided
2777   /// `(target, selector, strategy)`.
2778   /// @dev Use `""` for `description` if there is no description.
2779   /// @param role The role that will be used to determine the permission ID of the policyholder.
2780   /// @param strategy The strategy contract that will determine how the action is executed.
2781   /// @param target The contract called when the action is executed.
2782   /// @param value The value in wei to be sent when the action is executed.
2783   /// @param data Data to be called on the target when the action is executed.
2784   /// @param description A human readable description of the action and the changes it will enact.
2785   /// @return actionId Action ID of the newly created action.
2786   function createAction(
2787     uint8 role,
2788     ILlamaStrategy strategy,
2789     address target,
2790     uint256 value,
2791     bytes calldata data,
2792     string memory description
2793   ) external returns (uint256 actionId) {
2794     actionId = _createAction(msg.sender, role, strategy, target, value, data, description);
2795   }
2796 
2797   /// @notice Creates an action via an off-chain signature. The creator needs to hold a policy with the permission ID
2798   /// of the provided `(target, selector, strategy)`.
2799   /// @dev Use `""` for `description` if there is no description.
2800   /// @param policyholder The policyholder that signed the message.
2801   /// @param role The role that will be used to determine the permission ID of the policyholder.
2802   /// @param strategy The strategy contract that will determine how the action is executed.
2803   /// @param target The contract called when the action is executed.
2804   /// @param value The value in wei to be sent when the action is executed.
2805   /// @param data Data to be called on the target when the action is executed.
2806   /// @param description A human readable description of the action and the changes it will enact.
2807   /// @param v ECDSA signature component: Parity of the `y` coordinate of point `R`
2808   /// @param r ECDSA signature component: x-coordinate of `R`
2809   /// @param s ECDSA signature component: `s` value of the signature
2810   /// @return actionId Action ID of the newly created action.
2811   function createActionBySig(
2812     address policyholder,
2813     uint8 role,
2814     ILlamaStrategy strategy,
2815     address target,
2816     uint256 value,
2817     bytes calldata data,
2818     string memory description,
2819     uint8 v,
2820     bytes32 r,
2821     bytes32 s
2822   ) external returns (uint256 actionId) {
2823     bytes32 digest = _getCreateActionTypedDataHash(policyholder, role, strategy, target, value, data, description);
2824     address signer = ecrecover(digest, v, r, s);
2825     if (signer == address(0) || signer != policyholder) revert InvalidSignature();
2826     actionId = _createAction(signer, role, strategy, target, value, data, description);
2827   }
2828 
2829   /// @notice Queue an action by its `actionInfo` struct if it's in Approved state.
2830   /// @param actionInfo Data required to create an action.
2831   function queueAction(ActionInfo calldata actionInfo) external {
2832     Action storage action = actions[actionInfo.id];
2833     ActionState currentState = getActionState(actionInfo);
2834     if (currentState != ActionState.Approved) revert InvalidActionState(currentState);
2835 
2836     uint64 minExecutionTime = actionInfo.strategy.minExecutionTime(actionInfo);
2837     if (minExecutionTime < block.timestamp) revert MinExecutionTimeCannotBeInThePast();
2838     action.minExecutionTime = minExecutionTime;
2839     emit ActionQueued(actionInfo.id, msg.sender, actionInfo.strategy, actionInfo.creator, minExecutionTime);
2840   }
2841 
2842   /// @notice Execute an action by its `actionInfo` struct if it's in Queued state and `minExecutionTime` has passed.
2843   /// @param actionInfo Data required to create an action.
2844   function executeAction(ActionInfo calldata actionInfo) external payable {
2845     // Initial checks that action is ready to execute.
2846     Action storage action = actions[actionInfo.id];
2847     ActionState currentState = getActionState(actionInfo);
2848 
2849     if (currentState != ActionState.Queued) revert InvalidActionState(currentState);
2850     if (block.timestamp < action.minExecutionTime) revert MinExecutionTimeNotReached();
2851     if (msg.value != actionInfo.value) revert IncorrectMsgValue();
2852 
2853     action.executed = true;
2854 
2855     // Check pre-execution action guard.
2856     ILlamaActionGuard guard = actionGuard[actionInfo.target][bytes4(actionInfo.data)];
2857     if (guard != ILlamaActionGuard(address(0))) guard.validatePreActionExecution(actionInfo);
2858 
2859     // Execute action.
2860     (bool success, bytes memory result) =
2861       executor.execute(actionInfo.target, actionInfo.value, action.isScript, actionInfo.data);
2862 
2863     if (!success) revert FailedActionExecution(result);
2864 
2865     // Check post-execution action guard.
2866     if (guard != ILlamaActionGuard(address(0))) guard.validatePostActionExecution(actionInfo);
2867 
2868     // Action successfully executed.
2869     emit ActionExecuted(actionInfo.id, msg.sender, actionInfo.strategy, actionInfo.creator, result);
2870   }
2871 
2872   /// @notice Cancels an action by its `actionInfo` struct.
2873   /// @dev Rules for cancelation are defined by the strategy.
2874   /// @param actionInfo Data required to create an action.
2875   function cancelAction(ActionInfo calldata actionInfo) external {
2876     Action storage action = actions[actionInfo.id];
2877     _validateActionInfoHash(action.infoHash, actionInfo);
2878 
2879     // We don't need an explicit check on action existence because if it doesn't exist the strategy will be the zero
2880     // address, and Solidity will revert since there is no code at the zero address.
2881     actionInfo.strategy.validateActionCancelation(actionInfo, msg.sender);
2882 
2883     action.canceled = true;
2884     emit ActionCanceled(actionInfo.id);
2885   }
2886 
2887   /// @notice How policyholders add their support of the approval of an action with a reason.
2888   /// @dev Use `""` for `reason` if there is no reason.
2889   /// @param role The role the policyholder uses to cast their approval.
2890   /// @param actionInfo Data required to create an action.
2891   /// @param reason The reason given for the approval by the policyholder.
2892   function castApproval(uint8 role, ActionInfo calldata actionInfo, string calldata reason) external {
2893     return _castApproval(msg.sender, role, actionInfo, reason);
2894   }
2895 
2896   /// @notice How policyholders add their support of the approval of an action via an off-chain signature.
2897   /// @dev Use `""` for `reason` if there is no reason.
2898   /// @param policyholder The policyholder that signed the message.
2899   /// @param role The role the policyholder uses to cast their approval.
2900   /// @param actionInfo Data required to create an action.
2901   /// @param reason The reason given for the approval by the policyholder.
2902   /// @param v ECDSA signature component: Parity of the `y` coordinate of point `R`
2903   /// @param r ECDSA signature component: x-coordinate of `R`
2904   /// @param s ECDSA signature component: `s` value of the signature
2905   function castApprovalBySig(
2906     address policyholder,
2907     uint8 role,
2908     ActionInfo calldata actionInfo,
2909     string calldata reason,
2910     uint8 v,
2911     bytes32 r,
2912     bytes32 s
2913   ) external {
2914     bytes32 digest = _getCastApprovalTypedDataHash(policyholder, role, actionInfo, reason);
2915     address signer = ecrecover(digest, v, r, s);
2916     if (signer == address(0) || signer != policyholder) revert InvalidSignature();
2917     return _castApproval(signer, role, actionInfo, reason);
2918   }
2919 
2920   /// @notice How policyholders add their support of the disapproval of an action with a reason.
2921   /// @dev Use `""` for `reason` if there is no reason.
2922   /// @param role The role the policyholder uses to cast their disapproval.
2923   /// @param actionInfo Data required to create an action.
2924   /// @param reason The reason given for the disapproval by the policyholder.
2925   function castDisapproval(uint8 role, ActionInfo calldata actionInfo, string calldata reason) external {
2926     return _castDisapproval(msg.sender, role, actionInfo, reason);
2927   }
2928 
2929   /// @notice How policyholders add their support of the disapproval of an action via an off-chain signature.
2930   /// @dev Use `""` for `reason` if there is no reason.
2931   /// @param policyholder The policyholder that signed the message.
2932   /// @param role The role the policyholder uses to cast their disapproval.
2933   /// @param actionInfo Data required to create an action.
2934   /// @param reason The reason given for the approval by the policyholder.
2935   /// @param v ECDSA signature component: Parity of the `y` coordinate of point `R`
2936   /// @param r ECDSA signature component: x-coordinate of `R`
2937   /// @param s ECDSA signature component: `s` value of the signature
2938   function castDisapprovalBySig(
2939     address policyholder,
2940     uint8 role,
2941     ActionInfo calldata actionInfo,
2942     string calldata reason,
2943     uint8 v,
2944     bytes32 r,
2945     bytes32 s
2946   ) external {
2947     bytes32 digest = _getCastDisapprovalTypedDataHash(policyholder, role, actionInfo, reason);
2948     address signer = ecrecover(digest, v, r, s);
2949     if (signer == address(0) || signer != policyholder) revert InvalidSignature();
2950     return _castDisapproval(signer, role, actionInfo, reason);
2951   }
2952 
2953   /// @notice Deploy new strategies and add them to the mapping of authorized strategies.
2954   /// @param llamaStrategyLogic address of the Llama strategy logic contract.
2955   /// @param strategyConfigs Array of new strategy configurations.
2956   function createStrategies(ILlamaStrategy llamaStrategyLogic, bytes[] calldata strategyConfigs) external onlyLlama {
2957     _deployStrategies(llamaStrategyLogic, strategyConfigs);
2958   }
2959 
2960   /// @notice Deploy new accounts.
2961   /// @param llamaAccountLogic address of the Llama account logic contract.
2962   /// @param accountConfigs Array of new account configurations.
2963   function createAccounts(ILlamaAccount llamaAccountLogic, bytes[] calldata accountConfigs) external onlyLlama {
2964     _deployAccounts(llamaAccountLogic, accountConfigs);
2965   }
2966 
2967   /// @notice Sets `guard` as the action guard for the given `target` and `selector`.
2968   /// @param target The target contract where the `guard` will apply.
2969   /// @param selector The function selector where the `guard` will apply.
2970   /// @dev To remove a guard, set `guard` to the zero address.
2971   function setGuard(address target, bytes4 selector, ILlamaActionGuard guard) external onlyLlama {
2972     if (target == address(this) || target == address(policy)) revert RestrictedAddress();
2973     actionGuard[target][selector] = guard;
2974     emit ActionGuardSet(target, selector, guard);
2975   }
2976 
2977   /// @notice Authorizes `script` to be eligible to be delegatecalled from the executor.
2978   /// @param script The address of the script contract.
2979   /// @param authorized The boolean that determines if the `script` is being authorized or unauthorized.
2980   /// @dev To remove a `script`, set `authorized` to `false`.
2981   function authorizeScript(address script, bool authorized) external onlyLlama {
2982     if (script == address(this) || script == address(policy)) revert RestrictedAddress();
2983     authorizedScripts[script] = authorized;
2984     emit ScriptAuthorized(script, authorized);
2985   }
2986 
2987   /// @notice Increments the caller's nonce for the given `selector`. This is useful for revoking
2988   /// signatures that have not been used yet.
2989   /// @param selector The function selector to increment the nonce for.
2990   function incrementNonce(bytes4 selector) external {
2991     // Safety: Can never overflow a uint256 by incrementing.
2992     nonces[msg.sender][selector] = LlamaUtils.uncheckedIncrement(nonces[msg.sender][selector]);
2993   }
2994 
2995   /// @notice Get an Action struct by `actionId`.
2996   /// @param actionId ID of the action.
2997   /// @return The Action struct.
2998   function getAction(uint256 actionId) external view returns (Action memory) {
2999     return actions[actionId];
3000   }
3001 
3002   /// @notice Returns the timestamp of most recently created action.
3003   /// @dev Used by `LlamaPolicy` to ensure policy management does not occur immediately after action
3004   /// creation in the same timestamp, as this could result in invalid role supply counts being used.
3005   function getLastActionTimestamp() external view returns (uint256 timestamp) {
3006     return actionsCount == 0 ? 0 : actions[actionsCount - 1].creationTime;
3007   }
3008 
3009   /// @notice Get the current action state of an action by its `actionInfo` struct.
3010   /// @param actionInfo Data required to create an action.
3011   /// @return The current action state of the action.
3012   function getActionState(ActionInfo calldata actionInfo) public view returns (ActionState) {
3013     // We don't need an explicit check on the action ID to make sure it exists, because if the
3014     // action does not exist, the expected payload hash from storage will be `bytes32(0)`, so
3015     // bypassing this check by providing a non-existent actionId would require finding a collision
3016     // to get a hash of zero.
3017     Action storage action = actions[actionInfo.id];
3018     _validateActionInfoHash(action.infoHash, actionInfo);
3019 
3020     if (action.canceled) return ActionState.Canceled;
3021 
3022     if (action.executed) return ActionState.Executed;
3023 
3024     if (actionInfo.strategy.isActive(actionInfo)) return ActionState.Active;
3025 
3026     if (!actionInfo.strategy.isActionApproved(actionInfo)) return ActionState.Failed;
3027 
3028     if (action.minExecutionTime == 0) return ActionState.Approved;
3029 
3030     if (actionInfo.strategy.isActionDisapproved(actionInfo)) return ActionState.Failed;
3031 
3032     if (actionInfo.strategy.isActionExpired(actionInfo)) return ActionState.Expired;
3033 
3034     return ActionState.Queued;
3035   }
3036 
3037   // ================================
3038   // ======== Internal Logic ========
3039   // ================================
3040 
3041   /// @dev Creates an action. The creator needs to hold a policy with the permission ID of the provided
3042   /// `(target, selector, strategy)`.
3043   function _createAction(
3044     address policyholder,
3045     uint8 role,
3046     ILlamaStrategy strategy,
3047     address target,
3048     uint256 value,
3049     bytes calldata data,
3050     string memory description
3051   ) internal returns (uint256 actionId) {
3052     if (target == address(executor)) revert CannotSetExecutorAsTarget();
3053     if (!strategies[strategy]) revert InvalidStrategy();
3054 
3055     PermissionData memory permission = PermissionData(target, bytes4(data), strategy);
3056     bytes32 permissionId = keccak256(abi.encode(permission));
3057 
3058     // Typically (such as in Governor contracts) this should check that the caller has permission
3059     // at `block.number|timestamp - 1` but here we're just checking if the caller *currently* has
3060     // permission. Technically this introduces a race condition if e.g. an action to revoke a role
3061     // from someone (or revoke a permission from a role) is ready to be executed at the same time as
3062     // an action is created, as the order of transactions in the block then affects if action
3063     // creation would succeed. However, we are ok with this tradeoff because it means we don't need
3064     // to checkpoint the `canCreateAction` mapping which is simpler and cheaper, and in practice
3065     // this race condition is unlikely to matter.
3066     if (!policy.hasPermissionId(policyholder, role, permissionId)) revert PolicyholderDoesNotHavePermission();
3067 
3068     // Validate action creation.
3069     actionId = actionsCount;
3070 
3071     ActionInfo memory actionInfo = ActionInfo(actionId, policyholder, role, strategy, target, value, data);
3072     strategy.validateActionCreation(actionInfo);
3073 
3074     // Scope to avoid stack too deep
3075     {
3076       ILlamaActionGuard guard = actionGuard[target][bytes4(data)];
3077       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);
3078 
3079       // Save action.
3080       Action storage newAction = actions[actionId];
3081       newAction.infoHash = _infoHash(actionId, policyholder, role, strategy, target, value, data);
3082       newAction.creationTime = LlamaUtils.toUint64(block.timestamp);
3083       newAction.isScript = authorizedScripts[target];
3084     }
3085 
3086     actionsCount = LlamaUtils.uncheckedIncrement(actionsCount); // Safety: Can never overflow a uint256 by incrementing.
3087 
3088     emit ActionCreated(actionId, policyholder, role, strategy, target, value, data, description);
3089   }
3090 
3091   /// @dev How policyholders that have the right role contribute towards the approval of an action with a reason.
3092   function _castApproval(address policyholder, uint8 role, ActionInfo calldata actionInfo, string memory reason)
3093     internal
3094   {
3095     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Active);
3096 
3097     action.totalApprovals = _newCastCount(action.totalApprovals, quantity);
3098     approvals[actionInfo.id][policyholder] = true;
3099     emit ApprovalCast(actionInfo.id, policyholder, role, quantity, reason);
3100   }
3101 
3102   /// @dev How policyholders that have the right role contribute towards the disapproval of an action with a reason.
3103   function _castDisapproval(address policyholder, uint8 role, ActionInfo calldata actionInfo, string memory reason)
3104     internal
3105   {
3106     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Queued);
3107 
3108     action.totalDisapprovals = _newCastCount(action.totalDisapprovals, quantity);
3109     disapprovals[actionInfo.id][policyholder] = true;
3110     emit DisapprovalCast(actionInfo.id, policyholder, role, quantity, reason);
3111   }
3112 
3113   /// @dev The only `expectedState` values allowed to be passed into this method are Active or Queued.
3114   function _preCastAssertions(
3115     ActionInfo calldata actionInfo,
3116     address policyholder,
3117     uint8 role,
3118     ActionState expectedState
3119   ) internal returns (Action storage action, uint128 quantity) {
3120     action = actions[actionInfo.id];
3121     ActionState currentState = getActionState(actionInfo);
3122     if (currentState != expectedState) revert InvalidActionState(currentState);
3123 
3124     bool isApproval = expectedState == ActionState.Active;
3125     bool alreadyCast = isApproval ? approvals[actionInfo.id][policyholder] : disapprovals[actionInfo.id][policyholder];
3126     if (alreadyCast) revert DuplicateCast();
3127 
3128     bool hasRole = policy.hasRole(policyholder, role, action.creationTime);
3129     if (!hasRole) revert InvalidPolicyholder();
3130 
3131     if (isApproval) {
3132       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);
3133       quantity = actionInfo.strategy.getApprovalQuantityAt(policyholder, role, action.creationTime);
3134       if (quantity == 0) revert CannotCastWithZeroQuantity(policyholder, role);
3135     } else {
3136       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);
3137       quantity = actionInfo.strategy.getDisapprovalQuantityAt(policyholder, role, action.creationTime);
3138       if (quantity == 0) revert CannotCastWithZeroQuantity(policyholder, role);
3139     }
3140   }
3141 
3142   /// @dev Returns the new total count of approvals or disapprovals.
3143   function _newCastCount(uint128 currentCount, uint128 quantity) internal pure returns (uint128) {
3144     if (currentCount == type(uint128).max || quantity == type(uint128).max) return type(uint128).max;
3145     return currentCount + quantity;
3146   }
3147 
3148   /// @dev Deploys new strategies. Takes in the strategy logic contract to be used and an array of configurations to
3149   /// initialize the new strategies with. Returns the address of the first strategy, which is only used during the
3150   /// `LlamaCore` initialization so that we can ensure someone (specifically, policyholders with role ID 1) has the
3151   /// permission to assign role permissions.
3152   function _deployStrategies(ILlamaStrategy llamaStrategyLogic, bytes[] calldata strategyConfigs)
3153     internal
3154     returns (ILlamaStrategy firstStrategy)
3155   {
3156     if (address(factory).code.length > 0 && !factory.authorizedStrategyLogics(llamaStrategyLogic)) {
3157       // The only edge case where this check is skipped is if `_deployStrategies()` is called by root llama instance
3158       // during Llama Factory construction. This is because there is no code at the Llama Factory address yet.
3159       revert UnauthorizedStrategyLogic();
3160     }
3161 
3162     uint256 strategyLength = strategyConfigs.length;
3163     for (uint256 i = 0; i < strategyLength; i = LlamaUtils.uncheckedIncrement(i)) {
3164       bytes32 salt = bytes32(keccak256(strategyConfigs[i]));
3165       ILlamaStrategy strategy = ILlamaStrategy(Clones.cloneDeterministic(address(llamaStrategyLogic), salt));
3166       strategy.initialize(strategyConfigs[i]);
3167       strategies[strategy] = true;
3168       emit StrategyCreated(strategy, llamaStrategyLogic, strategyConfigs[i]);
3169       if (i == 0) firstStrategy = strategy;
3170     }
3171   }
3172 
3173   /// @dev Deploys new accounts. Takes in the account logic contract to be used and an array of configurations to
3174   /// initialize the new accounts with.
3175   function _deployAccounts(ILlamaAccount llamaAccountLogic, bytes[] calldata accountConfigs) internal {
3176     if (address(factory).code.length > 0 && !factory.authorizedAccountLogics(llamaAccountLogic)) {
3177       // The only edge case where this check is skipped is if `_deployAccounts()` is called by root llama instance
3178       // during Llama Factory construction. This is because there is no code at the Llama Factory address yet.
3179       revert UnauthorizedAccountLogic();
3180     }
3181 
3182     uint256 accountLength = accountConfigs.length;
3183     for (uint256 i = 0; i < accountLength; i = LlamaUtils.uncheckedIncrement(i)) {
3184       bytes32 salt = bytes32(keccak256(accountConfigs[i]));
3185       ILlamaAccount account = ILlamaAccount(Clones.cloneDeterministic(address(llamaAccountLogic), salt));
3186       account.initialize(accountConfigs[i]);
3187       emit AccountCreated(account, llamaAccountLogic, accountConfigs[i]);
3188     }
3189   }
3190 
3191   /// @dev Returns the hash of the `createAction` parameters using the `actionInfo` struct.
3192   function _infoHash(ActionInfo calldata actionInfo) internal pure returns (bytes32) {
3193     return _infoHash(
3194       actionInfo.id,
3195       actionInfo.creator,
3196       actionInfo.creatorRole,
3197       actionInfo.strategy,
3198       actionInfo.target,
3199       actionInfo.value,
3200       actionInfo.data
3201     );
3202   }
3203 
3204   /// @dev Returns the hash of the `createAction` parameters.
3205   function _infoHash(
3206     uint256 id,
3207     address creator,
3208     uint8 creatorRole,
3209     ILlamaStrategy strategy,
3210     address target,
3211     uint256 value,
3212     bytes calldata data
3213   ) internal pure returns (bytes32) {
3214     return keccak256(abi.encodePacked(id, creator, creatorRole, strategy, target, value, data));
3215   }
3216 
3217   /// @dev Validates that the hash of the `actionInfo` struct matches the provided hash.
3218   function _validateActionInfoHash(bytes32 actualHash, ActionInfo calldata actionInfo) internal pure {
3219     bytes32 expectedHash = _infoHash(actionInfo);
3220     if (actualHash != expectedHash) revert InfoHashMismatch();
3221   }
3222 
3223   /// @dev Returns the current nonce for a given policyholder and selector, and increments it. Used to prevent
3224   /// replay attacks.
3225   function _useNonce(address policyholder, bytes4 selector) internal returns (uint256 nonce) {
3226     nonce = nonces[policyholder][selector];
3227     nonces[policyholder][selector] = LlamaUtils.uncheckedIncrement(nonce);
3228   }
3229 
3230   // -------- EIP-712 Getters --------
3231 
3232   /// @dev Returns the EIP-712 domain separator.
3233   function _getDomainHash() internal view returns (bytes32) {
3234     return keccak256(
3235       abi.encode(EIP712_DOMAIN_TYPEHASH, keccak256(bytes(name)), keccak256(bytes("1")), block.chainid, address(this))
3236     );
3237   }
3238 
3239   /// @dev Returns the hash of the ABI-encoded EIP-712 message for the `CreateAction` domain, which can be used to
3240   /// recover the signer.
3241   function _getCreateActionTypedDataHash(
3242     address policyholder,
3243     uint8 role,
3244     ILlamaStrategy strategy,
3245     address target,
3246     uint256 value,
3247     bytes calldata data,
3248     string memory description
3249   ) internal returns (bytes32) {
3250     // Calculating and storing nonce in memory and using that below, instead of calculating in place to prevent stack
3251     // too deep error.
3252     uint256 nonce = _useNonce(policyholder, msg.sig);
3253 
3254     bytes32 createActionHash = keccak256(
3255       abi.encode(
3256         CREATE_ACTION_TYPEHASH,
3257         policyholder,
3258         role,
3259         address(strategy),
3260         target,
3261         value,
3262         keccak256(data),
3263         keccak256(bytes(description)),
3264         nonce
3265       )
3266     );
3267 
3268     return keccak256(abi.encodePacked("\x19\x01", _getDomainHash(), createActionHash));
3269   }
3270 
3271   /// @dev Returns the hash of the ABI-encoded EIP-712 message for the `CastApproval` domain, which can be used to
3272   /// recover the signer.
3273   function _getCastApprovalTypedDataHash(
3274     address policyholder,
3275     uint8 role,
3276     ActionInfo calldata actionInfo,
3277     string calldata reason
3278   ) internal returns (bytes32) {
3279     bytes32 castApprovalHash = keccak256(
3280       abi.encode(
3281         CAST_APPROVAL_TYPEHASH,
3282         policyholder,
3283         role,
3284         _getActionInfoHash(actionInfo),
3285         keccak256(bytes(reason)),
3286         _useNonce(policyholder, msg.sig)
3287       )
3288     );
3289 
3290     return keccak256(abi.encodePacked("\x19\x01", _getDomainHash(), castApprovalHash));
3291   }
3292 
3293   /// @dev Returns the hash of the ABI-encoded EIP-712 message for the `CastDisapproval` domain, which can be used to
3294   /// recover the signer.
3295   function _getCastDisapprovalTypedDataHash(
3296     address policyholder,
3297     uint8 role,
3298     ActionInfo calldata actionInfo,
3299     string calldata reason
3300   ) internal returns (bytes32) {
3301     bytes32 castDisapprovalHash = keccak256(
3302       abi.encode(
3303         CAST_DISAPPROVAL_TYPEHASH,
3304         policyholder,
3305         role,
3306         _getActionInfoHash(actionInfo),
3307         keccak256(bytes(reason)),
3308         _useNonce(policyholder, msg.sig)
3309       )
3310     );
3311 
3312     return keccak256(abi.encodePacked("\x19\x01", _getDomainHash(), castDisapprovalHash));
3313   }
3314 
3315   /// @dev Returns the hash of `actionInfo`.
3316   function _getActionInfoHash(ActionInfo calldata actionInfo) internal pure returns (bytes32) {
3317     return keccak256(
3318       abi.encode(
3319         ACTION_INFO_TYPEHASH,
3320         actionInfo.id,
3321         actionInfo.creator,
3322         actionInfo.creatorRole,
3323         address(actionInfo.strategy),
3324         actionInfo.target,
3325         actionInfo.value,
3326         keccak256(actionInfo.data)
3327       )
3328     );
3329   }
3330 }



```

### LlamaGovernanceScript.sol


```
Contract locking ether found:
	Contract LlamaCore (LlamaGovernanceScript.sol#3129-3912) has payable functions:
	 - LlamaCore.executeAction(ActionInfo) (LlamaGovernanceScript.sol#3426-3452)
	But does not have a function to withdraw the ether



    
3129 contract LlamaCore is Initializable {
3130   // ======================================
3131   // ======== Errors and Modifiers ========
3132   // ======================================
3133 
3134   /// @dev Policyholder cannot cast if it has 0 quantity of role.
3135   /// @param policyholder Address of policyholder.
3136   /// @param role The role being used in the cast.
3137   error CannotCastWithZeroQuantity(address policyholder, uint8 role);
3138 
3139   /// @dev An action's target contract cannot be the executor.
3140   error CannotSetExecutorAsTarget();
3141 
3142   /// @dev Address cannot be used.
3143   error RestrictedAddress();
3144 
3145   /// @dev Policyholders can only cast once.
3146   error DuplicateCast();
3147 
3148   /// @dev Action execution failed.
3149   /// @param reason Data returned by the function called by the action.
3150   error FailedActionExecution(bytes reason);
3151 
3152   /// @dev `ActionInfo` does not hash to the correct value.
3153   error InfoHashMismatch();
3154 
3155   /// @dev `msg.value` does not equal the action's value.
3156   error IncorrectMsgValue();
3157 
3158   /// @dev The action is not in the expected state.
3159   /// @param current The current state of the action.
3160   error InvalidActionState(ActionState current);
3161 
3162   /// @dev The policyholder does not have the role at action creation time.
3163   error InvalidPolicyholder();
3164 
3165   /// @dev The recovered signer does not match the expected policyholder.
3166   error InvalidSignature();
3167 
3168   /// @dev The provided address does not map to a deployed strategy.
3169   error InvalidStrategy();
3170 
3171   /// @dev An action cannot queue successfully if it's `minExecutionTime` is less than `block.timestamp`.
3172   error MinExecutionTimeCannotBeInThePast();
3173 
3174   /// @dev Only callable by a Llama instance's executor.
3175   error OnlyLlama();
3176 
3177   /// @dev Policyholder does not have the permission ID to create the action.
3178   error PolicyholderDoesNotHavePermission();
3179 
3180   /// @dev If `block.timestamp` is less than `minExecutionTime`, the action cannot be executed.
3181   error MinExecutionTimeNotReached();
3182 
3183   /// @dev Strategies can only be created with valid logic contracts.
3184   error UnauthorizedStrategyLogic();
3185 
3186   /// @dev Accounts can only be created with valid logic contracts.
3187   error UnauthorizedAccountLogic();
3188 
3189   /// @dev Checks that the caller is the Llama Executor and reverts if not.
3190   modifier onlyLlama() {
3191     if (msg.sender != address(executor)) revert OnlyLlama();
3192     _;
3193   }
3194 
3195   // ========================
3196   // ======== Events ========
3197   // ========================
3198 
3199   /// @dev Emitted when an action is created.
3200   event ActionCreated(
3201     uint256 id,
3202     address indexed creator,
3203     uint8 role,
3204     ILlamaStrategy indexed strategy,
3205     address indexed target,
3206     uint256 value,
3207     bytes data,
3208     string description
3209   );
3210 
3211   /// @dev Emitted when an action is canceled.
3212   event ActionCanceled(uint256 id);
3213 
3214   /// @dev Emitted when an action guard is set.
3215   event ActionGuardSet(address indexed target, bytes4 indexed selector, ILlamaActionGuard actionGuard);
3216 
3217   /// @dev Emitted when an action is queued.
3218   event ActionQueued(
3219     uint256 id,
3220     address indexed caller,
3221     ILlamaStrategy indexed strategy,
3222     address indexed creator,
3223     uint256 minExecutionTime
3224   );
3225 
3226   /// @dev Emitted when an action is executed.
3227   event ActionExecuted(
3228     uint256 id, address indexed caller, ILlamaStrategy indexed strategy, address indexed creator, bytes result
3229   );
3230 
3231   /// @dev Emitted when an approval is cast.
3232   event ApprovalCast(uint256 id, address indexed policyholder, uint8 indexed role, uint256 quantity, string reason);
3233 
3234   /// @dev Emitted when a disapproval is cast.
3235   event DisapprovalCast(uint256 id, address indexed policyholder, uint8 indexed role, uint256 quantity, string reason);
3236 
3237   /// @dev Emitted when a strategy is created and authorized.
3238   event StrategyCreated(ILlamaStrategy strategy, ILlamaStrategy indexed strategyLogic, bytes initializationData);
3239 
3240   /// @dev Emitted when an account is created.
3241   event AccountCreated(ILlamaAccount account, ILlamaAccount indexed accountLogic, bytes initializationData);
3242 
3243   /// @dev Emitted when a script is authorized.
3244   event ScriptAuthorized(address script, bool authorized);
3245 
3246   // =================================================
3247   // ======== Constants and Storage Variables ========
3248   // =================================================
3249 
3250   /// @dev EIP-712 base typehash.
3251   bytes32 internal constant EIP712_DOMAIN_TYPEHASH =
3252     keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");
3253 
3254   /// @dev EIP-712 createAction typehash.
3255   bytes32 internal constant CREATE_ACTION_TYPEHASH = keccak256(
3256     "CreateAction(address policyholder,uint8 role,address strategy,address target,uint256 value,bytes data,string description,uint256 nonce)"
3257   );
3258 
3259   /// @dev EIP-712 castApproval typehash.
3260   bytes32 internal constant CAST_APPROVAL_TYPEHASH = keccak256(
3261     "CastApproval(address policyholder,uint8 role,ActionInfo actionInfo,string reason,uint256 nonce)ActionInfo(uint256 id,address creator,uint8 creatorRole,address strategy,address target,uint256 value,bytes data)"
3262   );
3263 
3264   /// @dev EIP-712 castDisapproval typehash.
3265   bytes32 internal constant CAST_DISAPPROVAL_TYPEHASH = keccak256(
3266     "CastDisapproval(address policyholder,uint8 role,ActionInfo actionInfo,string reason,uint256 nonce)ActionInfo(uint256 id,address creator,uint8 creatorRole,address strategy,address target,uint256 value,bytes data)"
3267   );
3268 
3269   /// @dev EIP-712 actionInfo typehash.
3270   bytes32 internal constant ACTION_INFO_TYPEHASH = keccak256(
3271     "ActionInfo(uint256 id,address creator,uint8 creatorRole,address strategy,address target,uint256 value,bytes data)"
3272   );
3273 
3274   /// @dev Mapping of actionIds to Actions.
3275   /// @dev Making this `public` results in stack too deep with no optimizer, but this data can be
3276   /// accessed with the `getAction` function so this is ok. We want the contracts to compile
3277   /// without the optimizer so `forge coverage` can be used.
3278   mapping(uint256 => Action) internal actions;
3279 
3280   /// @notice The contract that executes actions for this Llama instance.
3281   LlamaExecutor public executor;
3282 
3283   /// @notice The ERC721 contract that defines the policies for this Llama instance.
3284   /// @dev We intentionally put this first so it's packed with the `Initializable` storage
3285   // variables, which are the key variables we want to check before and after a delegatecall.
3286   LlamaPolicy public policy;
3287 
3288   /// @notice The `LlamaFactory` contract that deployed this Llama instance.
3289   LlamaFactory public factory;
3290 
3291   /// @notice Name of this Llama instance.
3292   string public name;
3293 
3294   /// @notice The current number of actions created.
3295   uint256 public actionsCount;
3296 
3297   /// @notice Mapping of actionIds to policyholders to approvals.
3298   mapping(uint256 => mapping(address => bool)) public approvals;
3299 
3300   /// @notice Mapping of actionIds to policyholders to disapprovals.
3301   mapping(uint256 => mapping(address => bool)) public disapprovals;
3302 
3303   /// @notice Mapping of all authorized strategies.
3304   mapping(ILlamaStrategy => bool) public strategies;
3305 
3306   /// @notice Mapping of all authorized scripts.
3307   mapping(address => bool) public authorizedScripts;
3308 
3309   /// @notice Mapping of policyholders to function selectors to current nonces for EIP-712 signatures.
3310   /// @dev This is used to prevent replay attacks by incrementing the nonce for each operation (`createAction`,
3311   /// `castApproval` and `castDisapproval`) signed by the policyholder.
3312   mapping(address => mapping(bytes4 => uint256)) public nonces;
3313 
3314   /// @notice Mapping of target to selector to actionGuard address.
3315   mapping(address target => mapping(bytes4 selector => ILlamaActionGuard)) public actionGuard;
3316 
3317   // ======================================================
3318   // ======== Contract Creation and Initialization ========
3319   // ======================================================
3320 
3321   constructor() {
3322     _disableInitializers();
3323   }
3324 
3325   /// @notice Initializes a new `LlamaCore` clone.
3326   /// @param _name The name of the `LlamaCore` clone.
3327   /// @param _policy This Llama instance's policy contract.
3328   /// @param _llamaStrategyLogic The Llama Strategy implementation (logic) contract.
3329   /// @param _llamaAccountLogic The Llama Account implementation (logic) contract.
3330   /// @param initialStrategies Array of initial strategy configurations.
3331   /// @param initialAccounts Array of initial account configurations.
3332   /// @return bootstrapPermissionId The permission ID that's used to set role permissions.
3333   function initialize(
3334     string memory _name,
3335     LlamaPolicy _policy,
3336     ILlamaStrategy _llamaStrategyLogic,
3337     ILlamaAccount _llamaAccountLogic,
3338     bytes[] calldata initialStrategies,
3339     bytes[] calldata initialAccounts
3340   ) external initializer returns (bytes32 bootstrapPermissionId) {
3341     factory = LlamaFactory(msg.sender);
3342     name = _name;
3343     executor = new LlamaExecutor();
3344     policy = _policy;
3345 
3346     ILlamaStrategy bootstrapStrategy = _deployStrategies(_llamaStrategyLogic, initialStrategies);
3347     _deployAccounts(_llamaAccountLogic, initialAccounts);
3348 
3349     // Now we compute the permission ID used to set role permissions and return it.
3350     bytes4 selector = LlamaPolicy.setRolePermission.selector;
3351     return keccak256(abi.encode(PermissionData(address(policy), bytes4(selector), bootstrapStrategy)));
3352   }
3353 
3354   // ===========================================
3355   // ======== External and Public Logic ========
3356   // ===========================================
3357 
3358   /// @notice Creates an action. The creator needs to hold a policy with the permission ID of the provided
3359   /// `(target, selector, strategy)`.
3360   /// @dev Use `""` for `description` if there is no description.
3361   /// @param role The role that will be used to determine the permission ID of the policyholder.
3362   /// @param strategy The strategy contract that will determine how the action is executed.
3363   /// @param target The contract called when the action is executed.
3364   /// @param value The value in wei to be sent when the action is executed.
3365   /// @param data Data to be called on the target when the action is executed.
3366   /// @param description A human readable description of the action and the changes it will enact.
3367   /// @return actionId Action ID of the newly created action.
3368   function createAction(
3369     uint8 role,
3370     ILlamaStrategy strategy,
3371     address target,
3372     uint256 value,
3373     bytes calldata data,
3374     string memory description
3375   ) external returns (uint256 actionId) {
3376     actionId = _createAction(msg.sender, role, strategy, target, value, data, description);
3377   }
3378 
3379   /// @notice Creates an action via an off-chain signature. The creator needs to hold a policy with the permission ID
3380   /// of the provided `(target, selector, strategy)`.
3381   /// @dev Use `""` for `description` if there is no description.
3382   /// @param policyholder The policyholder that signed the message.
3383   /// @param role The role that will be used to determine the permission ID of the policyholder.
3384   /// @param strategy The strategy contract that will determine how the action is executed.
3385   /// @param target The contract called when the action is executed.
3386   /// @param value The value in wei to be sent when the action is executed.
3387   /// @param data Data to be called on the target when the action is executed.
3388   /// @param description A human readable description of the action and the changes it will enact.
3389   /// @param v ECDSA signature component: Parity of the `y` coordinate of point `R`
3390   /// @param r ECDSA signature component: x-coordinate of `R`
3391   /// @param s ECDSA signature component: `s` value of the signature
3392   /// @return actionId Action ID of the newly created action.
3393   function createActionBySig(
3394     address policyholder,
3395     uint8 role,
3396     ILlamaStrategy strategy,
3397     address target,
3398     uint256 value,
3399     bytes calldata data,
3400     string memory description,
3401     uint8 v,
3402     bytes32 r,
3403     bytes32 s
3404   ) external returns (uint256 actionId) {
3405     bytes32 digest = _getCreateActionTypedDataHash(policyholder, role, strategy, target, value, data, description);
3406     address signer = ecrecover(digest, v, r, s);
3407     if (signer == address(0) || signer != policyholder) revert InvalidSignature();
3408     actionId = _createAction(signer, role, strategy, target, value, data, description);
3409   }
3410 
3411   /// @notice Queue an action by its `actionInfo` struct if it's in Approved state.
3412   /// @param actionInfo Data required to create an action.
3413   function queueAction(ActionInfo calldata actionInfo) external {
3414     Action storage action = actions[actionInfo.id];
3415     ActionState currentState = getActionState(actionInfo);
3416     if (currentState != ActionState.Approved) revert InvalidActionState(currentState);
3417 
3418     uint64 minExecutionTime = actionInfo.strategy.minExecutionTime(actionInfo);
3419     if (minExecutionTime < block.timestamp) revert MinExecutionTimeCannotBeInThePast();
3420     action.minExecutionTime = minExecutionTime;
3421     emit ActionQueued(actionInfo.id, msg.sender, actionInfo.strategy, actionInfo.creator, minExecutionTime);
3422   }
3423 
3424   /// @notice Execute an action by its `actionInfo` struct if it's in Queued state and `minExecutionTime` has passed.
3425   /// @param actionInfo Data required to create an action.
3426   function executeAction(ActionInfo calldata actionInfo) external payable {
3427     // Initial checks that action is ready to execute.
3428     Action storage action = actions[actionInfo.id];
3429     ActionState currentState = getActionState(actionInfo);
3430 
3431     if (currentState != ActionState.Queued) revert InvalidActionState(currentState);
3432     if (block.timestamp < action.minExecutionTime) revert MinExecutionTimeNotReached();
3433     if (msg.value != actionInfo.value) revert IncorrectMsgValue();
3434 
3435     action.executed = true;
3436 
3437     // Check pre-execution action guard.
3438     ILlamaActionGuard guard = actionGuard[actionInfo.target][bytes4(actionInfo.data)];
3439     if (guard != ILlamaActionGuard(address(0))) guard.validatePreActionExecution(actionInfo);
3440 
3441     // Execute action.
3442     (bool success, bytes memory result) =
3443       executor.execute(actionInfo.target, actionInfo.value, action.isScript, actionInfo.data);
3444 
3445     if (!success) revert FailedActionExecution(result);
3446 
3447     // Check post-execution action guard.
3448     if (guard != ILlamaActionGuard(address(0))) guard.validatePostActionExecution(actionInfo);
3449 
3450     // Action successfully executed.
3451     emit ActionExecuted(actionInfo.id, msg.sender, actionInfo.strategy, actionInfo.creator, result);
3452   }
3453 
3454   /// @notice Cancels an action by its `actionInfo` struct.
3455   /// @dev Rules for cancelation are defined by the strategy.
3456   /// @param actionInfo Data required to create an action.
3457   function cancelAction(ActionInfo calldata actionInfo) external {
3458     Action storage action = actions[actionInfo.id];
3459     _validateActionInfoHash(action.infoHash, actionInfo);
3460 
3461     // We don't need an explicit check on action existence because if it doesn't exist the strategy will be the zero
3462     // address, and Solidity will revert since there is no code at the zero address.
3463     actionInfo.strategy.validateActionCancelation(actionInfo, msg.sender);
3464 
3465     action.canceled = true;
3466     emit ActionCanceled(actionInfo.id);
3467   }
3468 
3469   /// @notice How policyholders add their support of the approval of an action with a reason.
3470   /// @dev Use `""` for `reason` if there is no reason.
3471   /// @param role The role the policyholder uses to cast their approval.
3472   /// @param actionInfo Data required to create an action.
3473   /// @param reason The reason given for the approval by the policyholder.
3474   function castApproval(uint8 role, ActionInfo calldata actionInfo, string calldata reason) external {
3475     return _castApproval(msg.sender, role, actionInfo, reason);
3476   }
3477 
3478   /// @notice How policyholders add their support of the approval of an action via an off-chain signature.
3479   /// @dev Use `""` for `reason` if there is no reason.
3480   /// @param policyholder The policyholder that signed the message.
3481   /// @param role The role the policyholder uses to cast their approval.
3482   /// @param actionInfo Data required to create an action.
3483   /// @param reason The reason given for the approval by the policyholder.
3484   /// @param v ECDSA signature component: Parity of the `y` coordinate of point `R`
3485   /// @param r ECDSA signature component: x-coordinate of `R`
3486   /// @param s ECDSA signature component: `s` value of the signature
3487   function castApprovalBySig(
3488     address policyholder,
3489     uint8 role,
3490     ActionInfo calldata actionInfo,
3491     string calldata reason,
3492     uint8 v,
3493     bytes32 r,
3494     bytes32 s
3495   ) external {
3496     bytes32 digest = _getCastApprovalTypedDataHash(policyholder, role, actionInfo, reason);
3497     address signer = ecrecover(digest, v, r, s);
3498     if (signer == address(0) || signer != policyholder) revert InvalidSignature();
3499     return _castApproval(signer, role, actionInfo, reason);
3500   }
3501 
3502   /// @notice How policyholders add their support of the disapproval of an action with a reason.
3503   /// @dev Use `""` for `reason` if there is no reason.
3504   /// @param role The role the policyholder uses to cast their disapproval.
3505   /// @param actionInfo Data required to create an action.
3506   /// @param reason The reason given for the disapproval by the policyholder.
3507   function castDisapproval(uint8 role, ActionInfo calldata actionInfo, string calldata reason) external {
3508     return _castDisapproval(msg.sender, role, actionInfo, reason);
3509   }
3510 
3511   /// @notice How policyholders add their support of the disapproval of an action via an off-chain signature.
3512   /// @dev Use `""` for `reason` if there is no reason.
3513   /// @param policyholder The policyholder that signed the message.
3514   /// @param role The role the policyholder uses to cast their disapproval.
3515   /// @param actionInfo Data required to create an action.
3516   /// @param reason The reason given for the approval by the policyholder.
3517   /// @param v ECDSA signature component: Parity of the `y` coordinate of point `R`
3518   /// @param r ECDSA signature component: x-coordinate of `R`
3519   /// @param s ECDSA signature component: `s` value of the signature
3520   function castDisapprovalBySig(
3521     address policyholder,
3522     uint8 role,
3523     ActionInfo calldata actionInfo,
3524     string calldata reason,
3525     uint8 v,
3526     bytes32 r,
3527     bytes32 s
3528   ) external {
3529     bytes32 digest = _getCastDisapprovalTypedDataHash(policyholder, role, actionInfo, reason);
3530     address signer = ecrecover(digest, v, r, s);
3531     if (signer == address(0) || signer != policyholder) revert InvalidSignature();
3532     return _castDisapproval(signer, role, actionInfo, reason);
3533   }
3534 
3535   /// @notice Deploy new strategies and add them to the mapping of authorized strategies.
3536   /// @param llamaStrategyLogic address of the Llama strategy logic contract.
3537   /// @param strategyConfigs Array of new strategy configurations.
3538   function createStrategies(ILlamaStrategy llamaStrategyLogic, bytes[] calldata strategyConfigs) external onlyLlama {
3539     _deployStrategies(llamaStrategyLogic, strategyConfigs);
3540   }
3541 
3542   /// @notice Deploy new accounts.
3543   /// @param llamaAccountLogic address of the Llama account logic contract.
3544   /// @param accountConfigs Array of new account configurations.
3545   function createAccounts(ILlamaAccount llamaAccountLogic, bytes[] calldata accountConfigs) external onlyLlama {
3546     _deployAccounts(llamaAccountLogic, accountConfigs);
3547   }
3548 
3549   /// @notice Sets `guard` as the action guard for the given `target` and `selector`.
3550   /// @param target The target contract where the `guard` will apply.
3551   /// @param selector The function selector where the `guard` will apply.
3552   /// @dev To remove a guard, set `guard` to the zero address.
3553   function setGuard(address target, bytes4 selector, ILlamaActionGuard guard) external onlyLlama {
3554     if (target == address(this) || target == address(policy)) revert RestrictedAddress();
3555     actionGuard[target][selector] = guard;
3556     emit ActionGuardSet(target, selector, guard);
3557   }
3558 
3559   /// @notice Authorizes `script` to be eligible to be delegatecalled from the executor.
3560   /// @param script The address of the script contract.
3561   /// @param authorized The boolean that determines if the `script` is being authorized or unauthorized.
3562   /// @dev To remove a `script`, set `authorized` to `false`.
3563   function authorizeScript(address script, bool authorized) external onlyLlama {
3564     if (script == address(this) || script == address(policy)) revert RestrictedAddress();
3565     authorizedScripts[script] = authorized;
3566     emit ScriptAuthorized(script, authorized);
3567   }
3568 
3569   /// @notice Increments the caller's nonce for the given `selector`. This is useful for revoking
3570   /// signatures that have not been used yet.
3571   /// @param selector The function selector to increment the nonce for.
3572   function incrementNonce(bytes4 selector) external {
3573     // Safety: Can never overflow a uint256 by incrementing.
3574     nonces[msg.sender][selector] = LlamaUtils.uncheckedIncrement(nonces[msg.sender][selector]);
3575   }
3576 
3577   /// @notice Get an Action struct by `actionId`.
3578   /// @param actionId ID of the action.
3579   /// @return The Action struct.
3580   function getAction(uint256 actionId) external view returns (Action memory) {
3581     return actions[actionId];
3582   }
3583 
3584   /// @notice Returns the timestamp of most recently created action.
3585   /// @dev Used by `LlamaPolicy` to ensure policy management does not occur immediately after action
3586   /// creation in the same timestamp, as this could result in invalid role supply counts being used.
3587   function getLastActionTimestamp() external view returns (uint256 timestamp) {
3588     return actionsCount == 0 ? 0 : actions[actionsCount - 1].creationTime;
3589   }
3590 
3591   /// @notice Get the current action state of an action by its `actionInfo` struct.
3592   /// @param actionInfo Data required to create an action.
3593   /// @return The current action state of the action.
3594   function getActionState(ActionInfo calldata actionInfo) public view returns (ActionState) {
3595     // We don't need an explicit check on the action ID to make sure it exists, because if the
3596     // action does not exist, the expected payload hash from storage will be `bytes32(0)`, so
3597     // bypassing this check by providing a non-existent actionId would require finding a collision
3598     // to get a hash of zero.
3599     Action storage action = actions[actionInfo.id];
3600     _validateActionInfoHash(action.infoHash, actionInfo);
3601 
3602     if (action.canceled) return ActionState.Canceled;
3603 
3604     if (action.executed) return ActionState.Executed;
3605 
3606     if (actionInfo.strategy.isActive(actionInfo)) return ActionState.Active;
3607 
3608     if (!actionInfo.strategy.isActionApproved(actionInfo)) return ActionState.Failed;
3609 
3610     if (action.minExecutionTime == 0) return ActionState.Approved;
3611 
3612     if (actionInfo.strategy.isActionDisapproved(actionInfo)) return ActionState.Failed;
3613 
3614     if (actionInfo.strategy.isActionExpired(actionInfo)) return ActionState.Expired;
3615 
3616     return ActionState.Queued;
3617   }
3618 
3619   // ================================
3620   // ======== Internal Logic ========
3621   // ================================
3622 
3623   /// @dev Creates an action. The creator needs to hold a policy with the permission ID of the provided
3624   /// `(target, selector, strategy)`.
3625   function _createAction(
3626     address policyholder,
3627     uint8 role,
3628     ILlamaStrategy strategy,
3629     address target,
3630     uint256 value,
3631     bytes calldata data,
3632     string memory description
3633   ) internal returns (uint256 actionId) {
3634     if (target == address(executor)) revert CannotSetExecutorAsTarget();
3635     if (!strategies[strategy]) revert InvalidStrategy();
3636 
3637     PermissionData memory permission = PermissionData(target, bytes4(data), strategy);
3638     bytes32 permissionId = keccak256(abi.encode(permission));
3639 
3640     // Typically (such as in Governor contracts) this should check that the caller has permission
3641     // at `block.number|timestamp - 1` but here we're just checking if the caller *currently* has
3642     // permission. Technically this introduces a race condition if e.g. an action to revoke a role
3643     // from someone (or revoke a permission from a role) is ready to be executed at the same time as
3644     // an action is created, as the order of transactions in the block then affects if action
3645     // creation would succeed. However, we are ok with this tradeoff because it means we don't need
3646     // to checkpoint the `canCreateAction` mapping which is simpler and cheaper, and in practice
3647     // this race condition is unlikely to matter.
3648     if (!policy.hasPermissionId(policyholder, role, permissionId)) revert PolicyholderDoesNotHavePermission();
3649 
3650     // Validate action creation.
3651     actionId = actionsCount;
3652 
3653     ActionInfo memory actionInfo = ActionInfo(actionId, policyholder, role, strategy, target, value, data);
3654     strategy.validateActionCreation(actionInfo);
3655 
3656     // Scope to avoid stack too deep
3657     {
3658       ILlamaActionGuard guard = actionGuard[target][bytes4(data)];
3659       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);
3660 
3661       // Save action.
3662       Action storage newAction = actions[actionId];
3663       newAction.infoHash = _infoHash(actionId, policyholder, role, strategy, target, value, data);
3664       newAction.creationTime = LlamaUtils.toUint64(block.timestamp);
3665       newAction.isScript = authorizedScripts[target];
3666     }
3667 
3668     actionsCount = LlamaUtils.uncheckedIncrement(actionsCount); // Safety: Can never overflow a uint256 by incrementing.
3669 
3670     emit ActionCreated(actionId, policyholder, role, strategy, target, value, data, description);
3671   }
3672 
3673   /// @dev How policyholders that have the right role contribute towards the approval of an action with a reason.
3674   function _castApproval(address policyholder, uint8 role, ActionInfo calldata actionInfo, string memory reason)
3675     internal
3676   {
3677     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Active);
3678 
3679     action.totalApprovals = _newCastCount(action.totalApprovals, quantity);
3680     approvals[actionInfo.id][policyholder] = true;
3681     emit ApprovalCast(actionInfo.id, policyholder, role, quantity, reason);
3682   }
3683 
3684   /// @dev How policyholders that have the right role contribute towards the disapproval of an action with a reason.
3685   function _castDisapproval(address policyholder, uint8 role, ActionInfo calldata actionInfo, string memory reason)
3686     internal
3687   {
3688     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Queued);
3689 
3690     action.totalDisapprovals = _newCastCount(action.totalDisapprovals, quantity);
3691     disapprovals[actionInfo.id][policyholder] = true;
3692     emit DisapprovalCast(actionInfo.id, policyholder, role, quantity, reason);
3693   }
3694 
3695   /// @dev The only `expectedState` values allowed to be passed into this method are Active or Queued.
3696   function _preCastAssertions(
3697     ActionInfo calldata actionInfo,
3698     address policyholder,
3699     uint8 role,
3700     ActionState expectedState
3701   ) internal returns (Action storage action, uint128 quantity) {
3702     action = actions[actionInfo.id];
3703     ActionState currentState = getActionState(actionInfo);
3704     if (currentState != expectedState) revert InvalidActionState(currentState);
3705 
3706     bool isApproval = expectedState == ActionState.Active;
3707     bool alreadyCast = isApproval ? approvals[actionInfo.id][policyholder] : disapprovals[actionInfo.id][policyholder];
3708     if (alreadyCast) revert DuplicateCast();
3709 
3710     bool hasRole = policy.hasRole(policyholder, role, action.creationTime);
3711     if (!hasRole) revert InvalidPolicyholder();
3712 
3713     if (isApproval) {
3714       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);
3715       quantity = actionInfo.strategy.getApprovalQuantityAt(policyholder, role, action.creationTime);
3716       if (quantity == 0) revert CannotCastWithZeroQuantity(policyholder, role);
3717     } else {
3718       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);
3719       quantity = actionInfo.strategy.getDisapprovalQuantityAt(policyholder, role, action.creationTime);
3720       if (quantity == 0) revert CannotCastWithZeroQuantity(policyholder, role);
3721     }
3722   }
3723 
3724   /// @dev Returns the new total count of approvals or disapprovals.
3725   function _newCastCount(uint128 currentCount, uint128 quantity) internal pure returns (uint128) {
3726     if (currentCount == type(uint128).max || quantity == type(uint128).max) return type(uint128).max;
3727     return currentCount + quantity;
3728   }
3729 
3730   /// @dev Deploys new strategies. Takes in the strategy logic contract to be used and an array of configurations to
3731   /// initialize the new strategies with. Returns the address of the first strategy, which is only used during the
3732   /// `LlamaCore` initialization so that we can ensure someone (specifically, policyholders with role ID 1) has the
3733   /// permission to assign role permissions.
3734   function _deployStrategies(ILlamaStrategy llamaStrategyLogic, bytes[] calldata strategyConfigs)
3735     internal
3736     returns (ILlamaStrategy firstStrategy)
3737   {
3738     if (address(factory).code.length > 0 && !factory.authorizedStrategyLogics(llamaStrategyLogic)) {
3739       // The only edge case where this check is skipped is if `_deployStrategies()` is called by root llama instance
3740       // during Llama Factory construction. This is because there is no code at the Llama Factory address yet.
3741       revert UnauthorizedStrategyLogic();
3742     }
3743 
3744     uint256 strategyLength = strategyConfigs.length;
3745     for (uint256 i = 0; i < strategyLength; i = LlamaUtils.uncheckedIncrement(i)) {
3746       bytes32 salt = bytes32(keccak256(strategyConfigs[i]));
3747       ILlamaStrategy strategy = ILlamaStrategy(Clones.cloneDeterministic(address(llamaStrategyLogic), salt));
3748       strategy.initialize(strategyConfigs[i]);
3749       strategies[strategy] = true;
3750       emit StrategyCreated(strategy, llamaStrategyLogic, strategyConfigs[i]);
3751       if (i == 0) firstStrategy = strategy;
3752     }
3753   }
3754 
3755   /// @dev Deploys new accounts. Takes in the account logic contract to be used and an array of configurations to
3756   /// initialize the new accounts with.
3757   function _deployAccounts(ILlamaAccount llamaAccountLogic, bytes[] calldata accountConfigs) internal {
3758     if (address(factory).code.length > 0 && !factory.authorizedAccountLogics(llamaAccountLogic)) {
3759       // The only edge case where this check is skipped is if `_deployAccounts()` is called by root llama instance
3760       // during Llama Factory construction. This is because there is no code at the Llama Factory address yet.
3761       revert UnauthorizedAccountLogic();
3762     }
3763 
3764     uint256 accountLength = accountConfigs.length;
3765     for (uint256 i = 0; i < accountLength; i = LlamaUtils.uncheckedIncrement(i)) {
3766       bytes32 salt = bytes32(keccak256(accountConfigs[i]));
3767       ILlamaAccount account = ILlamaAccount(Clones.cloneDeterministic(address(llamaAccountLogic), salt));
3768       account.initialize(accountConfigs[i]);
3769       emit AccountCreated(account, llamaAccountLogic, accountConfigs[i]);
3770     }
3771   }
3772 
3773   /// @dev Returns the hash of the `createAction` parameters using the `actionInfo` struct.
3774   function _infoHash(ActionInfo calldata actionInfo) internal pure returns (bytes32) {
3775     return _infoHash(
3776       actionInfo.id,
3777       actionInfo.creator,
3778       actionInfo.creatorRole,
3779       actionInfo.strategy,
3780       actionInfo.target,
3781       actionInfo.value,
3782       actionInfo.data
3783     );
3784   }
3785 
3786   /// @dev Returns the hash of the `createAction` parameters.
3787   function _infoHash(
3788     uint256 id,
3789     address creator,
3790     uint8 creatorRole,
3791     ILlamaStrategy strategy,
3792     address target,
3793     uint256 value,
3794     bytes calldata data
3795   ) internal pure returns (bytes32) {
3796     return keccak256(abi.encodePacked(id, creator, creatorRole, strategy, target, value, data));
3797   }
3798 
3799   /// @dev Validates that the hash of the `actionInfo` struct matches the provided hash.
3800   function _validateActionInfoHash(bytes32 actualHash, ActionInfo calldata actionInfo) internal pure {
3801     bytes32 expectedHash = _infoHash(actionInfo);
3802     if (actualHash != expectedHash) revert InfoHashMismatch();
3803   }
3804 
3805   /// @dev Returns the current nonce for a given policyholder and selector, and increments it. Used to prevent
3806   /// replay attacks.
3807   function _useNonce(address policyholder, bytes4 selector) internal returns (uint256 nonce) {
3808     nonce = nonces[policyholder][selector];
3809     nonces[policyholder][selector] = LlamaUtils.uncheckedIncrement(nonce);
3810   }
3811 
3812   // -------- EIP-712 Getters --------
3813 
3814   /// @dev Returns the EIP-712 domain separator.
3815   function _getDomainHash() internal view returns (bytes32) {
3816     return keccak256(
3817       abi.encode(EIP712_DOMAIN_TYPEHASH, keccak256(bytes(name)), keccak256(bytes("1")), block.chainid, address(this))
3818     );
3819   }
3820 
3821   /// @dev Returns the hash of the ABI-encoded EIP-712 message for the `CreateAction` domain, which can be used to
3822   /// recover the signer.
3823   function _getCreateActionTypedDataHash(
3824     address policyholder,
3825     uint8 role,
3826     ILlamaStrategy strategy,
3827     address target,
3828     uint256 value,
3829     bytes calldata data,
3830     string memory description
3831   ) internal returns (bytes32) {
3832     // Calculating and storing nonce in memory and using that below, instead of calculating in place to prevent stack
3833     // too deep error.
3834     uint256 nonce = _useNonce(policyholder, msg.sig);
3835 
3836     bytes32 createActionHash = keccak256(
3837       abi.encode(
3838         CREATE_ACTION_TYPEHASH,
3839         policyholder,
3840         role,
3841         address(strategy),
3842         target,
3843         value,
3844         keccak256(data),
3845         keccak256(bytes(description)),
3846         nonce
3847       )
3848     );
3849 
3850     return keccak256(abi.encodePacked("\x19\x01", _getDomainHash(), createActionHash));
3851   }
3852 
3853   /// @dev Returns the hash of the ABI-encoded EIP-712 message for the `CastApproval` domain, which can be used to
3854   /// recover the signer.
3855   function _getCastApprovalTypedDataHash(
3856     address policyholder,
3857     uint8 role,
3858     ActionInfo calldata actionInfo,
3859     string calldata reason
3860   ) internal returns (bytes32) {
3861     bytes32 castApprovalHash = keccak256(
3862       abi.encode(
3863         CAST_APPROVAL_TYPEHASH,
3864         policyholder,
3865         role,
3866         _getActionInfoHash(actionInfo),
3867         keccak256(bytes(reason)),
3868         _useNonce(policyholder, msg.sig)
3869       )
3870     );
3871 
3872     return keccak256(abi.encodePacked("\x19\x01", _getDomainHash(), castApprovalHash));
3873   }
3874 
3875   /// @dev Returns the hash of the ABI-encoded EIP-712 message for the `CastDisapproval` domain, which can be used to
3876   /// recover the signer.
3877   function _getCastDisapprovalTypedDataHash(
3878     address policyholder,
3879     uint8 role,
3880     ActionInfo calldata actionInfo,
3881     string calldata reason
3882   ) internal returns (bytes32) {
3883     bytes32 castDisapprovalHash = keccak256(
3884       abi.encode(
3885         CAST_DISAPPROVAL_TYPEHASH,
3886         policyholder,
3887         role,
3888         _getActionInfoHash(actionInfo),
3889         keccak256(bytes(reason)),
3890         _useNonce(policyholder, msg.sig)
3891       )
3892     );
3893 
3894     return keccak256(abi.encodePacked("\x19\x01", _getDomainHash(), castDisapprovalHash));
3895   }
3896 
3897   /// @dev Returns the hash of `actionInfo`.
3898   function _getActionInfoHash(ActionInfo calldata actionInfo) internal pure returns (bytes32) {
3899     return keccak256(
3900       abi.encode(
3901         ACTION_INFO_TYPEHASH,
3902         actionInfo.id,
3903         actionInfo.creator,
3904         actionInfo.creatorRole,
3905         address(actionInfo.strategy),
3906         actionInfo.target,
3907         actionInfo.value,
3908         keccak256(actionInfo.data)
3909       )
3910     );
3911   }
3912 }



```

### LlamaPolicy.sol


```
Contract locking ether found:
	Contract LlamaCore (LlamaPolicy.sol#2536-3319) has payable functions:
	 - LlamaCore.executeAction(ActionInfo) (LlamaPolicy.sol#2833-2859)
	But does not have a function to withdraw the ether



    
2536 contract LlamaCore is Initializable {
2537   // ======================================
2538   // ======== Errors and Modifiers ========
2539   // ======================================
2540 
2541   /// @dev Policyholder cannot cast if it has 0 quantity of role.
2542   /// @param policyholder Address of policyholder.
2543   /// @param role The role being used in the cast.
2544   error CannotCastWithZeroQuantity(address policyholder, uint8 role);
2545 
2546   /// @dev An action's target contract cannot be the executor.
2547   error CannotSetExecutorAsTarget();
2548 
2549   /// @dev Address cannot be used.
2550   error RestrictedAddress();
2551 
2552   /// @dev Policyholders can only cast once.
2553   error DuplicateCast();
2554 
2555   /// @dev Action execution failed.
2556   /// @param reason Data returned by the function called by the action.
2557   error FailedActionExecution(bytes reason);
2558 
2559   /// @dev `ActionInfo` does not hash to the correct value.
2560   error InfoHashMismatch();
2561 
2562   /// @dev `msg.value` does not equal the action's value.
2563   error IncorrectMsgValue();
2564 
2565   /// @dev The action is not in the expected state.
2566   /// @param current The current state of the action.
2567   error InvalidActionState(ActionState current);
2568 
2569   /// @dev The policyholder does not have the role at action creation time.
2570   error InvalidPolicyholder();
2571 
2572   /// @dev The recovered signer does not match the expected policyholder.
2573   error InvalidSignature();
2574 
2575   /// @dev The provided address does not map to a deployed strategy.
2576   error InvalidStrategy();
2577 
2578   /// @dev An action cannot queue successfully if it's `minExecutionTime` is less than `block.timestamp`.
2579   error MinExecutionTimeCannotBeInThePast();
2580 
2581   /// @dev Only callable by a Llama instance's executor.
2582   error OnlyLlama();
2583 
2584   /// @dev Policyholder does not have the permission ID to create the action.
2585   error PolicyholderDoesNotHavePermission();
2586 
2587   /// @dev If `block.timestamp` is less than `minExecutionTime`, the action cannot be executed.
2588   error MinExecutionTimeNotReached();
2589 
2590   /// @dev Strategies can only be created with valid logic contracts.
2591   error UnauthorizedStrategyLogic();
2592 
2593   /// @dev Accounts can only be created with valid logic contracts.
2594   error UnauthorizedAccountLogic();
2595 
2596   /// @dev Checks that the caller is the Llama Executor and reverts if not.
2597   modifier onlyLlama() {
2598     if (msg.sender != address(executor)) revert OnlyLlama();
2599     _;
2600   }
2601 
2602   // ========================
2603   // ======== Events ========
2604   // ========================
2605 
2606   /// @dev Emitted when an action is created.
2607   event ActionCreated(
2608     uint256 id,
2609     address indexed creator,
2610     uint8 role,
2611     ILlamaStrategy indexed strategy,
2612     address indexed target,
2613     uint256 value,
2614     bytes data,
2615     string description
2616   );
2617 
2618   /// @dev Emitted when an action is canceled.
2619   event ActionCanceled(uint256 id);
2620 
2621   /// @dev Emitted when an action guard is set.
2622   event ActionGuardSet(address indexed target, bytes4 indexed selector, ILlamaActionGuard actionGuard);
2623 
2624   /// @dev Emitted when an action is queued.
2625   event ActionQueued(
2626     uint256 id,
2627     address indexed caller,
2628     ILlamaStrategy indexed strategy,
2629     address indexed creator,
2630     uint256 minExecutionTime
2631   );
2632 
2633   /// @dev Emitted when an action is executed.
2634   event ActionExecuted(
2635     uint256 id, address indexed caller, ILlamaStrategy indexed strategy, address indexed creator, bytes result
2636   );
2637 
2638   /// @dev Emitted when an approval is cast.
2639   event ApprovalCast(uint256 id, address indexed policyholder, uint8 indexed role, uint256 quantity, string reason);
2640 
2641   /// @dev Emitted when a disapproval is cast.
2642   event DisapprovalCast(uint256 id, address indexed policyholder, uint8 indexed role, uint256 quantity, string reason);
2643 
2644   /// @dev Emitted when a strategy is created and authorized.
2645   event StrategyCreated(ILlamaStrategy strategy, ILlamaStrategy indexed strategyLogic, bytes initializationData);
2646 
2647   /// @dev Emitted when an account is created.
2648   event AccountCreated(ILlamaAccount account, ILlamaAccount indexed accountLogic, bytes initializationData);
2649 
2650   /// @dev Emitted when a script is authorized.
2651   event ScriptAuthorized(address script, bool authorized);
2652 
2653   // =================================================
2654   // ======== Constants and Storage Variables ========
2655   // =================================================
2656 
2657   /// @dev EIP-712 base typehash.
2658   bytes32 internal constant EIP712_DOMAIN_TYPEHASH =
2659     keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");
2660 
2661   /// @dev EIP-712 createAction typehash.
2662   bytes32 internal constant CREATE_ACTION_TYPEHASH = keccak256(
2663     "CreateAction(address policyholder,uint8 role,address strategy,address target,uint256 value,bytes data,string description,uint256 nonce)"
2664   );
2665 
2666   /// @dev EIP-712 castApproval typehash.
2667   bytes32 internal constant CAST_APPROVAL_TYPEHASH = keccak256(
2668     "CastApproval(address policyholder,uint8 role,ActionInfo actionInfo,string reason,uint256 nonce)ActionInfo(uint256 id,address creator,uint8 creatorRole,address strategy,address target,uint256 value,bytes data)"
2669   );
2670 
2671   /// @dev EIP-712 castDisapproval typehash.
2672   bytes32 internal constant CAST_DISAPPROVAL_TYPEHASH = keccak256(
2673     "CastDisapproval(address policyholder,uint8 role,ActionInfo actionInfo,string reason,uint256 nonce)ActionInfo(uint256 id,address creator,uint8 creatorRole,address strategy,address target,uint256 value,bytes data)"
2674   );
2675 
2676   /// @dev EIP-712 actionInfo typehash.
2677   bytes32 internal constant ACTION_INFO_TYPEHASH = keccak256(
2678     "ActionInfo(uint256 id,address creator,uint8 creatorRole,address strategy,address target,uint256 value,bytes data)"
2679   );
2680 
2681   /// @dev Mapping of actionIds to Actions.
2682   /// @dev Making this `public` results in stack too deep with no optimizer, but this data can be
2683   /// accessed with the `getAction` function so this is ok. We want the contracts to compile
2684   /// without the optimizer so `forge coverage` can be used.
2685   mapping(uint256 => Action) internal actions;
2686 
2687   /// @notice The contract that executes actions for this Llama instance.
2688   LlamaExecutor public executor;
2689 
2690   /// @notice The ERC721 contract that defines the policies for this Llama instance.
2691   /// @dev We intentionally put this first so it's packed with the `Initializable` storage
2692   // variables, which are the key variables we want to check before and after a delegatecall.
2693   LlamaPolicy public policy;
2694 
2695   /// @notice The `LlamaFactory` contract that deployed this Llama instance.
2696   LlamaFactory public factory;
2697 
2698   /// @notice Name of this Llama instance.
2699   string public name;
2700 
2701   /// @notice The current number of actions created.
2702   uint256 public actionsCount;
2703 
2704   /// @notice Mapping of actionIds to policyholders to approvals.
2705   mapping(uint256 => mapping(address => bool)) public approvals;
2706 
2707   /// @notice Mapping of actionIds to policyholders to disapprovals.
2708   mapping(uint256 => mapping(address => bool)) public disapprovals;
2709 
2710   /// @notice Mapping of all authorized strategies.
2711   mapping(ILlamaStrategy => bool) public strategies;
2712 
2713   /// @notice Mapping of all authorized scripts.
2714   mapping(address => bool) public authorizedScripts;
2715 
2716   /// @notice Mapping of policyholders to function selectors to current nonces for EIP-712 signatures.
2717   /// @dev This is used to prevent replay attacks by incrementing the nonce for each operation (`createAction`,
2718   /// `castApproval` and `castDisapproval`) signed by the policyholder.
2719   mapping(address => mapping(bytes4 => uint256)) public nonces;
2720 
2721   /// @notice Mapping of target to selector to actionGuard address.
2722   mapping(address target => mapping(bytes4 selector => ILlamaActionGuard)) public actionGuard;
2723 
2724   // ======================================================
2725   // ======== Contract Creation and Initialization ========
2726   // ======================================================
2727 
2728   constructor() {
2729     _disableInitializers();
2730   }
2731 
2732   /// @notice Initializes a new `LlamaCore` clone.
2733   /// @param _name The name of the `LlamaCore` clone.
2734   /// @param _policy This Llama instance's policy contract.
2735   /// @param _llamaStrategyLogic The Llama Strategy implementation (logic) contract.
2736   /// @param _llamaAccountLogic The Llama Account implementation (logic) contract.
2737   /// @param initialStrategies Array of initial strategy configurations.
2738   /// @param initialAccounts Array of initial account configurations.
2739   /// @return bootstrapPermissionId The permission ID that's used to set role permissions.
2740   function initialize(
2741     string memory _name,
2742     LlamaPolicy _policy,
2743     ILlamaStrategy _llamaStrategyLogic,
2744     ILlamaAccount _llamaAccountLogic,
2745     bytes[] calldata initialStrategies,
2746     bytes[] calldata initialAccounts
2747   ) external initializer returns (bytes32 bootstrapPermissionId) {
2748     factory = LlamaFactory(msg.sender);
2749     name = _name;
2750     executor = new LlamaExecutor();
2751     policy = _policy;
2752 
2753     ILlamaStrategy bootstrapStrategy = _deployStrategies(_llamaStrategyLogic, initialStrategies);
2754     _deployAccounts(_llamaAccountLogic, initialAccounts);
2755 
2756     // Now we compute the permission ID used to set role permissions and return it.
2757     bytes4 selector = LlamaPolicy.setRolePermission.selector;
2758     return keccak256(abi.encode(PermissionData(address(policy), bytes4(selector), bootstrapStrategy)));
2759   }
2760 
2761   // ===========================================
2762   // ======== External and Public Logic ========
2763   // ===========================================
2764 
2765   /// @notice Creates an action. The creator needs to hold a policy with the permission ID of the provided
2766   /// `(target, selector, strategy)`.
2767   /// @dev Use `""` for `description` if there is no description.
2768   /// @param role The role that will be used to determine the permission ID of the policyholder.
2769   /// @param strategy The strategy contract that will determine how the action is executed.
2770   /// @param target The contract called when the action is executed.
2771   /// @param value The value in wei to be sent when the action is executed.
2772   /// @param data Data to be called on the target when the action is executed.
2773   /// @param description A human readable description of the action and the changes it will enact.
2774   /// @return actionId Action ID of the newly created action.
2775   function createAction(
2776     uint8 role,
2777     ILlamaStrategy strategy,
2778     address target,
2779     uint256 value,
2780     bytes calldata data,
2781     string memory description
2782   ) external returns (uint256 actionId) {
2783     actionId = _createAction(msg.sender, role, strategy, target, value, data, description);
2784   }
2785 
2786   /// @notice Creates an action via an off-chain signature. The creator needs to hold a policy with the permission ID
2787   /// of the provided `(target, selector, strategy)`.
2788   /// @dev Use `""` for `description` if there is no description.
2789   /// @param policyholder The policyholder that signed the message.
2790   /// @param role The role that will be used to determine the permission ID of the policyholder.
2791   /// @param strategy The strategy contract that will determine how the action is executed.
2792   /// @param target The contract called when the action is executed.
2793   /// @param value The value in wei to be sent when the action is executed.
2794   /// @param data Data to be called on the target when the action is executed.
2795   /// @param description A human readable description of the action and the changes it will enact.
2796   /// @param v ECDSA signature component: Parity of the `y` coordinate of point `R`
2797   /// @param r ECDSA signature component: x-coordinate of `R`
2798   /// @param s ECDSA signature component: `s` value of the signature
2799   /// @return actionId Action ID of the newly created action.
2800   function createActionBySig(
2801     address policyholder,
2802     uint8 role,
2803     ILlamaStrategy strategy,
2804     address target,
2805     uint256 value,
2806     bytes calldata data,
2807     string memory description,
2808     uint8 v,
2809     bytes32 r,
2810     bytes32 s
2811   ) external returns (uint256 actionId) {
2812     bytes32 digest = _getCreateActionTypedDataHash(policyholder, role, strategy, target, value, data, description);
2813     address signer = ecrecover(digest, v, r, s);
2814     if (signer == address(0) || signer != policyholder) revert InvalidSignature();
2815     actionId = _createAction(signer, role, strategy, target, value, data, description);
2816   }
2817 
2818   /// @notice Queue an action by its `actionInfo` struct if it's in Approved state.
2819   /// @param actionInfo Data required to create an action.
2820   function queueAction(ActionInfo calldata actionInfo) external {
2821     Action storage action = actions[actionInfo.id];
2822     ActionState currentState = getActionState(actionInfo);
2823     if (currentState != ActionState.Approved) revert InvalidActionState(currentState);
2824 
2825     uint64 minExecutionTime = actionInfo.strategy.minExecutionTime(actionInfo);
2826     if (minExecutionTime < block.timestamp) revert MinExecutionTimeCannotBeInThePast();
2827     action.minExecutionTime = minExecutionTime;
2828     emit ActionQueued(actionInfo.id, msg.sender, actionInfo.strategy, actionInfo.creator, minExecutionTime);
2829   }
2830 
2831   /// @notice Execute an action by its `actionInfo` struct if it's in Queued state and `minExecutionTime` has passed.
2832   /// @param actionInfo Data required to create an action.
2833   function executeAction(ActionInfo calldata actionInfo) external payable {
2834     // Initial checks that action is ready to execute.
2835     Action storage action = actions[actionInfo.id];
2836     ActionState currentState = getActionState(actionInfo);
2837 
2838     if (currentState != ActionState.Queued) revert InvalidActionState(currentState);
2839     if (block.timestamp < action.minExecutionTime) revert MinExecutionTimeNotReached();
2840     if (msg.value != actionInfo.value) revert IncorrectMsgValue();
2841 
2842     action.executed = true;
2843 
2844     // Check pre-execution action guard.
2845     ILlamaActionGuard guard = actionGuard[actionInfo.target][bytes4(actionInfo.data)];
2846     if (guard != ILlamaActionGuard(address(0))) guard.validatePreActionExecution(actionInfo);
2847 
2848     // Execute action.
2849     (bool success, bytes memory result) =
2850       executor.execute(actionInfo.target, actionInfo.value, action.isScript, actionInfo.data);
2851 
2852     if (!success) revert FailedActionExecution(result);
2853 
2854     // Check post-execution action guard.
2855     if (guard != ILlamaActionGuard(address(0))) guard.validatePostActionExecution(actionInfo);
2856 
2857     // Action successfully executed.
2858     emit ActionExecuted(actionInfo.id, msg.sender, actionInfo.strategy, actionInfo.creator, result);
2859   }
2860 
2861   /// @notice Cancels an action by its `actionInfo` struct.
2862   /// @dev Rules for cancelation are defined by the strategy.
2863   /// @param actionInfo Data required to create an action.
2864   function cancelAction(ActionInfo calldata actionInfo) external {
2865     Action storage action = actions[actionInfo.id];
2866     _validateActionInfoHash(action.infoHash, actionInfo);
2867 
2868     // We don't need an explicit check on action existence because if it doesn't exist the strategy will be the zero
2869     // address, and Solidity will revert since there is no code at the zero address.
2870     actionInfo.strategy.validateActionCancelation(actionInfo, msg.sender);
2871 
2872     action.canceled = true;
2873     emit ActionCanceled(actionInfo.id);
2874   }
2875 
2876   /// @notice How policyholders add their support of the approval of an action with a reason.
2877   /// @dev Use `""` for `reason` if there is no reason.
2878   /// @param role The role the policyholder uses to cast their approval.
2879   /// @param actionInfo Data required to create an action.
2880   /// @param reason The reason given for the approval by the policyholder.
2881   function castApproval(uint8 role, ActionInfo calldata actionInfo, string calldata reason) external {
2882     return _castApproval(msg.sender, role, actionInfo, reason);
2883   }
2884 
2885   /// @notice How policyholders add their support of the approval of an action via an off-chain signature.
2886   /// @dev Use `""` for `reason` if there is no reason.
2887   /// @param policyholder The policyholder that signed the message.
2888   /// @param role The role the policyholder uses to cast their approval.
2889   /// @param actionInfo Data required to create an action.
2890   /// @param reason The reason given for the approval by the policyholder.
2891   /// @param v ECDSA signature component: Parity of the `y` coordinate of point `R`
2892   /// @param r ECDSA signature component: x-coordinate of `R`
2893   /// @param s ECDSA signature component: `s` value of the signature
2894   function castApprovalBySig(
2895     address policyholder,
2896     uint8 role,
2897     ActionInfo calldata actionInfo,
2898     string calldata reason,
2899     uint8 v,
2900     bytes32 r,
2901     bytes32 s
2902   ) external {
2903     bytes32 digest = _getCastApprovalTypedDataHash(policyholder, role, actionInfo, reason);
2904     address signer = ecrecover(digest, v, r, s);
2905     if (signer == address(0) || signer != policyholder) revert InvalidSignature();
2906     return _castApproval(signer, role, actionInfo, reason);
2907   }
2908 
2909   /// @notice How policyholders add their support of the disapproval of an action with a reason.
2910   /// @dev Use `""` for `reason` if there is no reason.
2911   /// @param role The role the policyholder uses to cast their disapproval.
2912   /// @param actionInfo Data required to create an action.
2913   /// @param reason The reason given for the disapproval by the policyholder.
2914   function castDisapproval(uint8 role, ActionInfo calldata actionInfo, string calldata reason) external {
2915     return _castDisapproval(msg.sender, role, actionInfo, reason);
2916   }
2917 
2918   /// @notice How policyholders add their support of the disapproval of an action via an off-chain signature.
2919   /// @dev Use `""` for `reason` if there is no reason.
2920   /// @param policyholder The policyholder that signed the message.
2921   /// @param role The role the policyholder uses to cast their disapproval.
2922   /// @param actionInfo Data required to create an action.
2923   /// @param reason The reason given for the approval by the policyholder.
2924   /// @param v ECDSA signature component: Parity of the `y` coordinate of point `R`
2925   /// @param r ECDSA signature component: x-coordinate of `R`
2926   /// @param s ECDSA signature component: `s` value of the signature
2927   function castDisapprovalBySig(
2928     address policyholder,
2929     uint8 role,
2930     ActionInfo calldata actionInfo,
2931     string calldata reason,
2932     uint8 v,
2933     bytes32 r,
2934     bytes32 s
2935   ) external {
2936     bytes32 digest = _getCastDisapprovalTypedDataHash(policyholder, role, actionInfo, reason);
2937     address signer = ecrecover(digest, v, r, s);
2938     if (signer == address(0) || signer != policyholder) revert InvalidSignature();
2939     return _castDisapproval(signer, role, actionInfo, reason);
2940   }
2941 
2942   /// @notice Deploy new strategies and add them to the mapping of authorized strategies.
2943   /// @param llamaStrategyLogic address of the Llama strategy logic contract.
2944   /// @param strategyConfigs Array of new strategy configurations.
2945   function createStrategies(ILlamaStrategy llamaStrategyLogic, bytes[] calldata strategyConfigs) external onlyLlama {
2946     _deployStrategies(llamaStrategyLogic, strategyConfigs);
2947   }
2948 
2949   /// @notice Deploy new accounts.
2950   /// @param llamaAccountLogic address of the Llama account logic contract.
2951   /// @param accountConfigs Array of new account configurations.
2952   function createAccounts(ILlamaAccount llamaAccountLogic, bytes[] calldata accountConfigs) external onlyLlama {
2953     _deployAccounts(llamaAccountLogic, accountConfigs);
2954   }
2955 
2956   /// @notice Sets `guard` as the action guard for the given `target` and `selector`.
2957   /// @param target The target contract where the `guard` will apply.
2958   /// @param selector The function selector where the `guard` will apply.
2959   /// @dev To remove a guard, set `guard` to the zero address.
2960   function setGuard(address target, bytes4 selector, ILlamaActionGuard guard) external onlyLlama {
2961     if (target == address(this) || target == address(policy)) revert RestrictedAddress();
2962     actionGuard[target][selector] = guard;
2963     emit ActionGuardSet(target, selector, guard);
2964   }
2965 
2966   /// @notice Authorizes `script` to be eligible to be delegatecalled from the executor.
2967   /// @param script The address of the script contract.
2968   /// @param authorized The boolean that determines if the `script` is being authorized or unauthorized.
2969   /// @dev To remove a `script`, set `authorized` to `false`.
2970   function authorizeScript(address script, bool authorized) external onlyLlama {
2971     if (script == address(this) || script == address(policy)) revert RestrictedAddress();
2972     authorizedScripts[script] = authorized;
2973     emit ScriptAuthorized(script, authorized);
2974   }
2975 
2976   /// @notice Increments the caller's nonce for the given `selector`. This is useful for revoking
2977   /// signatures that have not been used yet.
2978   /// @param selector The function selector to increment the nonce for.
2979   function incrementNonce(bytes4 selector) external {
2980     // Safety: Can never overflow a uint256 by incrementing.
2981     nonces[msg.sender][selector] = LlamaUtils.uncheckedIncrement(nonces[msg.sender][selector]);
2982   }
2983 
2984   /// @notice Get an Action struct by `actionId`.
2985   /// @param actionId ID of the action.
2986   /// @return The Action struct.
2987   function getAction(uint256 actionId) external view returns (Action memory) {
2988     return actions[actionId];
2989   }
2990 
2991   /// @notice Returns the timestamp of most recently created action.
2992   /// @dev Used by `LlamaPolicy` to ensure policy management does not occur immediately after action
2993   /// creation in the same timestamp, as this could result in invalid role supply counts being used.
2994   function getLastActionTimestamp() external view returns (uint256 timestamp) {
2995     return actionsCount == 0 ? 0 : actions[actionsCount - 1].creationTime;
2996   }
2997 
2998   /// @notice Get the current action state of an action by its `actionInfo` struct.
2999   /// @param actionInfo Data required to create an action.
3000   /// @return The current action state of the action.
3001   function getActionState(ActionInfo calldata actionInfo) public view returns (ActionState) {
3002     // We don't need an explicit check on the action ID to make sure it exists, because if the
3003     // action does not exist, the expected payload hash from storage will be `bytes32(0)`, so
3004     // bypassing this check by providing a non-existent actionId would require finding a collision
3005     // to get a hash of zero.
3006     Action storage action = actions[actionInfo.id];
3007     _validateActionInfoHash(action.infoHash, actionInfo);
3008 
3009     if (action.canceled) return ActionState.Canceled;
3010 
3011     if (action.executed) return ActionState.Executed;
3012 
3013     if (actionInfo.strategy.isActive(actionInfo)) return ActionState.Active;
3014 
3015     if (!actionInfo.strategy.isActionApproved(actionInfo)) return ActionState.Failed;
3016 
3017     if (action.minExecutionTime == 0) return ActionState.Approved;
3018 
3019     if (actionInfo.strategy.isActionDisapproved(actionInfo)) return ActionState.Failed;
3020 
3021     if (actionInfo.strategy.isActionExpired(actionInfo)) return ActionState.Expired;
3022 
3023     return ActionState.Queued;
3024   }
3025 
3026   // ================================
3027   // ======== Internal Logic ========
3028   // ================================
3029 
3030   /// @dev Creates an action. The creator needs to hold a policy with the permission ID of the provided
3031   /// `(target, selector, strategy)`.
3032   function _createAction(
3033     address policyholder,
3034     uint8 role,
3035     ILlamaStrategy strategy,
3036     address target,
3037     uint256 value,
3038     bytes calldata data,
3039     string memory description
3040   ) internal returns (uint256 actionId) {
3041     if (target == address(executor)) revert CannotSetExecutorAsTarget();
3042     if (!strategies[strategy]) revert InvalidStrategy();
3043 
3044     PermissionData memory permission = PermissionData(target, bytes4(data), strategy);
3045     bytes32 permissionId = keccak256(abi.encode(permission));
3046 
3047     // Typically (such as in Governor contracts) this should check that the caller has permission
3048     // at `block.number|timestamp - 1` but here we're just checking if the caller *currently* has
3049     // permission. Technically this introduces a race condition if e.g. an action to revoke a role
3050     // from someone (or revoke a permission from a role) is ready to be executed at the same time as
3051     // an action is created, as the order of transactions in the block then affects if action
3052     // creation would succeed. However, we are ok with this tradeoff because it means we don't need
3053     // to checkpoint the `canCreateAction` mapping which is simpler and cheaper, and in practice
3054     // this race condition is unlikely to matter.
3055     if (!policy.hasPermissionId(policyholder, role, permissionId)) revert PolicyholderDoesNotHavePermission();
3056 
3057     // Validate action creation.
3058     actionId = actionsCount;
3059 
3060     ActionInfo memory actionInfo = ActionInfo(actionId, policyholder, role, strategy, target, value, data);
3061     strategy.validateActionCreation(actionInfo);
3062 
3063     // Scope to avoid stack too deep
3064     {
3065       ILlamaActionGuard guard = actionGuard[target][bytes4(data)];
3066       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);
3067 
3068       // Save action.
3069       Action storage newAction = actions[actionId];
3070       newAction.infoHash = _infoHash(actionId, policyholder, role, strategy, target, value, data);
3071       newAction.creationTime = LlamaUtils.toUint64(block.timestamp);
3072       newAction.isScript = authorizedScripts[target];
3073     }
3074 
3075     actionsCount = LlamaUtils.uncheckedIncrement(actionsCount); // Safety: Can never overflow a uint256 by incrementing.
3076 
3077     emit ActionCreated(actionId, policyholder, role, strategy, target, value, data, description);
3078   }
3079 
3080   /// @dev How policyholders that have the right role contribute towards the approval of an action with a reason.
3081   function _castApproval(address policyholder, uint8 role, ActionInfo calldata actionInfo, string memory reason)
3082     internal
3083   {
3084     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Active);
3085 
3086     action.totalApprovals = _newCastCount(action.totalApprovals, quantity);
3087     approvals[actionInfo.id][policyholder] = true;
3088     emit ApprovalCast(actionInfo.id, policyholder, role, quantity, reason);
3089   }
3090 
3091   /// @dev How policyholders that have the right role contribute towards the disapproval of an action with a reason.
3092   function _castDisapproval(address policyholder, uint8 role, ActionInfo calldata actionInfo, string memory reason)
3093     internal
3094   {
3095     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Queued);
3096 
3097     action.totalDisapprovals = _newCastCount(action.totalDisapprovals, quantity);
3098     disapprovals[actionInfo.id][policyholder] = true;
3099     emit DisapprovalCast(actionInfo.id, policyholder, role, quantity, reason);
3100   }
3101 
3102   /// @dev The only `expectedState` values allowed to be passed into this method are Active or Queued.
3103   function _preCastAssertions(
3104     ActionInfo calldata actionInfo,
3105     address policyholder,
3106     uint8 role,
3107     ActionState expectedState
3108   ) internal returns (Action storage action, uint128 quantity) {
3109     action = actions[actionInfo.id];
3110     ActionState currentState = getActionState(actionInfo);
3111     if (currentState != expectedState) revert InvalidActionState(currentState);
3112 
3113     bool isApproval = expectedState == ActionState.Active;
3114     bool alreadyCast = isApproval ? approvals[actionInfo.id][policyholder] : disapprovals[actionInfo.id][policyholder];
3115     if (alreadyCast) revert DuplicateCast();
3116 
3117     bool hasRole = policy.hasRole(policyholder, role, action.creationTime);
3118     if (!hasRole) revert InvalidPolicyholder();
3119 
3120     if (isApproval) {
3121       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);
3122       quantity = actionInfo.strategy.getApprovalQuantityAt(policyholder, role, action.creationTime);
3123       if (quantity == 0) revert CannotCastWithZeroQuantity(policyholder, role);
3124     } else {
3125       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);
3126       quantity = actionInfo.strategy.getDisapprovalQuantityAt(policyholder, role, action.creationTime);
3127       if (quantity == 0) revert CannotCastWithZeroQuantity(policyholder, role);
3128     }
3129   }
3130 
3131   /// @dev Returns the new total count of approvals or disapprovals.
3132   function _newCastCount(uint128 currentCount, uint128 quantity) internal pure returns (uint128) {
3133     if (currentCount == type(uint128).max || quantity == type(uint128).max) return type(uint128).max;
3134     return currentCount + quantity;
3135   }
3136 
3137   /// @dev Deploys new strategies. Takes in the strategy logic contract to be used and an array of configurations to
3138   /// initialize the new strategies with. Returns the address of the first strategy, which is only used during the
3139   /// `LlamaCore` initialization so that we can ensure someone (specifically, policyholders with role ID 1) has the
3140   /// permission to assign role permissions.
3141   function _deployStrategies(ILlamaStrategy llamaStrategyLogic, bytes[] calldata strategyConfigs)
3142     internal
3143     returns (ILlamaStrategy firstStrategy)
3144   {
3145     if (address(factory).code.length > 0 && !factory.authorizedStrategyLogics(llamaStrategyLogic)) {
3146       // The only edge case where this check is skipped is if `_deployStrategies()` is called by root llama instance
3147       // during Llama Factory construction. This is because there is no code at the Llama Factory address yet.
3148       revert UnauthorizedStrategyLogic();
3149     }
3150 
3151     uint256 strategyLength = strategyConfigs.length;
3152     for (uint256 i = 0; i < strategyLength; i = LlamaUtils.uncheckedIncrement(i)) {
3153       bytes32 salt = bytes32(keccak256(strategyConfigs[i]));
3154       ILlamaStrategy strategy = ILlamaStrategy(Clones.cloneDeterministic(address(llamaStrategyLogic), salt));
3155       strategy.initialize(strategyConfigs[i]);
3156       strategies[strategy] = true;
3157       emit StrategyCreated(strategy, llamaStrategyLogic, strategyConfigs[i]);
3158       if (i == 0) firstStrategy = strategy;
3159     }
3160   }
3161 
3162   /// @dev Deploys new accounts. Takes in the account logic contract to be used and an array of configurations to
3163   /// initialize the new accounts with.
3164   function _deployAccounts(ILlamaAccount llamaAccountLogic, bytes[] calldata accountConfigs) internal {
3165     if (address(factory).code.length > 0 && !factory.authorizedAccountLogics(llamaAccountLogic)) {
3166       // The only edge case where this check is skipped is if `_deployAccounts()` is called by root llama instance
3167       // during Llama Factory construction. This is because there is no code at the Llama Factory address yet.
3168       revert UnauthorizedAccountLogic();
3169     }
3170 
3171     uint256 accountLength = accountConfigs.length;
3172     for (uint256 i = 0; i < accountLength; i = LlamaUtils.uncheckedIncrement(i)) {
3173       bytes32 salt = bytes32(keccak256(accountConfigs[i]));
3174       ILlamaAccount account = ILlamaAccount(Clones.cloneDeterministic(address(llamaAccountLogic), salt));
3175       account.initialize(accountConfigs[i]);
3176       emit AccountCreated(account, llamaAccountLogic, accountConfigs[i]);
3177     }
3178   }
3179 
3180   /// @dev Returns the hash of the `createAction` parameters using the `actionInfo` struct.
3181   function _infoHash(ActionInfo calldata actionInfo) internal pure returns (bytes32) {
3182     return _infoHash(
3183       actionInfo.id,
3184       actionInfo.creator,
3185       actionInfo.creatorRole,
3186       actionInfo.strategy,
3187       actionInfo.target,
3188       actionInfo.value,
3189       actionInfo.data
3190     );
3191   }
3192 
3193   /// @dev Returns the hash of the `createAction` parameters.
3194   function _infoHash(
3195     uint256 id,
3196     address creator,
3197     uint8 creatorRole,
3198     ILlamaStrategy strategy,
3199     address target,
3200     uint256 value,
3201     bytes calldata data
3202   ) internal pure returns (bytes32) {
3203     return keccak256(abi.encodePacked(id, creator, creatorRole, strategy, target, value, data));
3204   }
3205 
3206   /// @dev Validates that the hash of the `actionInfo` struct matches the provided hash.
3207   function _validateActionInfoHash(bytes32 actualHash, ActionInfo calldata actionInfo) internal pure {
3208     bytes32 expectedHash = _infoHash(actionInfo);
3209     if (actualHash != expectedHash) revert InfoHashMismatch();
3210   }
3211 
3212   /// @dev Returns the current nonce for a given policyholder and selector, and increments it. Used to prevent
3213   /// replay attacks.
3214   function _useNonce(address policyholder, bytes4 selector) internal returns (uint256 nonce) {
3215     nonce = nonces[policyholder][selector];
3216     nonces[policyholder][selector] = LlamaUtils.uncheckedIncrement(nonce);
3217   }
3218 
3219   // -------- EIP-712 Getters --------
3220 
3221   /// @dev Returns the EIP-712 domain separator.
3222   function _getDomainHash() internal view returns (bytes32) {
3223     return keccak256(
3224       abi.encode(EIP712_DOMAIN_TYPEHASH, keccak256(bytes(name)), keccak256(bytes("1")), block.chainid, address(this))
3225     );
3226   }
3227 
3228   /// @dev Returns the hash of the ABI-encoded EIP-712 message for the `CreateAction` domain, which can be used to
3229   /// recover the signer.
3230   function _getCreateActionTypedDataHash(
3231     address policyholder,
3232     uint8 role,
3233     ILlamaStrategy strategy,
3234     address target,
3235     uint256 value,
3236     bytes calldata data,
3237     string memory description
3238   ) internal returns (bytes32) {
3239     // Calculating and storing nonce in memory and using that below, instead of calculating in place to prevent stack
3240     // too deep error.
3241     uint256 nonce = _useNonce(policyholder, msg.sig);
3242 
3243     bytes32 createActionHash = keccak256(
3244       abi.encode(
3245         CREATE_ACTION_TYPEHASH,
3246         policyholder,
3247         role,
3248         address(strategy),
3249         target,
3250         value,
3251         keccak256(data),
3252         keccak256(bytes(description)),
3253         nonce
3254       )
3255     );
3256 
3257     return keccak256(abi.encodePacked("\x19\x01", _getDomainHash(), createActionHash));
3258   }
3259 
3260   /// @dev Returns the hash of the ABI-encoded EIP-712 message for the `CastApproval` domain, which can be used to
3261   /// recover the signer.
3262   function _getCastApprovalTypedDataHash(
3263     address policyholder,
3264     uint8 role,
3265     ActionInfo calldata actionInfo,
3266     string calldata reason
3267   ) internal returns (bytes32) {
3268     bytes32 castApprovalHash = keccak256(
3269       abi.encode(
3270         CAST_APPROVAL_TYPEHASH,
3271         policyholder,
3272         role,
3273         _getActionInfoHash(actionInfo),
3274         keccak256(bytes(reason)),
3275         _useNonce(policyholder, msg.sig)
3276       )
3277     );
3278 
3279     return keccak256(abi.encodePacked("\x19\x01", _getDomainHash(), castApprovalHash));
3280   }
3281 
3282   /// @dev Returns the hash of the ABI-encoded EIP-712 message for the `CastDisapproval` domain, which can be used to
3283   /// recover the signer.
3284   function _getCastDisapprovalTypedDataHash(
3285     address policyholder,
3286     uint8 role,
3287     ActionInfo calldata actionInfo,
3288     string calldata reason
3289   ) internal returns (bytes32) {
3290     bytes32 castDisapprovalHash = keccak256(
3291       abi.encode(
3292         CAST_DISAPPROVAL_TYPEHASH,
3293         policyholder,
3294         role,
3295         _getActionInfoHash(actionInfo),
3296         keccak256(bytes(reason)),
3297         _useNonce(policyholder, msg.sig)
3298       )
3299     );
3300 
3301     return keccak256(abi.encodePacked("\x19\x01", _getDomainHash(), castDisapprovalHash));
3302   }
3303 
3304   /// @dev Returns the hash of `actionInfo`.
3305   function _getActionInfoHash(ActionInfo calldata actionInfo) internal pure returns (bytes32) {
3306     return keccak256(
3307       abi.encode(
3308         ACTION_INFO_TYPEHASH,
3309         actionInfo.id,
3310         actionInfo.creator,
3311         actionInfo.creatorRole,
3312         address(actionInfo.strategy),
3313         actionInfo.target,
3314         actionInfo.value,
3315         keccak256(actionInfo.data)
3316       )
3317     );
3318   }
3319 }



```

### LlamaRelativeQuorum.sol


```
Contract locking ether found:
	Contract LlamaCore (LlamaRelativeQuorum.sol#3361-4144) has payable functions:
	 - LlamaCore.executeAction(ActionInfo) (LlamaRelativeQuorum.sol#3658-3684)
	But does not have a function to withdraw the ether



    
3361 contract LlamaCore is Initializable {
3362   // ======================================
3363   // ======== Errors and Modifiers ========
3364   // ======================================
3365 
3366   /// @dev Policyholder cannot cast if it has 0 quantity of role.
3367   /// @param policyholder Address of policyholder.
3368   /// @param role The role being used in the cast.
3369   error CannotCastWithZeroQuantity(address policyholder, uint8 role);
3370 
3371   /// @dev An action's target contract cannot be the executor.
3372   error CannotSetExecutorAsTarget();
3373 
3374   /// @dev Address cannot be used.
3375   error RestrictedAddress();
3376 
3377   /// @dev Policyholders can only cast once.
3378   error DuplicateCast();
3379 
3380   /// @dev Action execution failed.
3381   /// @param reason Data returned by the function called by the action.
3382   error FailedActionExecution(bytes reason);
3383 
3384   /// @dev `ActionInfo` does not hash to the correct value.
3385   error InfoHashMismatch();
3386 
3387   /// @dev `msg.value` does not equal the action's value.
3388   error IncorrectMsgValue();
3389 
3390   /// @dev The action is not in the expected state.
3391   /// @param current The current state of the action.
3392   error InvalidActionState(ActionState current);
3393 
3394   /// @dev The policyholder does not have the role at action creation time.
3395   error InvalidPolicyholder();
3396 
3397   /// @dev The recovered signer does not match the expected policyholder.
3398   error InvalidSignature();
3399 
3400   /// @dev The provided address does not map to a deployed strategy.
3401   error InvalidStrategy();
3402 
3403   /// @dev An action cannot queue successfully if it's `minExecutionTime` is less than `block.timestamp`.
3404   error MinExecutionTimeCannotBeInThePast();
3405 
3406   /// @dev Only callable by a Llama instance's executor.
3407   error OnlyLlama();
3408 
3409   /// @dev Policyholder does not have the permission ID to create the action.
3410   error PolicyholderDoesNotHavePermission();
3411 
3412   /// @dev If `block.timestamp` is less than `minExecutionTime`, the action cannot be executed.
3413   error MinExecutionTimeNotReached();
3414 
3415   /// @dev Strategies can only be created with valid logic contracts.
3416   error UnauthorizedStrategyLogic();
3417 
3418   /// @dev Accounts can only be created with valid logic contracts.
3419   error UnauthorizedAccountLogic();
3420 
3421   /// @dev Checks that the caller is the Llama Executor and reverts if not.
3422   modifier onlyLlama() {
3423     if (msg.sender != address(executor)) revert OnlyLlama();
3424     _;
3425   }
3426 
3427   // ========================
3428   // ======== Events ========
3429   // ========================
3430 
3431   /// @dev Emitted when an action is created.
3432   event ActionCreated(
3433     uint256 id,
3434     address indexed creator,
3435     uint8 role,
3436     ILlamaStrategy indexed strategy,
3437     address indexed target,
3438     uint256 value,
3439     bytes data,
3440     string description
3441   );
3442 
3443   /// @dev Emitted when an action is canceled.
3444   event ActionCanceled(uint256 id);
3445 
3446   /// @dev Emitted when an action guard is set.
3447   event ActionGuardSet(address indexed target, bytes4 indexed selector, ILlamaActionGuard actionGuard);
3448 
3449   /// @dev Emitted when an action is queued.
3450   event ActionQueued(
3451     uint256 id,
3452     address indexed caller,
3453     ILlamaStrategy indexed strategy,
3454     address indexed creator,
3455     uint256 minExecutionTime
3456   );
3457 
3458   /// @dev Emitted when an action is executed.
3459   event ActionExecuted(
3460     uint256 id, address indexed caller, ILlamaStrategy indexed strategy, address indexed creator, bytes result
3461   );
3462 
3463   /// @dev Emitted when an approval is cast.
3464   event ApprovalCast(uint256 id, address indexed policyholder, uint8 indexed role, uint256 quantity, string reason);
3465 
3466   /// @dev Emitted when a disapproval is cast.
3467   event DisapprovalCast(uint256 id, address indexed policyholder, uint8 indexed role, uint256 quantity, string reason);
3468 
3469   /// @dev Emitted when a strategy is created and authorized.
3470   event StrategyCreated(ILlamaStrategy strategy, ILlamaStrategy indexed strategyLogic, bytes initializationData);
3471 
3472   /// @dev Emitted when an account is created.
3473   event AccountCreated(ILlamaAccount account, ILlamaAccount indexed accountLogic, bytes initializationData);
3474 
3475   /// @dev Emitted when a script is authorized.
3476   event ScriptAuthorized(address script, bool authorized);
3477 
3478   // =================================================
3479   // ======== Constants and Storage Variables ========
3480   // =================================================
3481 
3482   /// @dev EIP-712 base typehash.
3483   bytes32 internal constant EIP712_DOMAIN_TYPEHASH =
3484     keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");
3485 
3486   /// @dev EIP-712 createAction typehash.
3487   bytes32 internal constant CREATE_ACTION_TYPEHASH = keccak256(
3488     "CreateAction(address policyholder,uint8 role,address strategy,address target,uint256 value,bytes data,string description,uint256 nonce)"
3489   );
3490 
3491   /// @dev EIP-712 castApproval typehash.
3492   bytes32 internal constant CAST_APPROVAL_TYPEHASH = keccak256(
3493     "CastApproval(address policyholder,uint8 role,ActionInfo actionInfo,string reason,uint256 nonce)ActionInfo(uint256 id,address creator,uint8 creatorRole,address strategy,address target,uint256 value,bytes data)"
3494   );
3495 
3496   /// @dev EIP-712 castDisapproval typehash.
3497   bytes32 internal constant CAST_DISAPPROVAL_TYPEHASH = keccak256(
3498     "CastDisapproval(address policyholder,uint8 role,ActionInfo actionInfo,string reason,uint256 nonce)ActionInfo(uint256 id,address creator,uint8 creatorRole,address strategy,address target,uint256 value,bytes data)"
3499   );
3500 
3501   /// @dev EIP-712 actionInfo typehash.
3502   bytes32 internal constant ACTION_INFO_TYPEHASH = keccak256(
3503     "ActionInfo(uint256 id,address creator,uint8 creatorRole,address strategy,address target,uint256 value,bytes data)"
3504   );
3505 
3506   /// @dev Mapping of actionIds to Actions.
3507   /// @dev Making this `public` results in stack too deep with no optimizer, but this data can be
3508   /// accessed with the `getAction` function so this is ok. We want the contracts to compile
3509   /// without the optimizer so `forge coverage` can be used.
3510   mapping(uint256 => Action) internal actions;
3511 
3512   /// @notice The contract that executes actions for this Llama instance.
3513   LlamaExecutor public executor;
3514 
3515   /// @notice The ERC721 contract that defines the policies for this Llama instance.
3516   /// @dev We intentionally put this first so it's packed with the `Initializable` storage
3517   // variables, which are the key variables we want to check before and after a delegatecall.
3518   LlamaPolicy public policy;
3519 
3520   /// @notice The `LlamaFactory` contract that deployed this Llama instance.
3521   LlamaFactory public factory;
3522 
3523   /// @notice Name of this Llama instance.
3524   string public name;
3525 
3526   /// @notice The current number of actions created.
3527   uint256 public actionsCount;
3528 
3529   /// @notice Mapping of actionIds to policyholders to approvals.
3530   mapping(uint256 => mapping(address => bool)) public approvals;
3531 
3532   /// @notice Mapping of actionIds to policyholders to disapprovals.
3533   mapping(uint256 => mapping(address => bool)) public disapprovals;
3534 
3535   /// @notice Mapping of all authorized strategies.
3536   mapping(ILlamaStrategy => bool) public strategies;
3537 
3538   /// @notice Mapping of all authorized scripts.
3539   mapping(address => bool) public authorizedScripts;
3540 
3541   /// @notice Mapping of policyholders to function selectors to current nonces for EIP-712 signatures.
3542   /// @dev This is used to prevent replay attacks by incrementing the nonce for each operation (`createAction`,
3543   /// `castApproval` and `castDisapproval`) signed by the policyholder.
3544   mapping(address => mapping(bytes4 => uint256)) public nonces;
3545 
3546   /// @notice Mapping of target to selector to actionGuard address.
3547   mapping(address target => mapping(bytes4 selector => ILlamaActionGuard)) public actionGuard;
3548 
3549   // ======================================================
3550   // ======== Contract Creation and Initialization ========
3551   // ======================================================
3552 
3553   constructor() {
3554     _disableInitializers();
3555   }
3556 
3557   /// @notice Initializes a new `LlamaCore` clone.
3558   /// @param _name The name of the `LlamaCore` clone.
3559   /// @param _policy This Llama instance's policy contract.
3560   /// @param _llamaStrategyLogic The Llama Strategy implementation (logic) contract.
3561   /// @param _llamaAccountLogic The Llama Account implementation (logic) contract.
3562   /// @param initialStrategies Array of initial strategy configurations.
3563   /// @param initialAccounts Array of initial account configurations.
3564   /// @return bootstrapPermissionId The permission ID that's used to set role permissions.
3565   function initialize(
3566     string memory _name,
3567     LlamaPolicy _policy,
3568     ILlamaStrategy _llamaStrategyLogic,
3569     ILlamaAccount _llamaAccountLogic,
3570     bytes[] calldata initialStrategies,
3571     bytes[] calldata initialAccounts
3572   ) external initializer returns (bytes32 bootstrapPermissionId) {
3573     factory = LlamaFactory(msg.sender);
3574     name = _name;
3575     executor = new LlamaExecutor();
3576     policy = _policy;
3577 
3578     ILlamaStrategy bootstrapStrategy = _deployStrategies(_llamaStrategyLogic, initialStrategies);
3579     _deployAccounts(_llamaAccountLogic, initialAccounts);
3580 
3581     // Now we compute the permission ID used to set role permissions and return it.
3582     bytes4 selector = LlamaPolicy.setRolePermission.selector;
3583     return keccak256(abi.encode(PermissionData(address(policy), bytes4(selector), bootstrapStrategy)));
3584   }
3585 
3586   // ===========================================
3587   // ======== External and Public Logic ========
3588   // ===========================================
3589 
3590   /// @notice Creates an action. The creator needs to hold a policy with the permission ID of the provided
3591   /// `(target, selector, strategy)`.
3592   /// @dev Use `""` for `description` if there is no description.
3593   /// @param role The role that will be used to determine the permission ID of the policyholder.
3594   /// @param strategy The strategy contract that will determine how the action is executed.
3595   /// @param target The contract called when the action is executed.
3596   /// @param value The value in wei to be sent when the action is executed.
3597   /// @param data Data to be called on the target when the action is executed.
3598   /// @param description A human readable description of the action and the changes it will enact.
3599   /// @return actionId Action ID of the newly created action.
3600   function createAction(
3601     uint8 role,
3602     ILlamaStrategy strategy,
3603     address target,
3604     uint256 value,
3605     bytes calldata data,
3606     string memory description
3607   ) external returns (uint256 actionId) {
3608     actionId = _createAction(msg.sender, role, strategy, target, value, data, description);
3609   }
3610 
3611   /// @notice Creates an action via an off-chain signature. The creator needs to hold a policy with the permission ID
3612   /// of the provided `(target, selector, strategy)`.
3613   /// @dev Use `""` for `description` if there is no description.
3614   /// @param policyholder The policyholder that signed the message.
3615   /// @param role The role that will be used to determine the permission ID of the policyholder.
3616   /// @param strategy The strategy contract that will determine how the action is executed.
3617   /// @param target The contract called when the action is executed.
3618   /// @param value The value in wei to be sent when the action is executed.
3619   /// @param data Data to be called on the target when the action is executed.
3620   /// @param description A human readable description of the action and the changes it will enact.
3621   /// @param v ECDSA signature component: Parity of the `y` coordinate of point `R`
3622   /// @param r ECDSA signature component: x-coordinate of `R`
3623   /// @param s ECDSA signature component: `s` value of the signature
3624   /// @return actionId Action ID of the newly created action.
3625   function createActionBySig(
3626     address policyholder,
3627     uint8 role,
3628     ILlamaStrategy strategy,
3629     address target,
3630     uint256 value,
3631     bytes calldata data,
3632     string memory description,
3633     uint8 v,
3634     bytes32 r,
3635     bytes32 s
3636   ) external returns (uint256 actionId) {
3637     bytes32 digest = _getCreateActionTypedDataHash(policyholder, role, strategy, target, value, data, description);
3638     address signer = ecrecover(digest, v, r, s);
3639     if (signer == address(0) || signer != policyholder) revert InvalidSignature();
3640     actionId = _createAction(signer, role, strategy, target, value, data, description);
3641   }
3642 
3643   /// @notice Queue an action by its `actionInfo` struct if it's in Approved state.
3644   /// @param actionInfo Data required to create an action.
3645   function queueAction(ActionInfo calldata actionInfo) external {
3646     Action storage action = actions[actionInfo.id];
3647     ActionState currentState = getActionState(actionInfo);
3648     if (currentState != ActionState.Approved) revert InvalidActionState(currentState);
3649 
3650     uint64 minExecutionTime = actionInfo.strategy.minExecutionTime(actionInfo);
3651     if (minExecutionTime < block.timestamp) revert MinExecutionTimeCannotBeInThePast();
3652     action.minExecutionTime = minExecutionTime;
3653     emit ActionQueued(actionInfo.id, msg.sender, actionInfo.strategy, actionInfo.creator, minExecutionTime);
3654   }
3655 
3656   /// @notice Execute an action by its `actionInfo` struct if it's in Queued state and `minExecutionTime` has passed.
3657   /// @param actionInfo Data required to create an action.
3658   function executeAction(ActionInfo calldata actionInfo) external payable {
3659     // Initial checks that action is ready to execute.
3660     Action storage action = actions[actionInfo.id];
3661     ActionState currentState = getActionState(actionInfo);
3662 
3663     if (currentState != ActionState.Queued) revert InvalidActionState(currentState);
3664     if (block.timestamp < action.minExecutionTime) revert MinExecutionTimeNotReached();
3665     if (msg.value != actionInfo.value) revert IncorrectMsgValue();
3666 
3667     action.executed = true;
3668 
3669     // Check pre-execution action guard.
3670     ILlamaActionGuard guard = actionGuard[actionInfo.target][bytes4(actionInfo.data)];
3671     if (guard != ILlamaActionGuard(address(0))) guard.validatePreActionExecution(actionInfo);
3672 
3673     // Execute action.
3674     (bool success, bytes memory result) =
3675       executor.execute(actionInfo.target, actionInfo.value, action.isScript, actionInfo.data);
3676 
3677     if (!success) revert FailedActionExecution(result);
3678 
3679     // Check post-execution action guard.
3680     if (guard != ILlamaActionGuard(address(0))) guard.validatePostActionExecution(actionInfo);
3681 
3682     // Action successfully executed.
3683     emit ActionExecuted(actionInfo.id, msg.sender, actionInfo.strategy, actionInfo.creator, result);
3684   }
3685 
3686   /// @notice Cancels an action by its `actionInfo` struct.
3687   /// @dev Rules for cancelation are defined by the strategy.
3688   /// @param actionInfo Data required to create an action.
3689   function cancelAction(ActionInfo calldata actionInfo) external {
3690     Action storage action = actions[actionInfo.id];
3691     _validateActionInfoHash(action.infoHash, actionInfo);
3692 
3693     // We don't need an explicit check on action existence because if it doesn't exist the strategy will be the zero
3694     // address, and Solidity will revert since there is no code at the zero address.
3695     actionInfo.strategy.validateActionCancelation(actionInfo, msg.sender);
3696 
3697     action.canceled = true;
3698     emit ActionCanceled(actionInfo.id);
3699   }
3700 
3701   /// @notice How policyholders add their support of the approval of an action with a reason.
3702   /// @dev Use `""` for `reason` if there is no reason.
3703   /// @param role The role the policyholder uses to cast their approval.
3704   /// @param actionInfo Data required to create an action.
3705   /// @param reason The reason given for the approval by the policyholder.
3706   function castApproval(uint8 role, ActionInfo calldata actionInfo, string calldata reason) external {
3707     return _castApproval(msg.sender, role, actionInfo, reason);
3708   }
3709 
3710   /// @notice How policyholders add their support of the approval of an action via an off-chain signature.
3711   /// @dev Use `""` for `reason` if there is no reason.
3712   /// @param policyholder The policyholder that signed the message.
3713   /// @param role The role the policyholder uses to cast their approval.
3714   /// @param actionInfo Data required to create an action.
3715   /// @param reason The reason given for the approval by the policyholder.
3716   /// @param v ECDSA signature component: Parity of the `y` coordinate of point `R`
3717   /// @param r ECDSA signature component: x-coordinate of `R`
3718   /// @param s ECDSA signature component: `s` value of the signature
3719   function castApprovalBySig(
3720     address policyholder,
3721     uint8 role,
3722     ActionInfo calldata actionInfo,
3723     string calldata reason,
3724     uint8 v,
3725     bytes32 r,
3726     bytes32 s
3727   ) external {
3728     bytes32 digest = _getCastApprovalTypedDataHash(policyholder, role, actionInfo, reason);
3729     address signer = ecrecover(digest, v, r, s);
3730     if (signer == address(0) || signer != policyholder) revert InvalidSignature();
3731     return _castApproval(signer, role, actionInfo, reason);
3732   }
3733 
3734   /// @notice How policyholders add their support of the disapproval of an action with a reason.
3735   /// @dev Use `""` for `reason` if there is no reason.
3736   /// @param role The role the policyholder uses to cast their disapproval.
3737   /// @param actionInfo Data required to create an action.
3738   /// @param reason The reason given for the disapproval by the policyholder.
3739   function castDisapproval(uint8 role, ActionInfo calldata actionInfo, string calldata reason) external {
3740     return _castDisapproval(msg.sender, role, actionInfo, reason);
3741   }
3742 
3743   /// @notice How policyholders add their support of the disapproval of an action via an off-chain signature.
3744   /// @dev Use `""` for `reason` if there is no reason.
3745   /// @param policyholder The policyholder that signed the message.
3746   /// @param role The role the policyholder uses to cast their disapproval.
3747   /// @param actionInfo Data required to create an action.
3748   /// @param reason The reason given for the approval by the policyholder.
3749   /// @param v ECDSA signature component: Parity of the `y` coordinate of point `R`
3750   /// @param r ECDSA signature component: x-coordinate of `R`
3751   /// @param s ECDSA signature component: `s` value of the signature
3752   function castDisapprovalBySig(
3753     address policyholder,
3754     uint8 role,
3755     ActionInfo calldata actionInfo,
3756     string calldata reason,
3757     uint8 v,
3758     bytes32 r,
3759     bytes32 s
3760   ) external {
3761     bytes32 digest = _getCastDisapprovalTypedDataHash(policyholder, role, actionInfo, reason);
3762     address signer = ecrecover(digest, v, r, s);
3763     if (signer == address(0) || signer != policyholder) revert InvalidSignature();
3764     return _castDisapproval(signer, role, actionInfo, reason);
3765   }
3766 
3767   /// @notice Deploy new strategies and add them to the mapping of authorized strategies.
3768   /// @param llamaStrategyLogic address of the Llama strategy logic contract.
3769   /// @param strategyConfigs Array of new strategy configurations.
3770   function createStrategies(ILlamaStrategy llamaStrategyLogic, bytes[] calldata strategyConfigs) external onlyLlama {
3771     _deployStrategies(llamaStrategyLogic, strategyConfigs);
3772   }
3773 
3774   /// @notice Deploy new accounts.
3775   /// @param llamaAccountLogic address of the Llama account logic contract.
3776   /// @param accountConfigs Array of new account configurations.
3777   function createAccounts(ILlamaAccount llamaAccountLogic, bytes[] calldata accountConfigs) external onlyLlama {
3778     _deployAccounts(llamaAccountLogic, accountConfigs);
3779   }
3780 
3781   /// @notice Sets `guard` as the action guard for the given `target` and `selector`.
3782   /// @param target The target contract where the `guard` will apply.
3783   /// @param selector The function selector where the `guard` will apply.
3784   /// @dev To remove a guard, set `guard` to the zero address.
3785   function setGuard(address target, bytes4 selector, ILlamaActionGuard guard) external onlyLlama {
3786     if (target == address(this) || target == address(policy)) revert RestrictedAddress();
3787     actionGuard[target][selector] = guard;
3788     emit ActionGuardSet(target, selector, guard);
3789   }
3790 
3791   /// @notice Authorizes `script` to be eligible to be delegatecalled from the executor.
3792   /// @param script The address of the script contract.
3793   /// @param authorized The boolean that determines if the `script` is being authorized or unauthorized.
3794   /// @dev To remove a `script`, set `authorized` to `false`.
3795   function authorizeScript(address script, bool authorized) external onlyLlama {
3796     if (script == address(this) || script == address(policy)) revert RestrictedAddress();
3797     authorizedScripts[script] = authorized;
3798     emit ScriptAuthorized(script, authorized);
3799   }
3800 
3801   /// @notice Increments the caller's nonce for the given `selector`. This is useful for revoking
3802   /// signatures that have not been used yet.
3803   /// @param selector The function selector to increment the nonce for.
3804   function incrementNonce(bytes4 selector) external {
3805     // Safety: Can never overflow a uint256 by incrementing.
3806     nonces[msg.sender][selector] = LlamaUtils.uncheckedIncrement(nonces[msg.sender][selector]);
3807   }
3808 
3809   /// @notice Get an Action struct by `actionId`.
3810   /// @param actionId ID of the action.
3811   /// @return The Action struct.
3812   function getAction(uint256 actionId) external view returns (Action memory) {
3813     return actions[actionId];
3814   }
3815 
3816   /// @notice Returns the timestamp of most recently created action.
3817   /// @dev Used by `LlamaPolicy` to ensure policy management does not occur immediately after action
3818   /// creation in the same timestamp, as this could result in invalid role supply counts being used.
3819   function getLastActionTimestamp() external view returns (uint256 timestamp) {
3820     return actionsCount == 0 ? 0 : actions[actionsCount - 1].creationTime;
3821   }
3822 
3823   /// @notice Get the current action state of an action by its `actionInfo` struct.
3824   /// @param actionInfo Data required to create an action.
3825   /// @return The current action state of the action.
3826   function getActionState(ActionInfo calldata actionInfo) public view returns (ActionState) {
3827     // We don't need an explicit check on the action ID to make sure it exists, because if the
3828     // action does not exist, the expected payload hash from storage will be `bytes32(0)`, so
3829     // bypassing this check by providing a non-existent actionId would require finding a collision
3830     // to get a hash of zero.
3831     Action storage action = actions[actionInfo.id];
3832     _validateActionInfoHash(action.infoHash, actionInfo);
3833 
3834     if (action.canceled) return ActionState.Canceled;
3835 
3836     if (action.executed) return ActionState.Executed;
3837 
3838     if (actionInfo.strategy.isActive(actionInfo)) return ActionState.Active;
3839 
3840     if (!actionInfo.strategy.isActionApproved(actionInfo)) return ActionState.Failed;
3841 
3842     if (action.minExecutionTime == 0) return ActionState.Approved;
3843 
3844     if (actionInfo.strategy.isActionDisapproved(actionInfo)) return ActionState.Failed;
3845 
3846     if (actionInfo.strategy.isActionExpired(actionInfo)) return ActionState.Expired;
3847 
3848     return ActionState.Queued;
3849   }
3850 
3851   // ================================
3852   // ======== Internal Logic ========
3853   // ================================
3854 
3855   /// @dev Creates an action. The creator needs to hold a policy with the permission ID of the provided
3856   /// `(target, selector, strategy)`.
3857   function _createAction(
3858     address policyholder,
3859     uint8 role,
3860     ILlamaStrategy strategy,
3861     address target,
3862     uint256 value,
3863     bytes calldata data,
3864     string memory description
3865   ) internal returns (uint256 actionId) {
3866     if (target == address(executor)) revert CannotSetExecutorAsTarget();
3867     if (!strategies[strategy]) revert InvalidStrategy();
3868 
3869     PermissionData memory permission = PermissionData(target, bytes4(data), strategy);
3870     bytes32 permissionId = keccak256(abi.encode(permission));
3871 
3872     // Typically (such as in Governor contracts) this should check that the caller has permission
3873     // at `block.number|timestamp - 1` but here we're just checking if the caller *currently* has
3874     // permission. Technically this introduces a race condition if e.g. an action to revoke a role
3875     // from someone (or revoke a permission from a role) is ready to be executed at the same time as
3876     // an action is created, as the order of transactions in the block then affects if action
3877     // creation would succeed. However, we are ok with this tradeoff because it means we don't need
3878     // to checkpoint the `canCreateAction` mapping which is simpler and cheaper, and in practice
3879     // this race condition is unlikely to matter.
3880     if (!policy.hasPermissionId(policyholder, role, permissionId)) revert PolicyholderDoesNotHavePermission();
3881 
3882     // Validate action creation.
3883     actionId = actionsCount;
3884 
3885     ActionInfo memory actionInfo = ActionInfo(actionId, policyholder, role, strategy, target, value, data);
3886     strategy.validateActionCreation(actionInfo);
3887 
3888     // Scope to avoid stack too deep
3889     {
3890       ILlamaActionGuard guard = actionGuard[target][bytes4(data)];
3891       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);
3892 
3893       // Save action.
3894       Action storage newAction = actions[actionId];
3895       newAction.infoHash = _infoHash(actionId, policyholder, role, strategy, target, value, data);
3896       newAction.creationTime = LlamaUtils.toUint64(block.timestamp);
3897       newAction.isScript = authorizedScripts[target];
3898     }
3899 
3900     actionsCount = LlamaUtils.uncheckedIncrement(actionsCount); // Safety: Can never overflow a uint256 by incrementing.
3901 
3902     emit ActionCreated(actionId, policyholder, role, strategy, target, value, data, description);
3903   }
3904 
3905   /// @dev How policyholders that have the right role contribute towards the approval of an action with a reason.
3906   function _castApproval(address policyholder, uint8 role, ActionInfo calldata actionInfo, string memory reason)
3907     internal
3908   {
3909     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Active);
3910 
3911     action.totalApprovals = _newCastCount(action.totalApprovals, quantity);
3912     approvals[actionInfo.id][policyholder] = true;
3913     emit ApprovalCast(actionInfo.id, policyholder, role, quantity, reason);
3914   }
3915 
3916   /// @dev How policyholders that have the right role contribute towards the disapproval of an action with a reason.
3917   function _castDisapproval(address policyholder, uint8 role, ActionInfo calldata actionInfo, string memory reason)
3918     internal
3919   {
3920     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Queued);
3921 
3922     action.totalDisapprovals = _newCastCount(action.totalDisapprovals, quantity);
3923     disapprovals[actionInfo.id][policyholder] = true;
3924     emit DisapprovalCast(actionInfo.id, policyholder, role, quantity, reason);
3925   }
3926 
3927   /// @dev The only `expectedState` values allowed to be passed into this method are Active or Queued.
3928   function _preCastAssertions(
3929     ActionInfo calldata actionInfo,
3930     address policyholder,
3931     uint8 role,
3932     ActionState expectedState
3933   ) internal returns (Action storage action, uint128 quantity) {
3934     action = actions[actionInfo.id];
3935     ActionState currentState = getActionState(actionInfo);
3936     if (currentState != expectedState) revert InvalidActionState(currentState);
3937 
3938     bool isApproval = expectedState == ActionState.Active;
3939     bool alreadyCast = isApproval ? approvals[actionInfo.id][policyholder] : disapprovals[actionInfo.id][policyholder];
3940     if (alreadyCast) revert DuplicateCast();
3941 
3942     bool hasRole = policy.hasRole(policyholder, role, action.creationTime);
3943     if (!hasRole) revert InvalidPolicyholder();
3944 
3945     if (isApproval) {
3946       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);
3947       quantity = actionInfo.strategy.getApprovalQuantityAt(policyholder, role, action.creationTime);
3948       if (quantity == 0) revert CannotCastWithZeroQuantity(policyholder, role);
3949     } else {
3950       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);
3951       quantity = actionInfo.strategy.getDisapprovalQuantityAt(policyholder, role, action.creationTime);
3952       if (quantity == 0) revert CannotCastWithZeroQuantity(policyholder, role);
3953     }
3954   }
3955 
3956   /// @dev Returns the new total count of approvals or disapprovals.
3957   function _newCastCount(uint128 currentCount, uint128 quantity) internal pure returns (uint128) {
3958     if (currentCount == type(uint128).max || quantity == type(uint128).max) return type(uint128).max;
3959     return currentCount + quantity;
3960   }
3961 
3962   /// @dev Deploys new strategies. Takes in the strategy logic contract to be used and an array of configurations to
3963   /// initialize the new strategies with. Returns the address of the first strategy, which is only used during the
3964   /// `LlamaCore` initialization so that we can ensure someone (specifically, policyholders with role ID 1) has the
3965   /// permission to assign role permissions.
3966   function _deployStrategies(ILlamaStrategy llamaStrategyLogic, bytes[] calldata strategyConfigs)
3967     internal
3968     returns (ILlamaStrategy firstStrategy)
3969   {
3970     if (address(factory).code.length > 0 && !factory.authorizedStrategyLogics(llamaStrategyLogic)) {
3971       // The only edge case where this check is skipped is if `_deployStrategies()` is called by root llama instance
3972       // during Llama Factory construction. This is because there is no code at the Llama Factory address yet.
3973       revert UnauthorizedStrategyLogic();
3974     }
3975 
3976     uint256 strategyLength = strategyConfigs.length;
3977     for (uint256 i = 0; i < strategyLength; i = LlamaUtils.uncheckedIncrement(i)) {
3978       bytes32 salt = bytes32(keccak256(strategyConfigs[i]));
3979       ILlamaStrategy strategy = ILlamaStrategy(Clones.cloneDeterministic(address(llamaStrategyLogic), salt));
3980       strategy.initialize(strategyConfigs[i]);
3981       strategies[strategy] = true;
3982       emit StrategyCreated(strategy, llamaStrategyLogic, strategyConfigs[i]);
3983       if (i == 0) firstStrategy = strategy;
3984     }
3985   }
3986 
3987   /// @dev Deploys new accounts. Takes in the account logic contract to be used and an array of configurations to
3988   /// initialize the new accounts with.
3989   function _deployAccounts(ILlamaAccount llamaAccountLogic, bytes[] calldata accountConfigs) internal {
3990     if (address(factory).code.length > 0 && !factory.authorizedAccountLogics(llamaAccountLogic)) {
3991       // The only edge case where this check is skipped is if `_deployAccounts()` is called by root llama instance
3992       // during Llama Factory construction. This is because there is no code at the Llama Factory address yet.
3993       revert UnauthorizedAccountLogic();
3994     }
3995 
3996     uint256 accountLength = accountConfigs.length;
3997     for (uint256 i = 0; i < accountLength; i = LlamaUtils.uncheckedIncrement(i)) {
3998       bytes32 salt = bytes32(keccak256(accountConfigs[i]));
3999       ILlamaAccount account = ILlamaAccount(Clones.cloneDeterministic(address(llamaAccountLogic), salt));
4000       account.initialize(accountConfigs[i]);
4001       emit AccountCreated(account, llamaAccountLogic, accountConfigs[i]);
4002     }
4003   }
4004 
4005   /// @dev Returns the hash of the `createAction` parameters using the `actionInfo` struct.
4006   function _infoHash(ActionInfo calldata actionInfo) internal pure returns (bytes32) {
4007     return _infoHash(
4008       actionInfo.id,
4009       actionInfo.creator,
4010       actionInfo.creatorRole,
4011       actionInfo.strategy,
4012       actionInfo.target,
4013       actionInfo.value,
4014       actionInfo.data
4015     );
4016   }
4017 
4018   /// @dev Returns the hash of the `createAction` parameters.
4019   function _infoHash(
4020     uint256 id,
4021     address creator,
4022     uint8 creatorRole,
4023     ILlamaStrategy strategy,
4024     address target,
4025     uint256 value,
4026     bytes calldata data
4027   ) internal pure returns (bytes32) {
4028     return keccak256(abi.encodePacked(id, creator, creatorRole, strategy, target, value, data));
4029   }
4030 
4031   /// @dev Validates that the hash of the `actionInfo` struct matches the provided hash.
4032   function _validateActionInfoHash(bytes32 actualHash, ActionInfo calldata actionInfo) internal pure {
4033     bytes32 expectedHash = _infoHash(actionInfo);
4034     if (actualHash != expectedHash) revert InfoHashMismatch();
4035   }
4036 
4037   /// @dev Returns the current nonce for a given policyholder and selector, and increments it. Used to prevent
4038   /// replay attacks.
4039   function _useNonce(address policyholder, bytes4 selector) internal returns (uint256 nonce) {
4040     nonce = nonces[policyholder][selector];
4041     nonces[policyholder][selector] = LlamaUtils.uncheckedIncrement(nonce);
4042   }
4043 
4044   // -------- EIP-712 Getters --------
4045 
4046   /// @dev Returns the EIP-712 domain separator.
4047   function _getDomainHash() internal view returns (bytes32) {
4048     return keccak256(
4049       abi.encode(EIP712_DOMAIN_TYPEHASH, keccak256(bytes(name)), keccak256(bytes("1")), block.chainid, address(this))
4050     );
4051   }
4052 
4053   /// @dev Returns the hash of the ABI-encoded EIP-712 message for the `CreateAction` domain, which can be used to
4054   /// recover the signer.
4055   function _getCreateActionTypedDataHash(
4056     address policyholder,
4057     uint8 role,
4058     ILlamaStrategy strategy,
4059     address target,
4060     uint256 value,
4061     bytes calldata data,
4062     string memory description
4063   ) internal returns (bytes32) {
4064     // Calculating and storing nonce in memory and using that below, instead of calculating in place to prevent stack
4065     // too deep error.
4066     uint256 nonce = _useNonce(policyholder, msg.sig);
4067 
4068     bytes32 createActionHash = keccak256(
4069       abi.encode(
4070         CREATE_ACTION_TYPEHASH,
4071         policyholder,
4072         role,
4073         address(strategy),
4074         target,
4075         value,
4076         keccak256(data),
4077         keccak256(bytes(description)),
4078         nonce
4079       )
4080     );
4081 
4082     return keccak256(abi.encodePacked("\x19\x01", _getDomainHash(), createActionHash));
4083   }
4084 
4085   /// @dev Returns the hash of the ABI-encoded EIP-712 message for the `CastApproval` domain, which can be used to
4086   /// recover the signer.
4087   function _getCastApprovalTypedDataHash(
4088     address policyholder,
4089     uint8 role,
4090     ActionInfo calldata actionInfo,
4091     string calldata reason
4092   ) internal returns (bytes32) {
4093     bytes32 castApprovalHash = keccak256(
4094       abi.encode(
4095         CAST_APPROVAL_TYPEHASH,
4096         policyholder,
4097         role,
4098         _getActionInfoHash(actionInfo),
4099         keccak256(bytes(reason)),
4100         _useNonce(policyholder, msg.sig)
4101       )
4102     );
4103 
4104     return keccak256(abi.encodePacked("\x19\x01", _getDomainHash(), castApprovalHash));
4105   }
4106 
4107   /// @dev Returns the hash of the ABI-encoded EIP-712 message for the `CastDisapproval` domain, which can be used to
4108   /// recover the signer.
4109   function _getCastDisapprovalTypedDataHash(
4110     address policyholder,
4111     uint8 role,
4112     ActionInfo calldata actionInfo,
4113     string calldata reason
4114   ) internal returns (bytes32) {
4115     bytes32 castDisapprovalHash = keccak256(
4116       abi.encode(
4117         CAST_DISAPPROVAL_TYPEHASH,
4118         policyholder,
4119         role,
4120         _getActionInfoHash(actionInfo),
4121         keccak256(bytes(reason)),
4122         _useNonce(policyholder, msg.sig)
4123       )
4124     );
4125 
4126     return keccak256(abi.encodePacked("\x19\x01", _getDomainHash(), castDisapprovalHash));
4127   }
4128 
4129   /// @dev Returns the hash of `actionInfo`.
4130   function _getActionInfoHash(ActionInfo calldata actionInfo) internal pure returns (bytes32) {
4131     return keccak256(
4132       abi.encode(
4133         ACTION_INFO_TYPEHASH,
4134         actionInfo.id,
4135         actionInfo.creator,
4136         actionInfo.creatorRole,
4137         address(actionInfo.strategy),
4138         actionInfo.target,
4139         actionInfo.value,
4140         keccak256(actionInfo.data)
4141       )
4142     );
4143   }
4144 }



```

## reentrancy-no-eth
### Severity: Medium

### LlamaAbsolutePeerReview.sol


```
Reentrancy in LlamaCore._castDisapproval(address,uint8,ActionInfo,string) (LlamaAbsolutePeerReview.sol#3917-3925):
	External calls:
	- (action,quantity) = _preCastAssertions(actionInfo,policyholder,role,ActionState.Queued) (LlamaAbsolutePeerReview.sol#3920)
		- actionInfo.strategy.isApprovalEnabled(actionInfo,policyholder,role) (LlamaAbsolutePeerReview.sol#3946)
		- actionInfo.strategy.isDisapprovalEnabled(actionInfo,policyholder,role) (LlamaAbsolutePeerReview.sol#3950)
	State variables written after the call(s):
	- disapprovals[actionInfo.id][policyholder] = true (LlamaAbsolutePeerReview.sol#3923)
	LlamaCore.disapprovals (LlamaAbsolutePeerReview.sol#3533) can be used in cross function reentrancies:
	- LlamaCore._castDisapproval(address,uint8,ActionInfo,string) (LlamaAbsolutePeerReview.sol#3917-3925)
	- LlamaCore._preCastAssertions(ActionInfo,address,uint8,ActionState) (LlamaAbsolutePeerReview.sol#3928-3954)
	- LlamaCore.disapprovals (LlamaAbsolutePeerReview.sol#3533)



    
3920     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Queued);



    
3946       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);



    
3950       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);



    
3923     disapprovals[actionInfo.id][policyholder] = true;



```

```
Reentrancy in LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaAbsolutePeerReview.sol#3857-3903):
	External calls:
	- strategy.validateActionCreation(actionInfo) (LlamaAbsolutePeerReview.sol#3886)
	- guard.validateActionCreation(actionInfo) (LlamaAbsolutePeerReview.sol#3891)
	State variables written after the call(s):
	- actionsCount = LlamaUtils.uncheckedIncrement(actionsCount) (LlamaAbsolutePeerReview.sol#3900)
	LlamaCore.actionsCount (LlamaAbsolutePeerReview.sol#3527) can be used in cross function reentrancies:
	- LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaAbsolutePeerReview.sol#3857-3903)
	- LlamaCore.actionsCount (LlamaAbsolutePeerReview.sol#3527)
	- LlamaCore.getLastActionTimestamp() (LlamaAbsolutePeerReview.sol#3819-3821)



    
3886     strategy.validateActionCreation(actionInfo);



    
3891       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);



    
3900     actionsCount = LlamaUtils.uncheckedIncrement(actionsCount); // Safety: Can never overflow a uint256 by incrementing.



```

```
Reentrancy in LlamaCore._castApproval(address,uint8,ActionInfo,string) (LlamaAbsolutePeerReview.sol#3906-3914):
	External calls:
	- (action,quantity) = _preCastAssertions(actionInfo,policyholder,role,ActionState.Active) (LlamaAbsolutePeerReview.sol#3909)
		- actionInfo.strategy.isApprovalEnabled(actionInfo,policyholder,role) (LlamaAbsolutePeerReview.sol#3946)
		- actionInfo.strategy.isDisapprovalEnabled(actionInfo,policyholder,role) (LlamaAbsolutePeerReview.sol#3950)
	State variables written after the call(s):
	- approvals[actionInfo.id][policyholder] = true (LlamaAbsolutePeerReview.sol#3912)
	LlamaCore.approvals (LlamaAbsolutePeerReview.sol#3530) can be used in cross function reentrancies:
	- LlamaCore._castApproval(address,uint8,ActionInfo,string) (LlamaAbsolutePeerReview.sol#3906-3914)
	- LlamaCore._preCastAssertions(ActionInfo,address,uint8,ActionState) (LlamaAbsolutePeerReview.sol#3928-3954)
	- LlamaCore.approvals (LlamaAbsolutePeerReview.sol#3530)



    
3909     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Active);



    
3946       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);



    
3950       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);



    
3912     approvals[actionInfo.id][policyholder] = true;



```

```
Reentrancy in LlamaCore.cancelAction(ActionInfo) (LlamaAbsolutePeerReview.sol#3689-3699):
	External calls:
	- actionInfo.strategy.validateActionCancelation(actionInfo,msg.sender) (LlamaAbsolutePeerReview.sol#3695)
	State variables written after the call(s):
	- action.canceled = true (LlamaAbsolutePeerReview.sol#3697)
	LlamaCore.actions (LlamaAbsolutePeerReview.sol#3510) can be used in cross function reentrancies:
	- LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaAbsolutePeerReview.sol#3857-3903)
	- LlamaCore._preCastAssertions(ActionInfo,address,uint8,ActionState) (LlamaAbsolutePeerReview.sol#3928-3954)
	- LlamaCore.cancelAction(ActionInfo) (LlamaAbsolutePeerReview.sol#3689-3699)
	- LlamaCore.executeAction(ActionInfo) (LlamaAbsolutePeerReview.sol#3658-3684)
	- LlamaCore.getAction(uint256) (LlamaAbsolutePeerReview.sol#3812-3814)
	- LlamaCore.getActionState(ActionInfo) (LlamaAbsolutePeerReview.sol#3826-3849)
	- LlamaCore.getLastActionTimestamp() (LlamaAbsolutePeerReview.sol#3819-3821)
	- LlamaCore.queueAction(ActionInfo) (LlamaAbsolutePeerReview.sol#3645-3654)



    
3695     actionInfo.strategy.validateActionCancelation(actionInfo, msg.sender);



    
3697     action.canceled = true;



```

### LlamaAbsoluteQuorum.sol


```
Reentrancy in LlamaCore._castDisapproval(address,uint8,ActionInfo,string) (LlamaAbsoluteQuorum.sol#3917-3925):
	External calls:
	- (action,quantity) = _preCastAssertions(actionInfo,policyholder,role,ActionState.Queued) (LlamaAbsoluteQuorum.sol#3920)
		- actionInfo.strategy.isApprovalEnabled(actionInfo,policyholder,role) (LlamaAbsoluteQuorum.sol#3946)
		- actionInfo.strategy.isDisapprovalEnabled(actionInfo,policyholder,role) (LlamaAbsoluteQuorum.sol#3950)
	State variables written after the call(s):
	- disapprovals[actionInfo.id][policyholder] = true (LlamaAbsoluteQuorum.sol#3923)
	LlamaCore.disapprovals (LlamaAbsoluteQuorum.sol#3533) can be used in cross function reentrancies:
	- LlamaCore._castDisapproval(address,uint8,ActionInfo,string) (LlamaAbsoluteQuorum.sol#3917-3925)
	- LlamaCore._preCastAssertions(ActionInfo,address,uint8,ActionState) (LlamaAbsoluteQuorum.sol#3928-3954)
	- LlamaCore.disapprovals (LlamaAbsoluteQuorum.sol#3533)



    
3920     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Queued);



    
3946       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);



    
3950       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);



    
3923     disapprovals[actionInfo.id][policyholder] = true;



```

```
Reentrancy in LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaAbsoluteQuorum.sol#3857-3903):
	External calls:
	- strategy.validateActionCreation(actionInfo) (LlamaAbsoluteQuorum.sol#3886)
	- guard.validateActionCreation(actionInfo) (LlamaAbsoluteQuorum.sol#3891)
	State variables written after the call(s):
	- actionsCount = LlamaUtils.uncheckedIncrement(actionsCount) (LlamaAbsoluteQuorum.sol#3900)
	LlamaCore.actionsCount (LlamaAbsoluteQuorum.sol#3527) can be used in cross function reentrancies:
	- LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaAbsoluteQuorum.sol#3857-3903)
	- LlamaCore.actionsCount (LlamaAbsoluteQuorum.sol#3527)
	- LlamaCore.getLastActionTimestamp() (LlamaAbsoluteQuorum.sol#3819-3821)



    
3886     strategy.validateActionCreation(actionInfo);



    
3891       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);



    
3900     actionsCount = LlamaUtils.uncheckedIncrement(actionsCount); // Safety: Can never overflow a uint256 by incrementing.



```

```
Reentrancy in LlamaCore._castApproval(address,uint8,ActionInfo,string) (LlamaAbsoluteQuorum.sol#3906-3914):
	External calls:
	- (action,quantity) = _preCastAssertions(actionInfo,policyholder,role,ActionState.Active) (LlamaAbsoluteQuorum.sol#3909)
		- actionInfo.strategy.isApprovalEnabled(actionInfo,policyholder,role) (LlamaAbsoluteQuorum.sol#3946)
		- actionInfo.strategy.isDisapprovalEnabled(actionInfo,policyholder,role) (LlamaAbsoluteQuorum.sol#3950)
	State variables written after the call(s):
	- approvals[actionInfo.id][policyholder] = true (LlamaAbsoluteQuorum.sol#3912)
	LlamaCore.approvals (LlamaAbsoluteQuorum.sol#3530) can be used in cross function reentrancies:
	- LlamaCore._castApproval(address,uint8,ActionInfo,string) (LlamaAbsoluteQuorum.sol#3906-3914)
	- LlamaCore._preCastAssertions(ActionInfo,address,uint8,ActionState) (LlamaAbsoluteQuorum.sol#3928-3954)
	- LlamaCore.approvals (LlamaAbsoluteQuorum.sol#3530)



    
3909     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Active);



    
3946       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);



    
3950       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);



    
3912     approvals[actionInfo.id][policyholder] = true;



```

```
Reentrancy in LlamaCore.cancelAction(ActionInfo) (LlamaAbsoluteQuorum.sol#3689-3699):
	External calls:
	- actionInfo.strategy.validateActionCancelation(actionInfo,msg.sender) (LlamaAbsoluteQuorum.sol#3695)
	State variables written after the call(s):
	- action.canceled = true (LlamaAbsoluteQuorum.sol#3697)
	LlamaCore.actions (LlamaAbsoluteQuorum.sol#3510) can be used in cross function reentrancies:
	- LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaAbsoluteQuorum.sol#3857-3903)
	- LlamaCore._preCastAssertions(ActionInfo,address,uint8,ActionState) (LlamaAbsoluteQuorum.sol#3928-3954)
	- LlamaCore.cancelAction(ActionInfo) (LlamaAbsoluteQuorum.sol#3689-3699)
	- LlamaCore.executeAction(ActionInfo) (LlamaAbsoluteQuorum.sol#3658-3684)
	- LlamaCore.getAction(uint256) (LlamaAbsoluteQuorum.sol#3812-3814)
	- LlamaCore.getActionState(ActionInfo) (LlamaAbsoluteQuorum.sol#3826-3849)
	- LlamaCore.getLastActionTimestamp() (LlamaAbsoluteQuorum.sol#3819-3821)
	- LlamaCore.queueAction(ActionInfo) (LlamaAbsoluteQuorum.sol#3645-3654)



    
3695     actionInfo.strategy.validateActionCancelation(actionInfo, msg.sender);



    
3697     action.canceled = true;



```

### LlamaAccount.sol


```
Reentrancy in LlamaCore._castApproval(address,uint8,ActionInfo,string) (LlamaAccount.sol#4693-4701):
	External calls:
	- (action,quantity) = _preCastAssertions(actionInfo,policyholder,role,ActionState.Active) (LlamaAccount.sol#4696)
		- actionInfo.strategy.isApprovalEnabled(actionInfo,policyholder,role) (LlamaAccount.sol#4733)
		- actionInfo.strategy.isDisapprovalEnabled(actionInfo,policyholder,role) (LlamaAccount.sol#4737)
	State variables written after the call(s):
	- approvals[actionInfo.id][policyholder] = true (LlamaAccount.sol#4699)
	LlamaCore.approvals (LlamaAccount.sol#4317) can be used in cross function reentrancies:
	- LlamaCore._castApproval(address,uint8,ActionInfo,string) (LlamaAccount.sol#4693-4701)
	- LlamaCore._preCastAssertions(ActionInfo,address,uint8,ActionState) (LlamaAccount.sol#4715-4741)
	- LlamaCore.approvals (LlamaAccount.sol#4317)



    
4696     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Active);



    
4733       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);



    
4737       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);



    
4699     approvals[actionInfo.id][policyholder] = true;



```

```
Reentrancy in LlamaCore._castDisapproval(address,uint8,ActionInfo,string) (LlamaAccount.sol#4704-4712):
	External calls:
	- (action,quantity) = _preCastAssertions(actionInfo,policyholder,role,ActionState.Queued) (LlamaAccount.sol#4707)
		- actionInfo.strategy.isApprovalEnabled(actionInfo,policyholder,role) (LlamaAccount.sol#4733)
		- actionInfo.strategy.isDisapprovalEnabled(actionInfo,policyholder,role) (LlamaAccount.sol#4737)
	State variables written after the call(s):
	- disapprovals[actionInfo.id][policyholder] = true (LlamaAccount.sol#4710)
	LlamaCore.disapprovals (LlamaAccount.sol#4320) can be used in cross function reentrancies:
	- LlamaCore._castDisapproval(address,uint8,ActionInfo,string) (LlamaAccount.sol#4704-4712)
	- LlamaCore._preCastAssertions(ActionInfo,address,uint8,ActionState) (LlamaAccount.sol#4715-4741)
	- LlamaCore.disapprovals (LlamaAccount.sol#4320)



    
4707     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Queued);



    
4733       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);



    
4737       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);



    
4710     disapprovals[actionInfo.id][policyholder] = true;



```

```
Reentrancy in LlamaCore.cancelAction(ActionInfo) (LlamaAccount.sol#4476-4486):
	External calls:
	- actionInfo.strategy.validateActionCancelation(actionInfo,msg.sender) (LlamaAccount.sol#4482)
	State variables written after the call(s):
	- action.canceled = true (LlamaAccount.sol#4484)
	LlamaCore.actions (LlamaAccount.sol#4297) can be used in cross function reentrancies:
	- LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaAccount.sol#4644-4690)
	- LlamaCore._preCastAssertions(ActionInfo,address,uint8,ActionState) (LlamaAccount.sol#4715-4741)
	- LlamaCore.cancelAction(ActionInfo) (LlamaAccount.sol#4476-4486)
	- LlamaCore.executeAction(ActionInfo) (LlamaAccount.sol#4445-4471)
	- LlamaCore.getAction(uint256) (LlamaAccount.sol#4599-4601)
	- LlamaCore.getActionState(ActionInfo) (LlamaAccount.sol#4613-4636)
	- LlamaCore.getLastActionTimestamp() (LlamaAccount.sol#4606-4608)
	- LlamaCore.queueAction(ActionInfo) (LlamaAccount.sol#4432-4441)



    
4482     actionInfo.strategy.validateActionCancelation(actionInfo, msg.sender);



    
4484     action.canceled = true;



```

```
Reentrancy in LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaAccount.sol#4644-4690):
	External calls:
	- strategy.validateActionCreation(actionInfo) (LlamaAccount.sol#4673)
	- guard.validateActionCreation(actionInfo) (LlamaAccount.sol#4678)
	State variables written after the call(s):
	- actionsCount = LlamaUtils.uncheckedIncrement(actionsCount) (LlamaAccount.sol#4687)
	LlamaCore.actionsCount (LlamaAccount.sol#4314) can be used in cross function reentrancies:
	- LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaAccount.sol#4644-4690)
	- LlamaCore.actionsCount (LlamaAccount.sol#4314)
	- LlamaCore.getLastActionTimestamp() (LlamaAccount.sol#4606-4608)



    
4673     strategy.validateActionCreation(actionInfo);



    
4678       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);



    
4687     actionsCount = LlamaUtils.uncheckedIncrement(actionsCount); // Safety: Can never overflow a uint256 by incrementing.



```

### LlamaCore.sol


```
Reentrancy in LlamaCore._castApproval(address,uint8,ActionInfo,string) (LlamaCore.sol#3755-3763):
	External calls:
	- (action,quantity) = _preCastAssertions(actionInfo,policyholder,role,ActionState.Active) (LlamaCore.sol#3758)
		- actionInfo.strategy.isApprovalEnabled(actionInfo,policyholder,role) (LlamaCore.sol#3795)
		- actionInfo.strategy.isDisapprovalEnabled(actionInfo,policyholder,role) (LlamaCore.sol#3799)
	State variables written after the call(s):
	- approvals[actionInfo.id][policyholder] = true (LlamaCore.sol#3761)
	LlamaCore.approvals (LlamaCore.sol#3379) can be used in cross function reentrancies:
	- LlamaCore._castApproval(address,uint8,ActionInfo,string) (LlamaCore.sol#3755-3763)
	- LlamaCore._preCastAssertions(ActionInfo,address,uint8,ActionState) (LlamaCore.sol#3777-3803)
	- LlamaCore.approvals (LlamaCore.sol#3379)



    
3758     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Active);



    
3795       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);



    
3799       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);



    
3761     approvals[actionInfo.id][policyholder] = true;



```

```
Reentrancy in LlamaCore._castDisapproval(address,uint8,ActionInfo,string) (LlamaCore.sol#3766-3774):
	External calls:
	- (action,quantity) = _preCastAssertions(actionInfo,policyholder,role,ActionState.Queued) (LlamaCore.sol#3769)
		- actionInfo.strategy.isApprovalEnabled(actionInfo,policyholder,role) (LlamaCore.sol#3795)
		- actionInfo.strategy.isDisapprovalEnabled(actionInfo,policyholder,role) (LlamaCore.sol#3799)
	State variables written after the call(s):
	- disapprovals[actionInfo.id][policyholder] = true (LlamaCore.sol#3772)
	LlamaCore.disapprovals (LlamaCore.sol#3382) can be used in cross function reentrancies:
	- LlamaCore._castDisapproval(address,uint8,ActionInfo,string) (LlamaCore.sol#3766-3774)
	- LlamaCore._preCastAssertions(ActionInfo,address,uint8,ActionState) (LlamaCore.sol#3777-3803)
	- LlamaCore.disapprovals (LlamaCore.sol#3382)



    
3769     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Queued);



    
3795       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);



    
3799       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);



    
3772     disapprovals[actionInfo.id][policyholder] = true;



```

```
Reentrancy in LlamaCore.cancelAction(ActionInfo) (LlamaCore.sol#3538-3548):
	External calls:
	- actionInfo.strategy.validateActionCancelation(actionInfo,msg.sender) (LlamaCore.sol#3544)
	State variables written after the call(s):
	- action.canceled = true (LlamaCore.sol#3546)
	LlamaCore.actions (LlamaCore.sol#3359) can be used in cross function reentrancies:
	- LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaCore.sol#3706-3752)
	- LlamaCore._preCastAssertions(ActionInfo,address,uint8,ActionState) (LlamaCore.sol#3777-3803)
	- LlamaCore.cancelAction(ActionInfo) (LlamaCore.sol#3538-3548)
	- LlamaCore.executeAction(ActionInfo) (LlamaCore.sol#3507-3533)
	- LlamaCore.getAction(uint256) (LlamaCore.sol#3661-3663)
	- LlamaCore.getActionState(ActionInfo) (LlamaCore.sol#3675-3698)
	- LlamaCore.getLastActionTimestamp() (LlamaCore.sol#3668-3670)
	- LlamaCore.queueAction(ActionInfo) (LlamaCore.sol#3494-3503)



    
3544     actionInfo.strategy.validateActionCancelation(actionInfo, msg.sender);



    
3546     action.canceled = true;



```

```
Reentrancy in LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaCore.sol#3706-3752):
	External calls:
	- strategy.validateActionCreation(actionInfo) (LlamaCore.sol#3735)
	- guard.validateActionCreation(actionInfo) (LlamaCore.sol#3740)
	State variables written after the call(s):
	- actionsCount = LlamaUtils.uncheckedIncrement(actionsCount) (LlamaCore.sol#3749)
	LlamaCore.actionsCount (LlamaCore.sol#3376) can be used in cross function reentrancies:
	- LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaCore.sol#3706-3752)
	- LlamaCore.actionsCount (LlamaCore.sol#3376)
	- LlamaCore.getLastActionTimestamp() (LlamaCore.sol#3668-3670)



    
3735     strategy.validateActionCreation(actionInfo);



    
3740       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);



    
3749     actionsCount = LlamaUtils.uncheckedIncrement(actionsCount); // Safety: Can never overflow a uint256 by incrementing.



```

### LlamaFactory.sol


```
Reentrancy in LlamaCore.cancelAction(ActionInfo) (LlamaFactory.sol#2875-2885):
	External calls:
	- actionInfo.strategy.validateActionCancelation(actionInfo,msg.sender) (LlamaFactory.sol#2881)
	State variables written after the call(s):
	- action.canceled = true (LlamaFactory.sol#2883)
	LlamaCore.actions (LlamaFactory.sol#2696) can be used in cross function reentrancies:
	- LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaFactory.sol#3043-3089)
	- LlamaCore._preCastAssertions(ActionInfo,address,uint8,ActionState) (LlamaFactory.sol#3114-3140)
	- LlamaCore.cancelAction(ActionInfo) (LlamaFactory.sol#2875-2885)
	- LlamaCore.executeAction(ActionInfo) (LlamaFactory.sol#2844-2870)
	- LlamaCore.getAction(uint256) (LlamaFactory.sol#2998-3000)
	- LlamaCore.getActionState(ActionInfo) (LlamaFactory.sol#3012-3035)
	- LlamaCore.getLastActionTimestamp() (LlamaFactory.sol#3005-3007)
	- LlamaCore.queueAction(ActionInfo) (LlamaFactory.sol#2831-2840)



    
2881     actionInfo.strategy.validateActionCancelation(actionInfo, msg.sender);



    
2883     action.canceled = true;



```

```
Reentrancy in LlamaCore._castApproval(address,uint8,ActionInfo,string) (LlamaFactory.sol#3092-3100):
	External calls:
	- (action,quantity) = _preCastAssertions(actionInfo,policyholder,role,ActionState.Active) (LlamaFactory.sol#3095)
		- actionInfo.strategy.isApprovalEnabled(actionInfo,policyholder,role) (LlamaFactory.sol#3132)
		- actionInfo.strategy.isDisapprovalEnabled(actionInfo,policyholder,role) (LlamaFactory.sol#3136)
	State variables written after the call(s):
	- approvals[actionInfo.id][policyholder] = true (LlamaFactory.sol#3098)
	LlamaCore.approvals (LlamaFactory.sol#2716) can be used in cross function reentrancies:
	- LlamaCore._castApproval(address,uint8,ActionInfo,string) (LlamaFactory.sol#3092-3100)
	- LlamaCore._preCastAssertions(ActionInfo,address,uint8,ActionState) (LlamaFactory.sol#3114-3140)
	- LlamaCore.approvals (LlamaFactory.sol#2716)



    
3095     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Active);



    
3132       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);



    
3136       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);



    
3098     approvals[actionInfo.id][policyholder] = true;



```

```
Reentrancy in LlamaCore._castDisapproval(address,uint8,ActionInfo,string) (LlamaFactory.sol#3103-3111):
	External calls:
	- (action,quantity) = _preCastAssertions(actionInfo,policyholder,role,ActionState.Queued) (LlamaFactory.sol#3106)
		- actionInfo.strategy.isApprovalEnabled(actionInfo,policyholder,role) (LlamaFactory.sol#3132)
		- actionInfo.strategy.isDisapprovalEnabled(actionInfo,policyholder,role) (LlamaFactory.sol#3136)
	State variables written after the call(s):
	- disapprovals[actionInfo.id][policyholder] = true (LlamaFactory.sol#3109)
	LlamaCore.disapprovals (LlamaFactory.sol#2719) can be used in cross function reentrancies:
	- LlamaCore._castDisapproval(address,uint8,ActionInfo,string) (LlamaFactory.sol#3103-3111)
	- LlamaCore._preCastAssertions(ActionInfo,address,uint8,ActionState) (LlamaFactory.sol#3114-3140)
	- LlamaCore.disapprovals (LlamaFactory.sol#2719)



    
3106     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Queued);



    
3132       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);



    
3136       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);



    
3109     disapprovals[actionInfo.id][policyholder] = true;



```

```
Reentrancy in LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaFactory.sol#3043-3089):
	External calls:
	- strategy.validateActionCreation(actionInfo) (LlamaFactory.sol#3072)
	- guard.validateActionCreation(actionInfo) (LlamaFactory.sol#3077)
	State variables written after the call(s):
	- actionsCount = LlamaUtils.uncheckedIncrement(actionsCount) (LlamaFactory.sol#3086)
	LlamaCore.actionsCount (LlamaFactory.sol#2713) can be used in cross function reentrancies:
	- LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaFactory.sol#3043-3089)
	- LlamaCore.actionsCount (LlamaFactory.sol#2713)
	- LlamaCore.getLastActionTimestamp() (LlamaFactory.sol#3005-3007)



    
3072     strategy.validateActionCreation(actionInfo);



    
3077       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);



    
3086     actionsCount = LlamaUtils.uncheckedIncrement(actionsCount); // Safety: Can never overflow a uint256 by incrementing.



```

### LlamaGovernanceScript.sol


```
Reentrancy in LlamaCore._castApproval(address,uint8,ActionInfo,string) (LlamaGovernanceScript.sol#3674-3682):
	External calls:
	- (action,quantity) = _preCastAssertions(actionInfo,policyholder,role,ActionState.Active) (LlamaGovernanceScript.sol#3677)
		- actionInfo.strategy.isApprovalEnabled(actionInfo,policyholder,role) (LlamaGovernanceScript.sol#3714)
		- actionInfo.strategy.isDisapprovalEnabled(actionInfo,policyholder,role) (LlamaGovernanceScript.sol#3718)
	State variables written after the call(s):
	- approvals[actionInfo.id][policyholder] = true (LlamaGovernanceScript.sol#3680)
	LlamaCore.approvals (LlamaGovernanceScript.sol#3298) can be used in cross function reentrancies:
	- LlamaCore._castApproval(address,uint8,ActionInfo,string) (LlamaGovernanceScript.sol#3674-3682)
	- LlamaCore._preCastAssertions(ActionInfo,address,uint8,ActionState) (LlamaGovernanceScript.sol#3696-3722)
	- LlamaCore.approvals (LlamaGovernanceScript.sol#3298)



    
3677     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Active);



    
3714       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);



    
3718       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);



    
3680     approvals[actionInfo.id][policyholder] = true;



```

```
Reentrancy in LlamaCore._castDisapproval(address,uint8,ActionInfo,string) (LlamaGovernanceScript.sol#3685-3693):
	External calls:
	- (action,quantity) = _preCastAssertions(actionInfo,policyholder,role,ActionState.Queued) (LlamaGovernanceScript.sol#3688)
		- actionInfo.strategy.isApprovalEnabled(actionInfo,policyholder,role) (LlamaGovernanceScript.sol#3714)
		- actionInfo.strategy.isDisapprovalEnabled(actionInfo,policyholder,role) (LlamaGovernanceScript.sol#3718)
	State variables written after the call(s):
	- disapprovals[actionInfo.id][policyholder] = true (LlamaGovernanceScript.sol#3691)
	LlamaCore.disapprovals (LlamaGovernanceScript.sol#3301) can be used in cross function reentrancies:
	- LlamaCore._castDisapproval(address,uint8,ActionInfo,string) (LlamaGovernanceScript.sol#3685-3693)
	- LlamaCore._preCastAssertions(ActionInfo,address,uint8,ActionState) (LlamaGovernanceScript.sol#3696-3722)
	- LlamaCore.disapprovals (LlamaGovernanceScript.sol#3301)



    
3688     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Queued);



    
3714       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);



    
3718       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);



    
3691     disapprovals[actionInfo.id][policyholder] = true;



```

```
Reentrancy in LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaGovernanceScript.sol#3625-3671):
	External calls:
	- strategy.validateActionCreation(actionInfo) (LlamaGovernanceScript.sol#3654)
	- guard.validateActionCreation(actionInfo) (LlamaGovernanceScript.sol#3659)
	State variables written after the call(s):
	- actionsCount = LlamaUtils.uncheckedIncrement(actionsCount) (LlamaGovernanceScript.sol#3668)
	LlamaCore.actionsCount (LlamaGovernanceScript.sol#3295) can be used in cross function reentrancies:
	- LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaGovernanceScript.sol#3625-3671)
	- LlamaCore.actionsCount (LlamaGovernanceScript.sol#3295)
	- LlamaCore.getLastActionTimestamp() (LlamaGovernanceScript.sol#3587-3589)



    
3654     strategy.validateActionCreation(actionInfo);



    
3659       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);



    
3668     actionsCount = LlamaUtils.uncheckedIncrement(actionsCount); // Safety: Can never overflow a uint256 by incrementing.



```

```
Reentrancy in LlamaCore.cancelAction(ActionInfo) (LlamaGovernanceScript.sol#3457-3467):
	External calls:
	- actionInfo.strategy.validateActionCancelation(actionInfo,msg.sender) (LlamaGovernanceScript.sol#3463)
	State variables written after the call(s):
	- action.canceled = true (LlamaGovernanceScript.sol#3465)
	LlamaCore.actions (LlamaGovernanceScript.sol#3278) can be used in cross function reentrancies:
	- LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaGovernanceScript.sol#3625-3671)
	- LlamaCore._preCastAssertions(ActionInfo,address,uint8,ActionState) (LlamaGovernanceScript.sol#3696-3722)
	- LlamaCore.cancelAction(ActionInfo) (LlamaGovernanceScript.sol#3457-3467)
	- LlamaCore.executeAction(ActionInfo) (LlamaGovernanceScript.sol#3426-3452)
	- LlamaCore.getAction(uint256) (LlamaGovernanceScript.sol#3580-3582)
	- LlamaCore.getActionState(ActionInfo) (LlamaGovernanceScript.sol#3594-3617)
	- LlamaCore.getLastActionTimestamp() (LlamaGovernanceScript.sol#3587-3589)
	- LlamaCore.queueAction(ActionInfo) (LlamaGovernanceScript.sol#3413-3422)



    
3463     actionInfo.strategy.validateActionCancelation(actionInfo, msg.sender);



    
3465     action.canceled = true;



```

### LlamaPolicy.sol


```
Reentrancy in LlamaCore.cancelAction(ActionInfo) (LlamaPolicy.sol#2864-2874):
	External calls:
	- actionInfo.strategy.validateActionCancelation(actionInfo,msg.sender) (LlamaPolicy.sol#2870)
	State variables written after the call(s):
	- action.canceled = true (LlamaPolicy.sol#2872)
	LlamaCore.actions (LlamaPolicy.sol#2685) can be used in cross function reentrancies:
	- LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaPolicy.sol#3032-3078)
	- LlamaCore._preCastAssertions(ActionInfo,address,uint8,ActionState) (LlamaPolicy.sol#3103-3129)
	- LlamaCore.cancelAction(ActionInfo) (LlamaPolicy.sol#2864-2874)
	- LlamaCore.executeAction(ActionInfo) (LlamaPolicy.sol#2833-2859)
	- LlamaCore.getAction(uint256) (LlamaPolicy.sol#2987-2989)
	- LlamaCore.getActionState(ActionInfo) (LlamaPolicy.sol#3001-3024)
	- LlamaCore.getLastActionTimestamp() (LlamaPolicy.sol#2994-2996)
	- LlamaCore.queueAction(ActionInfo) (LlamaPolicy.sol#2820-2829)



    
2870     actionInfo.strategy.validateActionCancelation(actionInfo, msg.sender);



    
2872     action.canceled = true;



```

```
Reentrancy in LlamaCore._castDisapproval(address,uint8,ActionInfo,string) (LlamaPolicy.sol#3092-3100):
	External calls:
	- (action,quantity) = _preCastAssertions(actionInfo,policyholder,role,ActionState.Queued) (LlamaPolicy.sol#3095)
		- actionInfo.strategy.isApprovalEnabled(actionInfo,policyholder,role) (LlamaPolicy.sol#3121)
		- actionInfo.strategy.isDisapprovalEnabled(actionInfo,policyholder,role) (LlamaPolicy.sol#3125)
	State variables written after the call(s):
	- disapprovals[actionInfo.id][policyholder] = true (LlamaPolicy.sol#3098)
	LlamaCore.disapprovals (LlamaPolicy.sol#2708) can be used in cross function reentrancies:
	- LlamaCore._castDisapproval(address,uint8,ActionInfo,string) (LlamaPolicy.sol#3092-3100)
	- LlamaCore._preCastAssertions(ActionInfo,address,uint8,ActionState) (LlamaPolicy.sol#3103-3129)
	- LlamaCore.disapprovals (LlamaPolicy.sol#2708)



    
3095     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Queued);



    
3121       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);



    
3125       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);



    
3098     disapprovals[actionInfo.id][policyholder] = true;



```

```
Reentrancy in LlamaCore._castApproval(address,uint8,ActionInfo,string) (LlamaPolicy.sol#3081-3089):
	External calls:
	- (action,quantity) = _preCastAssertions(actionInfo,policyholder,role,ActionState.Active) (LlamaPolicy.sol#3084)
		- actionInfo.strategy.isApprovalEnabled(actionInfo,policyholder,role) (LlamaPolicy.sol#3121)
		- actionInfo.strategy.isDisapprovalEnabled(actionInfo,policyholder,role) (LlamaPolicy.sol#3125)
	State variables written after the call(s):
	- approvals[actionInfo.id][policyholder] = true (LlamaPolicy.sol#3087)
	LlamaCore.approvals (LlamaPolicy.sol#2705) can be used in cross function reentrancies:
	- LlamaCore._castApproval(address,uint8,ActionInfo,string) (LlamaPolicy.sol#3081-3089)
	- LlamaCore._preCastAssertions(ActionInfo,address,uint8,ActionState) (LlamaPolicy.sol#3103-3129)
	- LlamaCore.approvals (LlamaPolicy.sol#2705)



    
3084     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Active);



    
3121       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);



    
3125       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);



    
3087     approvals[actionInfo.id][policyholder] = true;



```

```
Reentrancy in LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaPolicy.sol#3032-3078):
	External calls:
	- strategy.validateActionCreation(actionInfo) (LlamaPolicy.sol#3061)
	- guard.validateActionCreation(actionInfo) (LlamaPolicy.sol#3066)
	State variables written after the call(s):
	- actionsCount = LlamaUtils.uncheckedIncrement(actionsCount) (LlamaPolicy.sol#3075)
	LlamaCore.actionsCount (LlamaPolicy.sol#2702) can be used in cross function reentrancies:
	- LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaPolicy.sol#3032-3078)
	- LlamaCore.actionsCount (LlamaPolicy.sol#2702)
	- LlamaCore.getLastActionTimestamp() (LlamaPolicy.sol#2994-2996)



    
3061     strategy.validateActionCreation(actionInfo);



    
3066       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);



    
3075     actionsCount = LlamaUtils.uncheckedIncrement(actionsCount); // Safety: Can never overflow a uint256 by incrementing.



```

### LlamaRelativeQuorum.sol


```
Reentrancy in LlamaCore._castDisapproval(address,uint8,ActionInfo,string) (LlamaRelativeQuorum.sol#3917-3925):
	External calls:
	- (action,quantity) = _preCastAssertions(actionInfo,policyholder,role,ActionState.Queued) (LlamaRelativeQuorum.sol#3920)
		- actionInfo.strategy.isApprovalEnabled(actionInfo,policyholder,role) (LlamaRelativeQuorum.sol#3946)
		- actionInfo.strategy.isDisapprovalEnabled(actionInfo,policyholder,role) (LlamaRelativeQuorum.sol#3950)
	State variables written after the call(s):
	- disapprovals[actionInfo.id][policyholder] = true (LlamaRelativeQuorum.sol#3923)
	LlamaCore.disapprovals (LlamaRelativeQuorum.sol#3533) can be used in cross function reentrancies:
	- LlamaCore._castDisapproval(address,uint8,ActionInfo,string) (LlamaRelativeQuorum.sol#3917-3925)
	- LlamaCore._preCastAssertions(ActionInfo,address,uint8,ActionState) (LlamaRelativeQuorum.sol#3928-3954)
	- LlamaCore.disapprovals (LlamaRelativeQuorum.sol#3533)



    
3920     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Queued);



    
3946       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);



    
3950       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);



    
3923     disapprovals[actionInfo.id][policyholder] = true;



```

```
Reentrancy in LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaRelativeQuorum.sol#3857-3903):
	External calls:
	- strategy.validateActionCreation(actionInfo) (LlamaRelativeQuorum.sol#3886)
	- guard.validateActionCreation(actionInfo) (LlamaRelativeQuorum.sol#3891)
	State variables written after the call(s):
	- actionsCount = LlamaUtils.uncheckedIncrement(actionsCount) (LlamaRelativeQuorum.sol#3900)
	LlamaCore.actionsCount (LlamaRelativeQuorum.sol#3527) can be used in cross function reentrancies:
	- LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaRelativeQuorum.sol#3857-3903)
	- LlamaCore.actionsCount (LlamaRelativeQuorum.sol#3527)
	- LlamaCore.getLastActionTimestamp() (LlamaRelativeQuorum.sol#3819-3821)



    
3886     strategy.validateActionCreation(actionInfo);



    
3891       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);



    
3900     actionsCount = LlamaUtils.uncheckedIncrement(actionsCount); // Safety: Can never overflow a uint256 by incrementing.



```

```
Reentrancy in LlamaCore._castApproval(address,uint8,ActionInfo,string) (LlamaRelativeQuorum.sol#3906-3914):
	External calls:
	- (action,quantity) = _preCastAssertions(actionInfo,policyholder,role,ActionState.Active) (LlamaRelativeQuorum.sol#3909)
		- actionInfo.strategy.isApprovalEnabled(actionInfo,policyholder,role) (LlamaRelativeQuorum.sol#3946)
		- actionInfo.strategy.isDisapprovalEnabled(actionInfo,policyholder,role) (LlamaRelativeQuorum.sol#3950)
	State variables written after the call(s):
	- approvals[actionInfo.id][policyholder] = true (LlamaRelativeQuorum.sol#3912)
	LlamaCore.approvals (LlamaRelativeQuorum.sol#3530) can be used in cross function reentrancies:
	- LlamaCore._castApproval(address,uint8,ActionInfo,string) (LlamaRelativeQuorum.sol#3906-3914)
	- LlamaCore._preCastAssertions(ActionInfo,address,uint8,ActionState) (LlamaRelativeQuorum.sol#3928-3954)
	- LlamaCore.approvals (LlamaRelativeQuorum.sol#3530)



    
3909     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Active);



    
3946       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);



    
3950       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);



    
3912     approvals[actionInfo.id][policyholder] = true;



```

```
Reentrancy in LlamaCore.cancelAction(ActionInfo) (LlamaRelativeQuorum.sol#3689-3699):
	External calls:
	- actionInfo.strategy.validateActionCancelation(actionInfo,msg.sender) (LlamaRelativeQuorum.sol#3695)
	State variables written after the call(s):
	- action.canceled = true (LlamaRelativeQuorum.sol#3697)
	LlamaCore.actions (LlamaRelativeQuorum.sol#3510) can be used in cross function reentrancies:
	- LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaRelativeQuorum.sol#3857-3903)
	- LlamaCore._preCastAssertions(ActionInfo,address,uint8,ActionState) (LlamaRelativeQuorum.sol#3928-3954)
	- LlamaCore.cancelAction(ActionInfo) (LlamaRelativeQuorum.sol#3689-3699)
	- LlamaCore.executeAction(ActionInfo) (LlamaRelativeQuorum.sol#3658-3684)
	- LlamaCore.getAction(uint256) (LlamaRelativeQuorum.sol#3812-3814)
	- LlamaCore.getActionState(ActionInfo) (LlamaRelativeQuorum.sol#3826-3849)
	- LlamaCore.getLastActionTimestamp() (LlamaRelativeQuorum.sol#3819-3821)
	- LlamaCore.queueAction(ActionInfo) (LlamaRelativeQuorum.sol#3645-3654)



    
3695     actionInfo.strategy.validateActionCancelation(actionInfo, msg.sender);



    
3697     action.canceled = true;



```

## unused-return
### Severity: Medium

### LlamaAbsolutePeerReview.sol


```
LlamaPolicy._mint(address) (LlamaAbsolutePeerReview.sol#2763-2775) ignores return value by roleBalanceCkpts[tokenId][ALL_HOLDERS_ROLE].push(1) (LlamaAbsolutePeerReview.sol#2774)



    
2774     roleBalanceCkpts[tokenId][ALL_HOLDERS_ROLE].push(1);



```

```
LlamaPolicy._setRoleHolder(uint8,address,uint128,uint64) (LlamaAbsolutePeerReview.sol#2690-2746) ignores return value by roleBalanceCkpts[tokenId][role].push(0,expiration) (LlamaAbsolutePeerReview.sol#2707)



    
2707     roleBalanceCkpts[tokenId][role].push(willHaveRole ? quantity : 0, expiration);



```

```
LlamaPolicy.isRoleExpired(address,uint8) (LlamaAbsolutePeerReview.sol#2583-2586) ignores return value by (expiration,quantity) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint() (LlamaAbsolutePeerReview.sol#2584)



    
2584     (,, uint64 expiration, uint128 quantity) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint();



```

```
LlamaPolicy.roleExpiration(address,uint8) (LlamaAbsolutePeerReview.sol#2589-2592) ignores return value by (expiration) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint() (LlamaAbsolutePeerReview.sol#2590)



    
2590     (,, uint64 expiration,) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint();



```

```
LlamaPolicy._burn(uint256) (LlamaAbsolutePeerReview.sol#2778-2789) ignores return value by roleBalanceCkpts[tokenId][ALL_HOLDERS_ROLE].push(0) (LlamaAbsolutePeerReview.sol#2788)



    
2788     roleBalanceCkpts[tokenId][ALL_HOLDERS_ROLE].push(0);



```

```
LlamaPolicy._setRoleHolder(uint8,address,uint128,uint64) (LlamaAbsolutePeerReview.sol#2690-2746) ignores return value by roleBalanceCkpts[tokenId][role].push(quantity,expiration) (LlamaAbsolutePeerReview.sol#2707)



    
2707     roleBalanceCkpts[tokenId][role].push(willHaveRole ? quantity : 0, expiration);



```

### LlamaAbsoluteQuorum.sol


```
LlamaPolicy._mint(address) (LlamaAbsoluteQuorum.sol#2763-2775) ignores return value by roleBalanceCkpts[tokenId][ALL_HOLDERS_ROLE].push(1) (LlamaAbsoluteQuorum.sol#2774)



    
2774     roleBalanceCkpts[tokenId][ALL_HOLDERS_ROLE].push(1);



```

```
LlamaPolicy._setRoleHolder(uint8,address,uint128,uint64) (LlamaAbsoluteQuorum.sol#2690-2746) ignores return value by roleBalanceCkpts[tokenId][role].push(0,expiration) (LlamaAbsoluteQuorum.sol#2707)



    
2707     roleBalanceCkpts[tokenId][role].push(willHaveRole ? quantity : 0, expiration);



```

```
LlamaPolicy.isRoleExpired(address,uint8) (LlamaAbsoluteQuorum.sol#2583-2586) ignores return value by (expiration,quantity) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint() (LlamaAbsoluteQuorum.sol#2584)



    
2584     (,, uint64 expiration, uint128 quantity) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint();



```

```
LlamaPolicy.roleExpiration(address,uint8) (LlamaAbsoluteQuorum.sol#2589-2592) ignores return value by (expiration) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint() (LlamaAbsoluteQuorum.sol#2590)



    
2590     (,, uint64 expiration,) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint();



```

```
LlamaPolicy._burn(uint256) (LlamaAbsoluteQuorum.sol#2778-2789) ignores return value by roleBalanceCkpts[tokenId][ALL_HOLDERS_ROLE].push(0) (LlamaAbsoluteQuorum.sol#2788)



    
2788     roleBalanceCkpts[tokenId][ALL_HOLDERS_ROLE].push(0);



```

```
LlamaPolicy._setRoleHolder(uint8,address,uint128,uint64) (LlamaAbsoluteQuorum.sol#2690-2746) ignores return value by roleBalanceCkpts[tokenId][role].push(quantity,expiration) (LlamaAbsoluteQuorum.sol#2707)



    
2707     roleBalanceCkpts[tokenId][role].push(willHaveRole ? quantity : 0, expiration);



```

### LlamaAccount.sol


```
LlamaPolicy._setRoleHolder(uint8,address,uint128,uint64) (LlamaAccount.sol#3848-3904) ignores return value by roleBalanceCkpts[tokenId][role].push(quantity,expiration) (LlamaAccount.sol#3865)



    
3865     roleBalanceCkpts[tokenId][role].push(willHaveRole ? quantity : 0, expiration);



```

```
LlamaPolicy._mint(address) (LlamaAccount.sol#3921-3933) ignores return value by roleBalanceCkpts[tokenId][ALL_HOLDERS_ROLE].push(1) (LlamaAccount.sol#3932)



    
3932     roleBalanceCkpts[tokenId][ALL_HOLDERS_ROLE].push(1);



```

```
LlamaPolicy._burn(uint256) (LlamaAccount.sol#3936-3947) ignores return value by roleBalanceCkpts[tokenId][ALL_HOLDERS_ROLE].push(0) (LlamaAccount.sol#3946)



    
3946     roleBalanceCkpts[tokenId][ALL_HOLDERS_ROLE].push(0);



```

```
LlamaAccount.approveERC20(LlamaAccount.ERC20Data) (LlamaAccount.sol#5097-5099) ignores return value by erc20Data.token.approve(erc20Data.recipient,erc20Data.amount) (LlamaAccount.sol#5098)



    
5098     erc20Data.token.approve(erc20Data.recipient, erc20Data.amount);



```

```
LlamaPolicy.roleExpiration(address,uint8) (LlamaAccount.sol#3747-3750) ignores return value by (expiration) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint() (LlamaAccount.sol#3748)



    
3748     (,, uint64 expiration,) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint();



```

```
LlamaPolicy.isRoleExpired(address,uint8) (LlamaAccount.sol#3741-3744) ignores return value by (expiration,quantity) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint() (LlamaAccount.sol#3742)



    
3742     (,, uint64 expiration, uint128 quantity) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint();



```

```
LlamaPolicy._setRoleHolder(uint8,address,uint128,uint64) (LlamaAccount.sol#3848-3904) ignores return value by roleBalanceCkpts[tokenId][role].push(0,expiration) (LlamaAccount.sol#3865)



    
3865     roleBalanceCkpts[tokenId][role].push(willHaveRole ? quantity : 0, expiration);



```

### LlamaCore.sol


```
LlamaPolicy.roleExpiration(address,uint8) (LlamaCore.sol#2809-2812) ignores return value by (expiration) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint() (LlamaCore.sol#2810)



    
2810     (,, uint64 expiration,) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint();



```

```
LlamaPolicy.isRoleExpired(address,uint8) (LlamaCore.sol#2803-2806) ignores return value by (expiration,quantity) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint() (LlamaCore.sol#2804)



    
2804     (,, uint64 expiration, uint128 quantity) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint();



```

```
LlamaPolicy._burn(uint256) (LlamaCore.sol#2998-3009) ignores return value by roleBalanceCkpts[tokenId][ALL_HOLDERS_ROLE].push(0) (LlamaCore.sol#3008)



    
3008     roleBalanceCkpts[tokenId][ALL_HOLDERS_ROLE].push(0);



```

```
LlamaPolicy._mint(address) (LlamaCore.sol#2983-2995) ignores return value by roleBalanceCkpts[tokenId][ALL_HOLDERS_ROLE].push(1) (LlamaCore.sol#2994)



    
2994     roleBalanceCkpts[tokenId][ALL_HOLDERS_ROLE].push(1);



```

```
LlamaPolicy._setRoleHolder(uint8,address,uint128,uint64) (LlamaCore.sol#2910-2966) ignores return value by roleBalanceCkpts[tokenId][role].push(0,expiration) (LlamaCore.sol#2927)



    
2927     roleBalanceCkpts[tokenId][role].push(willHaveRole ? quantity : 0, expiration);



```

```
LlamaPolicy._setRoleHolder(uint8,address,uint128,uint64) (LlamaCore.sol#2910-2966) ignores return value by roleBalanceCkpts[tokenId][role].push(quantity,expiration) (LlamaCore.sol#2927)



    
2927     roleBalanceCkpts[tokenId][role].push(willHaveRole ? quantity : 0, expiration);



```

### LlamaFactory.sol


```
LlamaPolicy._mint(address) (LlamaFactory.sol#2510-2522) ignores return value by roleBalanceCkpts[tokenId][ALL_HOLDERS_ROLE].push(1) (LlamaFactory.sol#2521)



    
2521     roleBalanceCkpts[tokenId][ALL_HOLDERS_ROLE].push(1);



```

```
LlamaPolicy._setRoleHolder(uint8,address,uint128,uint64) (LlamaFactory.sol#2437-2493) ignores return value by roleBalanceCkpts[tokenId][role].push(0,expiration) (LlamaFactory.sol#2454)



    
2454     roleBalanceCkpts[tokenId][role].push(willHaveRole ? quantity : 0, expiration);



```

```
LlamaPolicy._setRoleHolder(uint8,address,uint128,uint64) (LlamaFactory.sol#2437-2493) ignores return value by roleBalanceCkpts[tokenId][role].push(quantity,expiration) (LlamaFactory.sol#2454)



    
2454     roleBalanceCkpts[tokenId][role].push(willHaveRole ? quantity : 0, expiration);



```

```
LlamaPolicy.isRoleExpired(address,uint8) (LlamaFactory.sol#2330-2333) ignores return value by (expiration,quantity) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint() (LlamaFactory.sol#2331)



    
2331     (,, uint64 expiration, uint128 quantity) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint();



```

```
LlamaPolicy.roleExpiration(address,uint8) (LlamaFactory.sol#2336-2339) ignores return value by (expiration) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint() (LlamaFactory.sol#2337)



    
2337     (,, uint64 expiration,) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint();



```

```
LlamaPolicy._burn(uint256) (LlamaFactory.sol#2525-2536) ignores return value by roleBalanceCkpts[tokenId][ALL_HOLDERS_ROLE].push(0) (LlamaFactory.sol#2535)



    
2535     roleBalanceCkpts[tokenId][ALL_HOLDERS_ROLE].push(0);



```

### LlamaGovernanceScript.sol


```
LlamaPolicy._burn(uint256) (LlamaGovernanceScript.sol#2546-2557) ignores return value by roleBalanceCkpts[tokenId][ALL_HOLDERS_ROLE].push(0) (LlamaGovernanceScript.sol#2556)



    
2556     roleBalanceCkpts[tokenId][ALL_HOLDERS_ROLE].push(0);



```

```
LlamaPolicy._mint(address) (LlamaGovernanceScript.sol#2531-2543) ignores return value by roleBalanceCkpts[tokenId][ALL_HOLDERS_ROLE].push(1) (LlamaGovernanceScript.sol#2542)



    
2542     roleBalanceCkpts[tokenId][ALL_HOLDERS_ROLE].push(1);



```

```
LlamaPolicy._setRoleHolder(uint8,address,uint128,uint64) (LlamaGovernanceScript.sol#2458-2514) ignores return value by roleBalanceCkpts[tokenId][role].push(0,expiration) (LlamaGovernanceScript.sol#2475)



    
2475     roleBalanceCkpts[tokenId][role].push(willHaveRole ? quantity : 0, expiration);



```

```
LlamaPolicy.roleExpiration(address,uint8) (LlamaGovernanceScript.sol#2357-2360) ignores return value by (expiration) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint() (LlamaGovernanceScript.sol#2358)



    
2358     (,, uint64 expiration,) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint();



```

```
LlamaPolicy._setRoleHolder(uint8,address,uint128,uint64) (LlamaGovernanceScript.sol#2458-2514) ignores return value by roleBalanceCkpts[tokenId][role].push(quantity,expiration) (LlamaGovernanceScript.sol#2475)



    
2475     roleBalanceCkpts[tokenId][role].push(willHaveRole ? quantity : 0, expiration);



```

```
LlamaPolicy.isRoleExpired(address,uint8) (LlamaGovernanceScript.sol#2351-2354) ignores return value by (expiration,quantity) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint() (LlamaGovernanceScript.sol#2352)



    
2352     (,, uint64 expiration, uint128 quantity) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint();



```

### LlamaPolicy.sol


```
LlamaPolicy._setRoleHolder(uint8,address,uint128,uint64) (LlamaPolicy.sol#3888-3944) ignores return value by roleBalanceCkpts[tokenId][role].push(0,expiration) (LlamaPolicy.sol#3905)



    
3905     roleBalanceCkpts[tokenId][role].push(willHaveRole ? quantity : 0, expiration);



```

```
LlamaPolicy.isRoleExpired(address,uint8) (LlamaPolicy.sol#3781-3784) ignores return value by (expiration,quantity) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint() (LlamaPolicy.sol#3782)



    
3782     (,, uint64 expiration, uint128 quantity) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint();



```

```
LlamaPolicy._mint(address) (LlamaPolicy.sol#3961-3973) ignores return value by roleBalanceCkpts[tokenId][ALL_HOLDERS_ROLE].push(1) (LlamaPolicy.sol#3972)



    
3972     roleBalanceCkpts[tokenId][ALL_HOLDERS_ROLE].push(1);



```

```
LlamaPolicy._setRoleHolder(uint8,address,uint128,uint64) (LlamaPolicy.sol#3888-3944) ignores return value by roleBalanceCkpts[tokenId][role].push(quantity,expiration) (LlamaPolicy.sol#3905)



    
3905     roleBalanceCkpts[tokenId][role].push(willHaveRole ? quantity : 0, expiration);



```

```
LlamaPolicy.roleExpiration(address,uint8) (LlamaPolicy.sol#3787-3790) ignores return value by (expiration) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint() (LlamaPolicy.sol#3788)



    
3788     (,, uint64 expiration,) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint();



```

```
LlamaPolicy._burn(uint256) (LlamaPolicy.sol#3976-3987) ignores return value by roleBalanceCkpts[tokenId][ALL_HOLDERS_ROLE].push(0) (LlamaPolicy.sol#3986)



    
3986     roleBalanceCkpts[tokenId][ALL_HOLDERS_ROLE].push(0);



```

### LlamaRelativeQuorum.sol


```
LlamaPolicy._mint(address) (LlamaRelativeQuorum.sol#2763-2775) ignores return value by roleBalanceCkpts[tokenId][ALL_HOLDERS_ROLE].push(1) (LlamaRelativeQuorum.sol#2774)



    
2774     roleBalanceCkpts[tokenId][ALL_HOLDERS_ROLE].push(1);



```

```
LlamaPolicy._setRoleHolder(uint8,address,uint128,uint64) (LlamaRelativeQuorum.sol#2690-2746) ignores return value by roleBalanceCkpts[tokenId][role].push(0,expiration) (LlamaRelativeQuorum.sol#2707)



    
2707     roleBalanceCkpts[tokenId][role].push(willHaveRole ? quantity : 0, expiration);



```

```
LlamaPolicy.isRoleExpired(address,uint8) (LlamaRelativeQuorum.sol#2583-2586) ignores return value by (expiration,quantity) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint() (LlamaRelativeQuorum.sol#2584)



    
2584     (,, uint64 expiration, uint128 quantity) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint();



```

```
LlamaPolicy.roleExpiration(address,uint8) (LlamaRelativeQuorum.sol#2589-2592) ignores return value by (expiration) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint() (LlamaRelativeQuorum.sol#2590)



    
2590     (,, uint64 expiration,) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint();



```

```
LlamaPolicy._burn(uint256) (LlamaRelativeQuorum.sol#2778-2789) ignores return value by roleBalanceCkpts[tokenId][ALL_HOLDERS_ROLE].push(0) (LlamaRelativeQuorum.sol#2788)



    
2788     roleBalanceCkpts[tokenId][ALL_HOLDERS_ROLE].push(0);



```

```
LlamaPolicy._setRoleHolder(uint8,address,uint128,uint64) (LlamaRelativeQuorum.sol#2690-2746) ignores return value by roleBalanceCkpts[tokenId][role].push(quantity,expiration) (LlamaRelativeQuorum.sol#2707)



    
2707     roleBalanceCkpts[tokenId][role].push(willHaveRole ? quantity : 0, expiration);



```

## write-after-write
### Severity: Medium

### LlamaAbsolutePeerReview.sol


```
LibString.indexOf(string,string,uint256).result (LlamaAbsolutePeerReview.sol#1186) is written in both
	result = subjectLength_indexOf_asm_0 (LlamaAbsolutePeerReview.sol#1196)
	result = ~ 0 (LlamaAbsolutePeerReview.sol#1202)



    
1196                     result := subjectLength



    
1202                 result := not(0) // Initialize to `NOT_FOUND`.



```

```
LibString.indexOf(string,string,uint256).result (LlamaAbsolutePeerReview.sol#1186) is written in both
	result = from (LlamaAbsolutePeerReview.sol#1193)
	result = subjectLength_indexOf_asm_0 (LlamaAbsolutePeerReview.sol#1196)



    
1193                         result := from



    
1196                     result := subjectLength



```

### LlamaAbsoluteQuorum.sol


```
LibString.indexOf(string,string,uint256).result (LlamaAbsoluteQuorum.sol#1186) is written in both
	result = subjectLength_indexOf_asm_0 (LlamaAbsoluteQuorum.sol#1196)
	result = ~ 0 (LlamaAbsoluteQuorum.sol#1202)



    
1196                     result := subjectLength



    
1202                 result := not(0) // Initialize to `NOT_FOUND`.



```

```
LibString.indexOf(string,string,uint256).result (LlamaAbsoluteQuorum.sol#1186) is written in both
	result = from (LlamaAbsoluteQuorum.sol#1193)
	result = subjectLength_indexOf_asm_0 (LlamaAbsoluteQuorum.sol#1196)



    
1193                         result := from



    
1196                     result := subjectLength



```

### LlamaAccount.sol


```
LibString.indexOf(string,string,uint256).result (LlamaAccount.sol#1746) is written in both
	result = subjectLength_indexOf_asm_0 (LlamaAccount.sol#1756)
	result = ~ 0 (LlamaAccount.sol#1762)



    
1756                     result := subjectLength



    
1762                 result := not(0) // Initialize to `NOT_FOUND`.



```

```
LibString.indexOf(string,string,uint256).result (LlamaAccount.sol#1746) is written in both
	result = from (LlamaAccount.sol#1753)
	result = subjectLength_indexOf_asm_0 (LlamaAccount.sol#1756)



    
1753                         result := from



    
1756                     result := subjectLength



```

### LlamaCore.sol


```
LibString.indexOf(string,string,uint256).result (LlamaCore.sol#783) is written in both
	result = from (LlamaCore.sol#790)
	result = subjectLength_indexOf_asm_0 (LlamaCore.sol#793)



    
790                         result := from



    
793                     result := subjectLength



```

```
LibString.indexOf(string,string,uint256).result (LlamaCore.sol#783) is written in both
	result = subjectLength_indexOf_asm_0 (LlamaCore.sol#793)
	result = ~ 0 (LlamaCore.sol#799)



    
793                     result := subjectLength



    
799                 result := not(0) // Initialize to `NOT_FOUND`.



```

### LlamaFactory.sol


```
LibString.indexOf(string,string,uint256).result (LlamaFactory.sol#930) is written in both
	result = from (LlamaFactory.sol#937)
	result = subjectLength_indexOf_asm_0 (LlamaFactory.sol#940)



    
937                         result := from



    
940                     result := subjectLength



```

```
LibString.indexOf(string,string,uint256).result (LlamaFactory.sol#930) is written in both
	result = subjectLength_indexOf_asm_0 (LlamaFactory.sol#940)
	result = ~ 0 (LlamaFactory.sol#946)



    
940                     result := subjectLength



    
946                 result := not(0) // Initialize to `NOT_FOUND`.



```

### LlamaGovernanceScript.sol


```
LibString.indexOf(string,string,uint256).result (LlamaGovernanceScript.sol#954) is written in both
	result = from (LlamaGovernanceScript.sol#961)
	result = subjectLength_indexOf_asm_0 (LlamaGovernanceScript.sol#964)



    
961                         result := from



    
964                     result := subjectLength



```

```
LibString.indexOf(string,string,uint256).result (LlamaGovernanceScript.sol#954) is written in both
	result = subjectLength_indexOf_asm_0 (LlamaGovernanceScript.sol#964)
	result = ~ 0 (LlamaGovernanceScript.sol#970)



    
964                     result := subjectLength



    
970                 result := not(0) // Initialize to `NOT_FOUND`.



```

### LlamaPolicy.sol


```
LibString.indexOf(string,string,uint256).result (LlamaPolicy.sol#490) is written in both
	result = subjectLength_indexOf_asm_0 (LlamaPolicy.sol#500)
	result = ~ 0 (LlamaPolicy.sol#506)



    
500                     result := subjectLength



    
506                 result := not(0) // Initialize to `NOT_FOUND`.



```

```
LibString.indexOf(string,string,uint256).result (LlamaPolicy.sol#490) is written in both
	result = from (LlamaPolicy.sol#497)
	result = subjectLength_indexOf_asm_0 (LlamaPolicy.sol#500)



    
497                         result := from



    
500                     result := subjectLength



```

### LlamaPolicyMetadata.sol


```
LibString.indexOf(string,string,uint256).result (LlamaPolicyMetadata.sol#578) is written in both
	result = from (LlamaPolicyMetadata.sol#585)
	result = subjectLength_indexOf_asm_0 (LlamaPolicyMetadata.sol#588)



    
585                         result := from



    
588                     result := subjectLength



```

```
LibString.indexOf(string,string,uint256).result (LlamaPolicyMetadata.sol#578) is written in both
	result = subjectLength_indexOf_asm_0 (LlamaPolicyMetadata.sol#588)
	result = ~ 0 (LlamaPolicyMetadata.sol#594)



    
588                     result := subjectLength



    
594                 result := not(0) // Initialize to `NOT_FOUND`.



```

### LlamaRelativeQuorum.sol


```
LibString.indexOf(string,string,uint256).result (LlamaRelativeQuorum.sol#1186) is written in both
	result = subjectLength_indexOf_asm_0 (LlamaRelativeQuorum.sol#1196)
	result = ~ 0 (LlamaRelativeQuorum.sol#1202)



    
1196                     result := subjectLength



    
1202                 result := not(0) // Initialize to `NOT_FOUND`.



```

```
LibString.indexOf(string,string,uint256).result (LlamaRelativeQuorum.sol#1186) is written in both
	result = from (LlamaRelativeQuorum.sol#1193)
	result = subjectLength_indexOf_asm_0 (LlamaRelativeQuorum.sol#1196)



    
1193                         result := from



    
1196                     result := subjectLength



```

## unchecked-lowlevel
### Severity: Medium

### LlamaAccount.sol


```
Address.sendValue(address,uint256) (LlamaAccount.sol#361-370) ignores return value by (success) = recipient.call{value: amount}() (LlamaAccount.sol#366)



    
366         (bool success, ) = recipient.call{value: amount}("");



```

## missing-zero-check
### Severity: Low

### LlamaAbsolutePeerReview.sol


```
LlamaPolicy.finalizeInitialization(address,bytes32)._llamaExecutor (LlamaAbsolutePeerReview.sol#2439) lacks a zero-check on :
		- llamaExecutor = _llamaExecutor (LlamaAbsolutePeerReview.sol#2442)



    
2442     llamaExecutor = _llamaExecutor;



```

```
LlamaExecutor.execute(address,uint256,bool,bytes).target (LlamaAbsolutePeerReview.sol#688) lacks a zero-check on :
		- (success,result) = target.delegatecall(data) (LlamaAbsolutePeerReview.sol#693)
		- (success,result) = target.call{value: value}(data) (LlamaAbsolutePeerReview.sol#693)



    
693     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



    
693     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



```

### LlamaAbsoluteQuorum.sol


```
LlamaPolicy.finalizeInitialization(address,bytes32)._llamaExecutor (LlamaAbsoluteQuorum.sol#2439) lacks a zero-check on :
		- llamaExecutor = _llamaExecutor (LlamaAbsoluteQuorum.sol#2442)



    
2442     llamaExecutor = _llamaExecutor;



```

```
LlamaExecutor.execute(address,uint256,bool,bytes).target (LlamaAbsoluteQuorum.sol#688) lacks a zero-check on :
		- (success,result) = target.delegatecall(data) (LlamaAbsoluteQuorum.sol#693)
		- (success,result) = target.call{value: value}(data) (LlamaAbsoluteQuorum.sol#693)



    
693     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



    
693     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



```

### LlamaAccount.sol


```
LlamaPolicy.finalizeInitialization(address,bytes32)._llamaExecutor (LlamaAccount.sol#3597) lacks a zero-check on :
		- llamaExecutor = _llamaExecutor (LlamaAccount.sol#3600)



    
3600     llamaExecutor = _llamaExecutor;



```

```
LlamaAccount.execute(address,bool,bytes).target (LlamaAccount.sol#5213) lacks a zero-check on :
		- (success,result) = target.delegatecall(callData) (LlamaAccount.sol#5239)
		- (success,result) = target.call{value: msg.value}(callData) (LlamaAccount.sol#5242)



    
5239       (success, result) = target.delegatecall(callData);



    
5242       (success, result) = target.call{value: msg.value}(callData);



```

```
LlamaExecutor.execute(address,uint256,bool,bytes).target (LlamaAccount.sol#2863) lacks a zero-check on :
		- (success,result) = target.delegatecall(data) (LlamaAccount.sol#2868)
		- (success,result) = target.call{value: value}(data) (LlamaAccount.sol#2868)



    
2868     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



    
2868     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



```

### LlamaCore.sol


```
LlamaPolicy.finalizeInitialization(address,bytes32)._llamaExecutor (LlamaCore.sol#2659) lacks a zero-check on :
		- llamaExecutor = _llamaExecutor (LlamaCore.sol#2662)



    
2662     llamaExecutor = _llamaExecutor;



```

```
LlamaExecutor.execute(address,uint256,bool,bytes).target (LlamaCore.sol#1925) lacks a zero-check on :
		- (success,result) = target.delegatecall(data) (LlamaCore.sol#1930)
		- (success,result) = target.call{value: value}(data) (LlamaCore.sol#1930)



    
1930     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



    
1930     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



```

### LlamaExecutor.sol


```
LlamaExecutor.execute(address,uint256,bool,bytes).target (LlamaExecutor.sol#29) lacks a zero-check on :
		- (success,result) = target.delegatecall(data) (LlamaExecutor.sol#34)
		- (success,result) = target.call{value: value}(data) (LlamaExecutor.sol#34)



    
34     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



    
34     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



```

### LlamaFactory.sol


```
LlamaExecutor.execute(address,uint256,bool,bytes).target (LlamaFactory.sol#435) lacks a zero-check on :
		- (success,result) = target.delegatecall(data) (LlamaFactory.sol#440)
		- (success,result) = target.call{value: value}(data) (LlamaFactory.sol#440)



    
440     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



    
440     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



```

```
LlamaPolicy.finalizeInitialization(address,bytes32)._llamaExecutor (LlamaFactory.sol#2186) lacks a zero-check on :
		- llamaExecutor = _llamaExecutor (LlamaFactory.sol#2189)



    
2189     llamaExecutor = _llamaExecutor;



```

### LlamaGovernanceScript.sol


```
LlamaPolicy.finalizeInitialization(address,bytes32)._llamaExecutor (LlamaGovernanceScript.sol#2207) lacks a zero-check on :
		- llamaExecutor = _llamaExecutor (LlamaGovernanceScript.sol#2210)



    
2210     llamaExecutor = _llamaExecutor;



```

```
LlamaExecutor.execute(address,uint256,bool,bytes).target (LlamaGovernanceScript.sol#456) lacks a zero-check on :
		- (success,result) = target.delegatecall(data) (LlamaGovernanceScript.sol#461)
		- (success,result) = target.call{value: value}(data) (LlamaGovernanceScript.sol#461)



    
461     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



    
461     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



```

### LlamaPolicy.sol


```
LlamaExecutor.execute(address,uint256,bool,bytes).target (LlamaPolicy.sol#1960) lacks a zero-check on :
		- (success,result) = target.delegatecall(data) (LlamaPolicy.sol#1965)
		- (success,result) = target.call{value: value}(data) (LlamaPolicy.sol#1965)



    
1965     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



    
1965     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



```

```
LlamaPolicy.finalizeInitialization(address,bytes32)._llamaExecutor (LlamaPolicy.sol#3637) lacks a zero-check on :
		- llamaExecutor = _llamaExecutor (LlamaPolicy.sol#3640)



    
3640     llamaExecutor = _llamaExecutor;



```

### LlamaPolicyMetadataParamRegistry.sol


```
LlamaExecutor.execute(address,uint256,bool,bytes).target (LlamaPolicyMetadataParamRegistry.sol#29) lacks a zero-check on :
		- (success,result) = target.delegatecall(data) (LlamaPolicyMetadataParamRegistry.sol#34)
		- (success,result) = target.call{value: value}(data) (LlamaPolicyMetadataParamRegistry.sol#34)



    
34     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



    
34     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



```

### LlamaRelativeQuorum.sol


```
LlamaPolicy.finalizeInitialization(address,bytes32)._llamaExecutor (LlamaRelativeQuorum.sol#2439) lacks a zero-check on :
		- llamaExecutor = _llamaExecutor (LlamaRelativeQuorum.sol#2442)



    
2442     llamaExecutor = _llamaExecutor;



```

```
LlamaExecutor.execute(address,uint256,bool,bytes).target (LlamaRelativeQuorum.sol#688) lacks a zero-check on :
		- (success,result) = target.delegatecall(data) (LlamaRelativeQuorum.sol#693)
		- (success,result) = target.call{value: value}(data) (LlamaRelativeQuorum.sol#693)



    
693     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



    
693     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



```

## calls-loop
### Severity: Low

### LlamaAbsolutePeerReview.sol


```
LlamaPolicy._assertNoActionCreationsAtCurrentTimestamp() (LlamaAbsolutePeerReview.sol#2663-2668) has external calls inside a loop: llamaCore = LlamaExecutor(llamaExecutor).LLAMA_CORE() (LlamaAbsolutePeerReview.sol#2665)



    
2665     address llamaCore = LlamaExecutor(llamaExecutor).LLAMA_CORE();



```

```
LlamaPolicy._assertNoActionCreationsAtCurrentTimestamp() (LlamaAbsolutePeerReview.sol#2663-2668) has external calls inside a loop: lastActionCreation = LlamaCore(llamaCore).getLastActionTimestamp() (LlamaAbsolutePeerReview.sol#2666)



    
2666     uint256 lastActionCreation = LlamaCore(llamaCore).getLastActionTimestamp();



```

### LlamaAbsoluteQuorum.sol


```
LlamaPolicy._assertNoActionCreationsAtCurrentTimestamp() (LlamaAbsoluteQuorum.sol#2663-2668) has external calls inside a loop: llamaCore = LlamaExecutor(llamaExecutor).LLAMA_CORE() (LlamaAbsoluteQuorum.sol#2665)



    
2665     address llamaCore = LlamaExecutor(llamaExecutor).LLAMA_CORE();



```

```
LlamaPolicy._assertNoActionCreationsAtCurrentTimestamp() (LlamaAbsoluteQuorum.sol#2663-2668) has external calls inside a loop: lastActionCreation = LlamaCore(llamaCore).getLastActionTimestamp() (LlamaAbsoluteQuorum.sol#2666)



    
2666     uint256 lastActionCreation = LlamaCore(llamaCore).getLastActionTimestamp();



```

### LlamaAccount.sol


```
Address.sendValue(address,uint256) (LlamaAccount.sol#361-370) has external calls inside a loop: (success) = recipient.call{value: amount}() (LlamaAccount.sol#366)



    
366         (bool success, ) = recipient.call{value: amount}("");



```

```
LlamaAccount.batchTransferSingleERC1155(LlamaAccount.ERC1155BatchData) (LlamaAccount.sol#5171-5180) has external calls inside a loop: erc1155BatchData.token.safeBatchTransferFrom(address(this),erc1155BatchData.recipient,erc1155BatchData.tokenIds,erc1155BatchData.amounts,erc1155BatchData.data) (LlamaAccount.sol#5173-5179)



    
5173     erc1155BatchData.token.safeBatchTransferFrom(
5174       address(this),
5175       erc1155BatchData.recipient,
5176       erc1155BatchData.tokenIds,
5177       erc1155BatchData.amounts,
5178       erc1155BatchData.data
5179     );



```

```
LlamaPolicy._assertNoActionCreationsAtCurrentTimestamp() (LlamaAccount.sol#3821-3826) has external calls inside a loop: lastActionCreation = LlamaCore(llamaCore).getLastActionTimestamp() (LlamaAccount.sol#3824)



    
3824     uint256 lastActionCreation = LlamaCore(llamaCore).getLastActionTimestamp();



```

```
LlamaAccount.approveOperatorERC1155(LlamaAccount.ERC1155OperatorData) (LlamaAccount.sol#5193-5195) has external calls inside a loop: erc1155OperatorData.token.setApprovalForAll(erc1155OperatorData.recipient,erc1155OperatorData.approved) (LlamaAccount.sol#5194)



    
5194     erc1155OperatorData.token.setApprovalForAll(erc1155OperatorData.recipient, erc1155OperatorData.approved);



```

```
Address.functionCallWithValue(address,bytes,uint256,function()) (LlamaAccount.sol#429-440) has external calls inside a loop: (success,returndata) = target.call{value: value}(data) (LlamaAccount.sol#438)



    
438         (bool success, bytes memory returndata) = target.call{value: value}(data);



```

```
LlamaAccount.approveERC721(LlamaAccount.ERC721Data) (LlamaAccount.sol#5130-5132) has external calls inside a loop: erc721Data.token.approve(erc721Data.recipient,erc721Data.tokenId) (LlamaAccount.sol#5131)



    
5131     erc721Data.token.approve(erc721Data.recipient, erc721Data.tokenId);



```

```
LlamaAccount.approveERC20(LlamaAccount.ERC20Data) (LlamaAccount.sol#5097-5099) has external calls inside a loop: erc20Data.token.approve(erc20Data.recipient,erc20Data.amount) (LlamaAccount.sol#5098)



    
5098     erc20Data.token.approve(erc20Data.recipient, erc20Data.amount);



```

```
LlamaPolicy._assertNoActionCreationsAtCurrentTimestamp() (LlamaAccount.sol#3821-3826) has external calls inside a loop: llamaCore = LlamaExecutor(llamaExecutor).LLAMA_CORE() (LlamaAccount.sol#3823)



    
3823     address llamaCore = LlamaExecutor(llamaExecutor).LLAMA_CORE();



```

```
LlamaAccount.transferERC721(LlamaAccount.ERC721Data) (LlamaAccount.sol#5114-5117) has external calls inside a loop: erc721Data.token.transferFrom(address(this),erc721Data.recipient,erc721Data.tokenId) (LlamaAccount.sol#5116)



    
5116     erc721Data.token.transferFrom(address(this), erc721Data.recipient, erc721Data.tokenId);



```

```
LlamaAccount.approveOperatorERC721(LlamaAccount.ERC721OperatorData) (LlamaAccount.sol#5145-5147) has external calls inside a loop: erc721OperatorData.token.setApprovalForAll(erc721OperatorData.recipient,erc721OperatorData.approved) (LlamaAccount.sol#5146)



    
5146     erc721OperatorData.token.setApprovalForAll(erc721OperatorData.recipient, erc721OperatorData.approved);



```

### LlamaCore.sol


```
LlamaPolicy._assertNoActionCreationsAtCurrentTimestamp() (LlamaCore.sol#2883-2888) has external calls inside a loop: llamaCore = LlamaExecutor(llamaExecutor).LLAMA_CORE() (LlamaCore.sol#2885)



    
2885     address llamaCore = LlamaExecutor(llamaExecutor).LLAMA_CORE();



```

```
LlamaPolicy._assertNoActionCreationsAtCurrentTimestamp() (LlamaCore.sol#2883-2888) has external calls inside a loop: lastActionCreation = LlamaCore(llamaCore).getLastActionTimestamp() (LlamaCore.sol#2886)



    
2886     uint256 lastActionCreation = LlamaCore(llamaCore).getLastActionTimestamp();



```

### LlamaFactory.sol


```
LlamaPolicy._assertNoActionCreationsAtCurrentTimestamp() (LlamaFactory.sol#2410-2415) has external calls inside a loop: lastActionCreation = LlamaCore(llamaCore).getLastActionTimestamp() (LlamaFactory.sol#2413)



    
2413     uint256 lastActionCreation = LlamaCore(llamaCore).getLastActionTimestamp();



```

```
LlamaPolicy._assertNoActionCreationsAtCurrentTimestamp() (LlamaFactory.sol#2410-2415) has external calls inside a loop: llamaCore = LlamaExecutor(llamaExecutor).LLAMA_CORE() (LlamaFactory.sol#2412)



    
2412     address llamaCore = LlamaExecutor(llamaExecutor).LLAMA_CORE();



```

### LlamaGovernanceScript.sol


```
LlamaGovernanceScript.revokePolicies(address[]) (LlamaGovernanceScript.sol#4211-4216) has external calls inside a loop: policy.revokePolicy(_revokePolicies[i]) (LlamaGovernanceScript.sol#4214)



    
4214       policy.revokePolicy(_revokePolicies[i]);



```

```
LlamaGovernanceScript.updateRoleDescriptions(LlamaGovernanceScript.UpdateRoleDescription[]) (LlamaGovernanceScript.sol#4218-4223) has external calls inside a loop: policy.updateRoleDescription(roleDescriptions[i].role,roleDescriptions[i].description) (LlamaGovernanceScript.sol#4221)



    
4221       policy.updateRoleDescription(roleDescriptions[i].role, roleDescriptions[i].description);



```

```
LlamaGovernanceScript.initializeRoles(RoleDescription[]) (LlamaGovernanceScript.sol#4178-4184) has external calls inside a loop: policy.initializeRole(description[i]) (LlamaGovernanceScript.sol#4182)



    
4182       policy.initializeRole(description[i]);



```

```
LlamaPolicy._assertNoActionCreationsAtCurrentTimestamp() (LlamaGovernanceScript.sol#2431-2436) has external calls inside a loop: lastActionCreation = LlamaCore(llamaCore).getLastActionTimestamp() (LlamaGovernanceScript.sol#2434)



    
2434     uint256 lastActionCreation = LlamaCore(llamaCore).getLastActionTimestamp();



```

```
LlamaGovernanceScript.setRoleHolders(RoleHolderData[]) (LlamaGovernanceScript.sol#4186-4197) has external calls inside a loop: policy.setRoleHolder(_setRoleHolders[i].role,_setRoleHolders[i].policyholder,_setRoleHolders[i].quantity,_setRoleHolders[i].expiration) (LlamaGovernanceScript.sol#4190-4195)



    
4190       policy.setRoleHolder(
4191         _setRoleHolders[i].role,
4192         _setRoleHolders[i].policyholder,
4193         _setRoleHolders[i].quantity,
4194         _setRoleHolders[i].expiration
4195       );



```

```
LlamaPolicy._assertNoActionCreationsAtCurrentTimestamp() (LlamaGovernanceScript.sol#2431-2436) has external calls inside a loop: llamaCore = LlamaExecutor(llamaExecutor).LLAMA_CORE() (LlamaGovernanceScript.sol#2433)



    
2433     address llamaCore = LlamaExecutor(llamaExecutor).LLAMA_CORE();



```

```
LlamaGovernanceScript.setRolePermissions(RolePermissionData[]) (LlamaGovernanceScript.sol#4199-4207) has external calls inside a loop: policy.setRolePermission(_setRolePermissions[i].role,_setRolePermissions[i].permissionId,_setRolePermissions[i].hasPermission) (LlamaGovernanceScript.sol#4203-4205)



    
4203       policy.setRolePermission(
4204         _setRolePermissions[i].role, _setRolePermissions[i].permissionId, _setRolePermissions[i].hasPermission
4205       );



```

```
LlamaGovernanceScript.aggregate(address[],bytes[]) (LlamaGovernanceScript.sol#4065-4082) has external calls inside a loop: (success,response) = targets[i].call(data[i]) (LlamaGovernanceScript.sol#4078)



    
4078       (bool success, bytes memory response) = targets[i].call(data[i]);



```

### LlamaPolicy.sol


```
LlamaPolicy._assertNoActionCreationsAtCurrentTimestamp() (LlamaPolicy.sol#3861-3866) has external calls inside a loop: lastActionCreation = LlamaCore(llamaCore).getLastActionTimestamp() (LlamaPolicy.sol#3864)



    
3864     uint256 lastActionCreation = LlamaCore(llamaCore).getLastActionTimestamp();



```

```
LlamaPolicy._assertNoActionCreationsAtCurrentTimestamp() (LlamaPolicy.sol#3861-3866) has external calls inside a loop: llamaCore = LlamaExecutor(llamaExecutor).LLAMA_CORE() (LlamaPolicy.sol#3863)



    
3863     address llamaCore = LlamaExecutor(llamaExecutor).LLAMA_CORE();



```

### LlamaRelativeQuorum.sol


```
LlamaPolicy._assertNoActionCreationsAtCurrentTimestamp() (LlamaRelativeQuorum.sol#2663-2668) has external calls inside a loop: llamaCore = LlamaExecutor(llamaExecutor).LLAMA_CORE() (LlamaRelativeQuorum.sol#2665)



    
2665     address llamaCore = LlamaExecutor(llamaExecutor).LLAMA_CORE();



```

```
LlamaPolicy._assertNoActionCreationsAtCurrentTimestamp() (LlamaRelativeQuorum.sol#2663-2668) has external calls inside a loop: lastActionCreation = LlamaCore(llamaCore).getLastActionTimestamp() (LlamaRelativeQuorum.sol#2666)



    
2666     uint256 lastActionCreation = LlamaCore(llamaCore).getLastActionTimestamp();



```

## reentrancy-benign
### Severity: Low

### LlamaAbsolutePeerReview.sol


```
Reentrancy in LlamaFactory._deploy(string,ILlamaStrategy,ILlamaAccount,bytes[],bytes[],RoleDescription[],RoleHolderData[],RolePermissionData[]) (LlamaAbsolutePeerReview.sol#3294-3331):
	External calls:
	- policy.initialize(name,initialRoleDescriptions,initialRoleHolders,initialRolePermissions) (LlamaAbsolutePeerReview.sol#3318)
	- bootstrapPermissionId = llamaCore.initialize(name,policy,strategyLogic,accountLogic,initialStrategies,initialAccounts) (LlamaAbsolutePeerReview.sol#3321-3322)
	- policy.finalizeInitialization(address(llamaExecutor),bootstrapPermissionId) (LlamaAbsolutePeerReview.sol#3325)
	State variables written after the call(s):
	- llamaCount = LlamaUtils.uncheckedIncrement(llamaCount) (LlamaAbsolutePeerReview.sol#3330)



    
3318     policy.initialize(name, initialRoleDescriptions, initialRoleHolders, initialRolePermissions);



    
3321     bytes32 bootstrapPermissionId =
3322       llamaCore.initialize(name, policy, strategyLogic, accountLogic, initialStrategies, initialAccounts);



    
3325     policy.finalizeInitialization(address(llamaExecutor), bootstrapPermissionId);



    
3318     policy.initialize(name, initialRoleDescriptions, initialRoleHolders, initialRolePermissions);



    
3321     bytes32 bootstrapPermissionId =
3322       llamaCore.initialize(name, policy, strategyLogic, accountLogic, initialStrategies, initialAccounts);



    
3325     policy.finalizeInitialization(address(llamaExecutor), bootstrapPermissionId);



    
3330     llamaCount = LlamaUtils.uncheckedIncrement(llamaCount);



```

```
Reentrancy in LlamaCore._deployStrategies(ILlamaStrategy,bytes[]) (LlamaAbsolutePeerReview.sol#3966-3985):
	External calls:
	- strategy.initialize(strategyConfigs[i]) (LlamaAbsolutePeerReview.sol#3980)
	State variables written after the call(s):
	- strategies[strategy] = true (LlamaAbsolutePeerReview.sol#3981)



    
3980       strategy.initialize(strategyConfigs[i]);



    
3980       strategy.initialize(strategyConfigs[i]);



    
3981       strategies[strategy] = true;



```

```
Reentrancy in LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaAbsolutePeerReview.sol#3857-3903):
	External calls:
	- strategy.validateActionCreation(actionInfo) (LlamaAbsolutePeerReview.sol#3886)
	- guard.validateActionCreation(actionInfo) (LlamaAbsolutePeerReview.sol#3891)
	State variables written after the call(s):
	- newAction.infoHash = _infoHash(actionId,policyholder,role,strategy,target,value,data) (LlamaAbsolutePeerReview.sol#3895)
	- newAction.creationTime = LlamaUtils.toUint64(block.timestamp) (LlamaAbsolutePeerReview.sol#3896)
	- newAction.isScript = authorizedScripts[target] (LlamaAbsolutePeerReview.sol#3897)



    
3886     strategy.validateActionCreation(actionInfo);



    
3891       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);



    
3886     strategy.validateActionCreation(actionInfo);



    
3891       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);



    
3895       newAction.infoHash = _infoHash(actionId, policyholder, role, strategy, target, value, data);



    
3896       newAction.creationTime = LlamaUtils.toUint64(block.timestamp);



    
3897       newAction.isScript = authorizedScripts[target];



```

### LlamaAbsoluteQuorum.sol


```
Reentrancy in LlamaFactory._deploy(string,ILlamaStrategy,ILlamaAccount,bytes[],bytes[],RoleDescription[],RoleHolderData[],RolePermissionData[]) (LlamaAbsoluteQuorum.sol#3294-3331):
	External calls:
	- policy.initialize(name,initialRoleDescriptions,initialRoleHolders,initialRolePermissions) (LlamaAbsoluteQuorum.sol#3318)
	- bootstrapPermissionId = llamaCore.initialize(name,policy,strategyLogic,accountLogic,initialStrategies,initialAccounts) (LlamaAbsoluteQuorum.sol#3321-3322)
	- policy.finalizeInitialization(address(llamaExecutor),bootstrapPermissionId) (LlamaAbsoluteQuorum.sol#3325)
	State variables written after the call(s):
	- llamaCount = LlamaUtils.uncheckedIncrement(llamaCount) (LlamaAbsoluteQuorum.sol#3330)



    
3318     policy.initialize(name, initialRoleDescriptions, initialRoleHolders, initialRolePermissions);



    
3321     bytes32 bootstrapPermissionId =
3322       llamaCore.initialize(name, policy, strategyLogic, accountLogic, initialStrategies, initialAccounts);



    
3325     policy.finalizeInitialization(address(llamaExecutor), bootstrapPermissionId);



    
3318     policy.initialize(name, initialRoleDescriptions, initialRoleHolders, initialRolePermissions);



    
3321     bytes32 bootstrapPermissionId =
3322       llamaCore.initialize(name, policy, strategyLogic, accountLogic, initialStrategies, initialAccounts);



    
3325     policy.finalizeInitialization(address(llamaExecutor), bootstrapPermissionId);



    
3330     llamaCount = LlamaUtils.uncheckedIncrement(llamaCount);



```

```
Reentrancy in LlamaCore._deployStrategies(ILlamaStrategy,bytes[]) (LlamaAbsoluteQuorum.sol#3966-3985):
	External calls:
	- strategy.initialize(strategyConfigs[i]) (LlamaAbsoluteQuorum.sol#3980)
	State variables written after the call(s):
	- strategies[strategy] = true (LlamaAbsoluteQuorum.sol#3981)



    
3980       strategy.initialize(strategyConfigs[i]);



    
3980       strategy.initialize(strategyConfigs[i]);



    
3981       strategies[strategy] = true;



```

```
Reentrancy in LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaAbsoluteQuorum.sol#3857-3903):
	External calls:
	- strategy.validateActionCreation(actionInfo) (LlamaAbsoluteQuorum.sol#3886)
	- guard.validateActionCreation(actionInfo) (LlamaAbsoluteQuorum.sol#3891)
	State variables written after the call(s):
	- newAction.infoHash = _infoHash(actionId,policyholder,role,strategy,target,value,data) (LlamaAbsoluteQuorum.sol#3895)
	- newAction.creationTime = LlamaUtils.toUint64(block.timestamp) (LlamaAbsoluteQuorum.sol#3896)
	- newAction.isScript = authorizedScripts[target] (LlamaAbsoluteQuorum.sol#3897)



    
3886     strategy.validateActionCreation(actionInfo);



    
3891       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);



    
3886     strategy.validateActionCreation(actionInfo);



    
3891       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);



    
3895       newAction.infoHash = _infoHash(actionId, policyholder, role, strategy, target, value, data);



    
3896       newAction.creationTime = LlamaUtils.toUint64(block.timestamp);



    
3897       newAction.isScript = authorizedScripts[target];



```

### LlamaAccount.sol


```
Reentrancy in LlamaFactory._deploy(string,ILlamaStrategy,ILlamaAccount,bytes[],bytes[],RoleDescription[],RoleHolderData[],RolePermissionData[]) (LlamaAccount.sol#3369-3406):
	External calls:
	- policy.initialize(name,initialRoleDescriptions,initialRoleHolders,initialRolePermissions) (LlamaAccount.sol#3393)
	- bootstrapPermissionId = llamaCore.initialize(name,policy,strategyLogic,accountLogic,initialStrategies,initialAccounts) (LlamaAccount.sol#3396-3397)
	- policy.finalizeInitialization(address(llamaExecutor),bootstrapPermissionId) (LlamaAccount.sol#3400)
	State variables written after the call(s):
	- llamaCount = LlamaUtils.uncheckedIncrement(llamaCount) (LlamaAccount.sol#3405)



    
3393     policy.initialize(name, initialRoleDescriptions, initialRoleHolders, initialRolePermissions);



    
3396     bytes32 bootstrapPermissionId =
3397       llamaCore.initialize(name, policy, strategyLogic, accountLogic, initialStrategies, initialAccounts);



    
3400     policy.finalizeInitialization(address(llamaExecutor), bootstrapPermissionId);



    
3393     policy.initialize(name, initialRoleDescriptions, initialRoleHolders, initialRolePermissions);



    
3396     bytes32 bootstrapPermissionId =
3397       llamaCore.initialize(name, policy, strategyLogic, accountLogic, initialStrategies, initialAccounts);



    
3400     policy.finalizeInitialization(address(llamaExecutor), bootstrapPermissionId);



    
3405     llamaCount = LlamaUtils.uncheckedIncrement(llamaCount);



```

```
Reentrancy in LlamaCore._deployStrategies(ILlamaStrategy,bytes[]) (LlamaAccount.sol#4753-4772):
	External calls:
	- strategy.initialize(strategyConfigs[i]) (LlamaAccount.sol#4767)
	State variables written after the call(s):
	- strategies[strategy] = true (LlamaAccount.sol#4768)



    
4767       strategy.initialize(strategyConfigs[i]);



    
4767       strategy.initialize(strategyConfigs[i]);



    
4768       strategies[strategy] = true;



```

```
Reentrancy in LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaAccount.sol#4644-4690):
	External calls:
	- strategy.validateActionCreation(actionInfo) (LlamaAccount.sol#4673)
	- guard.validateActionCreation(actionInfo) (LlamaAccount.sol#4678)
	State variables written after the call(s):
	- newAction.infoHash = _infoHash(actionId,policyholder,role,strategy,target,value,data) (LlamaAccount.sol#4682)
	- newAction.creationTime = LlamaUtils.toUint64(block.timestamp) (LlamaAccount.sol#4683)
	- newAction.isScript = authorizedScripts[target] (LlamaAccount.sol#4684)



    
4673     strategy.validateActionCreation(actionInfo);



    
4678       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);



    
4673     strategy.validateActionCreation(actionInfo);



    
4678       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);



    
4682       newAction.infoHash = _infoHash(actionId, policyholder, role, strategy, target, value, data);



    
4683       newAction.creationTime = LlamaUtils.toUint64(block.timestamp);



    
4684       newAction.isScript = authorizedScripts[target];



```

### LlamaCore.sol


```
Reentrancy in LlamaFactory._deploy(string,ILlamaStrategy,ILlamaAccount,bytes[],bytes[],RoleDescription[],RoleHolderData[],RolePermissionData[]) (LlamaCore.sol#2431-2468):
	External calls:
	- policy.initialize(name,initialRoleDescriptions,initialRoleHolders,initialRolePermissions) (LlamaCore.sol#2455)
	- bootstrapPermissionId = llamaCore.initialize(name,policy,strategyLogic,accountLogic,initialStrategies,initialAccounts) (LlamaCore.sol#2458-2459)
	- policy.finalizeInitialization(address(llamaExecutor),bootstrapPermissionId) (LlamaCore.sol#2462)
	State variables written after the call(s):
	- llamaCount = LlamaUtils.uncheckedIncrement(llamaCount) (LlamaCore.sol#2467)



    
2455     policy.initialize(name, initialRoleDescriptions, initialRoleHolders, initialRolePermissions);



    
2458     bytes32 bootstrapPermissionId =
2459       llamaCore.initialize(name, policy, strategyLogic, accountLogic, initialStrategies, initialAccounts);



    
2462     policy.finalizeInitialization(address(llamaExecutor), bootstrapPermissionId);



    
2455     policy.initialize(name, initialRoleDescriptions, initialRoleHolders, initialRolePermissions);



    
2458     bytes32 bootstrapPermissionId =
2459       llamaCore.initialize(name, policy, strategyLogic, accountLogic, initialStrategies, initialAccounts);



    
2462     policy.finalizeInitialization(address(llamaExecutor), bootstrapPermissionId);



    
2467     llamaCount = LlamaUtils.uncheckedIncrement(llamaCount);



```

```
Reentrancy in LlamaCore._deployStrategies(ILlamaStrategy,bytes[]) (LlamaCore.sol#3815-3834):
	External calls:
	- strategy.initialize(strategyConfigs[i]) (LlamaCore.sol#3829)
	State variables written after the call(s):
	- strategies[strategy] = true (LlamaCore.sol#3830)



    
3829       strategy.initialize(strategyConfigs[i]);



    
3829       strategy.initialize(strategyConfigs[i]);



    
3830       strategies[strategy] = true;



```

```
Reentrancy in LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaCore.sol#3706-3752):
	External calls:
	- strategy.validateActionCreation(actionInfo) (LlamaCore.sol#3735)
	- guard.validateActionCreation(actionInfo) (LlamaCore.sol#3740)
	State variables written after the call(s):
	- newAction.infoHash = _infoHash(actionId,policyholder,role,strategy,target,value,data) (LlamaCore.sol#3744)
	- newAction.creationTime = LlamaUtils.toUint64(block.timestamp) (LlamaCore.sol#3745)
	- newAction.isScript = authorizedScripts[target] (LlamaCore.sol#3746)



    
3735     strategy.validateActionCreation(actionInfo);



    
3740       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);



    
3735     strategy.validateActionCreation(actionInfo);



    
3740       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);



    
3744       newAction.infoHash = _infoHash(actionId, policyholder, role, strategy, target, value, data);



    
3745       newAction.creationTime = LlamaUtils.toUint64(block.timestamp);



    
3746       newAction.isScript = authorizedScripts[target];



```

### LlamaFactory.sol


```
Reentrancy in LlamaCore._deployStrategies(ILlamaStrategy,bytes[]) (LlamaFactory.sol#3152-3171):
	External calls:
	- strategy.initialize(strategyConfigs[i]) (LlamaFactory.sol#3166)
	State variables written after the call(s):
	- strategies[strategy] = true (LlamaFactory.sol#3167)



    
3166       strategy.initialize(strategyConfigs[i]);



    
3166       strategy.initialize(strategyConfigs[i]);



    
3167       strategies[strategy] = true;



```

```
Reentrancy in LlamaFactory._deploy(string,ILlamaStrategy,ILlamaAccount,bytes[],bytes[],RoleDescription[],RoleHolderData[],RolePermissionData[]) (LlamaFactory.sol#3931-3968):
	External calls:
	- policy.initialize(name,initialRoleDescriptions,initialRoleHolders,initialRolePermissions) (LlamaFactory.sol#3955)
	- bootstrapPermissionId = llamaCore.initialize(name,policy,strategyLogic,accountLogic,initialStrategies,initialAccounts) (LlamaFactory.sol#3958-3959)
	- policy.finalizeInitialization(address(llamaExecutor),bootstrapPermissionId) (LlamaFactory.sol#3962)
	State variables written after the call(s):
	- llamaCount = LlamaUtils.uncheckedIncrement(llamaCount) (LlamaFactory.sol#3967)



    
3955     policy.initialize(name, initialRoleDescriptions, initialRoleHolders, initialRolePermissions);



    
3958     bytes32 bootstrapPermissionId =
3959       llamaCore.initialize(name, policy, strategyLogic, accountLogic, initialStrategies, initialAccounts);



    
3962     policy.finalizeInitialization(address(llamaExecutor), bootstrapPermissionId);



    
3955     policy.initialize(name, initialRoleDescriptions, initialRoleHolders, initialRolePermissions);



    
3958     bytes32 bootstrapPermissionId =
3959       llamaCore.initialize(name, policy, strategyLogic, accountLogic, initialStrategies, initialAccounts);



    
3962     policy.finalizeInitialization(address(llamaExecutor), bootstrapPermissionId);



    
3967     llamaCount = LlamaUtils.uncheckedIncrement(llamaCount);



```

```
Reentrancy in LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaFactory.sol#3043-3089):
	External calls:
	- strategy.validateActionCreation(actionInfo) (LlamaFactory.sol#3072)
	- guard.validateActionCreation(actionInfo) (LlamaFactory.sol#3077)
	State variables written after the call(s):
	- newAction.infoHash = _infoHash(actionId,policyholder,role,strategy,target,value,data) (LlamaFactory.sol#3081)
	- newAction.creationTime = LlamaUtils.toUint64(block.timestamp) (LlamaFactory.sol#3082)
	- newAction.isScript = authorizedScripts[target] (LlamaFactory.sol#3083)



    
3072     strategy.validateActionCreation(actionInfo);



    
3077       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);



    
3072     strategy.validateActionCreation(actionInfo);



    
3077       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);



    
3081       newAction.infoHash = _infoHash(actionId, policyholder, role, strategy, target, value, data);



    
3082       newAction.creationTime = LlamaUtils.toUint64(block.timestamp);



    
3083       newAction.isScript = authorizedScripts[target];



```

### LlamaGovernanceScript.sol


```
Reentrancy in LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaGovernanceScript.sol#3625-3671):
	External calls:
	- strategy.validateActionCreation(actionInfo) (LlamaGovernanceScript.sol#3654)
	- guard.validateActionCreation(actionInfo) (LlamaGovernanceScript.sol#3659)
	State variables written after the call(s):
	- newAction.infoHash = _infoHash(actionId,policyholder,role,strategy,target,value,data) (LlamaGovernanceScript.sol#3663)
	- newAction.creationTime = LlamaUtils.toUint64(block.timestamp) (LlamaGovernanceScript.sol#3664)
	- newAction.isScript = authorizedScripts[target] (LlamaGovernanceScript.sol#3665)



    
3654     strategy.validateActionCreation(actionInfo);



    
3659       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);



    
3654     strategy.validateActionCreation(actionInfo);



    
3659       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);



    
3663       newAction.infoHash = _infoHash(actionId, policyholder, role, strategy, target, value, data);



    
3664       newAction.creationTime = LlamaUtils.toUint64(block.timestamp);



    
3665       newAction.isScript = authorizedScripts[target];



```

```
Reentrancy in LlamaFactory._deploy(string,ILlamaStrategy,ILlamaAccount,bytes[],bytes[],RoleDescription[],RoleHolderData[],RolePermissionData[]) (LlamaGovernanceScript.sol#3062-3099):
	External calls:
	- policy.initialize(name,initialRoleDescriptions,initialRoleHolders,initialRolePermissions) (LlamaGovernanceScript.sol#3086)
	- bootstrapPermissionId = llamaCore.initialize(name,policy,strategyLogic,accountLogic,initialStrategies,initialAccounts) (LlamaGovernanceScript.sol#3089-3090)
	- policy.finalizeInitialization(address(llamaExecutor),bootstrapPermissionId) (LlamaGovernanceScript.sol#3093)
	State variables written after the call(s):
	- llamaCount = LlamaUtils.uncheckedIncrement(llamaCount) (LlamaGovernanceScript.sol#3098)



    
3086     policy.initialize(name, initialRoleDescriptions, initialRoleHolders, initialRolePermissions);



    
3089     bytes32 bootstrapPermissionId =
3090       llamaCore.initialize(name, policy, strategyLogic, accountLogic, initialStrategies, initialAccounts);



    
3093     policy.finalizeInitialization(address(llamaExecutor), bootstrapPermissionId);



    
3086     policy.initialize(name, initialRoleDescriptions, initialRoleHolders, initialRolePermissions);



    
3089     bytes32 bootstrapPermissionId =
3090       llamaCore.initialize(name, policy, strategyLogic, accountLogic, initialStrategies, initialAccounts);



    
3093     policy.finalizeInitialization(address(llamaExecutor), bootstrapPermissionId);



    
3098     llamaCount = LlamaUtils.uncheckedIncrement(llamaCount);



```

```
Reentrancy in LlamaCore._deployStrategies(ILlamaStrategy,bytes[]) (LlamaGovernanceScript.sol#3734-3753):
	External calls:
	- strategy.initialize(strategyConfigs[i]) (LlamaGovernanceScript.sol#3748)
	State variables written after the call(s):
	- strategies[strategy] = true (LlamaGovernanceScript.sol#3749)



    
3748       strategy.initialize(strategyConfigs[i]);



    
3748       strategy.initialize(strategyConfigs[i]);



    
3749       strategies[strategy] = true;



```

### LlamaPolicy.sol


```
Reentrancy in LlamaCore._deployStrategies(ILlamaStrategy,bytes[]) (LlamaPolicy.sol#3141-3160):
	External calls:
	- strategy.initialize(strategyConfigs[i]) (LlamaPolicy.sol#3155)
	State variables written after the call(s):
	- strategies[strategy] = true (LlamaPolicy.sol#3156)



    
3155       strategy.initialize(strategyConfigs[i]);



    
3155       strategy.initialize(strategyConfigs[i]);



    
3156       strategies[strategy] = true;



```

```
Reentrancy in LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaPolicy.sol#3032-3078):
	External calls:
	- strategy.validateActionCreation(actionInfo) (LlamaPolicy.sol#3061)
	- guard.validateActionCreation(actionInfo) (LlamaPolicy.sol#3066)
	State variables written after the call(s):
	- newAction.infoHash = _infoHash(actionId,policyholder,role,strategy,target,value,data) (LlamaPolicy.sol#3070)
	- newAction.creationTime = LlamaUtils.toUint64(block.timestamp) (LlamaPolicy.sol#3071)
	- newAction.isScript = authorizedScripts[target] (LlamaPolicy.sol#3072)



    
3061     strategy.validateActionCreation(actionInfo);



    
3066       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);



    
3061     strategy.validateActionCreation(actionInfo);



    
3066       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);



    
3070       newAction.infoHash = _infoHash(actionId, policyholder, role, strategy, target, value, data);



    
3071       newAction.creationTime = LlamaUtils.toUint64(block.timestamp);



    
3072       newAction.isScript = authorizedScripts[target];



```

```
Reentrancy in LlamaFactory._deploy(string,ILlamaStrategy,ILlamaAccount,bytes[],bytes[],RoleDescription[],RoleHolderData[],RolePermissionData[]) (LlamaPolicy.sol#2469-2506):
	External calls:
	- policy.initialize(name,initialRoleDescriptions,initialRoleHolders,initialRolePermissions) (LlamaPolicy.sol#2493)
	- bootstrapPermissionId = llamaCore.initialize(name,policy,strategyLogic,accountLogic,initialStrategies,initialAccounts) (LlamaPolicy.sol#2496-2497)
	- policy.finalizeInitialization(address(llamaExecutor),bootstrapPermissionId) (LlamaPolicy.sol#2500)
	State variables written after the call(s):
	- llamaCount = LlamaUtils.uncheckedIncrement(llamaCount) (LlamaPolicy.sol#2505)



    
2493     policy.initialize(name, initialRoleDescriptions, initialRoleHolders, initialRolePermissions);



    
2496     bytes32 bootstrapPermissionId =
2497       llamaCore.initialize(name, policy, strategyLogic, accountLogic, initialStrategies, initialAccounts);



    
2500     policy.finalizeInitialization(address(llamaExecutor), bootstrapPermissionId);



    
2493     policy.initialize(name, initialRoleDescriptions, initialRoleHolders, initialRolePermissions);



    
2496     bytes32 bootstrapPermissionId =
2497       llamaCore.initialize(name, policy, strategyLogic, accountLogic, initialStrategies, initialAccounts);



    
2500     policy.finalizeInitialization(address(llamaExecutor), bootstrapPermissionId);



    
2505     llamaCount = LlamaUtils.uncheckedIncrement(llamaCount);



```

### LlamaRelativeQuorum.sol


```
Reentrancy in LlamaFactory._deploy(string,ILlamaStrategy,ILlamaAccount,bytes[],bytes[],RoleDescription[],RoleHolderData[],RolePermissionData[]) (LlamaRelativeQuorum.sol#3294-3331):
	External calls:
	- policy.initialize(name,initialRoleDescriptions,initialRoleHolders,initialRolePermissions) (LlamaRelativeQuorum.sol#3318)
	- bootstrapPermissionId = llamaCore.initialize(name,policy,strategyLogic,accountLogic,initialStrategies,initialAccounts) (LlamaRelativeQuorum.sol#3321-3322)
	- policy.finalizeInitialization(address(llamaExecutor),bootstrapPermissionId) (LlamaRelativeQuorum.sol#3325)
	State variables written after the call(s):
	- llamaCount = LlamaUtils.uncheckedIncrement(llamaCount) (LlamaRelativeQuorum.sol#3330)



    
3318     policy.initialize(name, initialRoleDescriptions, initialRoleHolders, initialRolePermissions);



    
3321     bytes32 bootstrapPermissionId =
3322       llamaCore.initialize(name, policy, strategyLogic, accountLogic, initialStrategies, initialAccounts);



    
3325     policy.finalizeInitialization(address(llamaExecutor), bootstrapPermissionId);



    
3318     policy.initialize(name, initialRoleDescriptions, initialRoleHolders, initialRolePermissions);



    
3321     bytes32 bootstrapPermissionId =
3322       llamaCore.initialize(name, policy, strategyLogic, accountLogic, initialStrategies, initialAccounts);



    
3325     policy.finalizeInitialization(address(llamaExecutor), bootstrapPermissionId);



    
3330     llamaCount = LlamaUtils.uncheckedIncrement(llamaCount);



```

```
Reentrancy in LlamaCore._deployStrategies(ILlamaStrategy,bytes[]) (LlamaRelativeQuorum.sol#3966-3985):
	External calls:
	- strategy.initialize(strategyConfigs[i]) (LlamaRelativeQuorum.sol#3980)
	State variables written after the call(s):
	- strategies[strategy] = true (LlamaRelativeQuorum.sol#3981)



    
3980       strategy.initialize(strategyConfigs[i]);



    
3980       strategy.initialize(strategyConfigs[i]);



    
3981       strategies[strategy] = true;



```

```
Reentrancy in LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaRelativeQuorum.sol#3857-3903):
	External calls:
	- strategy.validateActionCreation(actionInfo) (LlamaRelativeQuorum.sol#3886)
	- guard.validateActionCreation(actionInfo) (LlamaRelativeQuorum.sol#3891)
	State variables written after the call(s):
	- newAction.infoHash = _infoHash(actionId,policyholder,role,strategy,target,value,data) (LlamaRelativeQuorum.sol#3895)
	- newAction.creationTime = LlamaUtils.toUint64(block.timestamp) (LlamaRelativeQuorum.sol#3896)
	- newAction.isScript = authorizedScripts[target] (LlamaRelativeQuorum.sol#3897)



    
3886     strategy.validateActionCreation(actionInfo);



    
3891       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);



    
3886     strategy.validateActionCreation(actionInfo);



    
3891       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);



    
3895       newAction.infoHash = _infoHash(actionId, policyholder, role, strategy, target, value, data);



    
3896       newAction.creationTime = LlamaUtils.toUint64(block.timestamp);



    
3897       newAction.isScript = authorizedScripts[target];



```

## reentrancy-events
### Severity: Low

### LlamaAbsolutePeerReview.sol


```
Reentrancy in LlamaCore.cancelAction(ActionInfo) (LlamaAbsolutePeerReview.sol#3689-3699):
	External calls:
	- actionInfo.strategy.validateActionCancelation(actionInfo,msg.sender) (LlamaAbsolutePeerReview.sol#3695)
	Event emitted after the call(s):
	- ActionCanceled(actionInfo.id) (LlamaAbsolutePeerReview.sol#3698)



    
3695     actionInfo.strategy.validateActionCancelation(actionInfo, msg.sender);



    
3698     emit ActionCanceled(actionInfo.id);



```

```
Reentrancy in LlamaCore._castDisapproval(address,uint8,ActionInfo,string) (LlamaAbsolutePeerReview.sol#3917-3925):
	External calls:
	- (action,quantity) = _preCastAssertions(actionInfo,policyholder,role,ActionState.Queued) (LlamaAbsolutePeerReview.sol#3920)
		- actionInfo.strategy.isApprovalEnabled(actionInfo,policyholder,role) (LlamaAbsolutePeerReview.sol#3946)
		- actionInfo.strategy.isDisapprovalEnabled(actionInfo,policyholder,role) (LlamaAbsolutePeerReview.sol#3950)
	Event emitted after the call(s):
	- DisapprovalCast(actionInfo.id,policyholder,role,quantity,reason) (LlamaAbsolutePeerReview.sol#3924)



    
3920     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Queued);



    
3946       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);



    
3950       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);



    
3924     emit DisapprovalCast(actionInfo.id, policyholder, role, quantity, reason);



```

```
Reentrancy in LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[]) (LlamaAbsolutePeerReview.sol#3565-3584):
	External calls:
	- bootstrapStrategy = _deployStrategies(_llamaStrategyLogic,initialStrategies) (LlamaAbsolutePeerReview.sol#3578)
		- strategy.initialize(strategyConfigs[i]) (LlamaAbsolutePeerReview.sol#3980)
	- _deployAccounts(_llamaAccountLogic,initialAccounts) (LlamaAbsolutePeerReview.sol#3579)
		- account.initialize(accountConfigs[i]) (LlamaAbsolutePeerReview.sol#4000)
	Event emitted after the call(s):
	- AccountCreated(account,llamaAccountLogic,accountConfigs[i]) (LlamaAbsolutePeerReview.sol#4001)
		- _deployAccounts(_llamaAccountLogic,initialAccounts) (LlamaAbsolutePeerReview.sol#3579)



    
3578     ILlamaStrategy bootstrapStrategy = _deployStrategies(_llamaStrategyLogic, initialStrategies);



    
3980       strategy.initialize(strategyConfigs[i]);



    
3579     _deployAccounts(_llamaAccountLogic, initialAccounts);



    
4000       account.initialize(accountConfigs[i]);



    
4001       emit AccountCreated(account, llamaAccountLogic, accountConfigs[i]);



    
3579     _deployAccounts(_llamaAccountLogic, initialAccounts);



```

```
Reentrancy in LlamaCore._deployStrategies(ILlamaStrategy,bytes[]) (LlamaAbsolutePeerReview.sol#3966-3985):
	External calls:
	- strategy.initialize(strategyConfigs[i]) (LlamaAbsolutePeerReview.sol#3980)
	Event emitted after the call(s):
	- StrategyCreated(strategy,llamaStrategyLogic,strategyConfigs[i]) (LlamaAbsolutePeerReview.sol#3982)



    
3980       strategy.initialize(strategyConfigs[i]);



    
3982       emit StrategyCreated(strategy, llamaStrategyLogic, strategyConfigs[i]);



```

```
Reentrancy in LlamaCore._deployAccounts(ILlamaAccount,bytes[]) (LlamaAbsolutePeerReview.sol#3989-4003):
	External calls:
	- account.initialize(accountConfigs[i]) (LlamaAbsolutePeerReview.sol#4000)
	Event emitted after the call(s):
	- AccountCreated(account,llamaAccountLogic,accountConfigs[i]) (LlamaAbsolutePeerReview.sol#4001)



    
4000       account.initialize(accountConfigs[i]);



    
4001       emit AccountCreated(account, llamaAccountLogic, accountConfigs[i]);



```

```
Reentrancy in LlamaFactory._deploy(string,ILlamaStrategy,ILlamaAccount,bytes[],bytes[],RoleDescription[],RoleHolderData[],RolePermissionData[]) (LlamaAbsolutePeerReview.sol#3294-3331):
	External calls:
	- policy.initialize(name,initialRoleDescriptions,initialRoleHolders,initialRolePermissions) (LlamaAbsolutePeerReview.sol#3318)
	- bootstrapPermissionId = llamaCore.initialize(name,policy,strategyLogic,accountLogic,initialStrategies,initialAccounts) (LlamaAbsolutePeerReview.sol#3321-3322)
	- policy.finalizeInitialization(address(llamaExecutor),bootstrapPermissionId) (LlamaAbsolutePeerReview.sol#3325)
	Event emitted after the call(s):
	- LlamaInstanceCreated(llamaCount,name,address(llamaCore),address(llamaExecutor),address(policy),block.chainid) (LlamaAbsolutePeerReview.sol#3327-3329)



    
3318     policy.initialize(name, initialRoleDescriptions, initialRoleHolders, initialRolePermissions);



    
3321     bytes32 bootstrapPermissionId =
3322       llamaCore.initialize(name, policy, strategyLogic, accountLogic, initialStrategies, initialAccounts);



    
3325     policy.finalizeInitialization(address(llamaExecutor), bootstrapPermissionId);



    
3327     emit LlamaInstanceCreated(
3328       llamaCount, name, address(llamaCore), address(llamaExecutor), address(policy), block.chainid
3329     );



```

```
Reentrancy in LlamaCore._castApproval(address,uint8,ActionInfo,string) (LlamaAbsolutePeerReview.sol#3906-3914):
	External calls:
	- (action,quantity) = _preCastAssertions(actionInfo,policyholder,role,ActionState.Active) (LlamaAbsolutePeerReview.sol#3909)
		- actionInfo.strategy.isApprovalEnabled(actionInfo,policyholder,role) (LlamaAbsolutePeerReview.sol#3946)
		- actionInfo.strategy.isDisapprovalEnabled(actionInfo,policyholder,role) (LlamaAbsolutePeerReview.sol#3950)
	Event emitted after the call(s):
	- ApprovalCast(actionInfo.id,policyholder,role,quantity,reason) (LlamaAbsolutePeerReview.sol#3913)



    
3909     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Active);



    
3946       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);



    
3950       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);



    
3913     emit ApprovalCast(actionInfo.id, policyholder, role, quantity, reason);



```

```
Reentrancy in LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaAbsolutePeerReview.sol#3857-3903):
	External calls:
	- strategy.validateActionCreation(actionInfo) (LlamaAbsolutePeerReview.sol#3886)
	- guard.validateActionCreation(actionInfo) (LlamaAbsolutePeerReview.sol#3891)
	Event emitted after the call(s):
	- ActionCreated(actionId,policyholder,role,strategy,target,value,data,description) (LlamaAbsolutePeerReview.sol#3902)



    
3886     strategy.validateActionCreation(actionInfo);



    
3891       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);



    
3902     emit ActionCreated(actionId, policyholder, role, strategy, target, value, data, description);



```

```
Reentrancy in LlamaCore.executeAction(ActionInfo) (LlamaAbsolutePeerReview.sol#3658-3684):
	External calls:
	- guard.validatePreActionExecution(actionInfo) (LlamaAbsolutePeerReview.sol#3671)
	- (success,result) = executor.execute(actionInfo.target,actionInfo.value,action.isScript,actionInfo.data) (LlamaAbsolutePeerReview.sol#3674-3675)
	- guard.validatePostActionExecution(actionInfo) (LlamaAbsolutePeerReview.sol#3680)
	Event emitted after the call(s):
	- ActionExecuted(actionInfo.id,msg.sender,actionInfo.strategy,actionInfo.creator,result) (LlamaAbsolutePeerReview.sol#3683)



    
3671     if (guard != ILlamaActionGuard(address(0))) guard.validatePreActionExecution(actionInfo);



    
3674     (bool success, bytes memory result) =
3675       executor.execute(actionInfo.target, actionInfo.value, action.isScript, actionInfo.data);



    
3680     if (guard != ILlamaActionGuard(address(0))) guard.validatePostActionExecution(actionInfo);



    
3683     emit ActionExecuted(actionInfo.id, msg.sender, actionInfo.strategy, actionInfo.creator, result);



```

### LlamaAbsoluteQuorum.sol


```
Reentrancy in LlamaCore.cancelAction(ActionInfo) (LlamaAbsoluteQuorum.sol#3689-3699):
	External calls:
	- actionInfo.strategy.validateActionCancelation(actionInfo,msg.sender) (LlamaAbsoluteQuorum.sol#3695)
	Event emitted after the call(s):
	- ActionCanceled(actionInfo.id) (LlamaAbsoluteQuorum.sol#3698)



    
3695     actionInfo.strategy.validateActionCancelation(actionInfo, msg.sender);



    
3698     emit ActionCanceled(actionInfo.id);



```

```
Reentrancy in LlamaCore._castDisapproval(address,uint8,ActionInfo,string) (LlamaAbsoluteQuorum.sol#3917-3925):
	External calls:
	- (action,quantity) = _preCastAssertions(actionInfo,policyholder,role,ActionState.Queued) (LlamaAbsoluteQuorum.sol#3920)
		- actionInfo.strategy.isApprovalEnabled(actionInfo,policyholder,role) (LlamaAbsoluteQuorum.sol#3946)
		- actionInfo.strategy.isDisapprovalEnabled(actionInfo,policyholder,role) (LlamaAbsoluteQuorum.sol#3950)
	Event emitted after the call(s):
	- DisapprovalCast(actionInfo.id,policyholder,role,quantity,reason) (LlamaAbsoluteQuorum.sol#3924)



    
3920     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Queued);



    
3946       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);



    
3950       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);



    
3924     emit DisapprovalCast(actionInfo.id, policyholder, role, quantity, reason);



```

```
Reentrancy in LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[]) (LlamaAbsoluteQuorum.sol#3565-3584):
	External calls:
	- bootstrapStrategy = _deployStrategies(_llamaStrategyLogic,initialStrategies) (LlamaAbsoluteQuorum.sol#3578)
		- strategy.initialize(strategyConfigs[i]) (LlamaAbsoluteQuorum.sol#3980)
	- _deployAccounts(_llamaAccountLogic,initialAccounts) (LlamaAbsoluteQuorum.sol#3579)
		- account.initialize(accountConfigs[i]) (LlamaAbsoluteQuorum.sol#4000)
	Event emitted after the call(s):
	- AccountCreated(account,llamaAccountLogic,accountConfigs[i]) (LlamaAbsoluteQuorum.sol#4001)
		- _deployAccounts(_llamaAccountLogic,initialAccounts) (LlamaAbsoluteQuorum.sol#3579)



    
3578     ILlamaStrategy bootstrapStrategy = _deployStrategies(_llamaStrategyLogic, initialStrategies);



    
3980       strategy.initialize(strategyConfigs[i]);



    
3579     _deployAccounts(_llamaAccountLogic, initialAccounts);



    
4000       account.initialize(accountConfigs[i]);



    
4001       emit AccountCreated(account, llamaAccountLogic, accountConfigs[i]);



    
3579     _deployAccounts(_llamaAccountLogic, initialAccounts);



```

```
Reentrancy in LlamaCore._deployStrategies(ILlamaStrategy,bytes[]) (LlamaAbsoluteQuorum.sol#3966-3985):
	External calls:
	- strategy.initialize(strategyConfigs[i]) (LlamaAbsoluteQuorum.sol#3980)
	Event emitted after the call(s):
	- StrategyCreated(strategy,llamaStrategyLogic,strategyConfigs[i]) (LlamaAbsoluteQuorum.sol#3982)



    
3980       strategy.initialize(strategyConfigs[i]);



    
3982       emit StrategyCreated(strategy, llamaStrategyLogic, strategyConfigs[i]);



```

```
Reentrancy in LlamaCore._deployAccounts(ILlamaAccount,bytes[]) (LlamaAbsoluteQuorum.sol#3989-4003):
	External calls:
	- account.initialize(accountConfigs[i]) (LlamaAbsoluteQuorum.sol#4000)
	Event emitted after the call(s):
	- AccountCreated(account,llamaAccountLogic,accountConfigs[i]) (LlamaAbsoluteQuorum.sol#4001)



    
4000       account.initialize(accountConfigs[i]);



    
4001       emit AccountCreated(account, llamaAccountLogic, accountConfigs[i]);



```

```
Reentrancy in LlamaFactory._deploy(string,ILlamaStrategy,ILlamaAccount,bytes[],bytes[],RoleDescription[],RoleHolderData[],RolePermissionData[]) (LlamaAbsoluteQuorum.sol#3294-3331):
	External calls:
	- policy.initialize(name,initialRoleDescriptions,initialRoleHolders,initialRolePermissions) (LlamaAbsoluteQuorum.sol#3318)
	- bootstrapPermissionId = llamaCore.initialize(name,policy,strategyLogic,accountLogic,initialStrategies,initialAccounts) (LlamaAbsoluteQuorum.sol#3321-3322)
	- policy.finalizeInitialization(address(llamaExecutor),bootstrapPermissionId) (LlamaAbsoluteQuorum.sol#3325)
	Event emitted after the call(s):
	- LlamaInstanceCreated(llamaCount,name,address(llamaCore),address(llamaExecutor),address(policy),block.chainid) (LlamaAbsoluteQuorum.sol#3327-3329)



    
3318     policy.initialize(name, initialRoleDescriptions, initialRoleHolders, initialRolePermissions);



    
3321     bytes32 bootstrapPermissionId =
3322       llamaCore.initialize(name, policy, strategyLogic, accountLogic, initialStrategies, initialAccounts);



    
3325     policy.finalizeInitialization(address(llamaExecutor), bootstrapPermissionId);



    
3327     emit LlamaInstanceCreated(
3328       llamaCount, name, address(llamaCore), address(llamaExecutor), address(policy), block.chainid
3329     );



```

```
Reentrancy in LlamaCore._castApproval(address,uint8,ActionInfo,string) (LlamaAbsoluteQuorum.sol#3906-3914):
	External calls:
	- (action,quantity) = _preCastAssertions(actionInfo,policyholder,role,ActionState.Active) (LlamaAbsoluteQuorum.sol#3909)
		- actionInfo.strategy.isApprovalEnabled(actionInfo,policyholder,role) (LlamaAbsoluteQuorum.sol#3946)
		- actionInfo.strategy.isDisapprovalEnabled(actionInfo,policyholder,role) (LlamaAbsoluteQuorum.sol#3950)
	Event emitted after the call(s):
	- ApprovalCast(actionInfo.id,policyholder,role,quantity,reason) (LlamaAbsoluteQuorum.sol#3913)



    
3909     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Active);



    
3946       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);



    
3950       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);



    
3913     emit ApprovalCast(actionInfo.id, policyholder, role, quantity, reason);



```

```
Reentrancy in LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaAbsoluteQuorum.sol#3857-3903):
	External calls:
	- strategy.validateActionCreation(actionInfo) (LlamaAbsoluteQuorum.sol#3886)
	- guard.validateActionCreation(actionInfo) (LlamaAbsoluteQuorum.sol#3891)
	Event emitted after the call(s):
	- ActionCreated(actionId,policyholder,role,strategy,target,value,data,description) (LlamaAbsoluteQuorum.sol#3902)



    
3886     strategy.validateActionCreation(actionInfo);



    
3891       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);



    
3902     emit ActionCreated(actionId, policyholder, role, strategy, target, value, data, description);



```

```
Reentrancy in LlamaCore.executeAction(ActionInfo) (LlamaAbsoluteQuorum.sol#3658-3684):
	External calls:
	- guard.validatePreActionExecution(actionInfo) (LlamaAbsoluteQuorum.sol#3671)
	- (success,result) = executor.execute(actionInfo.target,actionInfo.value,action.isScript,actionInfo.data) (LlamaAbsoluteQuorum.sol#3674-3675)
	- guard.validatePostActionExecution(actionInfo) (LlamaAbsoluteQuorum.sol#3680)
	Event emitted after the call(s):
	- ActionExecuted(actionInfo.id,msg.sender,actionInfo.strategy,actionInfo.creator,result) (LlamaAbsoluteQuorum.sol#3683)



    
3671     if (guard != ILlamaActionGuard(address(0))) guard.validatePreActionExecution(actionInfo);



    
3674     (bool success, bytes memory result) =
3675       executor.execute(actionInfo.target, actionInfo.value, action.isScript, actionInfo.data);



    
3680     if (guard != ILlamaActionGuard(address(0))) guard.validatePostActionExecution(actionInfo);



    
3683     emit ActionExecuted(actionInfo.id, msg.sender, actionInfo.strategy, actionInfo.creator, result);



```

### LlamaAccount.sol


```
Reentrancy in LlamaCore._castDisapproval(address,uint8,ActionInfo,string) (LlamaAccount.sol#4704-4712):
	External calls:
	- (action,quantity) = _preCastAssertions(actionInfo,policyholder,role,ActionState.Queued) (LlamaAccount.sol#4707)
		- actionInfo.strategy.isApprovalEnabled(actionInfo,policyholder,role) (LlamaAccount.sol#4733)
		- actionInfo.strategy.isDisapprovalEnabled(actionInfo,policyholder,role) (LlamaAccount.sol#4737)
	Event emitted after the call(s):
	- DisapprovalCast(actionInfo.id,policyholder,role,quantity,reason) (LlamaAccount.sol#4711)



    
4707     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Queued);



    
4733       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);



    
4737       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);



    
4711     emit DisapprovalCast(actionInfo.id, policyholder, role, quantity, reason);



```

```
Reentrancy in LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[]) (LlamaAccount.sol#4352-4371):
	External calls:
	- bootstrapStrategy = _deployStrategies(_llamaStrategyLogic,initialStrategies) (LlamaAccount.sol#4365)
		- strategy.initialize(strategyConfigs[i]) (LlamaAccount.sol#4767)
	- _deployAccounts(_llamaAccountLogic,initialAccounts) (LlamaAccount.sol#4366)
		- account.initialize(accountConfigs[i]) (LlamaAccount.sol#4787)
	Event emitted after the call(s):
	- AccountCreated(account,llamaAccountLogic,accountConfigs[i]) (LlamaAccount.sol#4788)
		- _deployAccounts(_llamaAccountLogic,initialAccounts) (LlamaAccount.sol#4366)



    
4365     ILlamaStrategy bootstrapStrategy = _deployStrategies(_llamaStrategyLogic, initialStrategies);



    
4767       strategy.initialize(strategyConfigs[i]);



    
4366     _deployAccounts(_llamaAccountLogic, initialAccounts);



    
4787       account.initialize(accountConfigs[i]);



    
4788       emit AccountCreated(account, llamaAccountLogic, accountConfigs[i]);



    
4366     _deployAccounts(_llamaAccountLogic, initialAccounts);



```

```
Reentrancy in LlamaCore._deployStrategies(ILlamaStrategy,bytes[]) (LlamaAccount.sol#4753-4772):
	External calls:
	- strategy.initialize(strategyConfigs[i]) (LlamaAccount.sol#4767)
	Event emitted after the call(s):
	- StrategyCreated(strategy,llamaStrategyLogic,strategyConfigs[i]) (LlamaAccount.sol#4769)



    
4767       strategy.initialize(strategyConfigs[i]);



    
4769       emit StrategyCreated(strategy, llamaStrategyLogic, strategyConfigs[i]);



```

```
Reentrancy in LlamaCore._deployAccounts(ILlamaAccount,bytes[]) (LlamaAccount.sol#4776-4790):
	External calls:
	- account.initialize(accountConfigs[i]) (LlamaAccount.sol#4787)
	Event emitted after the call(s):
	- AccountCreated(account,llamaAccountLogic,accountConfigs[i]) (LlamaAccount.sol#4788)



    
4787       account.initialize(accountConfigs[i]);



    
4788       emit AccountCreated(account, llamaAccountLogic, accountConfigs[i]);



```

```
Reentrancy in LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaAccount.sol#4644-4690):
	External calls:
	- strategy.validateActionCreation(actionInfo) (LlamaAccount.sol#4673)
	- guard.validateActionCreation(actionInfo) (LlamaAccount.sol#4678)
	Event emitted after the call(s):
	- ActionCreated(actionId,policyholder,role,strategy,target,value,data,description) (LlamaAccount.sol#4689)



    
4673     strategy.validateActionCreation(actionInfo);



    
4678       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);



    
4689     emit ActionCreated(actionId, policyholder, role, strategy, target, value, data, description);



```

```
Reentrancy in LlamaFactory._deploy(string,ILlamaStrategy,ILlamaAccount,bytes[],bytes[],RoleDescription[],RoleHolderData[],RolePermissionData[]) (LlamaAccount.sol#3369-3406):
	External calls:
	- policy.initialize(name,initialRoleDescriptions,initialRoleHolders,initialRolePermissions) (LlamaAccount.sol#3393)
	- bootstrapPermissionId = llamaCore.initialize(name,policy,strategyLogic,accountLogic,initialStrategies,initialAccounts) (LlamaAccount.sol#3396-3397)
	- policy.finalizeInitialization(address(llamaExecutor),bootstrapPermissionId) (LlamaAccount.sol#3400)
	Event emitted after the call(s):
	- LlamaInstanceCreated(llamaCount,name,address(llamaCore),address(llamaExecutor),address(policy),block.chainid) (LlamaAccount.sol#3402-3404)



    
3393     policy.initialize(name, initialRoleDescriptions, initialRoleHolders, initialRolePermissions);



    
3396     bytes32 bootstrapPermissionId =
3397       llamaCore.initialize(name, policy, strategyLogic, accountLogic, initialStrategies, initialAccounts);



    
3400     policy.finalizeInitialization(address(llamaExecutor), bootstrapPermissionId);



    
3402     emit LlamaInstanceCreated(
3403       llamaCount, name, address(llamaCore), address(llamaExecutor), address(policy), block.chainid
3404     );



```

```
Reentrancy in LlamaCore.executeAction(ActionInfo) (LlamaAccount.sol#4445-4471):
	External calls:
	- guard.validatePreActionExecution(actionInfo) (LlamaAccount.sol#4458)
	- (success,result) = executor.execute(actionInfo.target,actionInfo.value,action.isScript,actionInfo.data) (LlamaAccount.sol#4461-4462)
	- guard.validatePostActionExecution(actionInfo) (LlamaAccount.sol#4467)
	Event emitted after the call(s):
	- ActionExecuted(actionInfo.id,msg.sender,actionInfo.strategy,actionInfo.creator,result) (LlamaAccount.sol#4470)



    
4458     if (guard != ILlamaActionGuard(address(0))) guard.validatePreActionExecution(actionInfo);



    
4461     (bool success, bytes memory result) =
4462       executor.execute(actionInfo.target, actionInfo.value, action.isScript, actionInfo.data);



    
4467     if (guard != ILlamaActionGuard(address(0))) guard.validatePostActionExecution(actionInfo);



    
4470     emit ActionExecuted(actionInfo.id, msg.sender, actionInfo.strategy, actionInfo.creator, result);



```

```
Reentrancy in LlamaCore._castApproval(address,uint8,ActionInfo,string) (LlamaAccount.sol#4693-4701):
	External calls:
	- (action,quantity) = _preCastAssertions(actionInfo,policyholder,role,ActionState.Active) (LlamaAccount.sol#4696)
		- actionInfo.strategy.isApprovalEnabled(actionInfo,policyholder,role) (LlamaAccount.sol#4733)
		- actionInfo.strategy.isDisapprovalEnabled(actionInfo,policyholder,role) (LlamaAccount.sol#4737)
	Event emitted after the call(s):
	- ApprovalCast(actionInfo.id,policyholder,role,quantity,reason) (LlamaAccount.sol#4700)



    
4696     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Active);



    
4733       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);



    
4737       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);



    
4700     emit ApprovalCast(actionInfo.id, policyholder, role, quantity, reason);



```

```
Reentrancy in LlamaCore.cancelAction(ActionInfo) (LlamaAccount.sol#4476-4486):
	External calls:
	- actionInfo.strategy.validateActionCancelation(actionInfo,msg.sender) (LlamaAccount.sol#4482)
	Event emitted after the call(s):
	- ActionCanceled(actionInfo.id) (LlamaAccount.sol#4485)



    
4482     actionInfo.strategy.validateActionCancelation(actionInfo, msg.sender);



    
4485     emit ActionCanceled(actionInfo.id);



```

### LlamaCore.sol


```
Reentrancy in LlamaFactory._deploy(string,ILlamaStrategy,ILlamaAccount,bytes[],bytes[],RoleDescription[],RoleHolderData[],RolePermissionData[]) (LlamaCore.sol#2431-2468):
	External calls:
	- policy.initialize(name,initialRoleDescriptions,initialRoleHolders,initialRolePermissions) (LlamaCore.sol#2455)
	- bootstrapPermissionId = llamaCore.initialize(name,policy,strategyLogic,accountLogic,initialStrategies,initialAccounts) (LlamaCore.sol#2458-2459)
	- policy.finalizeInitialization(address(llamaExecutor),bootstrapPermissionId) (LlamaCore.sol#2462)
	Event emitted after the call(s):
	- LlamaInstanceCreated(llamaCount,name,address(llamaCore),address(llamaExecutor),address(policy),block.chainid) (LlamaCore.sol#2464-2466)



    
2455     policy.initialize(name, initialRoleDescriptions, initialRoleHolders, initialRolePermissions);



    
2458     bytes32 bootstrapPermissionId =
2459       llamaCore.initialize(name, policy, strategyLogic, accountLogic, initialStrategies, initialAccounts);



    
2462     policy.finalizeInitialization(address(llamaExecutor), bootstrapPermissionId);



    
2464     emit LlamaInstanceCreated(
2465       llamaCount, name, address(llamaCore), address(llamaExecutor), address(policy), block.chainid
2466     );



```

```
Reentrancy in LlamaCore.cancelAction(ActionInfo) (LlamaCore.sol#3538-3548):
	External calls:
	- actionInfo.strategy.validateActionCancelation(actionInfo,msg.sender) (LlamaCore.sol#3544)
	Event emitted after the call(s):
	- ActionCanceled(actionInfo.id) (LlamaCore.sol#3547)



    
3544     actionInfo.strategy.validateActionCancelation(actionInfo, msg.sender);



    
3547     emit ActionCanceled(actionInfo.id);



```

```
Reentrancy in LlamaCore._deployAccounts(ILlamaAccount,bytes[]) (LlamaCore.sol#3838-3852):
	External calls:
	- account.initialize(accountConfigs[i]) (LlamaCore.sol#3849)
	Event emitted after the call(s):
	- AccountCreated(account,llamaAccountLogic,accountConfigs[i]) (LlamaCore.sol#3850)



    
3849       account.initialize(accountConfigs[i]);



    
3850       emit AccountCreated(account, llamaAccountLogic, accountConfigs[i]);



```

```
Reentrancy in LlamaCore._castApproval(address,uint8,ActionInfo,string) (LlamaCore.sol#3755-3763):
	External calls:
	- (action,quantity) = _preCastAssertions(actionInfo,policyholder,role,ActionState.Active) (LlamaCore.sol#3758)
		- actionInfo.strategy.isApprovalEnabled(actionInfo,policyholder,role) (LlamaCore.sol#3795)
		- actionInfo.strategy.isDisapprovalEnabled(actionInfo,policyholder,role) (LlamaCore.sol#3799)
	Event emitted after the call(s):
	- ApprovalCast(actionInfo.id,policyholder,role,quantity,reason) (LlamaCore.sol#3762)



    
3758     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Active);



    
3795       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);



    
3799       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);



    
3762     emit ApprovalCast(actionInfo.id, policyholder, role, quantity, reason);



```

```
Reentrancy in LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaCore.sol#3706-3752):
	External calls:
	- strategy.validateActionCreation(actionInfo) (LlamaCore.sol#3735)
	- guard.validateActionCreation(actionInfo) (LlamaCore.sol#3740)
	Event emitted after the call(s):
	- ActionCreated(actionId,policyholder,role,strategy,target,value,data,description) (LlamaCore.sol#3751)



    
3735     strategy.validateActionCreation(actionInfo);



    
3740       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);



    
3751     emit ActionCreated(actionId, policyholder, role, strategy, target, value, data, description);



```

```
Reentrancy in LlamaCore._deployStrategies(ILlamaStrategy,bytes[]) (LlamaCore.sol#3815-3834):
	External calls:
	- strategy.initialize(strategyConfigs[i]) (LlamaCore.sol#3829)
	Event emitted after the call(s):
	- StrategyCreated(strategy,llamaStrategyLogic,strategyConfigs[i]) (LlamaCore.sol#3831)



    
3829       strategy.initialize(strategyConfigs[i]);



    
3831       emit StrategyCreated(strategy, llamaStrategyLogic, strategyConfigs[i]);



```

```
Reentrancy in LlamaCore._castDisapproval(address,uint8,ActionInfo,string) (LlamaCore.sol#3766-3774):
	External calls:
	- (action,quantity) = _preCastAssertions(actionInfo,policyholder,role,ActionState.Queued) (LlamaCore.sol#3769)
		- actionInfo.strategy.isApprovalEnabled(actionInfo,policyholder,role) (LlamaCore.sol#3795)
		- actionInfo.strategy.isDisapprovalEnabled(actionInfo,policyholder,role) (LlamaCore.sol#3799)
	Event emitted after the call(s):
	- DisapprovalCast(actionInfo.id,policyholder,role,quantity,reason) (LlamaCore.sol#3773)



    
3769     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Queued);



    
3795       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);



    
3799       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);



    
3773     emit DisapprovalCast(actionInfo.id, policyholder, role, quantity, reason);



```

```
Reentrancy in LlamaCore.executeAction(ActionInfo) (LlamaCore.sol#3507-3533):
	External calls:
	- guard.validatePreActionExecution(actionInfo) (LlamaCore.sol#3520)
	- (success,result) = executor.execute(actionInfo.target,actionInfo.value,action.isScript,actionInfo.data) (LlamaCore.sol#3523-3524)
	- guard.validatePostActionExecution(actionInfo) (LlamaCore.sol#3529)
	Event emitted after the call(s):
	- ActionExecuted(actionInfo.id,msg.sender,actionInfo.strategy,actionInfo.creator,result) (LlamaCore.sol#3532)



    
3520     if (guard != ILlamaActionGuard(address(0))) guard.validatePreActionExecution(actionInfo);



    
3523     (bool success, bytes memory result) =
3524       executor.execute(actionInfo.target, actionInfo.value, action.isScript, actionInfo.data);



    
3529     if (guard != ILlamaActionGuard(address(0))) guard.validatePostActionExecution(actionInfo);



    
3532     emit ActionExecuted(actionInfo.id, msg.sender, actionInfo.strategy, actionInfo.creator, result);



```

```
Reentrancy in LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[]) (LlamaCore.sol#3414-3433):
	External calls:
	- bootstrapStrategy = _deployStrategies(_llamaStrategyLogic,initialStrategies) (LlamaCore.sol#3427)
		- strategy.initialize(strategyConfigs[i]) (LlamaCore.sol#3829)
	- _deployAccounts(_llamaAccountLogic,initialAccounts) (LlamaCore.sol#3428)
		- account.initialize(accountConfigs[i]) (LlamaCore.sol#3849)
	Event emitted after the call(s):
	- AccountCreated(account,llamaAccountLogic,accountConfigs[i]) (LlamaCore.sol#3850)
		- _deployAccounts(_llamaAccountLogic,initialAccounts) (LlamaCore.sol#3428)



    
3427     ILlamaStrategy bootstrapStrategy = _deployStrategies(_llamaStrategyLogic, initialStrategies);



    
3829       strategy.initialize(strategyConfigs[i]);



    
3428     _deployAccounts(_llamaAccountLogic, initialAccounts);



    
3849       account.initialize(accountConfigs[i]);



    
3850       emit AccountCreated(account, llamaAccountLogic, accountConfigs[i]);



    
3428     _deployAccounts(_llamaAccountLogic, initialAccounts);



```

### LlamaFactory.sol


```
Reentrancy in LlamaCore.cancelAction(ActionInfo) (LlamaFactory.sol#2875-2885):
	External calls:
	- actionInfo.strategy.validateActionCancelation(actionInfo,msg.sender) (LlamaFactory.sol#2881)
	Event emitted after the call(s):
	- ActionCanceled(actionInfo.id) (LlamaFactory.sol#2884)



    
2881     actionInfo.strategy.validateActionCancelation(actionInfo, msg.sender);



    
2884     emit ActionCanceled(actionInfo.id);



```

```
Reentrancy in LlamaCore._deployAccounts(ILlamaAccount,bytes[]) (LlamaFactory.sol#3175-3189):
	External calls:
	- account.initialize(accountConfigs[i]) (LlamaFactory.sol#3186)
	Event emitted after the call(s):
	- AccountCreated(account,llamaAccountLogic,accountConfigs[i]) (LlamaFactory.sol#3187)



    
3186       account.initialize(accountConfigs[i]);



    
3187       emit AccountCreated(account, llamaAccountLogic, accountConfigs[i]);



```

```
Reentrancy in LlamaCore._castApproval(address,uint8,ActionInfo,string) (LlamaFactory.sol#3092-3100):
	External calls:
	- (action,quantity) = _preCastAssertions(actionInfo,policyholder,role,ActionState.Active) (LlamaFactory.sol#3095)
		- actionInfo.strategy.isApprovalEnabled(actionInfo,policyholder,role) (LlamaFactory.sol#3132)
		- actionInfo.strategy.isDisapprovalEnabled(actionInfo,policyholder,role) (LlamaFactory.sol#3136)
	Event emitted after the call(s):
	- ApprovalCast(actionInfo.id,policyholder,role,quantity,reason) (LlamaFactory.sol#3099)



    
3095     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Active);



    
3132       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);



    
3136       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);



    
3099     emit ApprovalCast(actionInfo.id, policyholder, role, quantity, reason);



```

```
Reentrancy in LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaFactory.sol#3043-3089):
	External calls:
	- strategy.validateActionCreation(actionInfo) (LlamaFactory.sol#3072)
	- guard.validateActionCreation(actionInfo) (LlamaFactory.sol#3077)
	Event emitted after the call(s):
	- ActionCreated(actionId,policyholder,role,strategy,target,value,data,description) (LlamaFactory.sol#3088)



    
3072     strategy.validateActionCreation(actionInfo);



    
3077       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);



    
3088     emit ActionCreated(actionId, policyholder, role, strategy, target, value, data, description);



```

```
Reentrancy in LlamaCore._castDisapproval(address,uint8,ActionInfo,string) (LlamaFactory.sol#3103-3111):
	External calls:
	- (action,quantity) = _preCastAssertions(actionInfo,policyholder,role,ActionState.Queued) (LlamaFactory.sol#3106)
		- actionInfo.strategy.isApprovalEnabled(actionInfo,policyholder,role) (LlamaFactory.sol#3132)
		- actionInfo.strategy.isDisapprovalEnabled(actionInfo,policyholder,role) (LlamaFactory.sol#3136)
	Event emitted after the call(s):
	- DisapprovalCast(actionInfo.id,policyholder,role,quantity,reason) (LlamaFactory.sol#3110)



    
3106     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Queued);



    
3132       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);



    
3136       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);



    
3110     emit DisapprovalCast(actionInfo.id, policyholder, role, quantity, reason);



```

```
Reentrancy in LlamaCore._deployStrategies(ILlamaStrategy,bytes[]) (LlamaFactory.sol#3152-3171):
	External calls:
	- strategy.initialize(strategyConfigs[i]) (LlamaFactory.sol#3166)
	Event emitted after the call(s):
	- StrategyCreated(strategy,llamaStrategyLogic,strategyConfigs[i]) (LlamaFactory.sol#3168)



    
3166       strategy.initialize(strategyConfigs[i]);



    
3168       emit StrategyCreated(strategy, llamaStrategyLogic, strategyConfigs[i]);



```

```
Reentrancy in LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[]) (LlamaFactory.sol#2751-2770):
	External calls:
	- bootstrapStrategy = _deployStrategies(_llamaStrategyLogic,initialStrategies) (LlamaFactory.sol#2764)
		- strategy.initialize(strategyConfigs[i]) (LlamaFactory.sol#3166)
	- _deployAccounts(_llamaAccountLogic,initialAccounts) (LlamaFactory.sol#2765)
		- account.initialize(accountConfigs[i]) (LlamaFactory.sol#3186)
	Event emitted after the call(s):
	- AccountCreated(account,llamaAccountLogic,accountConfigs[i]) (LlamaFactory.sol#3187)
		- _deployAccounts(_llamaAccountLogic,initialAccounts) (LlamaFactory.sol#2765)



    
2764     ILlamaStrategy bootstrapStrategy = _deployStrategies(_llamaStrategyLogic, initialStrategies);



    
3166       strategy.initialize(strategyConfigs[i]);



    
2765     _deployAccounts(_llamaAccountLogic, initialAccounts);



    
3186       account.initialize(accountConfigs[i]);



    
3187       emit AccountCreated(account, llamaAccountLogic, accountConfigs[i]);



    
2765     _deployAccounts(_llamaAccountLogic, initialAccounts);



```

```
Reentrancy in LlamaCore.executeAction(ActionInfo) (LlamaFactory.sol#2844-2870):
	External calls:
	- guard.validatePreActionExecution(actionInfo) (LlamaFactory.sol#2857)
	- (success,result) = executor.execute(actionInfo.target,actionInfo.value,action.isScript,actionInfo.data) (LlamaFactory.sol#2860-2861)
	- guard.validatePostActionExecution(actionInfo) (LlamaFactory.sol#2866)
	Event emitted after the call(s):
	- ActionExecuted(actionInfo.id,msg.sender,actionInfo.strategy,actionInfo.creator,result) (LlamaFactory.sol#2869)



    
2857     if (guard != ILlamaActionGuard(address(0))) guard.validatePreActionExecution(actionInfo);



    
2860     (bool success, bytes memory result) =
2861       executor.execute(actionInfo.target, actionInfo.value, action.isScript, actionInfo.data);



    
2866     if (guard != ILlamaActionGuard(address(0))) guard.validatePostActionExecution(actionInfo);



    
2869     emit ActionExecuted(actionInfo.id, msg.sender, actionInfo.strategy, actionInfo.creator, result);



```

```
Reentrancy in LlamaFactory._deploy(string,ILlamaStrategy,ILlamaAccount,bytes[],bytes[],RoleDescription[],RoleHolderData[],RolePermissionData[]) (LlamaFactory.sol#3931-3968):
	External calls:
	- policy.initialize(name,initialRoleDescriptions,initialRoleHolders,initialRolePermissions) (LlamaFactory.sol#3955)
	- bootstrapPermissionId = llamaCore.initialize(name,policy,strategyLogic,accountLogic,initialStrategies,initialAccounts) (LlamaFactory.sol#3958-3959)
	- policy.finalizeInitialization(address(llamaExecutor),bootstrapPermissionId) (LlamaFactory.sol#3962)
	Event emitted after the call(s):
	- LlamaInstanceCreated(llamaCount,name,address(llamaCore),address(llamaExecutor),address(policy),block.chainid) (LlamaFactory.sol#3964-3966)



    
3955     policy.initialize(name, initialRoleDescriptions, initialRoleHolders, initialRolePermissions);



    
3958     bytes32 bootstrapPermissionId =
3959       llamaCore.initialize(name, policy, strategyLogic, accountLogic, initialStrategies, initialAccounts);



    
3962     policy.finalizeInitialization(address(llamaExecutor), bootstrapPermissionId);



    
3964     emit LlamaInstanceCreated(
3965       llamaCount, name, address(llamaCore), address(llamaExecutor), address(policy), block.chainid
3966     );



```

### LlamaGovernanceScript.sol


```
Reentrancy in LlamaCore._deployStrategies(ILlamaStrategy,bytes[]) (LlamaGovernanceScript.sol#3734-3753):
	External calls:
	- strategy.initialize(strategyConfigs[i]) (LlamaGovernanceScript.sol#3748)
	Event emitted after the call(s):
	- StrategyCreated(strategy,llamaStrategyLogic,strategyConfigs[i]) (LlamaGovernanceScript.sol#3750)



    
3748       strategy.initialize(strategyConfigs[i]);



    
3750       emit StrategyCreated(strategy, llamaStrategyLogic, strategyConfigs[i]);



```

```
Reentrancy in LlamaCore.cancelAction(ActionInfo) (LlamaGovernanceScript.sol#3457-3467):
	External calls:
	- actionInfo.strategy.validateActionCancelation(actionInfo,msg.sender) (LlamaGovernanceScript.sol#3463)
	Event emitted after the call(s):
	- ActionCanceled(actionInfo.id) (LlamaGovernanceScript.sol#3466)



    
3463     actionInfo.strategy.validateActionCancelation(actionInfo, msg.sender);



    
3466     emit ActionCanceled(actionInfo.id);



```

```
Reentrancy in LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[]) (LlamaGovernanceScript.sol#3333-3352):
	External calls:
	- bootstrapStrategy = _deployStrategies(_llamaStrategyLogic,initialStrategies) (LlamaGovernanceScript.sol#3346)
		- strategy.initialize(strategyConfigs[i]) (LlamaGovernanceScript.sol#3748)
	- _deployAccounts(_llamaAccountLogic,initialAccounts) (LlamaGovernanceScript.sol#3347)
		- account.initialize(accountConfigs[i]) (LlamaGovernanceScript.sol#3768)
	Event emitted after the call(s):
	- AccountCreated(account,llamaAccountLogic,accountConfigs[i]) (LlamaGovernanceScript.sol#3769)
		- _deployAccounts(_llamaAccountLogic,initialAccounts) (LlamaGovernanceScript.sol#3347)



    
3346     ILlamaStrategy bootstrapStrategy = _deployStrategies(_llamaStrategyLogic, initialStrategies);



    
3748       strategy.initialize(strategyConfigs[i]);



    
3347     _deployAccounts(_llamaAccountLogic, initialAccounts);



    
3768       account.initialize(accountConfigs[i]);



    
3769       emit AccountCreated(account, llamaAccountLogic, accountConfigs[i]);



    
3347     _deployAccounts(_llamaAccountLogic, initialAccounts);



```

```
Reentrancy in LlamaCore.executeAction(ActionInfo) (LlamaGovernanceScript.sol#3426-3452):
	External calls:
	- guard.validatePreActionExecution(actionInfo) (LlamaGovernanceScript.sol#3439)
	- (success,result) = executor.execute(actionInfo.target,actionInfo.value,action.isScript,actionInfo.data) (LlamaGovernanceScript.sol#3442-3443)
	- guard.validatePostActionExecution(actionInfo) (LlamaGovernanceScript.sol#3448)
	Event emitted after the call(s):
	- ActionExecuted(actionInfo.id,msg.sender,actionInfo.strategy,actionInfo.creator,result) (LlamaGovernanceScript.sol#3451)



    
3439     if (guard != ILlamaActionGuard(address(0))) guard.validatePreActionExecution(actionInfo);



    
3442     (bool success, bytes memory result) =
3443       executor.execute(actionInfo.target, actionInfo.value, action.isScript, actionInfo.data);



    
3448     if (guard != ILlamaActionGuard(address(0))) guard.validatePostActionExecution(actionInfo);



    
3451     emit ActionExecuted(actionInfo.id, msg.sender, actionInfo.strategy, actionInfo.creator, result);



```

```
Reentrancy in LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaGovernanceScript.sol#3625-3671):
	External calls:
	- strategy.validateActionCreation(actionInfo) (LlamaGovernanceScript.sol#3654)
	- guard.validateActionCreation(actionInfo) (LlamaGovernanceScript.sol#3659)
	Event emitted after the call(s):
	- ActionCreated(actionId,policyholder,role,strategy,target,value,data,description) (LlamaGovernanceScript.sol#3670)



    
3654     strategy.validateActionCreation(actionInfo);



    
3659       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);



    
3670     emit ActionCreated(actionId, policyholder, role, strategy, target, value, data, description);



```

```
Reentrancy in LlamaCore._castApproval(address,uint8,ActionInfo,string) (LlamaGovernanceScript.sol#3674-3682):
	External calls:
	- (action,quantity) = _preCastAssertions(actionInfo,policyholder,role,ActionState.Active) (LlamaGovernanceScript.sol#3677)
		- actionInfo.strategy.isApprovalEnabled(actionInfo,policyholder,role) (LlamaGovernanceScript.sol#3714)
		- actionInfo.strategy.isDisapprovalEnabled(actionInfo,policyholder,role) (LlamaGovernanceScript.sol#3718)
	Event emitted after the call(s):
	- ApprovalCast(actionInfo.id,policyholder,role,quantity,reason) (LlamaGovernanceScript.sol#3681)



    
3677     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Active);



    
3714       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);



    
3718       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);



    
3681     emit ApprovalCast(actionInfo.id, policyholder, role, quantity, reason);



```

```
Reentrancy in LlamaCore._deployAccounts(ILlamaAccount,bytes[]) (LlamaGovernanceScript.sol#3757-3771):
	External calls:
	- account.initialize(accountConfigs[i]) (LlamaGovernanceScript.sol#3768)
	Event emitted after the call(s):
	- AccountCreated(account,llamaAccountLogic,accountConfigs[i]) (LlamaGovernanceScript.sol#3769)



    
3768       account.initialize(accountConfigs[i]);



    
3769       emit AccountCreated(account, llamaAccountLogic, accountConfigs[i]);



```

```
Reentrancy in LlamaFactory._deploy(string,ILlamaStrategy,ILlamaAccount,bytes[],bytes[],RoleDescription[],RoleHolderData[],RolePermissionData[]) (LlamaGovernanceScript.sol#3062-3099):
	External calls:
	- policy.initialize(name,initialRoleDescriptions,initialRoleHolders,initialRolePermissions) (LlamaGovernanceScript.sol#3086)
	- bootstrapPermissionId = llamaCore.initialize(name,policy,strategyLogic,accountLogic,initialStrategies,initialAccounts) (LlamaGovernanceScript.sol#3089-3090)
	- policy.finalizeInitialization(address(llamaExecutor),bootstrapPermissionId) (LlamaGovernanceScript.sol#3093)
	Event emitted after the call(s):
	- LlamaInstanceCreated(llamaCount,name,address(llamaCore),address(llamaExecutor),address(policy),block.chainid) (LlamaGovernanceScript.sol#3095-3097)



    
3086     policy.initialize(name, initialRoleDescriptions, initialRoleHolders, initialRolePermissions);



    
3089     bytes32 bootstrapPermissionId =
3090       llamaCore.initialize(name, policy, strategyLogic, accountLogic, initialStrategies, initialAccounts);



    
3093     policy.finalizeInitialization(address(llamaExecutor), bootstrapPermissionId);



    
3095     emit LlamaInstanceCreated(
3096       llamaCount, name, address(llamaCore), address(llamaExecutor), address(policy), block.chainid
3097     );



```

```
Reentrancy in LlamaCore._castDisapproval(address,uint8,ActionInfo,string) (LlamaGovernanceScript.sol#3685-3693):
	External calls:
	- (action,quantity) = _preCastAssertions(actionInfo,policyholder,role,ActionState.Queued) (LlamaGovernanceScript.sol#3688)
		- actionInfo.strategy.isApprovalEnabled(actionInfo,policyholder,role) (LlamaGovernanceScript.sol#3714)
		- actionInfo.strategy.isDisapprovalEnabled(actionInfo,policyholder,role) (LlamaGovernanceScript.sol#3718)
	Event emitted after the call(s):
	- DisapprovalCast(actionInfo.id,policyholder,role,quantity,reason) (LlamaGovernanceScript.sol#3692)



    
3688     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Queued);



    
3714       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);



    
3718       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);



    
3692     emit DisapprovalCast(actionInfo.id, policyholder, role, quantity, reason);



```

### LlamaPolicy.sol


```
Reentrancy in LlamaCore._deployAccounts(ILlamaAccount,bytes[]) (LlamaPolicy.sol#3164-3178):
	External calls:
	- account.initialize(accountConfigs[i]) (LlamaPolicy.sol#3175)
	Event emitted after the call(s):
	- AccountCreated(account,llamaAccountLogic,accountConfigs[i]) (LlamaPolicy.sol#3176)



    
3175       account.initialize(accountConfigs[i]);



    
3176       emit AccountCreated(account, llamaAccountLogic, accountConfigs[i]);



```

```
Reentrancy in LlamaCore._castDisapproval(address,uint8,ActionInfo,string) (LlamaPolicy.sol#3092-3100):
	External calls:
	- (action,quantity) = _preCastAssertions(actionInfo,policyholder,role,ActionState.Queued) (LlamaPolicy.sol#3095)
		- actionInfo.strategy.isApprovalEnabled(actionInfo,policyholder,role) (LlamaPolicy.sol#3121)
		- actionInfo.strategy.isDisapprovalEnabled(actionInfo,policyholder,role) (LlamaPolicy.sol#3125)
	Event emitted after the call(s):
	- DisapprovalCast(actionInfo.id,policyholder,role,quantity,reason) (LlamaPolicy.sol#3099)



    
3095     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Queued);



    
3121       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);



    
3125       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);



    
3099     emit DisapprovalCast(actionInfo.id, policyholder, role, quantity, reason);



```

```
Reentrancy in LlamaFactory._deploy(string,ILlamaStrategy,ILlamaAccount,bytes[],bytes[],RoleDescription[],RoleHolderData[],RolePermissionData[]) (LlamaPolicy.sol#2469-2506):
	External calls:
	- policy.initialize(name,initialRoleDescriptions,initialRoleHolders,initialRolePermissions) (LlamaPolicy.sol#2493)
	- bootstrapPermissionId = llamaCore.initialize(name,policy,strategyLogic,accountLogic,initialStrategies,initialAccounts) (LlamaPolicy.sol#2496-2497)
	- policy.finalizeInitialization(address(llamaExecutor),bootstrapPermissionId) (LlamaPolicy.sol#2500)
	Event emitted after the call(s):
	- LlamaInstanceCreated(llamaCount,name,address(llamaCore),address(llamaExecutor),address(policy),block.chainid) (LlamaPolicy.sol#2502-2504)



    
2493     policy.initialize(name, initialRoleDescriptions, initialRoleHolders, initialRolePermissions);



    
2496     bytes32 bootstrapPermissionId =
2497       llamaCore.initialize(name, policy, strategyLogic, accountLogic, initialStrategies, initialAccounts);



    
2500     policy.finalizeInitialization(address(llamaExecutor), bootstrapPermissionId);



    
2502     emit LlamaInstanceCreated(
2503       llamaCount, name, address(llamaCore), address(llamaExecutor), address(policy), block.chainid
2504     );



```

```
Reentrancy in LlamaCore._deployStrategies(ILlamaStrategy,bytes[]) (LlamaPolicy.sol#3141-3160):
	External calls:
	- strategy.initialize(strategyConfigs[i]) (LlamaPolicy.sol#3155)
	Event emitted after the call(s):
	- StrategyCreated(strategy,llamaStrategyLogic,strategyConfigs[i]) (LlamaPolicy.sol#3157)



    
3155       strategy.initialize(strategyConfigs[i]);



    
3157       emit StrategyCreated(strategy, llamaStrategyLogic, strategyConfigs[i]);



```

```
Reentrancy in LlamaCore.executeAction(ActionInfo) (LlamaPolicy.sol#2833-2859):
	External calls:
	- guard.validatePreActionExecution(actionInfo) (LlamaPolicy.sol#2846)
	- (success,result) = executor.execute(actionInfo.target,actionInfo.value,action.isScript,actionInfo.data) (LlamaPolicy.sol#2849-2850)
	- guard.validatePostActionExecution(actionInfo) (LlamaPolicy.sol#2855)
	Event emitted after the call(s):
	- ActionExecuted(actionInfo.id,msg.sender,actionInfo.strategy,actionInfo.creator,result) (LlamaPolicy.sol#2858)



    
2846     if (guard != ILlamaActionGuard(address(0))) guard.validatePreActionExecution(actionInfo);



    
2849     (bool success, bytes memory result) =
2850       executor.execute(actionInfo.target, actionInfo.value, action.isScript, actionInfo.data);



    
2855     if (guard != ILlamaActionGuard(address(0))) guard.validatePostActionExecution(actionInfo);



    
2858     emit ActionExecuted(actionInfo.id, msg.sender, actionInfo.strategy, actionInfo.creator, result);



```

```
Reentrancy in LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[]) (LlamaPolicy.sol#2740-2759):
	External calls:
	- bootstrapStrategy = _deployStrategies(_llamaStrategyLogic,initialStrategies) (LlamaPolicy.sol#2753)
		- strategy.initialize(strategyConfigs[i]) (LlamaPolicy.sol#3155)
	- _deployAccounts(_llamaAccountLogic,initialAccounts) (LlamaPolicy.sol#2754)
		- account.initialize(accountConfigs[i]) (LlamaPolicy.sol#3175)
	Event emitted after the call(s):
	- AccountCreated(account,llamaAccountLogic,accountConfigs[i]) (LlamaPolicy.sol#3176)
		- _deployAccounts(_llamaAccountLogic,initialAccounts) (LlamaPolicy.sol#2754)



    
2753     ILlamaStrategy bootstrapStrategy = _deployStrategies(_llamaStrategyLogic, initialStrategies);



    
3155       strategy.initialize(strategyConfigs[i]);



    
2754     _deployAccounts(_llamaAccountLogic, initialAccounts);



    
3175       account.initialize(accountConfigs[i]);



    
3176       emit AccountCreated(account, llamaAccountLogic, accountConfigs[i]);



    
2754     _deployAccounts(_llamaAccountLogic, initialAccounts);



```

```
Reentrancy in LlamaCore.cancelAction(ActionInfo) (LlamaPolicy.sol#2864-2874):
	External calls:
	- actionInfo.strategy.validateActionCancelation(actionInfo,msg.sender) (LlamaPolicy.sol#2870)
	Event emitted after the call(s):
	- ActionCanceled(actionInfo.id) (LlamaPolicy.sol#2873)



    
2870     actionInfo.strategy.validateActionCancelation(actionInfo, msg.sender);



    
2873     emit ActionCanceled(actionInfo.id);



```

```
Reentrancy in LlamaCore._castApproval(address,uint8,ActionInfo,string) (LlamaPolicy.sol#3081-3089):
	External calls:
	- (action,quantity) = _preCastAssertions(actionInfo,policyholder,role,ActionState.Active) (LlamaPolicy.sol#3084)
		- actionInfo.strategy.isApprovalEnabled(actionInfo,policyholder,role) (LlamaPolicy.sol#3121)
		- actionInfo.strategy.isDisapprovalEnabled(actionInfo,policyholder,role) (LlamaPolicy.sol#3125)
	Event emitted after the call(s):
	- ApprovalCast(actionInfo.id,policyholder,role,quantity,reason) (LlamaPolicy.sol#3088)



    
3084     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Active);



    
3121       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);



    
3125       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);



    
3088     emit ApprovalCast(actionInfo.id, policyholder, role, quantity, reason);



```

```
Reentrancy in LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaPolicy.sol#3032-3078):
	External calls:
	- strategy.validateActionCreation(actionInfo) (LlamaPolicy.sol#3061)
	- guard.validateActionCreation(actionInfo) (LlamaPolicy.sol#3066)
	Event emitted after the call(s):
	- ActionCreated(actionId,policyholder,role,strategy,target,value,data,description) (LlamaPolicy.sol#3077)



    
3061     strategy.validateActionCreation(actionInfo);



    
3066       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);



    
3077     emit ActionCreated(actionId, policyholder, role, strategy, target, value, data, description);



```

### LlamaRelativeQuorum.sol


```
Reentrancy in LlamaCore.cancelAction(ActionInfo) (LlamaRelativeQuorum.sol#3689-3699):
	External calls:
	- actionInfo.strategy.validateActionCancelation(actionInfo,msg.sender) (LlamaRelativeQuorum.sol#3695)
	Event emitted after the call(s):
	- ActionCanceled(actionInfo.id) (LlamaRelativeQuorum.sol#3698)



    
3695     actionInfo.strategy.validateActionCancelation(actionInfo, msg.sender);



    
3698     emit ActionCanceled(actionInfo.id);



```

```
Reentrancy in LlamaCore._castDisapproval(address,uint8,ActionInfo,string) (LlamaRelativeQuorum.sol#3917-3925):
	External calls:
	- (action,quantity) = _preCastAssertions(actionInfo,policyholder,role,ActionState.Queued) (LlamaRelativeQuorum.sol#3920)
		- actionInfo.strategy.isApprovalEnabled(actionInfo,policyholder,role) (LlamaRelativeQuorum.sol#3946)
		- actionInfo.strategy.isDisapprovalEnabled(actionInfo,policyholder,role) (LlamaRelativeQuorum.sol#3950)
	Event emitted after the call(s):
	- DisapprovalCast(actionInfo.id,policyholder,role,quantity,reason) (LlamaRelativeQuorum.sol#3924)



    
3920     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Queued);



    
3946       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);



    
3950       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);



    
3924     emit DisapprovalCast(actionInfo.id, policyholder, role, quantity, reason);



```

```
Reentrancy in LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[]) (LlamaRelativeQuorum.sol#3565-3584):
	External calls:
	- bootstrapStrategy = _deployStrategies(_llamaStrategyLogic,initialStrategies) (LlamaRelativeQuorum.sol#3578)
		- strategy.initialize(strategyConfigs[i]) (LlamaRelativeQuorum.sol#3980)
	- _deployAccounts(_llamaAccountLogic,initialAccounts) (LlamaRelativeQuorum.sol#3579)
		- account.initialize(accountConfigs[i]) (LlamaRelativeQuorum.sol#4000)
	Event emitted after the call(s):
	- AccountCreated(account,llamaAccountLogic,accountConfigs[i]) (LlamaRelativeQuorum.sol#4001)
		- _deployAccounts(_llamaAccountLogic,initialAccounts) (LlamaRelativeQuorum.sol#3579)



    
3578     ILlamaStrategy bootstrapStrategy = _deployStrategies(_llamaStrategyLogic, initialStrategies);



    
3980       strategy.initialize(strategyConfigs[i]);



    
3579     _deployAccounts(_llamaAccountLogic, initialAccounts);



    
4000       account.initialize(accountConfigs[i]);



    
4001       emit AccountCreated(account, llamaAccountLogic, accountConfigs[i]);



    
3579     _deployAccounts(_llamaAccountLogic, initialAccounts);



```

```
Reentrancy in LlamaCore._deployStrategies(ILlamaStrategy,bytes[]) (LlamaRelativeQuorum.sol#3966-3985):
	External calls:
	- strategy.initialize(strategyConfigs[i]) (LlamaRelativeQuorum.sol#3980)
	Event emitted after the call(s):
	- StrategyCreated(strategy,llamaStrategyLogic,strategyConfigs[i]) (LlamaRelativeQuorum.sol#3982)



    
3980       strategy.initialize(strategyConfigs[i]);



    
3982       emit StrategyCreated(strategy, llamaStrategyLogic, strategyConfigs[i]);



```

```
Reentrancy in LlamaCore._deployAccounts(ILlamaAccount,bytes[]) (LlamaRelativeQuorum.sol#3989-4003):
	External calls:
	- account.initialize(accountConfigs[i]) (LlamaRelativeQuorum.sol#4000)
	Event emitted after the call(s):
	- AccountCreated(account,llamaAccountLogic,accountConfigs[i]) (LlamaRelativeQuorum.sol#4001)



    
4000       account.initialize(accountConfigs[i]);



    
4001       emit AccountCreated(account, llamaAccountLogic, accountConfigs[i]);



```

```
Reentrancy in LlamaFactory._deploy(string,ILlamaStrategy,ILlamaAccount,bytes[],bytes[],RoleDescription[],RoleHolderData[],RolePermissionData[]) (LlamaRelativeQuorum.sol#3294-3331):
	External calls:
	- policy.initialize(name,initialRoleDescriptions,initialRoleHolders,initialRolePermissions) (LlamaRelativeQuorum.sol#3318)
	- bootstrapPermissionId = llamaCore.initialize(name,policy,strategyLogic,accountLogic,initialStrategies,initialAccounts) (LlamaRelativeQuorum.sol#3321-3322)
	- policy.finalizeInitialization(address(llamaExecutor),bootstrapPermissionId) (LlamaRelativeQuorum.sol#3325)
	Event emitted after the call(s):
	- LlamaInstanceCreated(llamaCount,name,address(llamaCore),address(llamaExecutor),address(policy),block.chainid) (LlamaRelativeQuorum.sol#3327-3329)



    
3318     policy.initialize(name, initialRoleDescriptions, initialRoleHolders, initialRolePermissions);



    
3321     bytes32 bootstrapPermissionId =
3322       llamaCore.initialize(name, policy, strategyLogic, accountLogic, initialStrategies, initialAccounts);



    
3325     policy.finalizeInitialization(address(llamaExecutor), bootstrapPermissionId);



    
3327     emit LlamaInstanceCreated(
3328       llamaCount, name, address(llamaCore), address(llamaExecutor), address(policy), block.chainid
3329     );



```

```
Reentrancy in LlamaCore._castApproval(address,uint8,ActionInfo,string) (LlamaRelativeQuorum.sol#3906-3914):
	External calls:
	- (action,quantity) = _preCastAssertions(actionInfo,policyholder,role,ActionState.Active) (LlamaRelativeQuorum.sol#3909)
		- actionInfo.strategy.isApprovalEnabled(actionInfo,policyholder,role) (LlamaRelativeQuorum.sol#3946)
		- actionInfo.strategy.isDisapprovalEnabled(actionInfo,policyholder,role) (LlamaRelativeQuorum.sol#3950)
	Event emitted after the call(s):
	- ApprovalCast(actionInfo.id,policyholder,role,quantity,reason) (LlamaRelativeQuorum.sol#3913)



    
3909     (Action storage action, uint128 quantity) = _preCastAssertions(actionInfo, policyholder, role, ActionState.Active);



    
3946       actionInfo.strategy.isApprovalEnabled(actionInfo, policyholder, role);



    
3950       actionInfo.strategy.isDisapprovalEnabled(actionInfo, policyholder, role);



    
3913     emit ApprovalCast(actionInfo.id, policyholder, role, quantity, reason);



```

```
Reentrancy in LlamaCore._createAction(address,uint8,ILlamaStrategy,address,uint256,bytes,string) (LlamaRelativeQuorum.sol#3857-3903):
	External calls:
	- strategy.validateActionCreation(actionInfo) (LlamaRelativeQuorum.sol#3886)
	- guard.validateActionCreation(actionInfo) (LlamaRelativeQuorum.sol#3891)
	Event emitted after the call(s):
	- ActionCreated(actionId,policyholder,role,strategy,target,value,data,description) (LlamaRelativeQuorum.sol#3902)



    
3886     strategy.validateActionCreation(actionInfo);



    
3891       if (guard != ILlamaActionGuard(address(0))) guard.validateActionCreation(actionInfo);



    
3902     emit ActionCreated(actionId, policyholder, role, strategy, target, value, data, description);



```

```
Reentrancy in LlamaCore.executeAction(ActionInfo) (LlamaRelativeQuorum.sol#3658-3684):
	External calls:
	- guard.validatePreActionExecution(actionInfo) (LlamaRelativeQuorum.sol#3671)
	- (success,result) = executor.execute(actionInfo.target,actionInfo.value,action.isScript,actionInfo.data) (LlamaRelativeQuorum.sol#3674-3675)
	- guard.validatePostActionExecution(actionInfo) (LlamaRelativeQuorum.sol#3680)
	Event emitted after the call(s):
	- ActionExecuted(actionInfo.id,msg.sender,actionInfo.strategy,actionInfo.creator,result) (LlamaRelativeQuorum.sol#3683)



    
3671     if (guard != ILlamaActionGuard(address(0))) guard.validatePreActionExecution(actionInfo);



    
3674     (bool success, bytes memory result) =
3675       executor.execute(actionInfo.target, actionInfo.value, action.isScript, actionInfo.data);



    
3680     if (guard != ILlamaActionGuard(address(0))) guard.validatePostActionExecution(actionInfo);



    
3683     emit ActionExecuted(actionInfo.id, msg.sender, actionInfo.strategy, actionInfo.creator, result);



```

## timestamp
### Severity: Low

### LlamaAbsolutePeerReview.sol


```
LlamaAbsoluteStrategyBase.isActionExpired(ActionInfo) (LlamaAbsolutePeerReview.sol#4517-4520) uses timestamp for comparisons
	Dangerous comparisons:
	- block.timestamp > action.minExecutionTime + expirationPeriod (LlamaAbsolutePeerReview.sol#4519)



    
4519     return block.timestamp > action.minExecutionTime + expirationPeriod;



```

```
Checkpoints.getAtProbablyRecentTimestamp(Checkpoints.History,uint256) (LlamaAbsolutePeerReview.sol#1835-1856) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(timestamp < block.timestamp,Checkpoints: timestamp is not in the past) (LlamaAbsolutePeerReview.sol#1836)



    
1836         require(timestamp < block.timestamp, "Checkpoints: timestamp is not in the past");



```

```
LlamaPolicy._assertNoActionCreationsAtCurrentTimestamp() (LlamaAbsolutePeerReview.sol#2663-2668) uses timestamp for comparisons
	Dangerous comparisons:
	- lastActionCreation == block.timestamp (LlamaAbsolutePeerReview.sol#2667)



    
2667     if (lastActionCreation == block.timestamp) revert ActionCreationAtSameTimestamp();



```

```
LlamaPolicy._assertValidRoleHolderUpdate(uint8,uint128,uint64) (LlamaAbsolutePeerReview.sol#2671-2687) uses timestamp for comparisons
	Dangerous comparisons:
	- case1 = quantity > 0 && expiration > block.timestamp (LlamaAbsolutePeerReview.sol#2684)
	- ! (case1 || case2) (LlamaAbsolutePeerReview.sol#2686)



    
2684     bool case1 = quantity > 0 && expiration > block.timestamp;



    
2686     if (!(case1 || case2)) revert InvalidRoleHolderInput();



```

```
LlamaCore.queueAction(ActionInfo) (LlamaAbsolutePeerReview.sol#3645-3654) uses timestamp for comparisons
	Dangerous comparisons:
	- minExecutionTime < block.timestamp (LlamaAbsolutePeerReview.sol#3651)



    
3651     if (minExecutionTime < block.timestamp) revert MinExecutionTimeCannotBeInThePast();



```

```
LlamaAbsoluteStrategyBase.isActive(ActionInfo) (LlamaAbsolutePeerReview.sol#4499-4502) uses timestamp for comparisons
	Dangerous comparisons:
	- block.timestamp <= approvalEndTime(actionInfo) && (isFixedLengthApprovalPeriod || ! isActionApproved(actionInfo)) (LlamaAbsolutePeerReview.sol#4500-4501)



    
4500     return
4501       block.timestamp <= approvalEndTime(actionInfo) && (isFixedLengthApprovalPeriod || !isActionApproved(actionInfo));



```

```
Checkpoints._insert(Checkpoints.Checkpoint[],uint64,uint64,uint128) (LlamaAbsolutePeerReview.sol#1920-1948) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(last.timestamp <= timestamp,Checkpoint: invalid timestamp) (LlamaAbsolutePeerReview.sol#1933)
	- last.timestamp == timestamp (LlamaAbsolutePeerReview.sol#1936)



    
1933             require(last.timestamp <= timestamp, "Checkpoint: invalid timestamp");



    
1936             if (last.timestamp == timestamp) {



```

```
LlamaCore.executeAction(ActionInfo) (LlamaAbsolutePeerReview.sol#3658-3684) uses timestamp for comparisons
	Dangerous comparisons:
	- block.timestamp < action.minExecutionTime (LlamaAbsolutePeerReview.sol#3664)



    
3664     if (block.timestamp < action.minExecutionTime) revert MinExecutionTimeNotReached();



```

```
LlamaPolicy.isRoleExpired(address,uint8) (LlamaAbsolutePeerReview.sol#2583-2586) uses timestamp for comparisons
	Dangerous comparisons:
	- quantity > 0 && block.timestamp > expiration (LlamaAbsolutePeerReview.sol#2585)



    
2585     return quantity > 0 && block.timestamp > expiration;



```

### LlamaAbsoluteQuorum.sol


```
LlamaAbsoluteStrategyBase.isActionExpired(ActionInfo) (LlamaAbsoluteQuorum.sol#4517-4520) uses timestamp for comparisons
	Dangerous comparisons:
	- block.timestamp > action.minExecutionTime + expirationPeriod (LlamaAbsoluteQuorum.sol#4519)



    
4519     return block.timestamp > action.minExecutionTime + expirationPeriod;



```

```
Checkpoints.getAtProbablyRecentTimestamp(Checkpoints.History,uint256) (LlamaAbsoluteQuorum.sol#1835-1856) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(timestamp < block.timestamp,Checkpoints: timestamp is not in the past) (LlamaAbsoluteQuorum.sol#1836)



    
1836         require(timestamp < block.timestamp, "Checkpoints: timestamp is not in the past");



```

```
LlamaPolicy._assertNoActionCreationsAtCurrentTimestamp() (LlamaAbsoluteQuorum.sol#2663-2668) uses timestamp for comparisons
	Dangerous comparisons:
	- lastActionCreation == block.timestamp (LlamaAbsoluteQuorum.sol#2667)



    
2667     if (lastActionCreation == block.timestamp) revert ActionCreationAtSameTimestamp();



```

```
LlamaPolicy._assertValidRoleHolderUpdate(uint8,uint128,uint64) (LlamaAbsoluteQuorum.sol#2671-2687) uses timestamp for comparisons
	Dangerous comparisons:
	- case1 = quantity > 0 && expiration > block.timestamp (LlamaAbsoluteQuorum.sol#2684)
	- ! (case1 || case2) (LlamaAbsoluteQuorum.sol#2686)



    
2684     bool case1 = quantity > 0 && expiration > block.timestamp;



    
2686     if (!(case1 || case2)) revert InvalidRoleHolderInput();



```

```
LlamaCore.queueAction(ActionInfo) (LlamaAbsoluteQuorum.sol#3645-3654) uses timestamp for comparisons
	Dangerous comparisons:
	- minExecutionTime < block.timestamp (LlamaAbsoluteQuorum.sol#3651)



    
3651     if (minExecutionTime < block.timestamp) revert MinExecutionTimeCannotBeInThePast();



```

```
LlamaAbsoluteStrategyBase.isActive(ActionInfo) (LlamaAbsoluteQuorum.sol#4499-4502) uses timestamp for comparisons
	Dangerous comparisons:
	- block.timestamp <= approvalEndTime(actionInfo) && (isFixedLengthApprovalPeriod || ! isActionApproved(actionInfo)) (LlamaAbsoluteQuorum.sol#4500-4501)



    
4500     return
4501       block.timestamp <= approvalEndTime(actionInfo) && (isFixedLengthApprovalPeriod || !isActionApproved(actionInfo));



```

```
Checkpoints._insert(Checkpoints.Checkpoint[],uint64,uint64,uint128) (LlamaAbsoluteQuorum.sol#1920-1948) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(last.timestamp <= timestamp,Checkpoint: invalid timestamp) (LlamaAbsoluteQuorum.sol#1933)
	- last.timestamp == timestamp (LlamaAbsoluteQuorum.sol#1936)



    
1933             require(last.timestamp <= timestamp, "Checkpoint: invalid timestamp");



    
1936             if (last.timestamp == timestamp) {



```

```
LlamaCore.executeAction(ActionInfo) (LlamaAbsoluteQuorum.sol#3658-3684) uses timestamp for comparisons
	Dangerous comparisons:
	- block.timestamp < action.minExecutionTime (LlamaAbsoluteQuorum.sol#3664)



    
3664     if (block.timestamp < action.minExecutionTime) revert MinExecutionTimeNotReached();



```

```
LlamaPolicy.isRoleExpired(address,uint8) (LlamaAbsoluteQuorum.sol#2583-2586) uses timestamp for comparisons
	Dangerous comparisons:
	- quantity > 0 && block.timestamp > expiration (LlamaAbsoluteQuorum.sol#2585)



    
2585     return quantity > 0 && block.timestamp > expiration;



```

### LlamaAccount.sol


```
LlamaPolicy._assertNoActionCreationsAtCurrentTimestamp() (LlamaAccount.sol#3821-3826) uses timestamp for comparisons
	Dangerous comparisons:
	- lastActionCreation == block.timestamp (LlamaAccount.sol#3825)



    
3825     if (lastActionCreation == block.timestamp) revert ActionCreationAtSameTimestamp();



```

```
LlamaCore.executeAction(ActionInfo) (LlamaAccount.sol#4445-4471) uses timestamp for comparisons
	Dangerous comparisons:
	- block.timestamp < action.minExecutionTime (LlamaAccount.sol#4451)



    
4451     if (block.timestamp < action.minExecutionTime) revert MinExecutionTimeNotReached();



```

```
LlamaPolicy._assertValidRoleHolderUpdate(uint8,uint128,uint64) (LlamaAccount.sol#3829-3845) uses timestamp for comparisons
	Dangerous comparisons:
	- case1 = quantity > 0 && expiration > block.timestamp (LlamaAccount.sol#3842)
	- ! (case1 || case2) (LlamaAccount.sol#3844)



    
3842     bool case1 = quantity > 0 && expiration > block.timestamp;



    
3844     if (!(case1 || case2)) revert InvalidRoleHolderInput();



```

```
Checkpoints._insert(Checkpoints.Checkpoint[],uint64,uint64,uint128) (LlamaAccount.sol#2480-2508) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(last.timestamp <= timestamp,Checkpoint: invalid timestamp) (LlamaAccount.sol#2493)
	- last.timestamp == timestamp (LlamaAccount.sol#2496)



    
2493             require(last.timestamp <= timestamp, "Checkpoint: invalid timestamp");



    
2496             if (last.timestamp == timestamp) {



```

```
LlamaPolicy.isRoleExpired(address,uint8) (LlamaAccount.sol#3741-3744) uses timestamp for comparisons
	Dangerous comparisons:
	- quantity > 0 && block.timestamp > expiration (LlamaAccount.sol#3743)



    
3743     return quantity > 0 && block.timestamp > expiration;



```

```
Checkpoints.getAtProbablyRecentTimestamp(Checkpoints.History,uint256) (LlamaAccount.sol#2395-2416) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(timestamp < block.timestamp,Checkpoints: timestamp is not in the past) (LlamaAccount.sol#2396)



    
2396         require(timestamp < block.timestamp, "Checkpoints: timestamp is not in the past");



```

```
LlamaCore.queueAction(ActionInfo) (LlamaAccount.sol#4432-4441) uses timestamp for comparisons
	Dangerous comparisons:
	- minExecutionTime < block.timestamp (LlamaAccount.sol#4438)



    
4438     if (minExecutionTime < block.timestamp) revert MinExecutionTimeCannotBeInThePast();



```

### LlamaCore.sol


```
LlamaCore.queueAction(ActionInfo) (LlamaCore.sol#3494-3503) uses timestamp for comparisons
	Dangerous comparisons:
	- minExecutionTime < block.timestamp (LlamaCore.sol#3500)



    
3500     if (minExecutionTime < block.timestamp) revert MinExecutionTimeCannotBeInThePast();



```

```
Checkpoints.getAtProbablyRecentTimestamp(Checkpoints.History,uint256) (LlamaCore.sol#1457-1478) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(timestamp < block.timestamp,Checkpoints: timestamp is not in the past) (LlamaCore.sol#1458)



    
1458         require(timestamp < block.timestamp, "Checkpoints: timestamp is not in the past");



```

```
Checkpoints._insert(Checkpoints.Checkpoint[],uint64,uint64,uint128) (LlamaCore.sol#1542-1570) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(last.timestamp <= timestamp,Checkpoint: invalid timestamp) (LlamaCore.sol#1555)
	- last.timestamp == timestamp (LlamaCore.sol#1558)



    
1555             require(last.timestamp <= timestamp, "Checkpoint: invalid timestamp");



    
1558             if (last.timestamp == timestamp) {



```

```
LlamaCore.executeAction(ActionInfo) (LlamaCore.sol#3507-3533) uses timestamp for comparisons
	Dangerous comparisons:
	- block.timestamp < action.minExecutionTime (LlamaCore.sol#3513)



    
3513     if (block.timestamp < action.minExecutionTime) revert MinExecutionTimeNotReached();



```

```
LlamaPolicy._assertValidRoleHolderUpdate(uint8,uint128,uint64) (LlamaCore.sol#2891-2907) uses timestamp for comparisons
	Dangerous comparisons:
	- case1 = quantity > 0 && expiration > block.timestamp (LlamaCore.sol#2904)
	- ! (case1 || case2) (LlamaCore.sol#2906)



    
2904     bool case1 = quantity > 0 && expiration > block.timestamp;



    
2906     if (!(case1 || case2)) revert InvalidRoleHolderInput();



```

```
LlamaPolicy._assertNoActionCreationsAtCurrentTimestamp() (LlamaCore.sol#2883-2888) uses timestamp for comparisons
	Dangerous comparisons:
	- lastActionCreation == block.timestamp (LlamaCore.sol#2887)



    
2887     if (lastActionCreation == block.timestamp) revert ActionCreationAtSameTimestamp();



```

```
LlamaPolicy.isRoleExpired(address,uint8) (LlamaCore.sol#2803-2806) uses timestamp for comparisons
	Dangerous comparisons:
	- quantity > 0 && block.timestamp > expiration (LlamaCore.sol#2805)



    
2805     return quantity > 0 && block.timestamp > expiration;



```

### LlamaFactory.sol


```
LlamaPolicy.isRoleExpired(address,uint8) (LlamaFactory.sol#2330-2333) uses timestamp for comparisons
	Dangerous comparisons:
	- quantity > 0 && block.timestamp > expiration (LlamaFactory.sol#2332)



    
2332     return quantity > 0 && block.timestamp > expiration;



```

```
Checkpoints._insert(Checkpoints.Checkpoint[],uint64,uint64,uint128) (LlamaFactory.sol#1664-1692) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(last.timestamp <= timestamp,Checkpoint: invalid timestamp) (LlamaFactory.sol#1677)
	- last.timestamp == timestamp (LlamaFactory.sol#1680)



    
1677             require(last.timestamp <= timestamp, "Checkpoint: invalid timestamp");



    
1680             if (last.timestamp == timestamp) {



```

```
Checkpoints.getAtProbablyRecentTimestamp(Checkpoints.History,uint256) (LlamaFactory.sol#1579-1600) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(timestamp < block.timestamp,Checkpoints: timestamp is not in the past) (LlamaFactory.sol#1580)



    
1580         require(timestamp < block.timestamp, "Checkpoints: timestamp is not in the past");



```

```
LlamaPolicy._assertValidRoleHolderUpdate(uint8,uint128,uint64) (LlamaFactory.sol#2418-2434) uses timestamp for comparisons
	Dangerous comparisons:
	- case1 = quantity > 0 && expiration > block.timestamp (LlamaFactory.sol#2431)
	- ! (case1 || case2) (LlamaFactory.sol#2433)



    
2431     bool case1 = quantity > 0 && expiration > block.timestamp;



    
2433     if (!(case1 || case2)) revert InvalidRoleHolderInput();



```

```
LlamaCore.executeAction(ActionInfo) (LlamaFactory.sol#2844-2870) uses timestamp for comparisons
	Dangerous comparisons:
	- block.timestamp < action.minExecutionTime (LlamaFactory.sol#2850)



    
2850     if (block.timestamp < action.minExecutionTime) revert MinExecutionTimeNotReached();



```

```
LlamaCore.queueAction(ActionInfo) (LlamaFactory.sol#2831-2840) uses timestamp for comparisons
	Dangerous comparisons:
	- minExecutionTime < block.timestamp (LlamaFactory.sol#2837)



    
2837     if (minExecutionTime < block.timestamp) revert MinExecutionTimeCannotBeInThePast();



```

```
LlamaPolicy._assertNoActionCreationsAtCurrentTimestamp() (LlamaFactory.sol#2410-2415) uses timestamp for comparisons
	Dangerous comparisons:
	- lastActionCreation == block.timestamp (LlamaFactory.sol#2414)



    
2414     if (lastActionCreation == block.timestamp) revert ActionCreationAtSameTimestamp();



```

### LlamaGovernanceScript.sol


```
LlamaPolicy._assertNoActionCreationsAtCurrentTimestamp() (LlamaGovernanceScript.sol#2431-2436) uses timestamp for comparisons
	Dangerous comparisons:
	- lastActionCreation == block.timestamp (LlamaGovernanceScript.sol#2435)



    
2435     if (lastActionCreation == block.timestamp) revert ActionCreationAtSameTimestamp();



```

```
LlamaCore.executeAction(ActionInfo) (LlamaGovernanceScript.sol#3426-3452) uses timestamp for comparisons
	Dangerous comparisons:
	- block.timestamp < action.minExecutionTime (LlamaGovernanceScript.sol#3432)



    
3432     if (block.timestamp < action.minExecutionTime) revert MinExecutionTimeNotReached();



```

```
LlamaPolicy.isRoleExpired(address,uint8) (LlamaGovernanceScript.sol#2351-2354) uses timestamp for comparisons
	Dangerous comparisons:
	- quantity > 0 && block.timestamp > expiration (LlamaGovernanceScript.sol#2353)



    
2353     return quantity > 0 && block.timestamp > expiration;



```

```
Checkpoints.getAtProbablyRecentTimestamp(Checkpoints.History,uint256) (LlamaGovernanceScript.sol#1603-1624) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(timestamp < block.timestamp,Checkpoints: timestamp is not in the past) (LlamaGovernanceScript.sol#1604)



    
1604         require(timestamp < block.timestamp, "Checkpoints: timestamp is not in the past");



```

```
LlamaCore.queueAction(ActionInfo) (LlamaGovernanceScript.sol#3413-3422) uses timestamp for comparisons
	Dangerous comparisons:
	- minExecutionTime < block.timestamp (LlamaGovernanceScript.sol#3419)



    
3419     if (minExecutionTime < block.timestamp) revert MinExecutionTimeCannotBeInThePast();



```

```
Checkpoints._insert(Checkpoints.Checkpoint[],uint64,uint64,uint128) (LlamaGovernanceScript.sol#1688-1716) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(last.timestamp <= timestamp,Checkpoint: invalid timestamp) (LlamaGovernanceScript.sol#1701)
	- last.timestamp == timestamp (LlamaGovernanceScript.sol#1704)



    
1701             require(last.timestamp <= timestamp, "Checkpoint: invalid timestamp");



    
1704             if (last.timestamp == timestamp) {



```

```
LlamaPolicy._assertValidRoleHolderUpdate(uint8,uint128,uint64) (LlamaGovernanceScript.sol#2439-2455) uses timestamp for comparisons
	Dangerous comparisons:
	- case1 = quantity > 0 && expiration > block.timestamp (LlamaGovernanceScript.sol#2452)
	- ! (case1 || case2) (LlamaGovernanceScript.sol#2454)



    
2452     bool case1 = quantity > 0 && expiration > block.timestamp;



    
2454     if (!(case1 || case2)) revert InvalidRoleHolderInput();



```

### LlamaPolicy.sol


```
LlamaCore.queueAction(ActionInfo) (LlamaPolicy.sol#2820-2829) uses timestamp for comparisons
	Dangerous comparisons:
	- minExecutionTime < block.timestamp (LlamaPolicy.sol#2826)



    
2826     if (minExecutionTime < block.timestamp) revert MinExecutionTimeCannotBeInThePast();



```

```
Checkpoints.getAtProbablyRecentTimestamp(Checkpoints.History,uint256) (LlamaPolicy.sol#1164-1185) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(timestamp < block.timestamp,Checkpoints: timestamp is not in the past) (LlamaPolicy.sol#1165)



    
1165         require(timestamp < block.timestamp, "Checkpoints: timestamp is not in the past");



```

```
LlamaPolicy.isRoleExpired(address,uint8) (LlamaPolicy.sol#3781-3784) uses timestamp for comparisons
	Dangerous comparisons:
	- quantity > 0 && block.timestamp > expiration (LlamaPolicy.sol#3783)



    
3783     return quantity > 0 && block.timestamp > expiration;



```

```
Checkpoints._insert(Checkpoints.Checkpoint[],uint64,uint64,uint128) (LlamaPolicy.sol#1249-1277) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(last.timestamp <= timestamp,Checkpoint: invalid timestamp) (LlamaPolicy.sol#1262)
	- last.timestamp == timestamp (LlamaPolicy.sol#1265)



    
1262             require(last.timestamp <= timestamp, "Checkpoint: invalid timestamp");



    
1265             if (last.timestamp == timestamp) {



```

```
LlamaPolicy._assertValidRoleHolderUpdate(uint8,uint128,uint64) (LlamaPolicy.sol#3869-3885) uses timestamp for comparisons
	Dangerous comparisons:
	- case1 = quantity > 0 && expiration > block.timestamp (LlamaPolicy.sol#3882)
	- ! (case1 || case2) (LlamaPolicy.sol#3884)



    
3882     bool case1 = quantity > 0 && expiration > block.timestamp;



    
3884     if (!(case1 || case2)) revert InvalidRoleHolderInput();



```

```
LlamaCore.executeAction(ActionInfo) (LlamaPolicy.sol#2833-2859) uses timestamp for comparisons
	Dangerous comparisons:
	- block.timestamp < action.minExecutionTime (LlamaPolicy.sol#2839)



    
2839     if (block.timestamp < action.minExecutionTime) revert MinExecutionTimeNotReached();



```

```
LlamaPolicy._assertNoActionCreationsAtCurrentTimestamp() (LlamaPolicy.sol#3861-3866) uses timestamp for comparisons
	Dangerous comparisons:
	- lastActionCreation == block.timestamp (LlamaPolicy.sol#3865)



    
3865     if (lastActionCreation == block.timestamp) revert ActionCreationAtSameTimestamp();



```

### LlamaRelativeQuorum.sol


```
Checkpoints.getAtProbablyRecentTimestamp(Checkpoints.History,uint256) (LlamaRelativeQuorum.sol#1835-1856) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(timestamp < block.timestamp,Checkpoints: timestamp is not in the past) (LlamaRelativeQuorum.sol#1836)



    
1836         require(timestamp < block.timestamp, "Checkpoints: timestamp is not in the past");



```

```
LlamaRelativeQuorum.isActive(ActionInfo) (LlamaRelativeQuorum.sol#4509-4512) uses timestamp for comparisons
	Dangerous comparisons:
	- block.timestamp <= approvalEndTime(actionInfo) && (isFixedLengthApprovalPeriod || ! isActionApproved(actionInfo)) (LlamaRelativeQuorum.sol#4510-4511)



    
4510     return
4511       block.timestamp <= approvalEndTime(actionInfo) && (isFixedLengthApprovalPeriod || !isActionApproved(actionInfo));



```

```
LlamaPolicy._assertNoActionCreationsAtCurrentTimestamp() (LlamaRelativeQuorum.sol#2663-2668) uses timestamp for comparisons
	Dangerous comparisons:
	- lastActionCreation == block.timestamp (LlamaRelativeQuorum.sol#2667)



    
2667     if (lastActionCreation == block.timestamp) revert ActionCreationAtSameTimestamp();



```

```
LlamaPolicy._assertValidRoleHolderUpdate(uint8,uint128,uint64) (LlamaRelativeQuorum.sol#2671-2687) uses timestamp for comparisons
	Dangerous comparisons:
	- case1 = quantity > 0 && expiration > block.timestamp (LlamaRelativeQuorum.sol#2684)
	- ! (case1 || case2) (LlamaRelativeQuorum.sol#2686)



    
2684     bool case1 = quantity > 0 && expiration > block.timestamp;



    
2686     if (!(case1 || case2)) revert InvalidRoleHolderInput();



```

```
LlamaCore.queueAction(ActionInfo) (LlamaRelativeQuorum.sol#3645-3654) uses timestamp for comparisons
	Dangerous comparisons:
	- minExecutionTime < block.timestamp (LlamaRelativeQuorum.sol#3651)



    
3651     if (minExecutionTime < block.timestamp) revert MinExecutionTimeCannotBeInThePast();



```

```
Checkpoints._insert(Checkpoints.Checkpoint[],uint64,uint64,uint128) (LlamaRelativeQuorum.sol#1920-1948) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(last.timestamp <= timestamp,Checkpoint: invalid timestamp) (LlamaRelativeQuorum.sol#1933)
	- last.timestamp == timestamp (LlamaRelativeQuorum.sol#1936)



    
1933             require(last.timestamp <= timestamp, "Checkpoint: invalid timestamp");



    
1936             if (last.timestamp == timestamp) {



```

```
LlamaCore.executeAction(ActionInfo) (LlamaRelativeQuorum.sol#3658-3684) uses timestamp for comparisons
	Dangerous comparisons:
	- block.timestamp < action.minExecutionTime (LlamaRelativeQuorum.sol#3664)



    
3664     if (block.timestamp < action.minExecutionTime) revert MinExecutionTimeNotReached();



```

```
LlamaRelativeQuorum.isActionExpired(ActionInfo) (LlamaRelativeQuorum.sol#4528-4531) uses timestamp for comparisons
	Dangerous comparisons:
	- block.timestamp > action.minExecutionTime + expirationPeriod (LlamaRelativeQuorum.sol#4530)



    
4530     return block.timestamp > action.minExecutionTime + expirationPeriod;



```

```
LlamaPolicy.isRoleExpired(address,uint8) (LlamaRelativeQuorum.sol#2583-2586) uses timestamp for comparisons
	Dangerous comparisons:
	- quantity > 0 && block.timestamp > expiration (LlamaRelativeQuorum.sol#2585)



    
2585     return quantity > 0 && block.timestamp > expiration;



```

## assembly
### Severity: Informational

### LlamaAbsolutePeerReview.sol


```
LibString.toHexStringChecksummed(address) (LlamaAbsolutePeerReview.sol#943-960) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#946-959)



    
946         assembly {
947             let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`
948             let o := add(str, 0x22)
949             let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `
950             let t := shl(240, 136) // `0b10001000 << 240`
951             for { let i := 0 } 1 {} {
952                 mstore(add(i, i), mul(t, byte(i, hashed)))
953                 i := add(i, 1)
954                 if eq(i, 20) { break }
955             }
956             mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))
957             o := add(o, 0x20)
958             mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))
959         }



```

```
LibString.packOne(string) (LlamaAbsolutePeerReview.sol#1702-1716) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#1704-1715)



    
1704         assembly {
1705             // We don't need to zero right pad the string,
1706             // since this is our own custom non-standard packing scheme.
1707             result :=
1708                 mul(
1709                     // Load the length and the bytes.
1710                     mload(add(a, 0x1f)),
1711                     // `length != 0 && length < 32`. Abuses underflow.
1712                     // Assumes that the length is valid and within the block gas limit.
1713                     lt(sub(mload(a), 1), 0x1f)
1714                 )
1715         }



```

```
FixedPointMathLib.mulDivUp(uint256,uint256,uint256) (LlamaAbsolutePeerReview.sol#236-252) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#242-251)



    
242         assembly {
243             // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))
244             if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {
245                 revert(0, 0)
246             }
247 
248             // If x * y modulo the denominator is strictly greater than 0,
249             // 1 is added to round up the division of x * y by the denominator.
250             z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))
251         }



```

```
FixedPointMathLib.sqrt(uint256) (LlamaAbsolutePeerReview.sol#347-410) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#349-409)



    
349         assembly {
350             let y := x // We start y at x, which will help us make our initial estimate.
351 
352             z := 181 // The "correct" value is 1, but this saves a multiplication later.
353 
354             // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad
355             // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.
356 
357             // We check y >= 2^(k + 8) but shift right by k bits
358             // each branch to ensure that if x >= 256, then y >= 256.
359             if iszero(lt(y, 0x10000000000000000000000000000000000)) {
360                 y := shr(128, y)
361                 z := shl(64, z)
362             }
363             if iszero(lt(y, 0x1000000000000000000)) {
364                 y := shr(64, y)
365                 z := shl(32, z)
366             }
367             if iszero(lt(y, 0x10000000000)) {
368                 y := shr(32, y)
369                 z := shl(16, z)
370             }
371             if iszero(lt(y, 0x1000000)) {
372                 y := shr(16, y)
373                 z := shl(8, z)
374             }
375 
376             // Goal was to get z*z*y within a small factor of x. More iterations could
377             // get y in a tighter range. Currently, we will have y in [256, 256*2^16).
378             // We ensured y >= 256 so that the relative difference between y and y+1 is small.
379             // That's not possible if x < 256 but we can just verify those cases exhaustively.
380 
381             // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.
382             // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.
383             // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.
384 
385             // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range
386             // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.
387 
388             // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate
389             // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.
390 
391             // There is no overflow risk here since y < 2^136 after the first branch above.
392             z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.
393 
394             // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.
395             z := shr(1, add(z, div(x, z)))
396             z := shr(1, add(z, div(x, z)))
397             z := shr(1, add(z, div(x, z)))
398             z := shr(1, add(z, div(x, z)))
399             z := shr(1, add(z, div(x, z)))
400             z := shr(1, add(z, div(x, z)))
401             z := shr(1, add(z, div(x, z)))
402 
403             // If x+1 is a perfect square, the Babylonian method cycles between
404             // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.
405             // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division
406             // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.
407             // If you don't care whether the floor or ceil square root is returned, you can remove this statement.
408             z := sub(z, lt(div(x, z), z))
409         }



```

```
LibString.toHexStringNoPrefix(bytes) (LlamaAbsolutePeerReview.sol#1027-1049) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#1029-1048)



    
1029         assembly {
1030             let length := mload(raw)
1031             str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.
1032             mstore(str, add(length, length)) // Store the length of the output.
1033 
1034             // Store "0123456789abcdef" in scratch space.
1035             mstore(0x0f, 0x30313233343536373839616263646566)
1036 
1037             let o := add(str, 0x20)
1038             let end := add(raw, length)
1039 
1040             for {} iszero(eq(raw, end)) {} {
1041                 raw := add(raw, 1)
1042                 mstore8(add(o, 1), mload(and(mload(raw), 15)))
1043                 mstore8(o, mload(and(shr(4, mload(raw)), 15)))
1044                 o := add(o, 2)
1045             }
1046             mstore(o, 0) // Zeroize the slot after the string.
1047             mstore(0x40, add(o, 0x20)) // Allocate the memory.
1048         }



```

```
LibString.toString(int256) (LlamaAbsolutePeerReview.sol#761-777) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#769-776)



    
769         assembly {
770             // We still have some spare memory space on the left,
771             // as we have allocated 3 words (96 bytes) for up to 78 digits.
772             let length := mload(str) // Load the string length.
773             mstore(str, 0x2d) // Store the '-' character.
774             str := sub(str, 1) // Move back the string pointer by a byte.
775             mstore(str, add(length, 1)) // Update the string length.
776         }



```

```
Base64.encode(bytes) (LlamaAbsolutePeerReview.sol#2811-2882) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#2830-2879)



    
2830         assembly {
2831             // Prepare the lookup table (skip the first "length" byte)
2832             let tablePtr := add(table, 1)
2833 
2834             // Prepare result pointer, jump over length
2835             let resultPtr := add(result, 32)
2836 
2837             // Run over the input, 3 bytes at a time
2838             for {
2839                 let dataPtr := data
2840                 let endPtr := add(data, mload(data))
2841             } lt(dataPtr, endPtr) {
2842 
2843             } {
2844                 // Advance 3 bytes
2845                 dataPtr := add(dataPtr, 3)
2846                 let input := mload(dataPtr)
2847 
2848                 // To write each character, shift the 3 bytes (18 bits) chunk
2849                 // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)
2850                 // and apply logical AND with 0x3F which is the number of
2851                 // the previous character in the ASCII table prior to the Base64 Table
2852                 // The result is then added to the table to get the character to write,
2853                 // and finally write it in the result pointer but with a left shift
2854                 // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits
2855 
2856                 mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))
2857                 resultPtr := add(resultPtr, 1) // Advance
2858 
2859                 mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))
2860                 resultPtr := add(resultPtr, 1) // Advance
2861 
2862                 mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))
2863                 resultPtr := add(resultPtr, 1) // Advance
2864 
2865                 mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))
2866                 resultPtr := add(resultPtr, 1) // Advance
2867             }
2868 
2869             // When data `bytes` is not exactly 3 bytes long
2870             // it is padded with `=` characters at the end
2871             switch mod(mload(data), 3)
2872             case 1 {
2873                 mstore8(sub(resultPtr, 1), 0x3d)
2874                 mstore8(sub(resultPtr, 2), 0x3d)
2875             }
2876             case 2 {
2877                 mstore8(sub(resultPtr, 1), 0x3d)
2878             }
2879         }



```

```
FixedPointMathLib.unsafeDivUp(uint256,uint256) (LlamaAbsolutePeerReview.sol#430-437) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#432-436)



    
432         assembly {
433             // Add 1 to x * y if x % y > 0. Note this will
434             // return 0 instead of reverting if y is zero.
435             z := add(gt(mod(x, y), 0), div(x, y))
436         }



```

```
LibString.packTwo(string,string) (LlamaAbsolutePeerReview.sol#1739-1757) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#1741-1756)



    
1741         assembly {
1742             let aLength := mload(a)
1743             // We don't need to zero right pad the strings,
1744             // since this is our own custom non-standard packing scheme.
1745             result :=
1746                 mul(
1747                     // Load the length and the bytes of `a` and `b`.
1748                     or(
1749                         shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),
1750                         mload(sub(add(b, 0x1e), aLength))
1751                     ),
1752                     // `totalLength != 0 && totalLength < 31`. Abuses underflow.
1753                     // Assumes that the lengths are valid and within the block gas limit.
1754                     lt(sub(add(aLength, mload(b)), 1), 0x1e)
1755                 )
1756         }



```

```
LibString.toString(uint256) (LlamaAbsolutePeerReview.sol#723-758) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#725-757)



    
725         assembly {
726             // The maximum value of a uint256 contains 78 digits (1 byte per digit), but
727             // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.
728             // We will need 1 word for the trailing zeros padding, 1 word for the length,
729             // and 3 words for a maximum of 78 digits.
730             str := add(mload(0x40), 0x80)
731             // Update the free memory pointer to allocate.
732             mstore(0x40, add(str, 0x20))
733             // Zeroize the slot after the string.
734             mstore(str, 0)
735 
736             // Cache the end of the memory to calculate the length later.
737             let end := str
738 
739             let w := not(0) // Tsk.
740             // We write the string from rightmost digit to leftmost digit.
741             // The following is essentially a do-while loop that also handles the zero case.
742             for { let temp := value } 1 {} {
743                 str := add(str, w) // `sub(str, 1)`.
744                 // Write the character to the pointer.
745                 // The ASCII index of the '0' character is 48.
746                 mstore8(str, add(48, mod(temp, 10)))
747                 // Keep dividing `temp` until zero.
748                 temp := div(temp, 10)
749                 if iszero(temp) { break }
750             }
751 
752             let length := sub(end, str)
753             // Move the pointer 32 bytes leftwards to make room for the length.
754             str := sub(str, 0x20)
755             // Store the length.
756             mstore(str, length)
757         }



```

```
Clones.cloneDeterministic(address,bytes32) (LlamaAbsolutePeerReview.sol#536-549) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#538-545)



    
538         assembly {
539             // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
540             // of the `implementation` address with the bytecode before the address.
541             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
542             // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
543             mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
544             instance := create2(0, 0x09, 0x37, salt)
545         }



```

```
FixedPointMathLib.unsafeMod(uint256,uint256) (LlamaAbsolutePeerReview.sol#412-419) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#414-418)



    
414         assembly {
415             // Mod x by y. Note this will return
416             // 0 instead of reverting if y is zero.
417             z := mod(x, y)
418         }



```

```
LibString.runeCount(string) (LlamaAbsolutePeerReview.sol#1056-1070) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#1058-1069)



    
1058         assembly {
1059             if mload(s) {
1060                 mstore(0x00, div(not(0), 255))
1061                 mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)
1062                 let o := add(s, 0x20)
1063                 let end := add(o, mload(s))
1064                 for { result := 1 } 1 { result := add(result, 1) } {
1065                     o := add(o, byte(0, mload(shr(250, mload(o)))))
1066                     if iszero(lt(o, end)) { break }
1067                 }
1068             }
1069         }



```

```
LibString.toMinimalHexStringNoPrefix(uint256) (LlamaAbsolutePeerReview.sol#888-897) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#891-896)



    
891         assembly {
892             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
893             let strLength := mload(str) // Get the length.
894             str := add(str, o) // Move the pointer, accounting for leading zero.
895             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
896         }



```

```
LibString.toHexStringNoPrefix(uint256,uint256) (LlamaAbsolutePeerReview.sol#804-852) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#810-851)



    
810         assembly {
811             // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes
812             // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.
813             // We add 0x20 to the total and round down to a multiple of 0x20.
814             // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.
815             str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))
816             // Allocate the memory.
817             mstore(0x40, add(str, 0x20))
818             // Zeroize the slot after the string.
819             mstore(str, 0)
820 
821             // Cache the end to calculate the length later.
822             let end := str
823             // Store "0123456789abcdef" in scratch space.
824             mstore(0x0f, 0x30313233343536373839616263646566)
825 
826             let start := sub(str, add(length, length))
827             let w := not(1) // Tsk.
828             let temp := value
829             // We write the string from rightmost digit to leftmost digit.
830             // The following is essentially a do-while loop that also handles the zero case.
831             for {} 1 {} {
832                 str := add(str, w) // `sub(str, 2)`.
833                 mstore8(add(str, 1), mload(and(temp, 15)))
834                 mstore8(str, mload(and(shr(4, temp), 15)))
835                 temp := shr(8, temp)
836                 if iszero(xor(str, start)) { break }
837             }
838 
839             if temp {
840                 // Store the function selector of `HexLengthInsufficient()`.
841                 mstore(0x00, 0x2194895a)
842                 // Revert with (offset, size).
843                 revert(0x1c, 0x04)
844             }
845 
846             // Compute the string's length.
847             let strLength := sub(end, str)
848             // Move the pointer and write the length.
849             str := sub(str, 0x20)
850             mstore(str, strLength)
851         }



```

```
LibString.endsWith(string,string) (LlamaAbsolutePeerReview.sol#1319-1344) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#1325-1343)



    
1325         assembly {
1326             let searchLength := mload(search)
1327             let subjectLength := mload(subject)
1328             // Whether `search` is not longer than `subject`.
1329             let withinRange := iszero(gt(searchLength, subjectLength))
1330             // Just using keccak256 directly is actually cheaper.
1331             // forgefmt: disable-next-item
1332             result := and(
1333                 withinRange,
1334                 eq(
1335                     keccak256(
1336                         // `subject + 0x20 + max(subjectLength - searchLength, 0)`.
1337                         add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),
1338                         searchLength
1339                     ),
1340                     keccak256(add(search, 0x20), searchLength)
1341                 )
1342             )
1343         }



```

```
LibString.toHexStringNoPrefix(uint256) (LlamaAbsolutePeerReview.sol#903-937) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#905-936)



    
905         assembly {
906             // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,
907             // 0x02 bytes for the prefix, and 0x40 bytes for the digits.
908             // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.
909             str := add(mload(0x40), 0x80)
910             // Allocate the memory.
911             mstore(0x40, add(str, 0x20))
912             // Zeroize the slot after the string.
913             mstore(str, 0)
914 
915             // Cache the end to calculate the length later.
916             let end := str
917             // Store "0123456789abcdef" in scratch space.
918             mstore(0x0f, 0x30313233343536373839616263646566)
919 
920             let w := not(1) // Tsk.
921             // We write the string from rightmost digit to leftmost digit.
922             // The following is essentially a do-while loop that also handles the zero case.
923             for { let temp := value } 1 {} {
924                 str := add(str, w) // `sub(str, 2)`.
925                 mstore8(add(str, 1), mload(and(temp, 15)))
926                 mstore8(str, mload(and(shr(4, temp), 15)))
927                 temp := shr(8, temp)
928                 if iszero(temp) { break }
929             }
930 
931             // Compute the string's length.
932             let strLength := sub(end, str)
933             // Move the pointer and write the length.
934             str := sub(str, 0x20)
935             mstore(str, strLength)
936         }



```

```
LibString.toMinimalHexString(uint256) (LlamaAbsolutePeerReview.sol#873-883) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#876-882)



    
876         assembly {
877             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
878             let strLength := add(mload(str), 2) // Compute the length.
879             mstore(add(str, o), 0x3078) // Write the "0x" prefix, accounting for leading zero.
880             str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.
881             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
882         }



```

```
Checkpoints._unsafeAccess(Checkpoints.Checkpoint[],uint256) (LlamaAbsolutePeerReview.sol#1998-2007) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#2003-2006)



    
2003         assembly {
2004             mstore(0, self.slot)
2005             result.slot := add(keccak256(0, 0x20), pos)
2006         }



```

```
LibString.concat(string,string) (LlamaAbsolutePeerReview.sol#1532-1566) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#1538-1565)



    
1538         assembly {
1539             let w := not(0x1f)
1540             result := mload(0x40)
1541             let aLength := mload(a)
1542             // Copy `a` one word at a time, backwards.
1543             for { let o := and(add(aLength, 0x20), w) } 1 {} {
1544                 mstore(add(result, o), mload(add(a, o)))
1545                 o := add(o, w) // `sub(o, 0x20)`.
1546                 if iszero(o) { break }
1547             }
1548             let bLength := mload(b)
1549             let output := add(result, aLength)
1550             // Copy `b` one word at a time, backwards.
1551             for { let o := and(add(bLength, 0x20), w) } 1 {} {
1552                 mstore(add(output, o), mload(add(b, o)))
1553                 o := add(o, w) // `sub(o, 0x20)`.
1554                 if iszero(o) { break }
1555             }
1556             let totalLength := add(aLength, bLength)
1557             let last := add(add(result, 0x20), totalLength)
1558             // Zeroize the slot after the string.
1559             mstore(last, 0)
1560             // Stores the length.
1561             mstore(result, totalLength)
1562             // Allocate memory for the length and the bytes,
1563             // rounded up to a multiple of 32.
1564             mstore(0x40, and(add(last, 0x1f), w))
1565         }



```

```
LibString.eq(string,string) (LlamaAbsolutePeerReview.sol#1694-1698) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#1695-1697)



    
1695         assembly {
1696             result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))
1697         }



```

```
Checkpoints.sqrt(uint256) (LlamaAbsolutePeerReview.sol#2021-2083) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#2022-2082)



    
2022         assembly {
2023             let y := x // We start y at x, which will help us make our initial estimate.
2024 
2025             z := 181 // The "correct" value is 1, but this saves a multiplication later.
2026 
2027             // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad
2028             // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.
2029 
2030             // We check y >= 2^(k + 8) but shift right by k bits
2031             // each branch to ensure that if x >= 256, then y >= 256.
2032             if iszero(lt(y, 0x10000000000000000000000000000000000)) {
2033                 y := shr(128, y)
2034                 z := shl(64, z)
2035             }
2036             if iszero(lt(y, 0x1000000000000000000)) {
2037                 y := shr(64, y)
2038                 z := shl(32, z)
2039             }
2040             if iszero(lt(y, 0x10000000000)) {
2041                 y := shr(32, y)
2042                 z := shl(16, z)
2043             }
2044             if iszero(lt(y, 0x1000000)) {
2045                 y := shr(16, y)
2046                 z := shl(8, z)
2047             }
2048 
2049             // Goal was to get z*z*y within a small factor of x. More iterations could
2050             // get y in a tighter range. Currently, we will have y in [256, 256*2^16).
2051             // We ensured y >= 256 so that the relative difference between y and y+1 is small.
2052             // That's not possible if x < 256 but we can just verify those cases exhaustively.
2053 
2054             // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.
2055             // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.
2056             // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.
2057 
2058             // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range
2059             // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.
2060 
2061             // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate
2062             // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.
2063 
2064             // There is no overflow risk here since y < 2^136 after the first branch above.
2065             z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.
2066 
2067             // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.
2068             z := shr(1, add(z, div(x, z)))
2069             z := shr(1, add(z, div(x, z)))
2070             z := shr(1, add(z, div(x, z)))
2071             z := shr(1, add(z, div(x, z)))
2072             z := shr(1, add(z, div(x, z)))
2073             z := shr(1, add(z, div(x, z)))
2074             z := shr(1, add(z, div(x, z)))
2075 
2076             // If x+1 is a perfect square, the Babylonian method cycles between
2077             // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.
2078             // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division
2079             // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.
2080             // If you don't care whether the floor or ceil square root is returned, you can remove this statement.
2081             z := sub(z, lt(div(x, z), z))
2082         }



```

```
LibString.toHexString(uint256,uint256) (LlamaAbsolutePeerReview.sol#788-797) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#791-796)



    
791         assembly {
792             let strLength := add(mload(str), 2) // Compute the length.
793             mstore(str, 0x3078) // Write the "0x" prefix.
794             str := sub(str, 2) // Move the pointer.
795             mstore(str, strLength) // Write the length.
796         }



```

```
LibString.toCase(string,bool) (LlamaAbsolutePeerReview.sol#1570-1596) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#1576-1595)



    
1576         assembly {
1577             let length := mload(subject)
1578             if length {
1579                 result := add(mload(0x40), 0x20)
1580                 subject := add(subject, 1)
1581                 let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)
1582                 let w := not(0)
1583                 for { let o := length } 1 {} {
1584                     o := add(o, w)
1585                     let b := and(0xff, mload(add(subject, o)))
1586                     mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))
1587                     if iszero(o) { break }
1588                 }
1589                 result := mload(0x40)
1590                 mstore(result, length) // Store the length.
1591                 let last := add(add(result, 0x20), length)
1592                 mstore(last, 0) // Zeroize the slot after the string.
1593                 mstore(0x40, add(last, 0x20)) // Allocate the memory.
1594             }
1595         }



```

```
LibString.escapeHTML(string) (LlamaAbsolutePeerReview.sol#1611-1642) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#1613-1641)



    
1613         assembly {
1614             for {
1615                 let end := add(s, mload(s))
1616                 result := add(mload(0x40), 0x20)
1617                 // Store the bytes of the packed offsets and strides into the scratch space.
1618                 // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.
1619                 mstore(0x1f, 0x900094)
1620                 mstore(0x08, 0xc0000000a6ab)
1621                 // Store "&quot;&amp;&#39;&lt;&gt;" into the scratch space.
1622                 mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))
1623             } iszero(eq(s, end)) {} {
1624                 s := add(s, 1)
1625                 let c := and(mload(s), 0xff)
1626                 // Not in `["\"","'","&","<",">"]`.
1627                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
1628                     mstore8(result, c)
1629                     result := add(result, 1)
1630                     continue
1631                 }
1632                 let t := shr(248, mload(c))
1633                 mstore(result, mload(and(t, 0x1f)))
1634                 result := add(result, shr(5, t))
1635             }
1636             let last := result
1637             mstore(last, 0) // Zeroize the slot after the string.
1638             result := mload(0x40)
1639             mstore(result, sub(last, add(result, 0x20))) // Store the length.
1640             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1641         }



```

```
LibString.directReturn(string) (LlamaAbsolutePeerReview.sol#1787-1800) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#1788-1799)



    
1788         assembly {
1789             // Assumes that the string does not start from the scratch space.
1790             let retStart := sub(a, 0x20)
1791             let retSize := add(mload(a), 0x40)
1792             // Right pad with zeroes. Just in case the string is produced
1793             // by a method that doesn't zero right pad.
1794             mstore(add(retStart, retSize), 0)
1795             // Store the return offset.
1796             mstore(retStart, 0x20)
1797             // End the transaction, returning the string.
1798             return(retStart, retSize)
1799         }



```

```
LibString.repeat(string,uint256) (LlamaAbsolutePeerReview.sol#1347-1377) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#1353-1376)



    
1353         assembly {
1354             let subjectLength := mload(subject)
1355             if iszero(or(iszero(times), iszero(subjectLength))) {
1356                 subject := add(subject, 0x20)
1357                 result := mload(0x40)
1358                 let output := add(result, 0x20)
1359                 for {} 1 {} {
1360                     // Copy the `subject` one word at a time.
1361                     for { let o := 0 } 1 {} {
1362                         mstore(add(output, o), mload(add(subject, o)))
1363                         o := add(o, 0x20)
1364                         if iszero(lt(o, subjectLength)) { break }
1365                     }
1366                     output := add(output, subjectLength)
1367                     times := sub(times, 1)
1368                     if iszero(times) { break }
1369                 }
1370                 mstore(output, 0) // Zeroize the slot after the string.
1371                 let resultLength := sub(output, add(result, 0x20))
1372                 mstore(result, resultLength) // Store the length.
1373                 // Allocate the memory.
1374                 mstore(0x40, add(result, add(resultLength, 0x20)))
1375             }
1376         }



```

```
LibString.split(string,string) (LlamaAbsolutePeerReview.sol#1483-1528) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#1490-1527)



    
1490         assembly {
1491             let w := not(0x1f)
1492             let indexPtr := add(indices, 0x20)
1493             let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))
1494             mstore(add(indicesEnd, w), mload(subject))
1495             mstore(indices, add(mload(indices), 1))
1496             let prevIndex := 0
1497             for {} 1 {} {
1498                 let index := mload(indexPtr)
1499                 mstore(indexPtr, 0x60)
1500                 if iszero(eq(index, prevIndex)) {
1501                     let element := mload(0x40)
1502                     let elementLength := sub(index, prevIndex)
1503                     mstore(element, elementLength)
1504                     // Copy the `subject` one word at a time, backwards.
1505                     for { let o := and(add(elementLength, 0x1f), w) } 1 {} {
1506                         mstore(add(element, o), mload(add(add(subject, prevIndex), o)))
1507                         o := add(o, w) // `sub(o, 0x20)`.
1508                         if iszero(o) { break }
1509                     }
1510                     // Zeroize the slot after the string.
1511                     mstore(add(add(element, 0x20), elementLength), 0)
1512                     // Allocate memory for the length and the bytes,
1513                     // rounded up to a multiple of 32.
1514                     mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))
1515                     // Store the `element` into the array.
1516                     mstore(indexPtr, element)
1517                 }
1518                 prevIndex := add(index, mload(delimiter))
1519                 indexPtr := add(indexPtr, 0x20)
1520                 if iszero(lt(indexPtr, indicesEnd)) { break }
1521             }
1522             result := indices
1523             if iszero(mload(delimiter)) {
1524                 result := add(indices, 0x20)
1525                 mstore(result, sub(mload(indices), 2))
1526             }
1527         }



```

```
FixedPointMathLib.rpow(uint256,uint256,uint256) (LlamaAbsolutePeerReview.sol#254-341) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#260-340)



    
260         assembly {
261             switch x
262             case 0 {
263                 switch n
264                 case 0 {
265                     // 0 ** 0 = 1
266                     z := scalar
267                 }
268                 default {
269                     // 0 ** n = 0
270                     z := 0
271                 }
272             }
273             default {
274                 switch mod(n, 2)
275                 case 0 {
276                     // If n is even, store scalar in z for now.
277                     z := scalar
278                 }
279                 default {
280                     // If n is odd, store x in z for now.
281                     z := x
282                 }
283 
284                 // Shifting right by 1 is like dividing by 2.
285                 let half := shr(1, scalar)
286 
287                 for {
288                     // Shift n right by 1 before looping to halve it.
289                     n := shr(1, n)
290                 } n {
291                     // Shift n right by 1 each iteration to halve it.
292                     n := shr(1, n)
293                 } {
294                     // Revert immediately if x ** 2 would overflow.
295                     // Equivalent to iszero(eq(div(xx, x), x)) here.
296                     if shr(128, x) {
297                         revert(0, 0)
298                     }
299 
300                     // Store x squared.
301                     let xx := mul(x, x)
302 
303                     // Round to the nearest number.
304                     let xxRound := add(xx, half)
305 
306                     // Revert if xx + half overflowed.
307                     if lt(xxRound, xx) {
308                         revert(0, 0)
309                     }
310 
311                     // Set x to scaled xxRound.
312                     x := div(xxRound, scalar)
313 
314                     // If n is even:
315                     if mod(n, 2) {
316                         // Compute z * x.
317                         let zx := mul(z, x)
318 
319                         // If z * x overflowed:
320                         if iszero(eq(div(zx, x), z)) {
321                             // Revert if x is non-zero.
322                             if iszero(iszero(x)) {
323                                 revert(0, 0)
324                             }
325                         }
326 
327                         // Round to the nearest number.
328                         let zxRound := add(zx, half)
329 
330                         // Revert if zx + half overflowed.
331                         if lt(zxRound, zx) {
332                             revert(0, 0)
333                         }
334 
335                         // Return properly scaled zxRound.
336                         z := div(zxRound, scalar)
337                     }
338                 }
339             }
340         }



```

```
LibString.unpackTwo(bytes32) (LlamaAbsolutePeerReview.sol#1762-1784) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#1768-1783)



    
1768         assembly {
1769             // Grab the free memory pointer.
1770             resultA := mload(0x40)
1771             resultB := add(resultA, 0x40)
1772             // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.
1773             mstore(0x40, add(resultB, 0x40))
1774             // Zeroize the length slots.
1775             mstore(resultA, 0)
1776             mstore(resultB, 0)
1777             // Store the lengths and bytes.
1778             mstore(add(resultA, 0x1f), packed)
1779             mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))
1780             // Right pad with zeroes.
1781             mstore(add(add(resultA, 0x20), mload(resultA)), 0)
1782             mstore(add(add(resultB, 0x20), mload(resultB)), 0)
1783         }



```

```
LibString.lastIndexOf(string,string,uint256) (LlamaAbsolutePeerReview.sol#1252-1284) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#1258-1283)



    
1258         assembly {
1259             for {} 1 {} {
1260                 result := not(0) // Initialize to `NOT_FOUND`.
1261                 let searchLength := mload(search)
1262                 if gt(searchLength, mload(subject)) { break }
1263                 let w := result
1264 
1265                 let fromMax := sub(mload(subject), searchLength)
1266                 if iszero(gt(fromMax, from)) { from := fromMax }
1267 
1268                 let end := add(add(subject, 0x20), w)
1269                 subject := add(add(subject, 0x20), from)
1270                 if iszero(gt(subject, end)) { break }
1271                 // As this function is not too often used,
1272                 // we shall simply use keccak256 for smaller bytecode size.
1273                 for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
1274                     if eq(keccak256(subject, searchLength), h) {
1275                         result := sub(subject, add(end, 1))
1276                         break
1277                     }
1278                     subject := add(subject, w) // `sub(subject, 1)`.
1279                     if iszero(gt(subject, end)) { break }
1280                 }
1281                 break
1282             }
1283         }



```

```
LibString.is7BitASCII(string) (LlamaAbsolutePeerReview.sol#1074-1096) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#1076-1095)



    
1076         assembly {
1077             let mask := shl(7, div(not(0), 255))
1078             result := 1
1079             let n := mload(s)
1080             if n {
1081                 let o := add(s, 0x20)
1082                 let end := add(o, n)
1083                 let last := mload(end)
1084                 mstore(end, 0)
1085                 for {} 1 {} {
1086                     if and(mask, mload(o)) {
1087                         result := 0
1088                         break
1089                     }
1090                     o := add(o, 0x20)
1091                     if iszero(lt(o, end)) { break }
1092                 }
1093                 mstore(end, last)
1094             }
1095         }



```

```
LibString.startsWith(string,string) (LlamaAbsolutePeerReview.sol#1298-1316) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#1304-1315)



    
1304         assembly {
1305             let searchLength := mload(search)
1306             // Just using keccak256 directly is actually cheaper.
1307             // forgefmt: disable-next-item
1308             result := and(
1309                 iszero(gt(searchLength, mload(subject))),
1310                 eq(
1311                     keccak256(add(subject, 0x20), searchLength),
1312                     keccak256(add(search, 0x20), searchLength)
1313                 )
1314             )
1315         }



```

```
LibString.escapeJSON(string) (LlamaAbsolutePeerReview.sol#1645-1691) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#1647-1690)



    
1647         assembly {
1648             for {
1649                 let end := add(s, mload(s))
1650                 result := add(mload(0x40), 0x20)
1651                 // Store "\\u0000" in scratch space.
1652                 // Store "0123456789abcdef" in scratch space.
1653                 // Also, store `{0x08:"b", 0x09:"t", 0x0a:"n", 0x0c:"f", 0x0d:"r"}`.
1654                 // into the scratch space.
1655                 mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)
1656                 // Bitmask for detecting `["\"","\\"]`.
1657                 let e := or(shl(0x22, 1), shl(0x5c, 1))
1658             } iszero(eq(s, end)) {} {
1659                 s := add(s, 1)
1660                 let c := and(mload(s), 0xff)
1661                 if iszero(lt(c, 0x20)) {
1662                     if iszero(and(shl(c, 1), e)) {
1663                         // Not in `["\"","\\"]`.
1664                         mstore8(result, c)
1665                         result := add(result, 1)
1666                         continue
1667                     }
1668                     mstore8(result, 0x5c) // "\\".
1669                     mstore8(add(result, 1), c)
1670                     result := add(result, 2)
1671                     continue
1672                 }
1673                 if iszero(and(shl(c, 1), 0x3700)) {
1674                     // Not in `["\b","\t","\n","\f","\d"]`.
1675                     mstore8(0x1d, mload(shr(4, c))) // Hex value.
1676                     mstore8(0x1e, mload(and(c, 15))) // Hex value.
1677                     mstore(result, mload(0x19)) // "\\u00XX".
1678                     result := add(result, 6)
1679                     continue
1680                 }
1681                 mstore8(result, 0x5c) // "\\".
1682                 mstore8(add(result, 1), mload(add(c, 8)))
1683                 result := add(result, 2)
1684             }
1685             let last := result
1686             mstore(last, 0) // Zeroize the slot after the string.
1687             result := mload(0x40)
1688             mstore(result, sub(last, add(result, 0x20))) // Store the length.
1689             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1690         }



```

```
LibString.toHexString(address) (LlamaAbsolutePeerReview.sol#964-973) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#967-972)



    
967         assembly {
968             let strLength := add(mload(str), 2) // Compute the length.
969             mstore(str, 0x3078) // Write the "0x" prefix.
970             str := sub(str, 2) // Move the pointer.
971             mstore(str, strLength) // Write the length.
972         }



```

```
LibString.replace(string,string,string) (LlamaAbsolutePeerReview.sol#1106-1178) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#1112-1177)



    
1112         assembly {
1113             let subjectLength := mload(subject)
1114             let searchLength := mload(search)
1115             let replacementLength := mload(replacement)
1116 
1117             subject := add(subject, 0x20)
1118             search := add(search, 0x20)
1119             replacement := add(replacement, 0x20)
1120             result := add(mload(0x40), 0x20)
1121 
1122             let subjectEnd := add(subject, subjectLength)
1123             if iszero(gt(searchLength, subjectLength)) {
1124                 let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)
1125                 let h := 0
1126                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
1127                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
1128                 let s := mload(search)
1129                 for {} 1 {} {
1130                     let t := mload(subject)
1131                     // Whether the first `searchLength % 32` bytes of
1132                     // `subject` and `search` matches.
1133                     if iszero(shr(m, xor(t, s))) {
1134                         if h {
1135                             if iszero(eq(keccak256(subject, searchLength), h)) {
1136                                 mstore(result, t)
1137                                 result := add(result, 1)
1138                                 subject := add(subject, 1)
1139                                 if iszero(lt(subject, subjectSearchEnd)) { break }
1140                                 continue
1141                             }
1142                         }
1143                         // Copy the `replacement` one word at a time.
1144                         for { let o := 0 } 1 {} {
1145                             mstore(add(result, o), mload(add(replacement, o)))
1146                             o := add(o, 0x20)
1147                             if iszero(lt(o, replacementLength)) { break }
1148                         }
1149                         result := add(result, replacementLength)
1150                         subject := add(subject, searchLength)
1151                         if searchLength {
1152                             if iszero(lt(subject, subjectSearchEnd)) { break }
1153                             continue
1154                         }
1155                     }
1156                     mstore(result, t)
1157                     result := add(result, 1)
1158                     subject := add(subject, 1)
1159                     if iszero(lt(subject, subjectSearchEnd)) { break }
1160                 }
1161             }
1162 
1163             let resultRemainder := result
1164             result := add(mload(0x40), 0x20)
1165             let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))
1166             // Copy the rest of the string one word at a time.
1167             for {} lt(subject, subjectEnd) {} {
1168                 mstore(resultRemainder, mload(subject))
1169                 resultRemainder := add(resultRemainder, 0x20)
1170                 subject := add(subject, 0x20)
1171             }
1172             result := sub(result, 0x20)
1173             let last := add(add(result, 0x20), k) // Zeroize the slot after the string.
1174             mstore(last, 0)
1175             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1176             mstore(result, k) // Store the length.
1177         }



```

```
LibString.toHexString(uint256) (LlamaAbsolutePeerReview.sol#858-867) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#861-866)



    
861         assembly {
862             let strLength := add(mload(str), 2) // Compute the length.
863             mstore(str, 0x3078) // Write the "0x" prefix.
864             str := sub(str, 2) // Move the pointer.
865             mstore(str, strLength) // Write the length.
866         }



```

```
FixedPointMathLib.mulDivDown(uint256,uint256,uint256) (LlamaAbsolutePeerReview.sol#219-234) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#225-233)



    
225         assembly {
226             // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))
227             if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {
228                 revert(0, 0)
229             }
230 
231             // Divide x * y by the denominator.
232             z := div(mul(x, y), denominator)
233         }



```

```
Clones.clone(address) (LlamaAbsolutePeerReview.sol#514-527) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#516-523)



    
516         assembly {
517             // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
518             // of the `implementation` address with the bytecode before the address.
519             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
520             // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
521             mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
522             instance := create(0, 0x09, 0x37)
523         }



```

```
LibString.indexOf(string,string,uint256) (LlamaAbsolutePeerReview.sol#1183-1236) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#1189-1235)



    
1189         assembly {
1190             for { let subjectLength := mload(subject) } 1 {} {
1191                 if iszero(mload(search)) {
1192                     if iszero(gt(from, subjectLength)) {
1193                         result := from
1194                         break
1195                     }
1196                     result := subjectLength
1197                     break
1198                 }
1199                 let searchLength := mload(search)
1200                 let subjectStart := add(subject, 0x20)
1201 
1202                 result := not(0) // Initialize to `NOT_FOUND`.
1203 
1204                 subject := add(subjectStart, from)
1205                 let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)
1206 
1207                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
1208                 let s := mload(add(search, 0x20))
1209 
1210                 if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }
1211 
1212                 if iszero(lt(searchLength, 0x20)) {
1213                     for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
1214                         if iszero(shr(m, xor(mload(subject), s))) {
1215                             if eq(keccak256(subject, searchLength), h) {
1216                                 result := sub(subject, subjectStart)
1217                                 break
1218                             }
1219                         }
1220                         subject := add(subject, 1)
1221                         if iszero(lt(subject, end)) { break }
1222                     }
1223                     break
1224                 }
1225                 for {} 1 {} {
1226                     if iszero(shr(m, xor(mload(subject), s))) {
1227                         result := sub(subject, subjectStart)
1228                         break
1229                     }
1230                     subject := add(subject, 1)
1231                     if iszero(lt(subject, end)) { break }
1232                 }
1233                 break
1234             }
1235         }



```

```
LibString.unpackOne(bytes32) (LlamaAbsolutePeerReview.sol#1721-1735) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#1723-1734)



    
1723         assembly {
1724             // Grab the free memory pointer.
1725             result := mload(0x40)
1726             // Allocate 2 words (1 for the length, 1 for the bytes).
1727             mstore(0x40, add(result, 0x40))
1728             // Zeroize the length slot.
1729             mstore(result, 0)
1730             // Store the length and bytes.
1731             mstore(add(result, 0x1f), packed)
1732             // Right pad with zeroes.
1733             mstore(add(add(result, 0x20), mload(result)), 0)
1734         }



```

```
Clones.predictDeterministicAddress(address,bytes32,address) (LlamaAbsolutePeerReview.sol#554-570) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#560-569)



    
560         assembly {
561             let ptr := mload(0x40)
562             mstore(add(ptr, 0x38), deployer)
563             mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)
564             mstore(add(ptr, 0x14), implementation)
565             mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)
566             mstore(add(ptr, 0x58), salt)
567             mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))
568             predicted := keccak256(add(ptr, 0x43), 0x55)
569         }



```

```
LibString.slice(string,uint256,uint256) (LlamaAbsolutePeerReview.sol#1381-1410) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#1387-1409)



    
1387         assembly {
1388             let subjectLength := mload(subject)
1389             if iszero(gt(subjectLength, end)) { end := subjectLength }
1390             if iszero(gt(subjectLength, start)) { start := subjectLength }
1391             if lt(start, end) {
1392                 result := mload(0x40)
1393                 let resultLength := sub(end, start)
1394                 mstore(result, resultLength)
1395                 subject := add(subject, start)
1396                 let w := not(0x1f)
1397                 // Copy the `subject` one word at a time, backwards.
1398                 for { let o := and(add(resultLength, 0x1f), w) } 1 {} {
1399                     mstore(add(result, o), mload(add(subject, o)))
1400                     o := add(o, w) // `sub(o, 0x20)`.
1401                     if iszero(o) { break }
1402                 }
1403                 // Zeroize the slot after the string.
1404                 mstore(add(add(result, 0x20), resultLength), 0)
1405                 // Allocate memory for the length and the bytes,
1406                 // rounded up to a multiple of 32.
1407                 mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))
1408             }
1409         }



```

```
LibString.toHexString(bytes) (LlamaAbsolutePeerReview.sol#1014-1023) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#1017-1022)



    
1017         assembly {
1018             let strLength := add(mload(str), 2) // Compute the length.
1019             mstore(str, 0x3078) // Write the "0x" prefix.
1020             str := sub(str, 2) // Move the pointer.
1021             mstore(str, strLength) // Write the length.
1022         }



```

```
LibString.toHexStringNoPrefix(address) (LlamaAbsolutePeerReview.sol#977-1010) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#979-1009)



    
979         assembly {
980             str := mload(0x40)
981 
982             // Allocate the memory.
983             // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,
984             // 0x02 bytes for the prefix, and 0x28 bytes for the digits.
985             // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.
986             mstore(0x40, add(str, 0x80))
987 
988             // Store "0123456789abcdef" in scratch space.
989             mstore(0x0f, 0x30313233343536373839616263646566)
990 
991             str := add(str, 2)
992             mstore(str, 40)
993 
994             let o := add(str, 0x20)
995             mstore(add(o, 40), 0)
996 
997             value := shl(96, value)
998 
999             // We write the string from rightmost digit to leftmost digit.
1000             // The following is essentially a do-while loop that also handles the zero case.
1001             for { let i := 0 } 1 {} {
1002                 let p := add(o, add(i, i))
1003                 let temp := byte(i, value)
1004                 mstore8(add(p, 1), mload(and(temp, 15)))
1005                 mstore8(p, mload(shr(4, temp)))
1006                 i := add(i, 1)
1007                 if eq(i, 20) { break }
1008             }
1009         }



```

```
LibString.indicesOf(string,string) (LlamaAbsolutePeerReview.sol#1424-1480) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#1430-1479)



    
1430         assembly {
1431             let subjectLength := mload(subject)
1432             let searchLength := mload(search)
1433 
1434             if iszero(gt(searchLength, subjectLength)) {
1435                 subject := add(subject, 0x20)
1436                 search := add(search, 0x20)
1437                 result := add(mload(0x40), 0x20)
1438 
1439                 let subjectStart := subject
1440                 let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)
1441                 let h := 0
1442                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
1443                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
1444                 let s := mload(search)
1445                 for {} 1 {} {
1446                     let t := mload(subject)
1447                     // Whether the first `searchLength % 32` bytes of
1448                     // `subject` and `search` matches.
1449                     if iszero(shr(m, xor(t, s))) {
1450                         if h {
1451                             if iszero(eq(keccak256(subject, searchLength), h)) {
1452                                 subject := add(subject, 1)
1453                                 if iszero(lt(subject, subjectSearchEnd)) { break }
1454                                 continue
1455                             }
1456                         }
1457                         // Append to `result`.
1458                         mstore(result, sub(subject, subjectStart))
1459                         result := add(result, 0x20)
1460                         // Advance `subject` by `searchLength`.
1461                         subject := add(subject, searchLength)
1462                         if searchLength {
1463                             if iszero(lt(subject, subjectSearchEnd)) { break }
1464                             continue
1465                         }
1466                     }
1467                     subject := add(subject, 1)
1468                     if iszero(lt(subject, subjectSearchEnd)) { break }
1469                 }
1470                 let resultEnd := result
1471                 // Assign `result` to the free memory pointer.
1472                 result := mload(0x40)
1473                 // Store the length of `result`.
1474                 mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))
1475                 // Allocate memory for result.
1476                 // We allocate one more word, so this array can be recycled for {split}.
1477                 mstore(0x40, add(resultEnd, 0x20))
1478             }
1479         }



```

```
FixedPointMathLib.unsafeDiv(uint256,uint256) (LlamaAbsolutePeerReview.sol#421-428) uses assembly
	- INLINE ASM (LlamaAbsolutePeerReview.sol#423-427)



    
423         assembly {
424             // Divide x by y. Note this will return
425             // 0 instead of reverting if y is zero.
426             r := div(x, y)
427         }



```

### LlamaAbsoluteQuorum.sol


```
LibString.toHexStringChecksummed(address) (LlamaAbsoluteQuorum.sol#943-960) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#946-959)



    
946         assembly {
947             let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`
948             let o := add(str, 0x22)
949             let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `
950             let t := shl(240, 136) // `0b10001000 << 240`
951             for { let i := 0 } 1 {} {
952                 mstore(add(i, i), mul(t, byte(i, hashed)))
953                 i := add(i, 1)
954                 if eq(i, 20) { break }
955             }
956             mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))
957             o := add(o, 0x20)
958             mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))
959         }



```

```
LibString.packOne(string) (LlamaAbsoluteQuorum.sol#1702-1716) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#1704-1715)



    
1704         assembly {
1705             // We don't need to zero right pad the string,
1706             // since this is our own custom non-standard packing scheme.
1707             result :=
1708                 mul(
1709                     // Load the length and the bytes.
1710                     mload(add(a, 0x1f)),
1711                     // `length != 0 && length < 32`. Abuses underflow.
1712                     // Assumes that the length is valid and within the block gas limit.
1713                     lt(sub(mload(a), 1), 0x1f)
1714                 )
1715         }



```

```
FixedPointMathLib.mulDivUp(uint256,uint256,uint256) (LlamaAbsoluteQuorum.sol#236-252) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#242-251)



    
242         assembly {
243             // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))
244             if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {
245                 revert(0, 0)
246             }
247 
248             // If x * y modulo the denominator is strictly greater than 0,
249             // 1 is added to round up the division of x * y by the denominator.
250             z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))
251         }



```

```
FixedPointMathLib.sqrt(uint256) (LlamaAbsoluteQuorum.sol#347-410) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#349-409)



    
349         assembly {
350             let y := x // We start y at x, which will help us make our initial estimate.
351 
352             z := 181 // The "correct" value is 1, but this saves a multiplication later.
353 
354             // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad
355             // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.
356 
357             // We check y >= 2^(k + 8) but shift right by k bits
358             // each branch to ensure that if x >= 256, then y >= 256.
359             if iszero(lt(y, 0x10000000000000000000000000000000000)) {
360                 y := shr(128, y)
361                 z := shl(64, z)
362             }
363             if iszero(lt(y, 0x1000000000000000000)) {
364                 y := shr(64, y)
365                 z := shl(32, z)
366             }
367             if iszero(lt(y, 0x10000000000)) {
368                 y := shr(32, y)
369                 z := shl(16, z)
370             }
371             if iszero(lt(y, 0x1000000)) {
372                 y := shr(16, y)
373                 z := shl(8, z)
374             }
375 
376             // Goal was to get z*z*y within a small factor of x. More iterations could
377             // get y in a tighter range. Currently, we will have y in [256, 256*2^16).
378             // We ensured y >= 256 so that the relative difference between y and y+1 is small.
379             // That's not possible if x < 256 but we can just verify those cases exhaustively.
380 
381             // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.
382             // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.
383             // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.
384 
385             // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range
386             // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.
387 
388             // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate
389             // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.
390 
391             // There is no overflow risk here since y < 2^136 after the first branch above.
392             z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.
393 
394             // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.
395             z := shr(1, add(z, div(x, z)))
396             z := shr(1, add(z, div(x, z)))
397             z := shr(1, add(z, div(x, z)))
398             z := shr(1, add(z, div(x, z)))
399             z := shr(1, add(z, div(x, z)))
400             z := shr(1, add(z, div(x, z)))
401             z := shr(1, add(z, div(x, z)))
402 
403             // If x+1 is a perfect square, the Babylonian method cycles between
404             // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.
405             // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division
406             // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.
407             // If you don't care whether the floor or ceil square root is returned, you can remove this statement.
408             z := sub(z, lt(div(x, z), z))
409         }



```

```
LibString.toHexStringNoPrefix(bytes) (LlamaAbsoluteQuorum.sol#1027-1049) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#1029-1048)



    
1029         assembly {
1030             let length := mload(raw)
1031             str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.
1032             mstore(str, add(length, length)) // Store the length of the output.
1033 
1034             // Store "0123456789abcdef" in scratch space.
1035             mstore(0x0f, 0x30313233343536373839616263646566)
1036 
1037             let o := add(str, 0x20)
1038             let end := add(raw, length)
1039 
1040             for {} iszero(eq(raw, end)) {} {
1041                 raw := add(raw, 1)
1042                 mstore8(add(o, 1), mload(and(mload(raw), 15)))
1043                 mstore8(o, mload(and(shr(4, mload(raw)), 15)))
1044                 o := add(o, 2)
1045             }
1046             mstore(o, 0) // Zeroize the slot after the string.
1047             mstore(0x40, add(o, 0x20)) // Allocate the memory.
1048         }



```

```
LibString.toString(int256) (LlamaAbsoluteQuorum.sol#761-777) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#769-776)



    
769         assembly {
770             // We still have some spare memory space on the left,
771             // as we have allocated 3 words (96 bytes) for up to 78 digits.
772             let length := mload(str) // Load the string length.
773             mstore(str, 0x2d) // Store the '-' character.
774             str := sub(str, 1) // Move back the string pointer by a byte.
775             mstore(str, add(length, 1)) // Update the string length.
776         }



```

```
Base64.encode(bytes) (LlamaAbsoluteQuorum.sol#2811-2882) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#2830-2879)



    
2830         assembly {
2831             // Prepare the lookup table (skip the first "length" byte)
2832             let tablePtr := add(table, 1)
2833 
2834             // Prepare result pointer, jump over length
2835             let resultPtr := add(result, 32)
2836 
2837             // Run over the input, 3 bytes at a time
2838             for {
2839                 let dataPtr := data
2840                 let endPtr := add(data, mload(data))
2841             } lt(dataPtr, endPtr) {
2842 
2843             } {
2844                 // Advance 3 bytes
2845                 dataPtr := add(dataPtr, 3)
2846                 let input := mload(dataPtr)
2847 
2848                 // To write each character, shift the 3 bytes (18 bits) chunk
2849                 // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)
2850                 // and apply logical AND with 0x3F which is the number of
2851                 // the previous character in the ASCII table prior to the Base64 Table
2852                 // The result is then added to the table to get the character to write,
2853                 // and finally write it in the result pointer but with a left shift
2854                 // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits
2855 
2856                 mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))
2857                 resultPtr := add(resultPtr, 1) // Advance
2858 
2859                 mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))
2860                 resultPtr := add(resultPtr, 1) // Advance
2861 
2862                 mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))
2863                 resultPtr := add(resultPtr, 1) // Advance
2864 
2865                 mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))
2866                 resultPtr := add(resultPtr, 1) // Advance
2867             }
2868 
2869             // When data `bytes` is not exactly 3 bytes long
2870             // it is padded with `=` characters at the end
2871             switch mod(mload(data), 3)
2872             case 1 {
2873                 mstore8(sub(resultPtr, 1), 0x3d)
2874                 mstore8(sub(resultPtr, 2), 0x3d)
2875             }
2876             case 2 {
2877                 mstore8(sub(resultPtr, 1), 0x3d)
2878             }
2879         }



```

```
FixedPointMathLib.unsafeDivUp(uint256,uint256) (LlamaAbsoluteQuorum.sol#430-437) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#432-436)



    
432         assembly {
433             // Add 1 to x * y if x % y > 0. Note this will
434             // return 0 instead of reverting if y is zero.
435             z := add(gt(mod(x, y), 0), div(x, y))
436         }



```

```
LibString.packTwo(string,string) (LlamaAbsoluteQuorum.sol#1739-1757) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#1741-1756)



    
1741         assembly {
1742             let aLength := mload(a)
1743             // We don't need to zero right pad the strings,
1744             // since this is our own custom non-standard packing scheme.
1745             result :=
1746                 mul(
1747                     // Load the length and the bytes of `a` and `b`.
1748                     or(
1749                         shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),
1750                         mload(sub(add(b, 0x1e), aLength))
1751                     ),
1752                     // `totalLength != 0 && totalLength < 31`. Abuses underflow.
1753                     // Assumes that the lengths are valid and within the block gas limit.
1754                     lt(sub(add(aLength, mload(b)), 1), 0x1e)
1755                 )
1756         }



```

```
LibString.toString(uint256) (LlamaAbsoluteQuorum.sol#723-758) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#725-757)



    
725         assembly {
726             // The maximum value of a uint256 contains 78 digits (1 byte per digit), but
727             // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.
728             // We will need 1 word for the trailing zeros padding, 1 word for the length,
729             // and 3 words for a maximum of 78 digits.
730             str := add(mload(0x40), 0x80)
731             // Update the free memory pointer to allocate.
732             mstore(0x40, add(str, 0x20))
733             // Zeroize the slot after the string.
734             mstore(str, 0)
735 
736             // Cache the end of the memory to calculate the length later.
737             let end := str
738 
739             let w := not(0) // Tsk.
740             // We write the string from rightmost digit to leftmost digit.
741             // The following is essentially a do-while loop that also handles the zero case.
742             for { let temp := value } 1 {} {
743                 str := add(str, w) // `sub(str, 1)`.
744                 // Write the character to the pointer.
745                 // The ASCII index of the '0' character is 48.
746                 mstore8(str, add(48, mod(temp, 10)))
747                 // Keep dividing `temp` until zero.
748                 temp := div(temp, 10)
749                 if iszero(temp) { break }
750             }
751 
752             let length := sub(end, str)
753             // Move the pointer 32 bytes leftwards to make room for the length.
754             str := sub(str, 0x20)
755             // Store the length.
756             mstore(str, length)
757         }



```

```
Clones.cloneDeterministic(address,bytes32) (LlamaAbsoluteQuorum.sol#536-549) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#538-545)



    
538         assembly {
539             // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
540             // of the `implementation` address with the bytecode before the address.
541             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
542             // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
543             mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
544             instance := create2(0, 0x09, 0x37, salt)
545         }



```

```
FixedPointMathLib.unsafeMod(uint256,uint256) (LlamaAbsoluteQuorum.sol#412-419) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#414-418)



    
414         assembly {
415             // Mod x by y. Note this will return
416             // 0 instead of reverting if y is zero.
417             z := mod(x, y)
418         }



```

```
LibString.runeCount(string) (LlamaAbsoluteQuorum.sol#1056-1070) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#1058-1069)



    
1058         assembly {
1059             if mload(s) {
1060                 mstore(0x00, div(not(0), 255))
1061                 mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)
1062                 let o := add(s, 0x20)
1063                 let end := add(o, mload(s))
1064                 for { result := 1 } 1 { result := add(result, 1) } {
1065                     o := add(o, byte(0, mload(shr(250, mload(o)))))
1066                     if iszero(lt(o, end)) { break }
1067                 }
1068             }
1069         }



```

```
LibString.toMinimalHexStringNoPrefix(uint256) (LlamaAbsoluteQuorum.sol#888-897) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#891-896)



    
891         assembly {
892             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
893             let strLength := mload(str) // Get the length.
894             str := add(str, o) // Move the pointer, accounting for leading zero.
895             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
896         }



```

```
LibString.toHexStringNoPrefix(uint256,uint256) (LlamaAbsoluteQuorum.sol#804-852) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#810-851)



    
810         assembly {
811             // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes
812             // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.
813             // We add 0x20 to the total and round down to a multiple of 0x20.
814             // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.
815             str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))
816             // Allocate the memory.
817             mstore(0x40, add(str, 0x20))
818             // Zeroize the slot after the string.
819             mstore(str, 0)
820 
821             // Cache the end to calculate the length later.
822             let end := str
823             // Store "0123456789abcdef" in scratch space.
824             mstore(0x0f, 0x30313233343536373839616263646566)
825 
826             let start := sub(str, add(length, length))
827             let w := not(1) // Tsk.
828             let temp := value
829             // We write the string from rightmost digit to leftmost digit.
830             // The following is essentially a do-while loop that also handles the zero case.
831             for {} 1 {} {
832                 str := add(str, w) // `sub(str, 2)`.
833                 mstore8(add(str, 1), mload(and(temp, 15)))
834                 mstore8(str, mload(and(shr(4, temp), 15)))
835                 temp := shr(8, temp)
836                 if iszero(xor(str, start)) { break }
837             }
838 
839             if temp {
840                 // Store the function selector of `HexLengthInsufficient()`.
841                 mstore(0x00, 0x2194895a)
842                 // Revert with (offset, size).
843                 revert(0x1c, 0x04)
844             }
845 
846             // Compute the string's length.
847             let strLength := sub(end, str)
848             // Move the pointer and write the length.
849             str := sub(str, 0x20)
850             mstore(str, strLength)
851         }



```

```
LibString.endsWith(string,string) (LlamaAbsoluteQuorum.sol#1319-1344) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#1325-1343)



    
1325         assembly {
1326             let searchLength := mload(search)
1327             let subjectLength := mload(subject)
1328             // Whether `search` is not longer than `subject`.
1329             let withinRange := iszero(gt(searchLength, subjectLength))
1330             // Just using keccak256 directly is actually cheaper.
1331             // forgefmt: disable-next-item
1332             result := and(
1333                 withinRange,
1334                 eq(
1335                     keccak256(
1336                         // `subject + 0x20 + max(subjectLength - searchLength, 0)`.
1337                         add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),
1338                         searchLength
1339                     ),
1340                     keccak256(add(search, 0x20), searchLength)
1341                 )
1342             )
1343         }



```

```
LibString.toHexStringNoPrefix(uint256) (LlamaAbsoluteQuorum.sol#903-937) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#905-936)



    
905         assembly {
906             // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,
907             // 0x02 bytes for the prefix, and 0x40 bytes for the digits.
908             // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.
909             str := add(mload(0x40), 0x80)
910             // Allocate the memory.
911             mstore(0x40, add(str, 0x20))
912             // Zeroize the slot after the string.
913             mstore(str, 0)
914 
915             // Cache the end to calculate the length later.
916             let end := str
917             // Store "0123456789abcdef" in scratch space.
918             mstore(0x0f, 0x30313233343536373839616263646566)
919 
920             let w := not(1) // Tsk.
921             // We write the string from rightmost digit to leftmost digit.
922             // The following is essentially a do-while loop that also handles the zero case.
923             for { let temp := value } 1 {} {
924                 str := add(str, w) // `sub(str, 2)`.
925                 mstore8(add(str, 1), mload(and(temp, 15)))
926                 mstore8(str, mload(and(shr(4, temp), 15)))
927                 temp := shr(8, temp)
928                 if iszero(temp) { break }
929             }
930 
931             // Compute the string's length.
932             let strLength := sub(end, str)
933             // Move the pointer and write the length.
934             str := sub(str, 0x20)
935             mstore(str, strLength)
936         }



```

```
LibString.toMinimalHexString(uint256) (LlamaAbsoluteQuorum.sol#873-883) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#876-882)



    
876         assembly {
877             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
878             let strLength := add(mload(str), 2) // Compute the length.
879             mstore(add(str, o), 0x3078) // Write the "0x" prefix, accounting for leading zero.
880             str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.
881             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
882         }



```

```
Checkpoints._unsafeAccess(Checkpoints.Checkpoint[],uint256) (LlamaAbsoluteQuorum.sol#1998-2007) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#2003-2006)



    
2003         assembly {
2004             mstore(0, self.slot)
2005             result.slot := add(keccak256(0, 0x20), pos)
2006         }



```

```
LibString.concat(string,string) (LlamaAbsoluteQuorum.sol#1532-1566) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#1538-1565)



    
1538         assembly {
1539             let w := not(0x1f)
1540             result := mload(0x40)
1541             let aLength := mload(a)
1542             // Copy `a` one word at a time, backwards.
1543             for { let o := and(add(aLength, 0x20), w) } 1 {} {
1544                 mstore(add(result, o), mload(add(a, o)))
1545                 o := add(o, w) // `sub(o, 0x20)`.
1546                 if iszero(o) { break }
1547             }
1548             let bLength := mload(b)
1549             let output := add(result, aLength)
1550             // Copy `b` one word at a time, backwards.
1551             for { let o := and(add(bLength, 0x20), w) } 1 {} {
1552                 mstore(add(output, o), mload(add(b, o)))
1553                 o := add(o, w) // `sub(o, 0x20)`.
1554                 if iszero(o) { break }
1555             }
1556             let totalLength := add(aLength, bLength)
1557             let last := add(add(result, 0x20), totalLength)
1558             // Zeroize the slot after the string.
1559             mstore(last, 0)
1560             // Stores the length.
1561             mstore(result, totalLength)
1562             // Allocate memory for the length and the bytes,
1563             // rounded up to a multiple of 32.
1564             mstore(0x40, and(add(last, 0x1f), w))
1565         }



```

```
LibString.eq(string,string) (LlamaAbsoluteQuorum.sol#1694-1698) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#1695-1697)



    
1695         assembly {
1696             result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))
1697         }



```

```
Checkpoints.sqrt(uint256) (LlamaAbsoluteQuorum.sol#2021-2083) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#2022-2082)



    
2022         assembly {
2023             let y := x // We start y at x, which will help us make our initial estimate.
2024 
2025             z := 181 // The "correct" value is 1, but this saves a multiplication later.
2026 
2027             // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad
2028             // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.
2029 
2030             // We check y >= 2^(k + 8) but shift right by k bits
2031             // each branch to ensure that if x >= 256, then y >= 256.
2032             if iszero(lt(y, 0x10000000000000000000000000000000000)) {
2033                 y := shr(128, y)
2034                 z := shl(64, z)
2035             }
2036             if iszero(lt(y, 0x1000000000000000000)) {
2037                 y := shr(64, y)
2038                 z := shl(32, z)
2039             }
2040             if iszero(lt(y, 0x10000000000)) {
2041                 y := shr(32, y)
2042                 z := shl(16, z)
2043             }
2044             if iszero(lt(y, 0x1000000)) {
2045                 y := shr(16, y)
2046                 z := shl(8, z)
2047             }
2048 
2049             // Goal was to get z*z*y within a small factor of x. More iterations could
2050             // get y in a tighter range. Currently, we will have y in [256, 256*2^16).
2051             // We ensured y >= 256 so that the relative difference between y and y+1 is small.
2052             // That's not possible if x < 256 but we can just verify those cases exhaustively.
2053 
2054             // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.
2055             // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.
2056             // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.
2057 
2058             // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range
2059             // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.
2060 
2061             // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate
2062             // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.
2063 
2064             // There is no overflow risk here since y < 2^136 after the first branch above.
2065             z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.
2066 
2067             // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.
2068             z := shr(1, add(z, div(x, z)))
2069             z := shr(1, add(z, div(x, z)))
2070             z := shr(1, add(z, div(x, z)))
2071             z := shr(1, add(z, div(x, z)))
2072             z := shr(1, add(z, div(x, z)))
2073             z := shr(1, add(z, div(x, z)))
2074             z := shr(1, add(z, div(x, z)))
2075 
2076             // If x+1 is a perfect square, the Babylonian method cycles between
2077             // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.
2078             // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division
2079             // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.
2080             // If you don't care whether the floor or ceil square root is returned, you can remove this statement.
2081             z := sub(z, lt(div(x, z), z))
2082         }



```

```
LibString.toHexString(uint256,uint256) (LlamaAbsoluteQuorum.sol#788-797) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#791-796)



    
791         assembly {
792             let strLength := add(mload(str), 2) // Compute the length.
793             mstore(str, 0x3078) // Write the "0x" prefix.
794             str := sub(str, 2) // Move the pointer.
795             mstore(str, strLength) // Write the length.
796         }



```

```
LibString.toCase(string,bool) (LlamaAbsoluteQuorum.sol#1570-1596) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#1576-1595)



    
1576         assembly {
1577             let length := mload(subject)
1578             if length {
1579                 result := add(mload(0x40), 0x20)
1580                 subject := add(subject, 1)
1581                 let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)
1582                 let w := not(0)
1583                 for { let o := length } 1 {} {
1584                     o := add(o, w)
1585                     let b := and(0xff, mload(add(subject, o)))
1586                     mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))
1587                     if iszero(o) { break }
1588                 }
1589                 result := mload(0x40)
1590                 mstore(result, length) // Store the length.
1591                 let last := add(add(result, 0x20), length)
1592                 mstore(last, 0) // Zeroize the slot after the string.
1593                 mstore(0x40, add(last, 0x20)) // Allocate the memory.
1594             }
1595         }



```

```
LibString.escapeHTML(string) (LlamaAbsoluteQuorum.sol#1611-1642) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#1613-1641)



    
1613         assembly {
1614             for {
1615                 let end := add(s, mload(s))
1616                 result := add(mload(0x40), 0x20)
1617                 // Store the bytes of the packed offsets and strides into the scratch space.
1618                 // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.
1619                 mstore(0x1f, 0x900094)
1620                 mstore(0x08, 0xc0000000a6ab)
1621                 // Store "&quot;&amp;&#39;&lt;&gt;" into the scratch space.
1622                 mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))
1623             } iszero(eq(s, end)) {} {
1624                 s := add(s, 1)
1625                 let c := and(mload(s), 0xff)
1626                 // Not in `["\"","'","&","<",">"]`.
1627                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
1628                     mstore8(result, c)
1629                     result := add(result, 1)
1630                     continue
1631                 }
1632                 let t := shr(248, mload(c))
1633                 mstore(result, mload(and(t, 0x1f)))
1634                 result := add(result, shr(5, t))
1635             }
1636             let last := result
1637             mstore(last, 0) // Zeroize the slot after the string.
1638             result := mload(0x40)
1639             mstore(result, sub(last, add(result, 0x20))) // Store the length.
1640             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1641         }



```

```
LibString.directReturn(string) (LlamaAbsoluteQuorum.sol#1787-1800) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#1788-1799)



    
1788         assembly {
1789             // Assumes that the string does not start from the scratch space.
1790             let retStart := sub(a, 0x20)
1791             let retSize := add(mload(a), 0x40)
1792             // Right pad with zeroes. Just in case the string is produced
1793             // by a method that doesn't zero right pad.
1794             mstore(add(retStart, retSize), 0)
1795             // Store the return offset.
1796             mstore(retStart, 0x20)
1797             // End the transaction, returning the string.
1798             return(retStart, retSize)
1799         }



```

```
LibString.repeat(string,uint256) (LlamaAbsoluteQuorum.sol#1347-1377) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#1353-1376)



    
1353         assembly {
1354             let subjectLength := mload(subject)
1355             if iszero(or(iszero(times), iszero(subjectLength))) {
1356                 subject := add(subject, 0x20)
1357                 result := mload(0x40)
1358                 let output := add(result, 0x20)
1359                 for {} 1 {} {
1360                     // Copy the `subject` one word at a time.
1361                     for { let o := 0 } 1 {} {
1362                         mstore(add(output, o), mload(add(subject, o)))
1363                         o := add(o, 0x20)
1364                         if iszero(lt(o, subjectLength)) { break }
1365                     }
1366                     output := add(output, subjectLength)
1367                     times := sub(times, 1)
1368                     if iszero(times) { break }
1369                 }
1370                 mstore(output, 0) // Zeroize the slot after the string.
1371                 let resultLength := sub(output, add(result, 0x20))
1372                 mstore(result, resultLength) // Store the length.
1373                 // Allocate the memory.
1374                 mstore(0x40, add(result, add(resultLength, 0x20)))
1375             }
1376         }



```

```
LibString.split(string,string) (LlamaAbsoluteQuorum.sol#1483-1528) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#1490-1527)



    
1490         assembly {
1491             let w := not(0x1f)
1492             let indexPtr := add(indices, 0x20)
1493             let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))
1494             mstore(add(indicesEnd, w), mload(subject))
1495             mstore(indices, add(mload(indices), 1))
1496             let prevIndex := 0
1497             for {} 1 {} {
1498                 let index := mload(indexPtr)
1499                 mstore(indexPtr, 0x60)
1500                 if iszero(eq(index, prevIndex)) {
1501                     let element := mload(0x40)
1502                     let elementLength := sub(index, prevIndex)
1503                     mstore(element, elementLength)
1504                     // Copy the `subject` one word at a time, backwards.
1505                     for { let o := and(add(elementLength, 0x1f), w) } 1 {} {
1506                         mstore(add(element, o), mload(add(add(subject, prevIndex), o)))
1507                         o := add(o, w) // `sub(o, 0x20)`.
1508                         if iszero(o) { break }
1509                     }
1510                     // Zeroize the slot after the string.
1511                     mstore(add(add(element, 0x20), elementLength), 0)
1512                     // Allocate memory for the length and the bytes,
1513                     // rounded up to a multiple of 32.
1514                     mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))
1515                     // Store the `element` into the array.
1516                     mstore(indexPtr, element)
1517                 }
1518                 prevIndex := add(index, mload(delimiter))
1519                 indexPtr := add(indexPtr, 0x20)
1520                 if iszero(lt(indexPtr, indicesEnd)) { break }
1521             }
1522             result := indices
1523             if iszero(mload(delimiter)) {
1524                 result := add(indices, 0x20)
1525                 mstore(result, sub(mload(indices), 2))
1526             }
1527         }



```

```
FixedPointMathLib.rpow(uint256,uint256,uint256) (LlamaAbsoluteQuorum.sol#254-341) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#260-340)



    
260         assembly {
261             switch x
262             case 0 {
263                 switch n
264                 case 0 {
265                     // 0 ** 0 = 1
266                     z := scalar
267                 }
268                 default {
269                     // 0 ** n = 0
270                     z := 0
271                 }
272             }
273             default {
274                 switch mod(n, 2)
275                 case 0 {
276                     // If n is even, store scalar in z for now.
277                     z := scalar
278                 }
279                 default {
280                     // If n is odd, store x in z for now.
281                     z := x
282                 }
283 
284                 // Shifting right by 1 is like dividing by 2.
285                 let half := shr(1, scalar)
286 
287                 for {
288                     // Shift n right by 1 before looping to halve it.
289                     n := shr(1, n)
290                 } n {
291                     // Shift n right by 1 each iteration to halve it.
292                     n := shr(1, n)
293                 } {
294                     // Revert immediately if x ** 2 would overflow.
295                     // Equivalent to iszero(eq(div(xx, x), x)) here.
296                     if shr(128, x) {
297                         revert(0, 0)
298                     }
299 
300                     // Store x squared.
301                     let xx := mul(x, x)
302 
303                     // Round to the nearest number.
304                     let xxRound := add(xx, half)
305 
306                     // Revert if xx + half overflowed.
307                     if lt(xxRound, xx) {
308                         revert(0, 0)
309                     }
310 
311                     // Set x to scaled xxRound.
312                     x := div(xxRound, scalar)
313 
314                     // If n is even:
315                     if mod(n, 2) {
316                         // Compute z * x.
317                         let zx := mul(z, x)
318 
319                         // If z * x overflowed:
320                         if iszero(eq(div(zx, x), z)) {
321                             // Revert if x is non-zero.
322                             if iszero(iszero(x)) {
323                                 revert(0, 0)
324                             }
325                         }
326 
327                         // Round to the nearest number.
328                         let zxRound := add(zx, half)
329 
330                         // Revert if zx + half overflowed.
331                         if lt(zxRound, zx) {
332                             revert(0, 0)
333                         }
334 
335                         // Return properly scaled zxRound.
336                         z := div(zxRound, scalar)
337                     }
338                 }
339             }
340         }



```

```
LibString.unpackTwo(bytes32) (LlamaAbsoluteQuorum.sol#1762-1784) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#1768-1783)



    
1768         assembly {
1769             // Grab the free memory pointer.
1770             resultA := mload(0x40)
1771             resultB := add(resultA, 0x40)
1772             // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.
1773             mstore(0x40, add(resultB, 0x40))
1774             // Zeroize the length slots.
1775             mstore(resultA, 0)
1776             mstore(resultB, 0)
1777             // Store the lengths and bytes.
1778             mstore(add(resultA, 0x1f), packed)
1779             mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))
1780             // Right pad with zeroes.
1781             mstore(add(add(resultA, 0x20), mload(resultA)), 0)
1782             mstore(add(add(resultB, 0x20), mload(resultB)), 0)
1783         }



```

```
LibString.lastIndexOf(string,string,uint256) (LlamaAbsoluteQuorum.sol#1252-1284) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#1258-1283)



    
1258         assembly {
1259             for {} 1 {} {
1260                 result := not(0) // Initialize to `NOT_FOUND`.
1261                 let searchLength := mload(search)
1262                 if gt(searchLength, mload(subject)) { break }
1263                 let w := result
1264 
1265                 let fromMax := sub(mload(subject), searchLength)
1266                 if iszero(gt(fromMax, from)) { from := fromMax }
1267 
1268                 let end := add(add(subject, 0x20), w)
1269                 subject := add(add(subject, 0x20), from)
1270                 if iszero(gt(subject, end)) { break }
1271                 // As this function is not too often used,
1272                 // we shall simply use keccak256 for smaller bytecode size.
1273                 for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
1274                     if eq(keccak256(subject, searchLength), h) {
1275                         result := sub(subject, add(end, 1))
1276                         break
1277                     }
1278                     subject := add(subject, w) // `sub(subject, 1)`.
1279                     if iszero(gt(subject, end)) { break }
1280                 }
1281                 break
1282             }
1283         }



```

```
LibString.is7BitASCII(string) (LlamaAbsoluteQuorum.sol#1074-1096) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#1076-1095)



    
1076         assembly {
1077             let mask := shl(7, div(not(0), 255))
1078             result := 1
1079             let n := mload(s)
1080             if n {
1081                 let o := add(s, 0x20)
1082                 let end := add(o, n)
1083                 let last := mload(end)
1084                 mstore(end, 0)
1085                 for {} 1 {} {
1086                     if and(mask, mload(o)) {
1087                         result := 0
1088                         break
1089                     }
1090                     o := add(o, 0x20)
1091                     if iszero(lt(o, end)) { break }
1092                 }
1093                 mstore(end, last)
1094             }
1095         }



```

```
LibString.startsWith(string,string) (LlamaAbsoluteQuorum.sol#1298-1316) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#1304-1315)



    
1304         assembly {
1305             let searchLength := mload(search)
1306             // Just using keccak256 directly is actually cheaper.
1307             // forgefmt: disable-next-item
1308             result := and(
1309                 iszero(gt(searchLength, mload(subject))),
1310                 eq(
1311                     keccak256(add(subject, 0x20), searchLength),
1312                     keccak256(add(search, 0x20), searchLength)
1313                 )
1314             )
1315         }



```

```
LibString.escapeJSON(string) (LlamaAbsoluteQuorum.sol#1645-1691) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#1647-1690)



    
1647         assembly {
1648             for {
1649                 let end := add(s, mload(s))
1650                 result := add(mload(0x40), 0x20)
1651                 // Store "\\u0000" in scratch space.
1652                 // Store "0123456789abcdef" in scratch space.
1653                 // Also, store `{0x08:"b", 0x09:"t", 0x0a:"n", 0x0c:"f", 0x0d:"r"}`.
1654                 // into the scratch space.
1655                 mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)
1656                 // Bitmask for detecting `["\"","\\"]`.
1657                 let e := or(shl(0x22, 1), shl(0x5c, 1))
1658             } iszero(eq(s, end)) {} {
1659                 s := add(s, 1)
1660                 let c := and(mload(s), 0xff)
1661                 if iszero(lt(c, 0x20)) {
1662                     if iszero(and(shl(c, 1), e)) {
1663                         // Not in `["\"","\\"]`.
1664                         mstore8(result, c)
1665                         result := add(result, 1)
1666                         continue
1667                     }
1668                     mstore8(result, 0x5c) // "\\".
1669                     mstore8(add(result, 1), c)
1670                     result := add(result, 2)
1671                     continue
1672                 }
1673                 if iszero(and(shl(c, 1), 0x3700)) {
1674                     // Not in `["\b","\t","\n","\f","\d"]`.
1675                     mstore8(0x1d, mload(shr(4, c))) // Hex value.
1676                     mstore8(0x1e, mload(and(c, 15))) // Hex value.
1677                     mstore(result, mload(0x19)) // "\\u00XX".
1678                     result := add(result, 6)
1679                     continue
1680                 }
1681                 mstore8(result, 0x5c) // "\\".
1682                 mstore8(add(result, 1), mload(add(c, 8)))
1683                 result := add(result, 2)
1684             }
1685             let last := result
1686             mstore(last, 0) // Zeroize the slot after the string.
1687             result := mload(0x40)
1688             mstore(result, sub(last, add(result, 0x20))) // Store the length.
1689             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1690         }



```

```
LibString.toHexString(address) (LlamaAbsoluteQuorum.sol#964-973) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#967-972)



    
967         assembly {
968             let strLength := add(mload(str), 2) // Compute the length.
969             mstore(str, 0x3078) // Write the "0x" prefix.
970             str := sub(str, 2) // Move the pointer.
971             mstore(str, strLength) // Write the length.
972         }



```

```
LibString.replace(string,string,string) (LlamaAbsoluteQuorum.sol#1106-1178) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#1112-1177)



    
1112         assembly {
1113             let subjectLength := mload(subject)
1114             let searchLength := mload(search)
1115             let replacementLength := mload(replacement)
1116 
1117             subject := add(subject, 0x20)
1118             search := add(search, 0x20)
1119             replacement := add(replacement, 0x20)
1120             result := add(mload(0x40), 0x20)
1121 
1122             let subjectEnd := add(subject, subjectLength)
1123             if iszero(gt(searchLength, subjectLength)) {
1124                 let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)
1125                 let h := 0
1126                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
1127                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
1128                 let s := mload(search)
1129                 for {} 1 {} {
1130                     let t := mload(subject)
1131                     // Whether the first `searchLength % 32` bytes of
1132                     // `subject` and `search` matches.
1133                     if iszero(shr(m, xor(t, s))) {
1134                         if h {
1135                             if iszero(eq(keccak256(subject, searchLength), h)) {
1136                                 mstore(result, t)
1137                                 result := add(result, 1)
1138                                 subject := add(subject, 1)
1139                                 if iszero(lt(subject, subjectSearchEnd)) { break }
1140                                 continue
1141                             }
1142                         }
1143                         // Copy the `replacement` one word at a time.
1144                         for { let o := 0 } 1 {} {
1145                             mstore(add(result, o), mload(add(replacement, o)))
1146                             o := add(o, 0x20)
1147                             if iszero(lt(o, replacementLength)) { break }
1148                         }
1149                         result := add(result, replacementLength)
1150                         subject := add(subject, searchLength)
1151                         if searchLength {
1152                             if iszero(lt(subject, subjectSearchEnd)) { break }
1153                             continue
1154                         }
1155                     }
1156                     mstore(result, t)
1157                     result := add(result, 1)
1158                     subject := add(subject, 1)
1159                     if iszero(lt(subject, subjectSearchEnd)) { break }
1160                 }
1161             }
1162 
1163             let resultRemainder := result
1164             result := add(mload(0x40), 0x20)
1165             let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))
1166             // Copy the rest of the string one word at a time.
1167             for {} lt(subject, subjectEnd) {} {
1168                 mstore(resultRemainder, mload(subject))
1169                 resultRemainder := add(resultRemainder, 0x20)
1170                 subject := add(subject, 0x20)
1171             }
1172             result := sub(result, 0x20)
1173             let last := add(add(result, 0x20), k) // Zeroize the slot after the string.
1174             mstore(last, 0)
1175             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1176             mstore(result, k) // Store the length.
1177         }



```

```
LibString.toHexString(uint256) (LlamaAbsoluteQuorum.sol#858-867) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#861-866)



    
861         assembly {
862             let strLength := add(mload(str), 2) // Compute the length.
863             mstore(str, 0x3078) // Write the "0x" prefix.
864             str := sub(str, 2) // Move the pointer.
865             mstore(str, strLength) // Write the length.
866         }



```

```
FixedPointMathLib.mulDivDown(uint256,uint256,uint256) (LlamaAbsoluteQuorum.sol#219-234) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#225-233)



    
225         assembly {
226             // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))
227             if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {
228                 revert(0, 0)
229             }
230 
231             // Divide x * y by the denominator.
232             z := div(mul(x, y), denominator)
233         }



```

```
Clones.clone(address) (LlamaAbsoluteQuorum.sol#514-527) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#516-523)



    
516         assembly {
517             // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
518             // of the `implementation` address with the bytecode before the address.
519             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
520             // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
521             mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
522             instance := create(0, 0x09, 0x37)
523         }



```

```
LibString.indexOf(string,string,uint256) (LlamaAbsoluteQuorum.sol#1183-1236) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#1189-1235)



    
1189         assembly {
1190             for { let subjectLength := mload(subject) } 1 {} {
1191                 if iszero(mload(search)) {
1192                     if iszero(gt(from, subjectLength)) {
1193                         result := from
1194                         break
1195                     }
1196                     result := subjectLength
1197                     break
1198                 }
1199                 let searchLength := mload(search)
1200                 let subjectStart := add(subject, 0x20)
1201 
1202                 result := not(0) // Initialize to `NOT_FOUND`.
1203 
1204                 subject := add(subjectStart, from)
1205                 let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)
1206 
1207                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
1208                 let s := mload(add(search, 0x20))
1209 
1210                 if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }
1211 
1212                 if iszero(lt(searchLength, 0x20)) {
1213                     for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
1214                         if iszero(shr(m, xor(mload(subject), s))) {
1215                             if eq(keccak256(subject, searchLength), h) {
1216                                 result := sub(subject, subjectStart)
1217                                 break
1218                             }
1219                         }
1220                         subject := add(subject, 1)
1221                         if iszero(lt(subject, end)) { break }
1222                     }
1223                     break
1224                 }
1225                 for {} 1 {} {
1226                     if iszero(shr(m, xor(mload(subject), s))) {
1227                         result := sub(subject, subjectStart)
1228                         break
1229                     }
1230                     subject := add(subject, 1)
1231                     if iszero(lt(subject, end)) { break }
1232                 }
1233                 break
1234             }
1235         }



```

```
LibString.unpackOne(bytes32) (LlamaAbsoluteQuorum.sol#1721-1735) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#1723-1734)



    
1723         assembly {
1724             // Grab the free memory pointer.
1725             result := mload(0x40)
1726             // Allocate 2 words (1 for the length, 1 for the bytes).
1727             mstore(0x40, add(result, 0x40))
1728             // Zeroize the length slot.
1729             mstore(result, 0)
1730             // Store the length and bytes.
1731             mstore(add(result, 0x1f), packed)
1732             // Right pad with zeroes.
1733             mstore(add(add(result, 0x20), mload(result)), 0)
1734         }



```

```
Clones.predictDeterministicAddress(address,bytes32,address) (LlamaAbsoluteQuorum.sol#554-570) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#560-569)



    
560         assembly {
561             let ptr := mload(0x40)
562             mstore(add(ptr, 0x38), deployer)
563             mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)
564             mstore(add(ptr, 0x14), implementation)
565             mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)
566             mstore(add(ptr, 0x58), salt)
567             mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))
568             predicted := keccak256(add(ptr, 0x43), 0x55)
569         }



```

```
LibString.slice(string,uint256,uint256) (LlamaAbsoluteQuorum.sol#1381-1410) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#1387-1409)



    
1387         assembly {
1388             let subjectLength := mload(subject)
1389             if iszero(gt(subjectLength, end)) { end := subjectLength }
1390             if iszero(gt(subjectLength, start)) { start := subjectLength }
1391             if lt(start, end) {
1392                 result := mload(0x40)
1393                 let resultLength := sub(end, start)
1394                 mstore(result, resultLength)
1395                 subject := add(subject, start)
1396                 let w := not(0x1f)
1397                 // Copy the `subject` one word at a time, backwards.
1398                 for { let o := and(add(resultLength, 0x1f), w) } 1 {} {
1399                     mstore(add(result, o), mload(add(subject, o)))
1400                     o := add(o, w) // `sub(o, 0x20)`.
1401                     if iszero(o) { break }
1402                 }
1403                 // Zeroize the slot after the string.
1404                 mstore(add(add(result, 0x20), resultLength), 0)
1405                 // Allocate memory for the length and the bytes,
1406                 // rounded up to a multiple of 32.
1407                 mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))
1408             }
1409         }



```

```
LibString.toHexString(bytes) (LlamaAbsoluteQuorum.sol#1014-1023) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#1017-1022)



    
1017         assembly {
1018             let strLength := add(mload(str), 2) // Compute the length.
1019             mstore(str, 0x3078) // Write the "0x" prefix.
1020             str := sub(str, 2) // Move the pointer.
1021             mstore(str, strLength) // Write the length.
1022         }



```

```
LibString.toHexStringNoPrefix(address) (LlamaAbsoluteQuorum.sol#977-1010) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#979-1009)



    
979         assembly {
980             str := mload(0x40)
981 
982             // Allocate the memory.
983             // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,
984             // 0x02 bytes for the prefix, and 0x28 bytes for the digits.
985             // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.
986             mstore(0x40, add(str, 0x80))
987 
988             // Store "0123456789abcdef" in scratch space.
989             mstore(0x0f, 0x30313233343536373839616263646566)
990 
991             str := add(str, 2)
992             mstore(str, 40)
993 
994             let o := add(str, 0x20)
995             mstore(add(o, 40), 0)
996 
997             value := shl(96, value)
998 
999             // We write the string from rightmost digit to leftmost digit.
1000             // The following is essentially a do-while loop that also handles the zero case.
1001             for { let i := 0 } 1 {} {
1002                 let p := add(o, add(i, i))
1003                 let temp := byte(i, value)
1004                 mstore8(add(p, 1), mload(and(temp, 15)))
1005                 mstore8(p, mload(shr(4, temp)))
1006                 i := add(i, 1)
1007                 if eq(i, 20) { break }
1008             }
1009         }



```

```
LibString.indicesOf(string,string) (LlamaAbsoluteQuorum.sol#1424-1480) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#1430-1479)



    
1430         assembly {
1431             let subjectLength := mload(subject)
1432             let searchLength := mload(search)
1433 
1434             if iszero(gt(searchLength, subjectLength)) {
1435                 subject := add(subject, 0x20)
1436                 search := add(search, 0x20)
1437                 result := add(mload(0x40), 0x20)
1438 
1439                 let subjectStart := subject
1440                 let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)
1441                 let h := 0
1442                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
1443                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
1444                 let s := mload(search)
1445                 for {} 1 {} {
1446                     let t := mload(subject)
1447                     // Whether the first `searchLength % 32` bytes of
1448                     // `subject` and `search` matches.
1449                     if iszero(shr(m, xor(t, s))) {
1450                         if h {
1451                             if iszero(eq(keccak256(subject, searchLength), h)) {
1452                                 subject := add(subject, 1)
1453                                 if iszero(lt(subject, subjectSearchEnd)) { break }
1454                                 continue
1455                             }
1456                         }
1457                         // Append to `result`.
1458                         mstore(result, sub(subject, subjectStart))
1459                         result := add(result, 0x20)
1460                         // Advance `subject` by `searchLength`.
1461                         subject := add(subject, searchLength)
1462                         if searchLength {
1463                             if iszero(lt(subject, subjectSearchEnd)) { break }
1464                             continue
1465                         }
1466                     }
1467                     subject := add(subject, 1)
1468                     if iszero(lt(subject, subjectSearchEnd)) { break }
1469                 }
1470                 let resultEnd := result
1471                 // Assign `result` to the free memory pointer.
1472                 result := mload(0x40)
1473                 // Store the length of `result`.
1474                 mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))
1475                 // Allocate memory for result.
1476                 // We allocate one more word, so this array can be recycled for {split}.
1477                 mstore(0x40, add(resultEnd, 0x20))
1478             }
1479         }



```

```
FixedPointMathLib.unsafeDiv(uint256,uint256) (LlamaAbsoluteQuorum.sol#421-428) uses assembly
	- INLINE ASM (LlamaAbsoluteQuorum.sol#423-427)



    
423         assembly {
424             // Divide x by y. Note this will return
425             // 0 instead of reverting if y is zero.
426             r := div(x, y)
427         }



```

### LlamaAccount.sol


```
LibString.directReturn(string) (LlamaAccount.sol#2347-2360) uses assembly
	- INLINE ASM (LlamaAccount.sol#2348-2359)



    
2348         assembly {
2349             // Assumes that the string does not start from the scratch space.
2350             let retStart := sub(a, 0x20)
2351             let retSize := add(mload(a), 0x40)
2352             // Right pad with zeroes. Just in case the string is produced
2353             // by a method that doesn't zero right pad.
2354             mstore(add(retStart, retSize), 0)
2355             // Store the return offset.
2356             mstore(retStart, 0x20)
2357             // End the transaction, returning the string.
2358             return(retStart, retSize)
2359         }



```

```
LibString.startsWith(string,string) (LlamaAccount.sol#1858-1876) uses assembly
	- INLINE ASM (LlamaAccount.sol#1864-1875)



    
1864         assembly {
1865             let searchLength := mload(search)
1866             // Just using keccak256 directly is actually cheaper.
1867             // forgefmt: disable-next-item
1868             result := and(
1869                 iszero(gt(searchLength, mload(subject))),
1870                 eq(
1871                     keccak256(add(subject, 0x20), searchLength),
1872                     keccak256(add(search, 0x20), searchLength)
1873                 )
1874             )
1875         }



```

```
LibString.endsWith(string,string) (LlamaAccount.sol#1879-1904) uses assembly
	- INLINE ASM (LlamaAccount.sol#1885-1903)



    
1885         assembly {
1886             let searchLength := mload(search)
1887             let subjectLength := mload(subject)
1888             // Whether `search` is not longer than `subject`.
1889             let withinRange := iszero(gt(searchLength, subjectLength))
1890             // Just using keccak256 directly is actually cheaper.
1891             // forgefmt: disable-next-item
1892             result := and(
1893                 withinRange,
1894                 eq(
1895                     keccak256(
1896                         // `subject + 0x20 + max(subjectLength - searchLength, 0)`.
1897                         add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),
1898                         searchLength
1899                     ),
1900                     keccak256(add(search, 0x20), searchLength)
1901                 )
1902             )
1903         }



```

```
LibString.repeat(string,uint256) (LlamaAccount.sol#1907-1937) uses assembly
	- INLINE ASM (LlamaAccount.sol#1913-1936)



    
1913         assembly {
1914             let subjectLength := mload(subject)
1915             if iszero(or(iszero(times), iszero(subjectLength))) {
1916                 subject := add(subject, 0x20)
1917                 result := mload(0x40)
1918                 let output := add(result, 0x20)
1919                 for {} 1 {} {
1920                     // Copy the `subject` one word at a time.
1921                     for { let o := 0 } 1 {} {
1922                         mstore(add(output, o), mload(add(subject, o)))
1923                         o := add(o, 0x20)
1924                         if iszero(lt(o, subjectLength)) { break }
1925                     }
1926                     output := add(output, subjectLength)
1927                     times := sub(times, 1)
1928                     if iszero(times) { break }
1929                 }
1930                 mstore(output, 0) // Zeroize the slot after the string.
1931                 let resultLength := sub(output, add(result, 0x20))
1932                 mstore(result, resultLength) // Store the length.
1933                 // Allocate the memory.
1934                 mstore(0x40, add(result, add(resultLength, 0x20)))
1935             }
1936         }



```

```
LibString.runeCount(string) (LlamaAccount.sol#1616-1630) uses assembly
	- INLINE ASM (LlamaAccount.sol#1618-1629)



    
1618         assembly {
1619             if mload(s) {
1620                 mstore(0x00, div(not(0), 255))
1621                 mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)
1622                 let o := add(s, 0x20)
1623                 let end := add(o, mload(s))
1624                 for { result := 1 } 1 { result := add(result, 1) } {
1625                     o := add(o, byte(0, mload(shr(250, mload(o)))))
1626                     if iszero(lt(o, end)) { break }
1627                 }
1628             }
1629         }



```

```
LibString.unpackTwo(bytes32) (LlamaAccount.sol#2322-2344) uses assembly
	- INLINE ASM (LlamaAccount.sol#2328-2343)



    
2328         assembly {
2329             // Grab the free memory pointer.
2330             resultA := mload(0x40)
2331             resultB := add(resultA, 0x40)
2332             // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.
2333             mstore(0x40, add(resultB, 0x40))
2334             // Zeroize the length slots.
2335             mstore(resultA, 0)
2336             mstore(resultB, 0)
2337             // Store the lengths and bytes.
2338             mstore(add(resultA, 0x1f), packed)
2339             mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))
2340             // Right pad with zeroes.
2341             mstore(add(add(resultA, 0x20), mload(resultA)), 0)
2342             mstore(add(add(resultB, 0x20), mload(resultB)), 0)
2343         }



```

```
LibString.eq(string,string) (LlamaAccount.sol#2254-2258) uses assembly
	- INLINE ASM (LlamaAccount.sol#2255-2257)



    
2255         assembly {
2256             result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))
2257         }



```

```
LibString.toMinimalHexStringNoPrefix(uint256) (LlamaAccount.sol#1448-1457) uses assembly
	- INLINE ASM (LlamaAccount.sol#1451-1456)



    
1451         assembly {
1452             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
1453             let strLength := mload(str) // Get the length.
1454             str := add(str, o) // Move the pointer, accounting for leading zero.
1455             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
1456         }



```

```
LibString.toHexString(bytes) (LlamaAccount.sol#1574-1583) uses assembly
	- INLINE ASM (LlamaAccount.sol#1577-1582)



    
1577         assembly {
1578             let strLength := add(mload(str), 2) // Compute the length.
1579             mstore(str, 0x3078) // Write the "0x" prefix.
1580             str := sub(str, 2) // Move the pointer.
1581             mstore(str, strLength) // Write the length.
1582         }



```

```
Clones.predictDeterministicAddress(address,bytes32,address) (LlamaAccount.sol#1231-1247) uses assembly
	- INLINE ASM (LlamaAccount.sol#1237-1246)



    
1237         assembly {
1238             let ptr := mload(0x40)
1239             mstore(add(ptr, 0x38), deployer)
1240             mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)
1241             mstore(add(ptr, 0x14), implementation)
1242             mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)
1243             mstore(add(ptr, 0x58), salt)
1244             mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))
1245             predicted := keccak256(add(ptr, 0x43), 0x55)
1246         }



```

```
LibString.toHexString(uint256,uint256) (LlamaAccount.sol#1348-1357) uses assembly
	- INLINE ASM (LlamaAccount.sol#1351-1356)



    
1351         assembly {
1352             let strLength := add(mload(str), 2) // Compute the length.
1353             mstore(str, 0x3078) // Write the "0x" prefix.
1354             str := sub(str, 2) // Move the pointer.
1355             mstore(str, strLength) // Write the length.
1356         }



```

```
Checkpoints.sqrt(uint256) (LlamaAccount.sol#2581-2643) uses assembly
	- INLINE ASM (LlamaAccount.sol#2582-2642)



    
2582         assembly {
2583             let y := x // We start y at x, which will help us make our initial estimate.
2584 
2585             z := 181 // The "correct" value is 1, but this saves a multiplication later.
2586 
2587             // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad
2588             // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.
2589 
2590             // We check y >= 2^(k + 8) but shift right by k bits
2591             // each branch to ensure that if x >= 256, then y >= 256.
2592             if iszero(lt(y, 0x10000000000000000000000000000000000)) {
2593                 y := shr(128, y)
2594                 z := shl(64, z)
2595             }
2596             if iszero(lt(y, 0x1000000000000000000)) {
2597                 y := shr(64, y)
2598                 z := shl(32, z)
2599             }
2600             if iszero(lt(y, 0x10000000000)) {
2601                 y := shr(32, y)
2602                 z := shl(16, z)
2603             }
2604             if iszero(lt(y, 0x1000000)) {
2605                 y := shr(16, y)
2606                 z := shl(8, z)
2607             }
2608 
2609             // Goal was to get z*z*y within a small factor of x. More iterations could
2610             // get y in a tighter range. Currently, we will have y in [256, 256*2^16).
2611             // We ensured y >= 256 so that the relative difference between y and y+1 is small.
2612             // That's not possible if x < 256 but we can just verify those cases exhaustively.
2613 
2614             // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.
2615             // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.
2616             // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.
2617 
2618             // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range
2619             // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.
2620 
2621             // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate
2622             // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.
2623 
2624             // There is no overflow risk here since y < 2^136 after the first branch above.
2625             z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.
2626 
2627             // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.
2628             z := shr(1, add(z, div(x, z)))
2629             z := shr(1, add(z, div(x, z)))
2630             z := shr(1, add(z, div(x, z)))
2631             z := shr(1, add(z, div(x, z)))
2632             z := shr(1, add(z, div(x, z)))
2633             z := shr(1, add(z, div(x, z)))
2634             z := shr(1, add(z, div(x, z)))
2635 
2636             // If x+1 is a perfect square, the Babylonian method cycles between
2637             // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.
2638             // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division
2639             // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.
2640             // If you don't care whether the floor or ceil square root is returned, you can remove this statement.
2641             z := sub(z, lt(div(x, z), z))
2642         }



```

```
LibString.toHexString(address) (LlamaAccount.sol#1524-1533) uses assembly
	- INLINE ASM (LlamaAccount.sol#1527-1532)



    
1527         assembly {
1528             let strLength := add(mload(str), 2) // Compute the length.
1529             mstore(str, 0x3078) // Write the "0x" prefix.
1530             str := sub(str, 2) // Move the pointer.
1531             mstore(str, strLength) // Write the length.
1532         }



```

```
LibString.toString(int256) (LlamaAccount.sol#1321-1337) uses assembly
	- INLINE ASM (LlamaAccount.sol#1329-1336)



    
1329         assembly {
1330             // We still have some spare memory space on the left,
1331             // as we have allocated 3 words (96 bytes) for up to 78 digits.
1332             let length := mload(str) // Load the string length.
1333             mstore(str, 0x2d) // Store the '-' character.
1334             str := sub(str, 1) // Move back the string pointer by a byte.
1335             mstore(str, add(length, 1)) // Update the string length.
1336         }



```

```
LibString.lastIndexOf(string,string,uint256) (LlamaAccount.sol#1812-1844) uses assembly
	- INLINE ASM (LlamaAccount.sol#1818-1843)



    
1818         assembly {
1819             for {} 1 {} {
1820                 result := not(0) // Initialize to `NOT_FOUND`.
1821                 let searchLength := mload(search)
1822                 if gt(searchLength, mload(subject)) { break }
1823                 let w := result
1824 
1825                 let fromMax := sub(mload(subject), searchLength)
1826                 if iszero(gt(fromMax, from)) { from := fromMax }
1827 
1828                 let end := add(add(subject, 0x20), w)
1829                 subject := add(add(subject, 0x20), from)
1830                 if iszero(gt(subject, end)) { break }
1831                 // As this function is not too often used,
1832                 // we shall simply use keccak256 for smaller bytecode size.
1833                 for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
1834                     if eq(keccak256(subject, searchLength), h) {
1835                         result := sub(subject, add(end, 1))
1836                         break
1837                     }
1838                     subject := add(subject, w) // `sub(subject, 1)`.
1839                     if iszero(gt(subject, end)) { break }
1840                 }
1841                 break
1842             }
1843         }



```

```
LibString.escapeHTML(string) (LlamaAccount.sol#2171-2202) uses assembly
	- INLINE ASM (LlamaAccount.sol#2173-2201)



    
2173         assembly {
2174             for {
2175                 let end := add(s, mload(s))
2176                 result := add(mload(0x40), 0x20)
2177                 // Store the bytes of the packed offsets and strides into the scratch space.
2178                 // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.
2179                 mstore(0x1f, 0x900094)
2180                 mstore(0x08, 0xc0000000a6ab)
2181                 // Store "&quot;&amp;&#39;&lt;&gt;" into the scratch space.
2182                 mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))
2183             } iszero(eq(s, end)) {} {
2184                 s := add(s, 1)
2185                 let c := and(mload(s), 0xff)
2186                 // Not in `["\"","'","&","<",">"]`.
2187                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
2188                     mstore8(result, c)
2189                     result := add(result, 1)
2190                     continue
2191                 }
2192                 let t := shr(248, mload(c))
2193                 mstore(result, mload(and(t, 0x1f)))
2194                 result := add(result, shr(5, t))
2195             }
2196             let last := result
2197             mstore(last, 0) // Zeroize the slot after the string.
2198             result := mload(0x40)
2199             mstore(result, sub(last, add(result, 0x20))) // Store the length.
2200             mstore(0x40, add(last, 0x20)) // Allocate the memory.
2201         }



```

```
LibString.escapeJSON(string) (LlamaAccount.sol#2205-2251) uses assembly
	- INLINE ASM (LlamaAccount.sol#2207-2250)



    
2207         assembly {
2208             for {
2209                 let end := add(s, mload(s))
2210                 result := add(mload(0x40), 0x20)
2211                 // Store "\\u0000" in scratch space.
2212                 // Store "0123456789abcdef" in scratch space.
2213                 // Also, store `{0x08:"b", 0x09:"t", 0x0a:"n", 0x0c:"f", 0x0d:"r"}`.
2214                 // into the scratch space.
2215                 mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)
2216                 // Bitmask for detecting `["\"","\\"]`.
2217                 let e := or(shl(0x22, 1), shl(0x5c, 1))
2218             } iszero(eq(s, end)) {} {
2219                 s := add(s, 1)
2220                 let c := and(mload(s), 0xff)
2221                 if iszero(lt(c, 0x20)) {
2222                     if iszero(and(shl(c, 1), e)) {
2223                         // Not in `["\"","\\"]`.
2224                         mstore8(result, c)
2225                         result := add(result, 1)
2226                         continue
2227                     }
2228                     mstore8(result, 0x5c) // "\\".
2229                     mstore8(add(result, 1), c)
2230                     result := add(result, 2)
2231                     continue
2232                 }
2233                 if iszero(and(shl(c, 1), 0x3700)) {
2234                     // Not in `["\b","\t","\n","\f","\d"]`.
2235                     mstore8(0x1d, mload(shr(4, c))) // Hex value.
2236                     mstore8(0x1e, mload(and(c, 15))) // Hex value.
2237                     mstore(result, mload(0x19)) // "\\u00XX".
2238                     result := add(result, 6)
2239                     continue
2240                 }
2241                 mstore8(result, 0x5c) // "\\".
2242                 mstore8(add(result, 1), mload(add(c, 8)))
2243                 result := add(result, 2)
2244             }
2245             let last := result
2246             mstore(last, 0) // Zeroize the slot after the string.
2247             result := mload(0x40)
2248             mstore(result, sub(last, add(result, 0x20))) // Store the length.
2249             mstore(0x40, add(last, 0x20)) // Allocate the memory.
2250         }



```

```
Clones.clone(address) (LlamaAccount.sol#1191-1204) uses assembly
	- INLINE ASM (LlamaAccount.sol#1193-1200)



    
1193         assembly {
1194             // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
1195             // of the `implementation` address with the bytecode before the address.
1196             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
1197             // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
1198             mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
1199             instance := create(0, 0x09, 0x37)
1200         }



```

```
Checkpoints._unsafeAccess(Checkpoints.Checkpoint[],uint256) (LlamaAccount.sol#2558-2567) uses assembly
	- INLINE ASM (LlamaAccount.sol#2563-2566)



    
2563         assembly {
2564             mstore(0, self.slot)
2565             result.slot := add(keccak256(0, 0x20), pos)
2566         }



```

```
LlamaAccount._readSlot0() (LlamaAccount.sol#5254-5258) uses assembly
	- INLINE ASM (LlamaAccount.sol#5255-5257)



    
5255     assembly {
5256       slot0 := sload(0)
5257     }



```

```
LibString.slice(string,uint256,uint256) (LlamaAccount.sol#1941-1970) uses assembly
	- INLINE ASM (LlamaAccount.sol#1947-1969)



    
1947         assembly {
1948             let subjectLength := mload(subject)
1949             if iszero(gt(subjectLength, end)) { end := subjectLength }
1950             if iszero(gt(subjectLength, start)) { start := subjectLength }
1951             if lt(start, end) {
1952                 result := mload(0x40)
1953                 let resultLength := sub(end, start)
1954                 mstore(result, resultLength)
1955                 subject := add(subject, start)
1956                 let w := not(0x1f)
1957                 // Copy the `subject` one word at a time, backwards.
1958                 for { let o := and(add(resultLength, 0x1f), w) } 1 {} {
1959                     mstore(add(result, o), mload(add(subject, o)))
1960                     o := add(o, w) // `sub(o, 0x20)`.
1961                     if iszero(o) { break }
1962                 }
1963                 // Zeroize the slot after the string.
1964                 mstore(add(add(result, 0x20), resultLength), 0)
1965                 // Allocate memory for the length and the bytes,
1966                 // rounded up to a multiple of 32.
1967                 mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))
1968             }
1969         }



```

```
LibString.toCase(string,bool) (LlamaAccount.sol#2130-2156) uses assembly
	- INLINE ASM (LlamaAccount.sol#2136-2155)



    
2136         assembly {
2137             let length := mload(subject)
2138             if length {
2139                 result := add(mload(0x40), 0x20)
2140                 subject := add(subject, 1)
2141                 let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)
2142                 let w := not(0)
2143                 for { let o := length } 1 {} {
2144                     o := add(o, w)
2145                     let b := and(0xff, mload(add(subject, o)))
2146                     mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))
2147                     if iszero(o) { break }
2148                 }
2149                 result := mload(0x40)
2150                 mstore(result, length) // Store the length.
2151                 let last := add(add(result, 0x20), length)
2152                 mstore(last, 0) // Zeroize the slot after the string.
2153                 mstore(0x40, add(last, 0x20)) // Allocate the memory.
2154             }
2155         }



```

```
LibString.toHexStringNoPrefix(address) (LlamaAccount.sol#1537-1570) uses assembly
	- INLINE ASM (LlamaAccount.sol#1539-1569)



    
1539         assembly {
1540             str := mload(0x40)
1541 
1542             // Allocate the memory.
1543             // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,
1544             // 0x02 bytes for the prefix, and 0x28 bytes for the digits.
1545             // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.
1546             mstore(0x40, add(str, 0x80))
1547 
1548             // Store "0123456789abcdef" in scratch space.
1549             mstore(0x0f, 0x30313233343536373839616263646566)
1550 
1551             str := add(str, 2)
1552             mstore(str, 40)
1553 
1554             let o := add(str, 0x20)
1555             mstore(add(o, 40), 0)
1556 
1557             value := shl(96, value)
1558 
1559             // We write the string from rightmost digit to leftmost digit.
1560             // The following is essentially a do-while loop that also handles the zero case.
1561             for { let i := 0 } 1 {} {
1562                 let p := add(o, add(i, i))
1563                 let temp := byte(i, value)
1564                 mstore8(add(p, 1), mload(and(temp, 15)))
1565                 mstore8(p, mload(shr(4, temp)))
1566                 i := add(i, 1)
1567                 if eq(i, 20) { break }
1568             }
1569         }



```

```
LibString.toHexStringNoPrefix(bytes) (LlamaAccount.sol#1587-1609) uses assembly
	- INLINE ASM (LlamaAccount.sol#1589-1608)



    
1589         assembly {
1590             let length := mload(raw)
1591             str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.
1592             mstore(str, add(length, length)) // Store the length of the output.
1593 
1594             // Store "0123456789abcdef" in scratch space.
1595             mstore(0x0f, 0x30313233343536373839616263646566)
1596 
1597             let o := add(str, 0x20)
1598             let end := add(raw, length)
1599 
1600             for {} iszero(eq(raw, end)) {} {
1601                 raw := add(raw, 1)
1602                 mstore8(add(o, 1), mload(and(mload(raw), 15)))
1603                 mstore8(o, mload(and(shr(4, mload(raw)), 15)))
1604                 o := add(o, 2)
1605             }
1606             mstore(o, 0) // Zeroize the slot after the string.
1607             mstore(0x40, add(o, 0x20)) // Allocate the memory.
1608         }



```

```
Address._revert(bytes,function()) (LlamaAccount.sol#543-556) uses assembly
	- INLINE ASM (LlamaAccount.sol#548-551)



    
548             assembly {
549                 let returndata_size := mload(returndata)
550                 revert(add(32, returndata), returndata_size)
551             }



```

```
Clones.cloneDeterministic(address,bytes32) (LlamaAccount.sol#1213-1226) uses assembly
	- INLINE ASM (LlamaAccount.sol#1215-1222)



    
1215         assembly {
1216             // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
1217             // of the `implementation` address with the bytecode before the address.
1218             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
1219             // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
1220             mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
1221             instance := create2(0, 0x09, 0x37, salt)
1222         }



```

```
LibString.indicesOf(string,string) (LlamaAccount.sol#1984-2040) uses assembly
	- INLINE ASM (LlamaAccount.sol#1990-2039)



    
1990         assembly {
1991             let subjectLength := mload(subject)
1992             let searchLength := mload(search)
1993 
1994             if iszero(gt(searchLength, subjectLength)) {
1995                 subject := add(subject, 0x20)
1996                 search := add(search, 0x20)
1997                 result := add(mload(0x40), 0x20)
1998 
1999                 let subjectStart := subject
2000                 let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)
2001                 let h := 0
2002                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
2003                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
2004                 let s := mload(search)
2005                 for {} 1 {} {
2006                     let t := mload(subject)
2007                     // Whether the first `searchLength % 32` bytes of
2008                     // `subject` and `search` matches.
2009                     if iszero(shr(m, xor(t, s))) {
2010                         if h {
2011                             if iszero(eq(keccak256(subject, searchLength), h)) {
2012                                 subject := add(subject, 1)
2013                                 if iszero(lt(subject, subjectSearchEnd)) { break }
2014                                 continue
2015                             }
2016                         }
2017                         // Append to `result`.
2018                         mstore(result, sub(subject, subjectStart))
2019                         result := add(result, 0x20)
2020                         // Advance `subject` by `searchLength`.
2021                         subject := add(subject, searchLength)
2022                         if searchLength {
2023                             if iszero(lt(subject, subjectSearchEnd)) { break }
2024                             continue
2025                         }
2026                     }
2027                     subject := add(subject, 1)
2028                     if iszero(lt(subject, subjectSearchEnd)) { break }
2029                 }
2030                 let resultEnd := result
2031                 // Assign `result` to the free memory pointer.
2032                 result := mload(0x40)
2033                 // Store the length of `result`.
2034                 mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))
2035                 // Allocate memory for result.
2036                 // We allocate one more word, so this array can be recycled for {split}.
2037                 mstore(0x40, add(resultEnd, 0x20))
2038             }
2039         }



```

```
LibString.concat(string,string) (LlamaAccount.sol#2092-2126) uses assembly
	- INLINE ASM (LlamaAccount.sol#2098-2125)



    
2098         assembly {
2099             let w := not(0x1f)
2100             result := mload(0x40)
2101             let aLength := mload(a)
2102             // Copy `a` one word at a time, backwards.
2103             for { let o := and(add(aLength, 0x20), w) } 1 {} {
2104                 mstore(add(result, o), mload(add(a, o)))
2105                 o := add(o, w) // `sub(o, 0x20)`.
2106                 if iszero(o) { break }
2107             }
2108             let bLength := mload(b)
2109             let output := add(result, aLength)
2110             // Copy `b` one word at a time, backwards.
2111             for { let o := and(add(bLength, 0x20), w) } 1 {} {
2112                 mstore(add(output, o), mload(add(b, o)))
2113                 o := add(o, w) // `sub(o, 0x20)`.
2114                 if iszero(o) { break }
2115             }
2116             let totalLength := add(aLength, bLength)
2117             let last := add(add(result, 0x20), totalLength)
2118             // Zeroize the slot after the string.
2119             mstore(last, 0)
2120             // Stores the length.
2121             mstore(result, totalLength)
2122             // Allocate memory for the length and the bytes,
2123             // rounded up to a multiple of 32.
2124             mstore(0x40, and(add(last, 0x1f), w))
2125         }



```

```
LibString.toHexStringChecksummed(address) (LlamaAccount.sol#1503-1520) uses assembly
	- INLINE ASM (LlamaAccount.sol#1506-1519)



    
1506         assembly {
1507             let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`
1508             let o := add(str, 0x22)
1509             let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `
1510             let t := shl(240, 136) // `0b10001000 << 240`
1511             for { let i := 0 } 1 {} {
1512                 mstore(add(i, i), mul(t, byte(i, hashed)))
1513                 i := add(i, 1)
1514                 if eq(i, 20) { break }
1515             }
1516             mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))
1517             o := add(o, 0x20)
1518             mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))
1519         }



```

```
LibString.toMinimalHexString(uint256) (LlamaAccount.sol#1433-1443) uses assembly
	- INLINE ASM (LlamaAccount.sol#1436-1442)



    
1436         assembly {
1437             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
1438             let strLength := add(mload(str), 2) // Compute the length.
1439             mstore(add(str, o), 0x3078) // Write the "0x" prefix, accounting for leading zero.
1440             str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.
1441             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
1442         }



```

```
LibString.toString(uint256) (LlamaAccount.sol#1283-1318) uses assembly
	- INLINE ASM (LlamaAccount.sol#1285-1317)



    
1285         assembly {
1286             // The maximum value of a uint256 contains 78 digits (1 byte per digit), but
1287             // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.
1288             // We will need 1 word for the trailing zeros padding, 1 word for the length,
1289             // and 3 words for a maximum of 78 digits.
1290             str := add(mload(0x40), 0x80)
1291             // Update the free memory pointer to allocate.
1292             mstore(0x40, add(str, 0x20))
1293             // Zeroize the slot after the string.
1294             mstore(str, 0)
1295 
1296             // Cache the end of the memory to calculate the length later.
1297             let end := str
1298 
1299             let w := not(0) // Tsk.
1300             // We write the string from rightmost digit to leftmost digit.
1301             // The following is essentially a do-while loop that also handles the zero case.
1302             for { let temp := value } 1 {} {
1303                 str := add(str, w) // `sub(str, 1)`.
1304                 // Write the character to the pointer.
1305                 // The ASCII index of the '0' character is 48.
1306                 mstore8(str, add(48, mod(temp, 10)))
1307                 // Keep dividing `temp` until zero.
1308                 temp := div(temp, 10)
1309                 if iszero(temp) { break }
1310             }
1311 
1312             let length := sub(end, str)
1313             // Move the pointer 32 bytes leftwards to make room for the length.
1314             str := sub(str, 0x20)
1315             // Store the length.
1316             mstore(str, length)
1317         }



```

```
LibString.packOne(string) (LlamaAccount.sol#2262-2276) uses assembly
	- INLINE ASM (LlamaAccount.sol#2264-2275)



    
2264         assembly {
2265             // We don't need to zero right pad the string,
2266             // since this is our own custom non-standard packing scheme.
2267             result :=
2268                 mul(
2269                     // Load the length and the bytes.
2270                     mload(add(a, 0x1f)),
2271                     // `length != 0 && length < 32`. Abuses underflow.
2272                     // Assumes that the length is valid and within the block gas limit.
2273                     lt(sub(mload(a), 1), 0x1f)
2274                 )
2275         }



```

```
LibString.replace(string,string,string) (LlamaAccount.sol#1666-1738) uses assembly
	- INLINE ASM (LlamaAccount.sol#1672-1737)



    
1672         assembly {
1673             let subjectLength := mload(subject)
1674             let searchLength := mload(search)
1675             let replacementLength := mload(replacement)
1676 
1677             subject := add(subject, 0x20)
1678             search := add(search, 0x20)
1679             replacement := add(replacement, 0x20)
1680             result := add(mload(0x40), 0x20)
1681 
1682             let subjectEnd := add(subject, subjectLength)
1683             if iszero(gt(searchLength, subjectLength)) {
1684                 let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)
1685                 let h := 0
1686                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
1687                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
1688                 let s := mload(search)
1689                 for {} 1 {} {
1690                     let t := mload(subject)
1691                     // Whether the first `searchLength % 32` bytes of
1692                     // `subject` and `search` matches.
1693                     if iszero(shr(m, xor(t, s))) {
1694                         if h {
1695                             if iszero(eq(keccak256(subject, searchLength), h)) {
1696                                 mstore(result, t)
1697                                 result := add(result, 1)
1698                                 subject := add(subject, 1)
1699                                 if iszero(lt(subject, subjectSearchEnd)) { break }
1700                                 continue
1701                             }
1702                         }
1703                         // Copy the `replacement` one word at a time.
1704                         for { let o := 0 } 1 {} {
1705                             mstore(add(result, o), mload(add(replacement, o)))
1706                             o := add(o, 0x20)
1707                             if iszero(lt(o, replacementLength)) { break }
1708                         }
1709                         result := add(result, replacementLength)
1710                         subject := add(subject, searchLength)
1711                         if searchLength {
1712                             if iszero(lt(subject, subjectSearchEnd)) { break }
1713                             continue
1714                         }
1715                     }
1716                     mstore(result, t)
1717                     result := add(result, 1)
1718                     subject := add(subject, 1)
1719                     if iszero(lt(subject, subjectSearchEnd)) { break }
1720                 }
1721             }
1722 
1723             let resultRemainder := result
1724             result := add(mload(0x40), 0x20)
1725             let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))
1726             // Copy the rest of the string one word at a time.
1727             for {} lt(subject, subjectEnd) {} {
1728                 mstore(resultRemainder, mload(subject))
1729                 resultRemainder := add(resultRemainder, 0x20)
1730                 subject := add(subject, 0x20)
1731             }
1732             result := sub(result, 0x20)
1733             let last := add(add(result, 0x20), k) // Zeroize the slot after the string.
1734             mstore(last, 0)
1735             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1736             mstore(result, k) // Store the length.
1737         }



```

```
LibString.indexOf(string,string,uint256) (LlamaAccount.sol#1743-1796) uses assembly
	- INLINE ASM (LlamaAccount.sol#1749-1795)



    
1749         assembly {
1750             for { let subjectLength := mload(subject) } 1 {} {
1751                 if iszero(mload(search)) {
1752                     if iszero(gt(from, subjectLength)) {
1753                         result := from
1754                         break
1755                     }
1756                     result := subjectLength
1757                     break
1758                 }
1759                 let searchLength := mload(search)
1760                 let subjectStart := add(subject, 0x20)
1761 
1762                 result := not(0) // Initialize to `NOT_FOUND`.
1763 
1764                 subject := add(subjectStart, from)
1765                 let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)
1766 
1767                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
1768                 let s := mload(add(search, 0x20))
1769 
1770                 if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }
1771 
1772                 if iszero(lt(searchLength, 0x20)) {
1773                     for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
1774                         if iszero(shr(m, xor(mload(subject), s))) {
1775                             if eq(keccak256(subject, searchLength), h) {
1776                                 result := sub(subject, subjectStart)
1777                                 break
1778                             }
1779                         }
1780                         subject := add(subject, 1)
1781                         if iszero(lt(subject, end)) { break }
1782                     }
1783                     break
1784                 }
1785                 for {} 1 {} {
1786                     if iszero(shr(m, xor(mload(subject), s))) {
1787                         result := sub(subject, subjectStart)
1788                         break
1789                     }
1790                     subject := add(subject, 1)
1791                     if iszero(lt(subject, end)) { break }
1792                 }
1793                 break
1794             }
1795         }



```

```
LibString.toHexStringNoPrefix(uint256,uint256) (LlamaAccount.sol#1364-1412) uses assembly
	- INLINE ASM (LlamaAccount.sol#1370-1411)



    
1370         assembly {
1371             // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes
1372             // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.
1373             // We add 0x20 to the total and round down to a multiple of 0x20.
1374             // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.
1375             str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))
1376             // Allocate the memory.
1377             mstore(0x40, add(str, 0x20))
1378             // Zeroize the slot after the string.
1379             mstore(str, 0)
1380 
1381             // Cache the end to calculate the length later.
1382             let end := str
1383             // Store "0123456789abcdef" in scratch space.
1384             mstore(0x0f, 0x30313233343536373839616263646566)
1385 
1386             let start := sub(str, add(length, length))
1387             let w := not(1) // Tsk.
1388             let temp := value
1389             // We write the string from rightmost digit to leftmost digit.
1390             // The following is essentially a do-while loop that also handles the zero case.
1391             for {} 1 {} {
1392                 str := add(str, w) // `sub(str, 2)`.
1393                 mstore8(add(str, 1), mload(and(temp, 15)))
1394                 mstore8(str, mload(and(shr(4, temp), 15)))
1395                 temp := shr(8, temp)
1396                 if iszero(xor(str, start)) { break }
1397             }
1398 
1399             if temp {
1400                 // Store the function selector of `HexLengthInsufficient()`.
1401                 mstore(0x00, 0x2194895a)
1402                 // Revert with (offset, size).
1403                 revert(0x1c, 0x04)
1404             }
1405 
1406             // Compute the string's length.
1407             let strLength := sub(end, str)
1408             // Move the pointer and write the length.
1409             str := sub(str, 0x20)
1410             mstore(str, strLength)
1411         }



```

```
LibString.split(string,string) (LlamaAccount.sol#2043-2088) uses assembly
	- INLINE ASM (LlamaAccount.sol#2050-2087)



    
2050         assembly {
2051             let w := not(0x1f)
2052             let indexPtr := add(indices, 0x20)
2053             let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))
2054             mstore(add(indicesEnd, w), mload(subject))
2055             mstore(indices, add(mload(indices), 1))
2056             let prevIndex := 0
2057             for {} 1 {} {
2058                 let index := mload(indexPtr)
2059                 mstore(indexPtr, 0x60)
2060                 if iszero(eq(index, prevIndex)) {
2061                     let element := mload(0x40)
2062                     let elementLength := sub(index, prevIndex)
2063                     mstore(element, elementLength)
2064                     // Copy the `subject` one word at a time, backwards.
2065                     for { let o := and(add(elementLength, 0x1f), w) } 1 {} {
2066                         mstore(add(element, o), mload(add(add(subject, prevIndex), o)))
2067                         o := add(o, w) // `sub(o, 0x20)`.
2068                         if iszero(o) { break }
2069                     }
2070                     // Zeroize the slot after the string.
2071                     mstore(add(add(element, 0x20), elementLength), 0)
2072                     // Allocate memory for the length and the bytes,
2073                     // rounded up to a multiple of 32.
2074                     mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))
2075                     // Store the `element` into the array.
2076                     mstore(indexPtr, element)
2077                 }
2078                 prevIndex := add(index, mload(delimiter))
2079                 indexPtr := add(indexPtr, 0x20)
2080                 if iszero(lt(indexPtr, indicesEnd)) { break }
2081             }
2082             result := indices
2083             if iszero(mload(delimiter)) {
2084                 result := add(indices, 0x20)
2085                 mstore(result, sub(mload(indices), 2))
2086             }
2087         }



```

```
Base64.encode(bytes) (LlamaAccount.sol#2886-2957) uses assembly
	- INLINE ASM (LlamaAccount.sol#2905-2954)



    
2905         assembly {
2906             // Prepare the lookup table (skip the first "length" byte)
2907             let tablePtr := add(table, 1)
2908 
2909             // Prepare result pointer, jump over length
2910             let resultPtr := add(result, 32)
2911 
2912             // Run over the input, 3 bytes at a time
2913             for {
2914                 let dataPtr := data
2915                 let endPtr := add(data, mload(data))
2916             } lt(dataPtr, endPtr) {
2917 
2918             } {
2919                 // Advance 3 bytes
2920                 dataPtr := add(dataPtr, 3)
2921                 let input := mload(dataPtr)
2922 
2923                 // To write each character, shift the 3 bytes (18 bits) chunk
2924                 // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)
2925                 // and apply logical AND with 0x3F which is the number of
2926                 // the previous character in the ASCII table prior to the Base64 Table
2927                 // The result is then added to the table to get the character to write,
2928                 // and finally write it in the result pointer but with a left shift
2929                 // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits
2930 
2931                 mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))
2932                 resultPtr := add(resultPtr, 1) // Advance
2933 
2934                 mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))
2935                 resultPtr := add(resultPtr, 1) // Advance
2936 
2937                 mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))
2938                 resultPtr := add(resultPtr, 1) // Advance
2939 
2940                 mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))
2941                 resultPtr := add(resultPtr, 1) // Advance
2942             }
2943 
2944             // When data `bytes` is not exactly 3 bytes long
2945             // it is padded with `=` characters at the end
2946             switch mod(mload(data), 3)
2947             case 1 {
2948                 mstore8(sub(resultPtr, 1), 0x3d)
2949                 mstore8(sub(resultPtr, 2), 0x3d)
2950             }
2951             case 2 {
2952                 mstore8(sub(resultPtr, 1), 0x3d)
2953             }
2954         }



```

```
LibString.packTwo(string,string) (LlamaAccount.sol#2299-2317) uses assembly
	- INLINE ASM (LlamaAccount.sol#2301-2316)



    
2301         assembly {
2302             let aLength := mload(a)
2303             // We don't need to zero right pad the strings,
2304             // since this is our own custom non-standard packing scheme.
2305             result :=
2306                 mul(
2307                     // Load the length and the bytes of `a` and `b`.
2308                     or(
2309                         shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),
2310                         mload(sub(add(b, 0x1e), aLength))
2311                     ),
2312                     // `totalLength != 0 && totalLength < 31`. Abuses underflow.
2313                     // Assumes that the lengths are valid and within the block gas limit.
2314                     lt(sub(add(aLength, mload(b)), 1), 0x1e)
2315                 )
2316         }



```

```
LibString.toHexStringNoPrefix(uint256) (LlamaAccount.sol#1463-1497) uses assembly
	- INLINE ASM (LlamaAccount.sol#1465-1496)



    
1465         assembly {
1466             // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,
1467             // 0x02 bytes for the prefix, and 0x40 bytes for the digits.
1468             // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.
1469             str := add(mload(0x40), 0x80)
1470             // Allocate the memory.
1471             mstore(0x40, add(str, 0x20))
1472             // Zeroize the slot after the string.
1473             mstore(str, 0)
1474 
1475             // Cache the end to calculate the length later.
1476             let end := str
1477             // Store "0123456789abcdef" in scratch space.
1478             mstore(0x0f, 0x30313233343536373839616263646566)
1479 
1480             let w := not(1) // Tsk.
1481             // We write the string from rightmost digit to leftmost digit.
1482             // The following is essentially a do-while loop that also handles the zero case.
1483             for { let temp := value } 1 {} {
1484                 str := add(str, w) // `sub(str, 2)`.
1485                 mstore8(add(str, 1), mload(and(temp, 15)))
1486                 mstore8(str, mload(and(shr(4, temp), 15)))
1487                 temp := shr(8, temp)
1488                 if iszero(temp) { break }
1489             }
1490 
1491             // Compute the string's length.
1492             let strLength := sub(end, str)
1493             // Move the pointer and write the length.
1494             str := sub(str, 0x20)
1495             mstore(str, strLength)
1496         }



```

```
LibString.toHexString(uint256) (LlamaAccount.sol#1418-1427) uses assembly
	- INLINE ASM (LlamaAccount.sol#1421-1426)



    
1421         assembly {
1422             let strLength := add(mload(str), 2) // Compute the length.
1423             mstore(str, 0x3078) // Write the "0x" prefix.
1424             str := sub(str, 2) // Move the pointer.
1425             mstore(str, strLength) // Write the length.
1426         }



```

```
LibString.unpackOne(bytes32) (LlamaAccount.sol#2281-2295) uses assembly
	- INLINE ASM (LlamaAccount.sol#2283-2294)



    
2283         assembly {
2284             // Grab the free memory pointer.
2285             result := mload(0x40)
2286             // Allocate 2 words (1 for the length, 1 for the bytes).
2287             mstore(0x40, add(result, 0x40))
2288             // Zeroize the length slot.
2289             mstore(result, 0)
2290             // Store the length and bytes.
2291             mstore(add(result, 0x1f), packed)
2292             // Right pad with zeroes.
2293             mstore(add(add(result, 0x20), mload(result)), 0)
2294         }



```

```
LibString.is7BitASCII(string) (LlamaAccount.sol#1634-1656) uses assembly
	- INLINE ASM (LlamaAccount.sol#1636-1655)



    
1636         assembly {
1637             let mask := shl(7, div(not(0), 255))
1638             result := 1
1639             let n := mload(s)
1640             if n {
1641                 let o := add(s, 0x20)
1642                 let end := add(o, n)
1643                 let last := mload(end)
1644                 mstore(end, 0)
1645                 for {} 1 {} {
1646                     if and(mask, mload(o)) {
1647                         result := 0
1648                         break
1649                     }
1650                     o := add(o, 0x20)
1651                     if iszero(lt(o, end)) { break }
1652                 }
1653                 mstore(end, last)
1654             }
1655         }



```

### LlamaCore.sol


```
LibString.toHexStringNoPrefix(address) (LlamaCore.sol#574-607) uses assembly
	- INLINE ASM (LlamaCore.sol#576-606)



    
576         assembly {
577             str := mload(0x40)
578 
579             // Allocate the memory.
580             // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,
581             // 0x02 bytes for the prefix, and 0x28 bytes for the digits.
582             // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.
583             mstore(0x40, add(str, 0x80))
584 
585             // Store "0123456789abcdef" in scratch space.
586             mstore(0x0f, 0x30313233343536373839616263646566)
587 
588             str := add(str, 2)
589             mstore(str, 40)
590 
591             let o := add(str, 0x20)
592             mstore(add(o, 40), 0)
593 
594             value := shl(96, value)
595 
596             // We write the string from rightmost digit to leftmost digit.
597             // The following is essentially a do-while loop that also handles the zero case.
598             for { let i := 0 } 1 {} {
599                 let p := add(o, add(i, i))
600                 let temp := byte(i, value)
601                 mstore8(add(p, 1), mload(and(temp, 15)))
602                 mstore8(p, mload(shr(4, temp)))
603                 i := add(i, 1)
604                 if eq(i, 20) { break }
605             }
606         }



```

```
LibString.escapeJSON(string) (LlamaCore.sol#1242-1288) uses assembly
	- INLINE ASM (LlamaCore.sol#1244-1287)



    
1244         assembly {
1245             for {
1246                 let end := add(s, mload(s))
1247                 result := add(mload(0x40), 0x20)
1248                 // Store "\\u0000" in scratch space.
1249                 // Store "0123456789abcdef" in scratch space.
1250                 // Also, store `{0x08:"b", 0x09:"t", 0x0a:"n", 0x0c:"f", 0x0d:"r"}`.
1251                 // into the scratch space.
1252                 mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)
1253                 // Bitmask for detecting `["\"","\\"]`.
1254                 let e := or(shl(0x22, 1), shl(0x5c, 1))
1255             } iszero(eq(s, end)) {} {
1256                 s := add(s, 1)
1257                 let c := and(mload(s), 0xff)
1258                 if iszero(lt(c, 0x20)) {
1259                     if iszero(and(shl(c, 1), e)) {
1260                         // Not in `["\"","\\"]`.
1261                         mstore8(result, c)
1262                         result := add(result, 1)
1263                         continue
1264                     }
1265                     mstore8(result, 0x5c) // "\\".
1266                     mstore8(add(result, 1), c)
1267                     result := add(result, 2)
1268                     continue
1269                 }
1270                 if iszero(and(shl(c, 1), 0x3700)) {
1271                     // Not in `["\b","\t","\n","\f","\d"]`.
1272                     mstore8(0x1d, mload(shr(4, c))) // Hex value.
1273                     mstore8(0x1e, mload(and(c, 15))) // Hex value.
1274                     mstore(result, mload(0x19)) // "\\u00XX".
1275                     result := add(result, 6)
1276                     continue
1277                 }
1278                 mstore8(result, 0x5c) // "\\".
1279                 mstore8(add(result, 1), mload(add(c, 8)))
1280                 result := add(result, 2)
1281             }
1282             let last := result
1283             mstore(last, 0) // Zeroize the slot after the string.
1284             result := mload(0x40)
1285             mstore(result, sub(last, add(result, 0x20))) // Store the length.
1286             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1287         }



```

```
LibString.lastIndexOf(string,string,uint256) (LlamaCore.sol#849-881) uses assembly
	- INLINE ASM (LlamaCore.sol#855-880)



    
855         assembly {
856             for {} 1 {} {
857                 result := not(0) // Initialize to `NOT_FOUND`.
858                 let searchLength := mload(search)
859                 if gt(searchLength, mload(subject)) { break }
860                 let w := result
861 
862                 let fromMax := sub(mload(subject), searchLength)
863                 if iszero(gt(fromMax, from)) { from := fromMax }
864 
865                 let end := add(add(subject, 0x20), w)
866                 subject := add(add(subject, 0x20), from)
867                 if iszero(gt(subject, end)) { break }
868                 // As this function is not too often used,
869                 // we shall simply use keccak256 for smaller bytecode size.
870                 for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
871                     if eq(keccak256(subject, searchLength), h) {
872                         result := sub(subject, add(end, 1))
873                         break
874                     }
875                     subject := add(subject, w) // `sub(subject, 1)`.
876                     if iszero(gt(subject, end)) { break }
877                 }
878                 break
879             }
880         }



```

```
LibString.toHexStringChecksummed(address) (LlamaCore.sol#540-557) uses assembly
	- INLINE ASM (LlamaCore.sol#543-556)



    
543         assembly {
544             let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`
545             let o := add(str, 0x22)
546             let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `
547             let t := shl(240, 136) // `0b10001000 << 240`
548             for { let i := 0 } 1 {} {
549                 mstore(add(i, i), mul(t, byte(i, hashed)))
550                 i := add(i, 1)
551                 if eq(i, 20) { break }
552             }
553             mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))
554             o := add(o, 0x20)
555             mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))
556         }



```

```
LibString.toCase(string,bool) (LlamaCore.sol#1167-1193) uses assembly
	- INLINE ASM (LlamaCore.sol#1173-1192)



    
1173         assembly {
1174             let length := mload(subject)
1175             if length {
1176                 result := add(mload(0x40), 0x20)
1177                 subject := add(subject, 1)
1178                 let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)
1179                 let w := not(0)
1180                 for { let o := length } 1 {} {
1181                     o := add(o, w)
1182                     let b := and(0xff, mload(add(subject, o)))
1183                     mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))
1184                     if iszero(o) { break }
1185                 }
1186                 result := mload(0x40)
1187                 mstore(result, length) // Store the length.
1188                 let last := add(add(result, 0x20), length)
1189                 mstore(last, 0) // Zeroize the slot after the string.
1190                 mstore(0x40, add(last, 0x20)) // Allocate the memory.
1191             }
1192         }



```

```
LibString.indicesOf(string,string) (LlamaCore.sol#1021-1077) uses assembly
	- INLINE ASM (LlamaCore.sol#1027-1076)



    
1027         assembly {
1028             let subjectLength := mload(subject)
1029             let searchLength := mload(search)
1030 
1031             if iszero(gt(searchLength, subjectLength)) {
1032                 subject := add(subject, 0x20)
1033                 search := add(search, 0x20)
1034                 result := add(mload(0x40), 0x20)
1035 
1036                 let subjectStart := subject
1037                 let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)
1038                 let h := 0
1039                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
1040                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
1041                 let s := mload(search)
1042                 for {} 1 {} {
1043                     let t := mload(subject)
1044                     // Whether the first `searchLength % 32` bytes of
1045                     // `subject` and `search` matches.
1046                     if iszero(shr(m, xor(t, s))) {
1047                         if h {
1048                             if iszero(eq(keccak256(subject, searchLength), h)) {
1049                                 subject := add(subject, 1)
1050                                 if iszero(lt(subject, subjectSearchEnd)) { break }
1051                                 continue
1052                             }
1053                         }
1054                         // Append to `result`.
1055                         mstore(result, sub(subject, subjectStart))
1056                         result := add(result, 0x20)
1057                         // Advance `subject` by `searchLength`.
1058                         subject := add(subject, searchLength)
1059                         if searchLength {
1060                             if iszero(lt(subject, subjectSearchEnd)) { break }
1061                             continue
1062                         }
1063                     }
1064                     subject := add(subject, 1)
1065                     if iszero(lt(subject, subjectSearchEnd)) { break }
1066                 }
1067                 let resultEnd := result
1068                 // Assign `result` to the free memory pointer.
1069                 result := mload(0x40)
1070                 // Store the length of `result`.
1071                 mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))
1072                 // Allocate memory for result.
1073                 // We allocate one more word, so this array can be recycled for {split}.
1074                 mstore(0x40, add(resultEnd, 0x20))
1075             }
1076         }



```

```
LibString.unpackTwo(bytes32) (LlamaCore.sol#1359-1381) uses assembly
	- INLINE ASM (LlamaCore.sol#1365-1380)



    
1365         assembly {
1366             // Grab the free memory pointer.
1367             resultA := mload(0x40)
1368             resultB := add(resultA, 0x40)
1369             // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.
1370             mstore(0x40, add(resultB, 0x40))
1371             // Zeroize the length slots.
1372             mstore(resultA, 0)
1373             mstore(resultB, 0)
1374             // Store the lengths and bytes.
1375             mstore(add(resultA, 0x1f), packed)
1376             mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))
1377             // Right pad with zeroes.
1378             mstore(add(add(resultA, 0x20), mload(resultA)), 0)
1379             mstore(add(add(resultB, 0x20), mload(resultB)), 0)
1380         }



```

```
Clones.predictDeterministicAddress(address,bytes32,address) (LlamaCore.sol#68-84) uses assembly
	- INLINE ASM (LlamaCore.sol#74-83)



    
74         assembly {
75             let ptr := mload(0x40)
76             mstore(add(ptr, 0x38), deployer)
77             mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)
78             mstore(add(ptr, 0x14), implementation)
79             mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)
80             mstore(add(ptr, 0x58), salt)
81             mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))
82             predicted := keccak256(add(ptr, 0x43), 0x55)
83         }



```

```
LibString.toHexString(uint256) (LlamaCore.sol#455-464) uses assembly
	- INLINE ASM (LlamaCore.sol#458-463)



    
458         assembly {
459             let strLength := add(mload(str), 2) // Compute the length.
460             mstore(str, 0x3078) // Write the "0x" prefix.
461             str := sub(str, 2) // Move the pointer.
462             mstore(str, strLength) // Write the length.
463         }



```

```
LibString.slice(string,uint256,uint256) (LlamaCore.sol#978-1007) uses assembly
	- INLINE ASM (LlamaCore.sol#984-1006)



    
984         assembly {
985             let subjectLength := mload(subject)
986             if iszero(gt(subjectLength, end)) { end := subjectLength }
987             if iszero(gt(subjectLength, start)) { start := subjectLength }
988             if lt(start, end) {
989                 result := mload(0x40)
990                 let resultLength := sub(end, start)
991                 mstore(result, resultLength)
992                 subject := add(subject, start)
993                 let w := not(0x1f)
994                 // Copy the `subject` one word at a time, backwards.
995                 for { let o := and(add(resultLength, 0x1f), w) } 1 {} {
996                     mstore(add(result, o), mload(add(subject, o)))
997                     o := add(o, w) // `sub(o, 0x20)`.
998                     if iszero(o) { break }
999                 }
1000                 // Zeroize the slot after the string.
1001                 mstore(add(add(result, 0x20), resultLength), 0)
1002                 // Allocate memory for the length and the bytes,
1003                 // rounded up to a multiple of 32.
1004                 mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))
1005             }
1006         }



```

```
LibString.toHexStringNoPrefix(uint256,uint256) (LlamaCore.sol#401-449) uses assembly
	- INLINE ASM (LlamaCore.sol#407-448)



    
407         assembly {
408             // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes
409             // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.
410             // We add 0x20 to the total and round down to a multiple of 0x20.
411             // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.
412             str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))
413             // Allocate the memory.
414             mstore(0x40, add(str, 0x20))
415             // Zeroize the slot after the string.
416             mstore(str, 0)
417 
418             // Cache the end to calculate the length later.
419             let end := str
420             // Store "0123456789abcdef" in scratch space.
421             mstore(0x0f, 0x30313233343536373839616263646566)
422 
423             let start := sub(str, add(length, length))
424             let w := not(1) // Tsk.
425             let temp := value
426             // We write the string from rightmost digit to leftmost digit.
427             // The following is essentially a do-while loop that also handles the zero case.
428             for {} 1 {} {
429                 str := add(str, w) // `sub(str, 2)`.
430                 mstore8(add(str, 1), mload(and(temp, 15)))
431                 mstore8(str, mload(and(shr(4, temp), 15)))
432                 temp := shr(8, temp)
433                 if iszero(xor(str, start)) { break }
434             }
435 
436             if temp {
437                 // Store the function selector of `HexLengthInsufficient()`.
438                 mstore(0x00, 0x2194895a)
439                 // Revert with (offset, size).
440                 revert(0x1c, 0x04)
441             }
442 
443             // Compute the string's length.
444             let strLength := sub(end, str)
445             // Move the pointer and write the length.
446             str := sub(str, 0x20)
447             mstore(str, strLength)
448         }



```

```
LibString.escapeHTML(string) (LlamaCore.sol#1208-1239) uses assembly
	- INLINE ASM (LlamaCore.sol#1210-1238)



    
1210         assembly {
1211             for {
1212                 let end := add(s, mload(s))
1213                 result := add(mload(0x40), 0x20)
1214                 // Store the bytes of the packed offsets and strides into the scratch space.
1215                 // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.
1216                 mstore(0x1f, 0x900094)
1217                 mstore(0x08, 0xc0000000a6ab)
1218                 // Store "&quot;&amp;&#39;&lt;&gt;" into the scratch space.
1219                 mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))
1220             } iszero(eq(s, end)) {} {
1221                 s := add(s, 1)
1222                 let c := and(mload(s), 0xff)
1223                 // Not in `["\"","'","&","<",">"]`.
1224                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
1225                     mstore8(result, c)
1226                     result := add(result, 1)
1227                     continue
1228                 }
1229                 let t := shr(248, mload(c))
1230                 mstore(result, mload(and(t, 0x1f)))
1231                 result := add(result, shr(5, t))
1232             }
1233             let last := result
1234             mstore(last, 0) // Zeroize the slot after the string.
1235             result := mload(0x40)
1236             mstore(result, sub(last, add(result, 0x20))) // Store the length.
1237             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1238         }



```

```
LibString.toHexString(uint256,uint256) (LlamaCore.sol#385-394) uses assembly
	- INLINE ASM (LlamaCore.sol#388-393)



    
388         assembly {
389             let strLength := add(mload(str), 2) // Compute the length.
390             mstore(str, 0x3078) // Write the "0x" prefix.
391             str := sub(str, 2) // Move the pointer.
392             mstore(str, strLength) // Write the length.
393         }



```

```
LibString.toHexStringNoPrefix(bytes) (LlamaCore.sol#624-646) uses assembly
	- INLINE ASM (LlamaCore.sol#626-645)



    
626         assembly {
627             let length := mload(raw)
628             str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.
629             mstore(str, add(length, length)) // Store the length of the output.
630 
631             // Store "0123456789abcdef" in scratch space.
632             mstore(0x0f, 0x30313233343536373839616263646566)
633 
634             let o := add(str, 0x20)
635             let end := add(raw, length)
636 
637             for {} iszero(eq(raw, end)) {} {
638                 raw := add(raw, 1)
639                 mstore8(add(o, 1), mload(and(mload(raw), 15)))
640                 mstore8(o, mload(and(shr(4, mload(raw)), 15)))
641                 o := add(o, 2)
642             }
643             mstore(o, 0) // Zeroize the slot after the string.
644             mstore(0x40, add(o, 0x20)) // Allocate the memory.
645         }



```

```
LibString.eq(string,string) (LlamaCore.sol#1291-1295) uses assembly
	- INLINE ASM (LlamaCore.sol#1292-1294)



    
1292         assembly {
1293             result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))
1294         }



```

```
LibString.replace(string,string,string) (LlamaCore.sol#703-775) uses assembly
	- INLINE ASM (LlamaCore.sol#709-774)



    
709         assembly {
710             let subjectLength := mload(subject)
711             let searchLength := mload(search)
712             let replacementLength := mload(replacement)
713 
714             subject := add(subject, 0x20)
715             search := add(search, 0x20)
716             replacement := add(replacement, 0x20)
717             result := add(mload(0x40), 0x20)
718 
719             let subjectEnd := add(subject, subjectLength)
720             if iszero(gt(searchLength, subjectLength)) {
721                 let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)
722                 let h := 0
723                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
724                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
725                 let s := mload(search)
726                 for {} 1 {} {
727                     let t := mload(subject)
728                     // Whether the first `searchLength % 32` bytes of
729                     // `subject` and `search` matches.
730                     if iszero(shr(m, xor(t, s))) {
731                         if h {
732                             if iszero(eq(keccak256(subject, searchLength), h)) {
733                                 mstore(result, t)
734                                 result := add(result, 1)
735                                 subject := add(subject, 1)
736                                 if iszero(lt(subject, subjectSearchEnd)) { break }
737                                 continue
738                             }
739                         }
740                         // Copy the `replacement` one word at a time.
741                         for { let o := 0 } 1 {} {
742                             mstore(add(result, o), mload(add(replacement, o)))
743                             o := add(o, 0x20)
744                             if iszero(lt(o, replacementLength)) { break }
745                         }
746                         result := add(result, replacementLength)
747                         subject := add(subject, searchLength)
748                         if searchLength {
749                             if iszero(lt(subject, subjectSearchEnd)) { break }
750                             continue
751                         }
752                     }
753                     mstore(result, t)
754                     result := add(result, 1)
755                     subject := add(subject, 1)
756                     if iszero(lt(subject, subjectSearchEnd)) { break }
757                 }
758             }
759 
760             let resultRemainder := result
761             result := add(mload(0x40), 0x20)
762             let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))
763             // Copy the rest of the string one word at a time.
764             for {} lt(subject, subjectEnd) {} {
765                 mstore(resultRemainder, mload(subject))
766                 resultRemainder := add(resultRemainder, 0x20)
767                 subject := add(subject, 0x20)
768             }
769             result := sub(result, 0x20)
770             let last := add(add(result, 0x20), k) // Zeroize the slot after the string.
771             mstore(last, 0)
772             mstore(0x40, add(last, 0x20)) // Allocate the memory.
773             mstore(result, k) // Store the length.
774         }



```

```
Checkpoints.sqrt(uint256) (LlamaCore.sol#1643-1705) uses assembly
	- INLINE ASM (LlamaCore.sol#1644-1704)



    
1644         assembly {
1645             let y := x // We start y at x, which will help us make our initial estimate.
1646 
1647             z := 181 // The "correct" value is 1, but this saves a multiplication later.
1648 
1649             // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad
1650             // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.
1651 
1652             // We check y >= 2^(k + 8) but shift right by k bits
1653             // each branch to ensure that if x >= 256, then y >= 256.
1654             if iszero(lt(y, 0x10000000000000000000000000000000000)) {
1655                 y := shr(128, y)
1656                 z := shl(64, z)
1657             }
1658             if iszero(lt(y, 0x1000000000000000000)) {
1659                 y := shr(64, y)
1660                 z := shl(32, z)
1661             }
1662             if iszero(lt(y, 0x10000000000)) {
1663                 y := shr(32, y)
1664                 z := shl(16, z)
1665             }
1666             if iszero(lt(y, 0x1000000)) {
1667                 y := shr(16, y)
1668                 z := shl(8, z)
1669             }
1670 
1671             // Goal was to get z*z*y within a small factor of x. More iterations could
1672             // get y in a tighter range. Currently, we will have y in [256, 256*2^16).
1673             // We ensured y >= 256 so that the relative difference between y and y+1 is small.
1674             // That's not possible if x < 256 but we can just verify those cases exhaustively.
1675 
1676             // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.
1677             // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.
1678             // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.
1679 
1680             // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range
1681             // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.
1682 
1683             // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate
1684             // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.
1685 
1686             // There is no overflow risk here since y < 2^136 after the first branch above.
1687             z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.
1688 
1689             // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.
1690             z := shr(1, add(z, div(x, z)))
1691             z := shr(1, add(z, div(x, z)))
1692             z := shr(1, add(z, div(x, z)))
1693             z := shr(1, add(z, div(x, z)))
1694             z := shr(1, add(z, div(x, z)))
1695             z := shr(1, add(z, div(x, z)))
1696             z := shr(1, add(z, div(x, z)))
1697 
1698             // If x+1 is a perfect square, the Babylonian method cycles between
1699             // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.
1700             // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division
1701             // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.
1702             // If you don't care whether the floor or ceil square root is returned, you can remove this statement.
1703             z := sub(z, lt(div(x, z), z))
1704         }



```

```
LibString.toHexStringNoPrefix(uint256) (LlamaCore.sol#500-534) uses assembly
	- INLINE ASM (LlamaCore.sol#502-533)



    
502         assembly {
503             // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,
504             // 0x02 bytes for the prefix, and 0x40 bytes for the digits.
505             // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.
506             str := add(mload(0x40), 0x80)
507             // Allocate the memory.
508             mstore(0x40, add(str, 0x20))
509             // Zeroize the slot after the string.
510             mstore(str, 0)
511 
512             // Cache the end to calculate the length later.
513             let end := str
514             // Store "0123456789abcdef" in scratch space.
515             mstore(0x0f, 0x30313233343536373839616263646566)
516 
517             let w := not(1) // Tsk.
518             // We write the string from rightmost digit to leftmost digit.
519             // The following is essentially a do-while loop that also handles the zero case.
520             for { let temp := value } 1 {} {
521                 str := add(str, w) // `sub(str, 2)`.
522                 mstore8(add(str, 1), mload(and(temp, 15)))
523                 mstore8(str, mload(and(shr(4, temp), 15)))
524                 temp := shr(8, temp)
525                 if iszero(temp) { break }
526             }
527 
528             // Compute the string's length.
529             let strLength := sub(end, str)
530             // Move the pointer and write the length.
531             str := sub(str, 0x20)
532             mstore(str, strLength)
533         }



```

```
LibString.indexOf(string,string,uint256) (LlamaCore.sol#780-833) uses assembly
	- INLINE ASM (LlamaCore.sol#786-832)



    
786         assembly {
787             for { let subjectLength := mload(subject) } 1 {} {
788                 if iszero(mload(search)) {
789                     if iszero(gt(from, subjectLength)) {
790                         result := from
791                         break
792                     }
793                     result := subjectLength
794                     break
795                 }
796                 let searchLength := mload(search)
797                 let subjectStart := add(subject, 0x20)
798 
799                 result := not(0) // Initialize to `NOT_FOUND`.
800 
801                 subject := add(subjectStart, from)
802                 let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)
803 
804                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
805                 let s := mload(add(search, 0x20))
806 
807                 if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }
808 
809                 if iszero(lt(searchLength, 0x20)) {
810                     for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
811                         if iszero(shr(m, xor(mload(subject), s))) {
812                             if eq(keccak256(subject, searchLength), h) {
813                                 result := sub(subject, subjectStart)
814                                 break
815                             }
816                         }
817                         subject := add(subject, 1)
818                         if iszero(lt(subject, end)) { break }
819                     }
820                     break
821                 }
822                 for {} 1 {} {
823                     if iszero(shr(m, xor(mload(subject), s))) {
824                         result := sub(subject, subjectStart)
825                         break
826                     }
827                     subject := add(subject, 1)
828                     if iszero(lt(subject, end)) { break }
829                 }
830                 break
831             }
832         }



```

```
LibString.packTwo(string,string) (LlamaCore.sol#1336-1354) uses assembly
	- INLINE ASM (LlamaCore.sol#1338-1353)



    
1338         assembly {
1339             let aLength := mload(a)
1340             // We don't need to zero right pad the strings,
1341             // since this is our own custom non-standard packing scheme.
1342             result :=
1343                 mul(
1344                     // Load the length and the bytes of `a` and `b`.
1345                     or(
1346                         shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),
1347                         mload(sub(add(b, 0x1e), aLength))
1348                     ),
1349                     // `totalLength != 0 && totalLength < 31`. Abuses underflow.
1350                     // Assumes that the lengths are valid and within the block gas limit.
1351                     lt(sub(add(aLength, mload(b)), 1), 0x1e)
1352                 )
1353         }



```

```
LibString.toMinimalHexString(uint256) (LlamaCore.sol#470-480) uses assembly
	- INLINE ASM (LlamaCore.sol#473-479)



    
473         assembly {
474             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
475             let strLength := add(mload(str), 2) // Compute the length.
476             mstore(add(str, o), 0x3078) // Write the "0x" prefix, accounting for leading zero.
477             str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.
478             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
479         }



```

```
LibString.split(string,string) (LlamaCore.sol#1080-1125) uses assembly
	- INLINE ASM (LlamaCore.sol#1087-1124)



    
1087         assembly {
1088             let w := not(0x1f)
1089             let indexPtr := add(indices, 0x20)
1090             let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))
1091             mstore(add(indicesEnd, w), mload(subject))
1092             mstore(indices, add(mload(indices), 1))
1093             let prevIndex := 0
1094             for {} 1 {} {
1095                 let index := mload(indexPtr)
1096                 mstore(indexPtr, 0x60)
1097                 if iszero(eq(index, prevIndex)) {
1098                     let element := mload(0x40)
1099                     let elementLength := sub(index, prevIndex)
1100                     mstore(element, elementLength)
1101                     // Copy the `subject` one word at a time, backwards.
1102                     for { let o := and(add(elementLength, 0x1f), w) } 1 {} {
1103                         mstore(add(element, o), mload(add(add(subject, prevIndex), o)))
1104                         o := add(o, w) // `sub(o, 0x20)`.
1105                         if iszero(o) { break }
1106                     }
1107                     // Zeroize the slot after the string.
1108                     mstore(add(add(element, 0x20), elementLength), 0)
1109                     // Allocate memory for the length and the bytes,
1110                     // rounded up to a multiple of 32.
1111                     mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))
1112                     // Store the `element` into the array.
1113                     mstore(indexPtr, element)
1114                 }
1115                 prevIndex := add(index, mload(delimiter))
1116                 indexPtr := add(indexPtr, 0x20)
1117                 if iszero(lt(indexPtr, indicesEnd)) { break }
1118             }
1119             result := indices
1120             if iszero(mload(delimiter)) {
1121                 result := add(indices, 0x20)
1122                 mstore(result, sub(mload(indices), 2))
1123             }
1124         }



```

```
Clones.cloneDeterministic(address,bytes32) (LlamaCore.sol#50-63) uses assembly
	- INLINE ASM (LlamaCore.sol#52-59)



    
52         assembly {
53             // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
54             // of the `implementation` address with the bytecode before the address.
55             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
56             // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
57             mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
58             instance := create2(0, 0x09, 0x37, salt)
59         }



```

```
LibString.toHexString(bytes) (LlamaCore.sol#611-620) uses assembly
	- INLINE ASM (LlamaCore.sol#614-619)



    
614         assembly {
615             let strLength := add(mload(str), 2) // Compute the length.
616             mstore(str, 0x3078) // Write the "0x" prefix.
617             str := sub(str, 2) // Move the pointer.
618             mstore(str, strLength) // Write the length.
619         }



```

```
LibString.startsWith(string,string) (LlamaCore.sol#895-913) uses assembly
	- INLINE ASM (LlamaCore.sol#901-912)



    
901         assembly {
902             let searchLength := mload(search)
903             // Just using keccak256 directly is actually cheaper.
904             // forgefmt: disable-next-item
905             result := and(
906                 iszero(gt(searchLength, mload(subject))),
907                 eq(
908                     keccak256(add(subject, 0x20), searchLength),
909                     keccak256(add(search, 0x20), searchLength)
910                 )
911             )
912         }



```

```
LibString.toString(int256) (LlamaCore.sol#358-374) uses assembly
	- INLINE ASM (LlamaCore.sol#366-373)



    
366         assembly {
367             // We still have some spare memory space on the left,
368             // as we have allocated 3 words (96 bytes) for up to 78 digits.
369             let length := mload(str) // Load the string length.
370             mstore(str, 0x2d) // Store the '-' character.
371             str := sub(str, 1) // Move back the string pointer by a byte.
372             mstore(str, add(length, 1)) // Update the string length.
373         }



```

```
Checkpoints._unsafeAccess(Checkpoints.Checkpoint[],uint256) (LlamaCore.sol#1620-1629) uses assembly
	- INLINE ASM (LlamaCore.sol#1625-1628)



    
1625         assembly {
1626             mstore(0, self.slot)
1627             result.slot := add(keccak256(0, 0x20), pos)
1628         }



```

```
LibString.toMinimalHexStringNoPrefix(uint256) (LlamaCore.sol#485-494) uses assembly
	- INLINE ASM (LlamaCore.sol#488-493)



    
488         assembly {
489             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
490             let strLength := mload(str) // Get the length.
491             str := add(str, o) // Move the pointer, accounting for leading zero.
492             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
493         }



```

```
LibString.directReturn(string) (LlamaCore.sol#1384-1397) uses assembly
	- INLINE ASM (LlamaCore.sol#1385-1396)



    
1385         assembly {
1386             // Assumes that the string does not start from the scratch space.
1387             let retStart := sub(a, 0x20)
1388             let retSize := add(mload(a), 0x40)
1389             // Right pad with zeroes. Just in case the string is produced
1390             // by a method that doesn't zero right pad.
1391             mstore(add(retStart, retSize), 0)
1392             // Store the return offset.
1393             mstore(retStart, 0x20)
1394             // End the transaction, returning the string.
1395             return(retStart, retSize)
1396         }



```

```
LibString.toString(uint256) (LlamaCore.sol#320-355) uses assembly
	- INLINE ASM (LlamaCore.sol#322-354)



    
322         assembly {
323             // The maximum value of a uint256 contains 78 digits (1 byte per digit), but
324             // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.
325             // We will need 1 word for the trailing zeros padding, 1 word for the length,
326             // and 3 words for a maximum of 78 digits.
327             str := add(mload(0x40), 0x80)
328             // Update the free memory pointer to allocate.
329             mstore(0x40, add(str, 0x20))
330             // Zeroize the slot after the string.
331             mstore(str, 0)
332 
333             // Cache the end of the memory to calculate the length later.
334             let end := str
335 
336             let w := not(0) // Tsk.
337             // We write the string from rightmost digit to leftmost digit.
338             // The following is essentially a do-while loop that also handles the zero case.
339             for { let temp := value } 1 {} {
340                 str := add(str, w) // `sub(str, 1)`.
341                 // Write the character to the pointer.
342                 // The ASCII index of the '0' character is 48.
343                 mstore8(str, add(48, mod(temp, 10)))
344                 // Keep dividing `temp` until zero.
345                 temp := div(temp, 10)
346                 if iszero(temp) { break }
347             }
348 
349             let length := sub(end, str)
350             // Move the pointer 32 bytes leftwards to make room for the length.
351             str := sub(str, 0x20)
352             // Store the length.
353             mstore(str, length)
354         }



```

```
LibString.concat(string,string) (LlamaCore.sol#1129-1163) uses assembly
	- INLINE ASM (LlamaCore.sol#1135-1162)



    
1135         assembly {
1136             let w := not(0x1f)
1137             result := mload(0x40)
1138             let aLength := mload(a)
1139             // Copy `a` one word at a time, backwards.
1140             for { let o := and(add(aLength, 0x20), w) } 1 {} {
1141                 mstore(add(result, o), mload(add(a, o)))
1142                 o := add(o, w) // `sub(o, 0x20)`.
1143                 if iszero(o) { break }
1144             }
1145             let bLength := mload(b)
1146             let output := add(result, aLength)
1147             // Copy `b` one word at a time, backwards.
1148             for { let o := and(add(bLength, 0x20), w) } 1 {} {
1149                 mstore(add(output, o), mload(add(b, o)))
1150                 o := add(o, w) // `sub(o, 0x20)`.
1151                 if iszero(o) { break }
1152             }
1153             let totalLength := add(aLength, bLength)
1154             let last := add(add(result, 0x20), totalLength)
1155             // Zeroize the slot after the string.
1156             mstore(last, 0)
1157             // Stores the length.
1158             mstore(result, totalLength)
1159             // Allocate memory for the length and the bytes,
1160             // rounded up to a multiple of 32.
1161             mstore(0x40, and(add(last, 0x1f), w))
1162         }



```

```
LibString.unpackOne(bytes32) (LlamaCore.sol#1318-1332) uses assembly
	- INLINE ASM (LlamaCore.sol#1320-1331)



    
1320         assembly {
1321             // Grab the free memory pointer.
1322             result := mload(0x40)
1323             // Allocate 2 words (1 for the length, 1 for the bytes).
1324             mstore(0x40, add(result, 0x40))
1325             // Zeroize the length slot.
1326             mstore(result, 0)
1327             // Store the length and bytes.
1328             mstore(add(result, 0x1f), packed)
1329             // Right pad with zeroes.
1330             mstore(add(add(result, 0x20), mload(result)), 0)
1331         }



```

```
LibString.repeat(string,uint256) (LlamaCore.sol#944-974) uses assembly
	- INLINE ASM (LlamaCore.sol#950-973)



    
950         assembly {
951             let subjectLength := mload(subject)
952             if iszero(or(iszero(times), iszero(subjectLength))) {
953                 subject := add(subject, 0x20)
954                 result := mload(0x40)
955                 let output := add(result, 0x20)
956                 for {} 1 {} {
957                     // Copy the `subject` one word at a time.
958                     for { let o := 0 } 1 {} {
959                         mstore(add(output, o), mload(add(subject, o)))
960                         o := add(o, 0x20)
961                         if iszero(lt(o, subjectLength)) { break }
962                     }
963                     output := add(output, subjectLength)
964                     times := sub(times, 1)
965                     if iszero(times) { break }
966                 }
967                 mstore(output, 0) // Zeroize the slot after the string.
968                 let resultLength := sub(output, add(result, 0x20))
969                 mstore(result, resultLength) // Store the length.
970                 // Allocate the memory.
971                 mstore(0x40, add(result, add(resultLength, 0x20)))
972             }
973         }



```

```
LibString.is7BitASCII(string) (LlamaCore.sol#671-693) uses assembly
	- INLINE ASM (LlamaCore.sol#673-692)



    
673         assembly {
674             let mask := shl(7, div(not(0), 255))
675             result := 1
676             let n := mload(s)
677             if n {
678                 let o := add(s, 0x20)
679                 let end := add(o, n)
680                 let last := mload(end)
681                 mstore(end, 0)
682                 for {} 1 {} {
683                     if and(mask, mload(o)) {
684                         result := 0
685                         break
686                     }
687                     o := add(o, 0x20)
688                     if iszero(lt(o, end)) { break }
689                 }
690                 mstore(end, last)
691             }
692         }



```

```
Base64.encode(bytes) (LlamaCore.sol#1948-2019) uses assembly
	- INLINE ASM (LlamaCore.sol#1967-2016)



    
1967         assembly {
1968             // Prepare the lookup table (skip the first "length" byte)
1969             let tablePtr := add(table, 1)
1970 
1971             // Prepare result pointer, jump over length
1972             let resultPtr := add(result, 32)
1973 
1974             // Run over the input, 3 bytes at a time
1975             for {
1976                 let dataPtr := data
1977                 let endPtr := add(data, mload(data))
1978             } lt(dataPtr, endPtr) {
1979 
1980             } {
1981                 // Advance 3 bytes
1982                 dataPtr := add(dataPtr, 3)
1983                 let input := mload(dataPtr)
1984 
1985                 // To write each character, shift the 3 bytes (18 bits) chunk
1986                 // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)
1987                 // and apply logical AND with 0x3F which is the number of
1988                 // the previous character in the ASCII table prior to the Base64 Table
1989                 // The result is then added to the table to get the character to write,
1990                 // and finally write it in the result pointer but with a left shift
1991                 // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits
1992 
1993                 mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))
1994                 resultPtr := add(resultPtr, 1) // Advance
1995 
1996                 mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))
1997                 resultPtr := add(resultPtr, 1) // Advance
1998 
1999                 mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))
2000                 resultPtr := add(resultPtr, 1) // Advance
2001 
2002                 mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))
2003                 resultPtr := add(resultPtr, 1) // Advance
2004             }
2005 
2006             // When data `bytes` is not exactly 3 bytes long
2007             // it is padded with `=` characters at the end
2008             switch mod(mload(data), 3)
2009             case 1 {
2010                 mstore8(sub(resultPtr, 1), 0x3d)
2011                 mstore8(sub(resultPtr, 2), 0x3d)
2012             }
2013             case 2 {
2014                 mstore8(sub(resultPtr, 1), 0x3d)
2015             }
2016         }



```

```
LibString.runeCount(string) (LlamaCore.sol#653-667) uses assembly
	- INLINE ASM (LlamaCore.sol#655-666)



    
655         assembly {
656             if mload(s) {
657                 mstore(0x00, div(not(0), 255))
658                 mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)
659                 let o := add(s, 0x20)
660                 let end := add(o, mload(s))
661                 for { result := 1 } 1 { result := add(result, 1) } {
662                     o := add(o, byte(0, mload(shr(250, mload(o)))))
663                     if iszero(lt(o, end)) { break }
664                 }
665             }
666         }



```

```
LibString.endsWith(string,string) (LlamaCore.sol#916-941) uses assembly
	- INLINE ASM (LlamaCore.sol#922-940)



    
922         assembly {
923             let searchLength := mload(search)
924             let subjectLength := mload(subject)
925             // Whether `search` is not longer than `subject`.
926             let withinRange := iszero(gt(searchLength, subjectLength))
927             // Just using keccak256 directly is actually cheaper.
928             // forgefmt: disable-next-item
929             result := and(
930                 withinRange,
931                 eq(
932                     keccak256(
933                         // `subject + 0x20 + max(subjectLength - searchLength, 0)`.
934                         add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),
935                         searchLength
936                     ),
937                     keccak256(add(search, 0x20), searchLength)
938                 )
939             )
940         }



```

```
LibString.toHexString(address) (LlamaCore.sol#561-570) uses assembly
	- INLINE ASM (LlamaCore.sol#564-569)



    
564         assembly {
565             let strLength := add(mload(str), 2) // Compute the length.
566             mstore(str, 0x3078) // Write the "0x" prefix.
567             str := sub(str, 2) // Move the pointer.
568             mstore(str, strLength) // Write the length.
569         }



```

```
LibString.packOne(string) (LlamaCore.sol#1299-1313) uses assembly
	- INLINE ASM (LlamaCore.sol#1301-1312)



    
1301         assembly {
1302             // We don't need to zero right pad the string,
1303             // since this is our own custom non-standard packing scheme.
1304             result :=
1305                 mul(
1306                     // Load the length and the bytes.
1307                     mload(add(a, 0x1f)),
1308                     // `length != 0 && length < 32`. Abuses underflow.
1309                     // Assumes that the length is valid and within the block gas limit.
1310                     lt(sub(mload(a), 1), 0x1f)
1311                 )
1312         }



```

```
Clones.clone(address) (LlamaCore.sol#28-41) uses assembly
	- INLINE ASM (LlamaCore.sol#30-37)



    
30         assembly {
31             // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
32             // of the `implementation` address with the bytecode before the address.
33             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
34             // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
35             mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
36             instance := create(0, 0x09, 0x37)
37         }



```

### LlamaFactory.sol


```
LibString.endsWith(string,string) (LlamaFactory.sol#1063-1088) uses assembly
	- INLINE ASM (LlamaFactory.sol#1069-1087)



    
1069         assembly {
1070             let searchLength := mload(search)
1071             let subjectLength := mload(subject)
1072             // Whether `search` is not longer than `subject`.
1073             let withinRange := iszero(gt(searchLength, subjectLength))
1074             // Just using keccak256 directly is actually cheaper.
1075             // forgefmt: disable-next-item
1076             result := and(
1077                 withinRange,
1078                 eq(
1079                     keccak256(
1080                         // `subject + 0x20 + max(subjectLength - searchLength, 0)`.
1081                         add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),
1082                         searchLength
1083                     ),
1084                     keccak256(add(search, 0x20), searchLength)
1085                 )
1086             )
1087         }



```

```
LibString.toString(uint256) (LlamaFactory.sol#467-502) uses assembly
	- INLINE ASM (LlamaFactory.sol#469-501)



    
469         assembly {
470             // The maximum value of a uint256 contains 78 digits (1 byte per digit), but
471             // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.
472             // We will need 1 word for the trailing zeros padding, 1 word for the length,
473             // and 3 words for a maximum of 78 digits.
474             str := add(mload(0x40), 0x80)
475             // Update the free memory pointer to allocate.
476             mstore(0x40, add(str, 0x20))
477             // Zeroize the slot after the string.
478             mstore(str, 0)
479 
480             // Cache the end of the memory to calculate the length later.
481             let end := str
482 
483             let w := not(0) // Tsk.
484             // We write the string from rightmost digit to leftmost digit.
485             // The following is essentially a do-while loop that also handles the zero case.
486             for { let temp := value } 1 {} {
487                 str := add(str, w) // `sub(str, 1)`.
488                 // Write the character to the pointer.
489                 // The ASCII index of the '0' character is 48.
490                 mstore8(str, add(48, mod(temp, 10)))
491                 // Keep dividing `temp` until zero.
492                 temp := div(temp, 10)
493                 if iszero(temp) { break }
494             }
495 
496             let length := sub(end, str)
497             // Move the pointer 32 bytes leftwards to make room for the length.
498             str := sub(str, 0x20)
499             // Store the length.
500             mstore(str, length)
501         }



```

```
LibString.repeat(string,uint256) (LlamaFactory.sol#1091-1121) uses assembly
	- INLINE ASM (LlamaFactory.sol#1097-1120)



    
1097         assembly {
1098             let subjectLength := mload(subject)
1099             if iszero(or(iszero(times), iszero(subjectLength))) {
1100                 subject := add(subject, 0x20)
1101                 result := mload(0x40)
1102                 let output := add(result, 0x20)
1103                 for {} 1 {} {
1104                     // Copy the `subject` one word at a time.
1105                     for { let o := 0 } 1 {} {
1106                         mstore(add(output, o), mload(add(subject, o)))
1107                         o := add(o, 0x20)
1108                         if iszero(lt(o, subjectLength)) { break }
1109                     }
1110                     output := add(output, subjectLength)
1111                     times := sub(times, 1)
1112                     if iszero(times) { break }
1113                 }
1114                 mstore(output, 0) // Zeroize the slot after the string.
1115                 let resultLength := sub(output, add(result, 0x20))
1116                 mstore(result, resultLength) // Store the length.
1117                 // Allocate the memory.
1118                 mstore(0x40, add(result, add(resultLength, 0x20)))
1119             }
1120         }



```

```
LibString.lastIndexOf(string,string,uint256) (LlamaFactory.sol#996-1028) uses assembly
	- INLINE ASM (LlamaFactory.sol#1002-1027)



    
1002         assembly {
1003             for {} 1 {} {
1004                 result := not(0) // Initialize to `NOT_FOUND`.
1005                 let searchLength := mload(search)
1006                 if gt(searchLength, mload(subject)) { break }
1007                 let w := result
1008 
1009                 let fromMax := sub(mload(subject), searchLength)
1010                 if iszero(gt(fromMax, from)) { from := fromMax }
1011 
1012                 let end := add(add(subject, 0x20), w)
1013                 subject := add(add(subject, 0x20), from)
1014                 if iszero(gt(subject, end)) { break }
1015                 // As this function is not too often used,
1016                 // we shall simply use keccak256 for smaller bytecode size.
1017                 for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
1018                     if eq(keccak256(subject, searchLength), h) {
1019                         result := sub(subject, add(end, 1))
1020                         break
1021                     }
1022                     subject := add(subject, w) // `sub(subject, 1)`.
1023                     if iszero(gt(subject, end)) { break }
1024                 }
1025                 break
1026             }
1027         }



```

```
LibString.packOne(string) (LlamaFactory.sol#1446-1460) uses assembly
	- INLINE ASM (LlamaFactory.sol#1448-1459)



    
1448         assembly {
1449             // We don't need to zero right pad the string,
1450             // since this is our own custom non-standard packing scheme.
1451             result :=
1452                 mul(
1453                     // Load the length and the bytes.
1454                     mload(add(a, 0x1f)),
1455                     // `length != 0 && length < 32`. Abuses underflow.
1456                     // Assumes that the length is valid and within the block gas limit.
1457                     lt(sub(mload(a), 1), 0x1f)
1458                 )
1459         }



```

```
LibString.slice(string,uint256,uint256) (LlamaFactory.sol#1125-1154) uses assembly
	- INLINE ASM (LlamaFactory.sol#1131-1153)



    
1131         assembly {
1132             let subjectLength := mload(subject)
1133             if iszero(gt(subjectLength, end)) { end := subjectLength }
1134             if iszero(gt(subjectLength, start)) { start := subjectLength }
1135             if lt(start, end) {
1136                 result := mload(0x40)
1137                 let resultLength := sub(end, start)
1138                 mstore(result, resultLength)
1139                 subject := add(subject, start)
1140                 let w := not(0x1f)
1141                 // Copy the `subject` one word at a time, backwards.
1142                 for { let o := and(add(resultLength, 0x1f), w) } 1 {} {
1143                     mstore(add(result, o), mload(add(subject, o)))
1144                     o := add(o, w) // `sub(o, 0x20)`.
1145                     if iszero(o) { break }
1146                 }
1147                 // Zeroize the slot after the string.
1148                 mstore(add(add(result, 0x20), resultLength), 0)
1149                 // Allocate memory for the length and the bytes,
1150                 // rounded up to a multiple of 32.
1151                 mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))
1152             }
1153         }



```

```
Checkpoints._unsafeAccess(Checkpoints.Checkpoint[],uint256) (LlamaFactory.sol#1742-1751) uses assembly
	- INLINE ASM (LlamaFactory.sol#1747-1750)



    
1747         assembly {
1748             mstore(0, self.slot)
1749             result.slot := add(keccak256(0, 0x20), pos)
1750         }



```

```
LibString.escapeJSON(string) (LlamaFactory.sol#1389-1435) uses assembly
	- INLINE ASM (LlamaFactory.sol#1391-1434)



    
1391         assembly {
1392             for {
1393                 let end := add(s, mload(s))
1394                 result := add(mload(0x40), 0x20)
1395                 // Store "\\u0000" in scratch space.
1396                 // Store "0123456789abcdef" in scratch space.
1397                 // Also, store `{0x08:"b", 0x09:"t", 0x0a:"n", 0x0c:"f", 0x0d:"r"}`.
1398                 // into the scratch space.
1399                 mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)
1400                 // Bitmask for detecting `["\"","\\"]`.
1401                 let e := or(shl(0x22, 1), shl(0x5c, 1))
1402             } iszero(eq(s, end)) {} {
1403                 s := add(s, 1)
1404                 let c := and(mload(s), 0xff)
1405                 if iszero(lt(c, 0x20)) {
1406                     if iszero(and(shl(c, 1), e)) {
1407                         // Not in `["\"","\\"]`.
1408                         mstore8(result, c)
1409                         result := add(result, 1)
1410                         continue
1411                     }
1412                     mstore8(result, 0x5c) // "\\".
1413                     mstore8(add(result, 1), c)
1414                     result := add(result, 2)
1415                     continue
1416                 }
1417                 if iszero(and(shl(c, 1), 0x3700)) {
1418                     // Not in `["\b","\t","\n","\f","\d"]`.
1419                     mstore8(0x1d, mload(shr(4, c))) // Hex value.
1420                     mstore8(0x1e, mload(and(c, 15))) // Hex value.
1421                     mstore(result, mload(0x19)) // "\\u00XX".
1422                     result := add(result, 6)
1423                     continue
1424                 }
1425                 mstore8(result, 0x5c) // "\\".
1426                 mstore8(add(result, 1), mload(add(c, 8)))
1427                 result := add(result, 2)
1428             }
1429             let last := result
1430             mstore(last, 0) // Zeroize the slot after the string.
1431             result := mload(0x40)
1432             mstore(result, sub(last, add(result, 0x20))) // Store the length.
1433             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1434         }



```

```
Clones.predictDeterministicAddress(address,bytes32,address) (LlamaFactory.sol#68-84) uses assembly
	- INLINE ASM (LlamaFactory.sol#74-83)



    
74         assembly {
75             let ptr := mload(0x40)
76             mstore(add(ptr, 0x38), deployer)
77             mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)
78             mstore(add(ptr, 0x14), implementation)
79             mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)
80             mstore(add(ptr, 0x58), salt)
81             mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))
82             predicted := keccak256(add(ptr, 0x43), 0x55)
83         }



```

```
LibString.indexOf(string,string,uint256) (LlamaFactory.sol#927-980) uses assembly
	- INLINE ASM (LlamaFactory.sol#933-979)



    
933         assembly {
934             for { let subjectLength := mload(subject) } 1 {} {
935                 if iszero(mload(search)) {
936                     if iszero(gt(from, subjectLength)) {
937                         result := from
938                         break
939                     }
940                     result := subjectLength
941                     break
942                 }
943                 let searchLength := mload(search)
944                 let subjectStart := add(subject, 0x20)
945 
946                 result := not(0) // Initialize to `NOT_FOUND`.
947 
948                 subject := add(subjectStart, from)
949                 let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)
950 
951                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
952                 let s := mload(add(search, 0x20))
953 
954                 if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }
955 
956                 if iszero(lt(searchLength, 0x20)) {
957                     for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
958                         if iszero(shr(m, xor(mload(subject), s))) {
959                             if eq(keccak256(subject, searchLength), h) {
960                                 result := sub(subject, subjectStart)
961                                 break
962                             }
963                         }
964                         subject := add(subject, 1)
965                         if iszero(lt(subject, end)) { break }
966                     }
967                     break
968                 }
969                 for {} 1 {} {
970                     if iszero(shr(m, xor(mload(subject), s))) {
971                         result := sub(subject, subjectStart)
972                         break
973                     }
974                     subject := add(subject, 1)
975                     if iszero(lt(subject, end)) { break }
976                 }
977                 break
978             }
979         }



```

```
LibString.toHexString(uint256,uint256) (LlamaFactory.sol#532-541) uses assembly
	- INLINE ASM (LlamaFactory.sol#535-540)



    
535         assembly {
536             let strLength := add(mload(str), 2) // Compute the length.
537             mstore(str, 0x3078) // Write the "0x" prefix.
538             str := sub(str, 2) // Move the pointer.
539             mstore(str, strLength) // Write the length.
540         }



```

```
LibString.unpackOne(bytes32) (LlamaFactory.sol#1465-1479) uses assembly
	- INLINE ASM (LlamaFactory.sol#1467-1478)



    
1467         assembly {
1468             // Grab the free memory pointer.
1469             result := mload(0x40)
1470             // Allocate 2 words (1 for the length, 1 for the bytes).
1471             mstore(0x40, add(result, 0x40))
1472             // Zeroize the length slot.
1473             mstore(result, 0)
1474             // Store the length and bytes.
1475             mstore(add(result, 0x1f), packed)
1476             // Right pad with zeroes.
1477             mstore(add(add(result, 0x20), mload(result)), 0)
1478         }



```

```
LibString.indicesOf(string,string) (LlamaFactory.sol#1168-1224) uses assembly
	- INLINE ASM (LlamaFactory.sol#1174-1223)



    
1174         assembly {
1175             let subjectLength := mload(subject)
1176             let searchLength := mload(search)
1177 
1178             if iszero(gt(searchLength, subjectLength)) {
1179                 subject := add(subject, 0x20)
1180                 search := add(search, 0x20)
1181                 result := add(mload(0x40), 0x20)
1182 
1183                 let subjectStart := subject
1184                 let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)
1185                 let h := 0
1186                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
1187                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
1188                 let s := mload(search)
1189                 for {} 1 {} {
1190                     let t := mload(subject)
1191                     // Whether the first `searchLength % 32` bytes of
1192                     // `subject` and `search` matches.
1193                     if iszero(shr(m, xor(t, s))) {
1194                         if h {
1195                             if iszero(eq(keccak256(subject, searchLength), h)) {
1196                                 subject := add(subject, 1)
1197                                 if iszero(lt(subject, subjectSearchEnd)) { break }
1198                                 continue
1199                             }
1200                         }
1201                         // Append to `result`.
1202                         mstore(result, sub(subject, subjectStart))
1203                         result := add(result, 0x20)
1204                         // Advance `subject` by `searchLength`.
1205                         subject := add(subject, searchLength)
1206                         if searchLength {
1207                             if iszero(lt(subject, subjectSearchEnd)) { break }
1208                             continue
1209                         }
1210                     }
1211                     subject := add(subject, 1)
1212                     if iszero(lt(subject, subjectSearchEnd)) { break }
1213                 }
1214                 let resultEnd := result
1215                 // Assign `result` to the free memory pointer.
1216                 result := mload(0x40)
1217                 // Store the length of `result`.
1218                 mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))
1219                 // Allocate memory for result.
1220                 // We allocate one more word, so this array can be recycled for {split}.
1221                 mstore(0x40, add(resultEnd, 0x20))
1222             }
1223         }



```

```
LibString.concat(string,string) (LlamaFactory.sol#1276-1310) uses assembly
	- INLINE ASM (LlamaFactory.sol#1282-1309)



    
1282         assembly {
1283             let w := not(0x1f)
1284             result := mload(0x40)
1285             let aLength := mload(a)
1286             // Copy `a` one word at a time, backwards.
1287             for { let o := and(add(aLength, 0x20), w) } 1 {} {
1288                 mstore(add(result, o), mload(add(a, o)))
1289                 o := add(o, w) // `sub(o, 0x20)`.
1290                 if iszero(o) { break }
1291             }
1292             let bLength := mload(b)
1293             let output := add(result, aLength)
1294             // Copy `b` one word at a time, backwards.
1295             for { let o := and(add(bLength, 0x20), w) } 1 {} {
1296                 mstore(add(output, o), mload(add(b, o)))
1297                 o := add(o, w) // `sub(o, 0x20)`.
1298                 if iszero(o) { break }
1299             }
1300             let totalLength := add(aLength, bLength)
1301             let last := add(add(result, 0x20), totalLength)
1302             // Zeroize the slot after the string.
1303             mstore(last, 0)
1304             // Stores the length.
1305             mstore(result, totalLength)
1306             // Allocate memory for the length and the bytes,
1307             // rounded up to a multiple of 32.
1308             mstore(0x40, and(add(last, 0x1f), w))
1309         }



```

```
LibString.toString(int256) (LlamaFactory.sol#505-521) uses assembly
	- INLINE ASM (LlamaFactory.sol#513-520)



    
513         assembly {
514             // We still have some spare memory space on the left,
515             // as we have allocated 3 words (96 bytes) for up to 78 digits.
516             let length := mload(str) // Load the string length.
517             mstore(str, 0x2d) // Store the '-' character.
518             str := sub(str, 1) // Move back the string pointer by a byte.
519             mstore(str, add(length, 1)) // Update the string length.
520         }



```

```
LibString.toHexString(address) (LlamaFactory.sol#708-717) uses assembly
	- INLINE ASM (LlamaFactory.sol#711-716)



    
711         assembly {
712             let strLength := add(mload(str), 2) // Compute the length.
713             mstore(str, 0x3078) // Write the "0x" prefix.
714             str := sub(str, 2) // Move the pointer.
715             mstore(str, strLength) // Write the length.
716         }



```

```
LibString.unpackTwo(bytes32) (LlamaFactory.sol#1506-1528) uses assembly
	- INLINE ASM (LlamaFactory.sol#1512-1527)



    
1512         assembly {
1513             // Grab the free memory pointer.
1514             resultA := mload(0x40)
1515             resultB := add(resultA, 0x40)
1516             // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.
1517             mstore(0x40, add(resultB, 0x40))
1518             // Zeroize the length slots.
1519             mstore(resultA, 0)
1520             mstore(resultB, 0)
1521             // Store the lengths and bytes.
1522             mstore(add(resultA, 0x1f), packed)
1523             mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))
1524             // Right pad with zeroes.
1525             mstore(add(add(resultA, 0x20), mload(resultA)), 0)
1526             mstore(add(add(resultB, 0x20), mload(resultB)), 0)
1527         }



```

```
LibString.toHexStringNoPrefix(uint256) (LlamaFactory.sol#647-681) uses assembly
	- INLINE ASM (LlamaFactory.sol#649-680)



    
649         assembly {
650             // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,
651             // 0x02 bytes for the prefix, and 0x40 bytes for the digits.
652             // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.
653             str := add(mload(0x40), 0x80)
654             // Allocate the memory.
655             mstore(0x40, add(str, 0x20))
656             // Zeroize the slot after the string.
657             mstore(str, 0)
658 
659             // Cache the end to calculate the length later.
660             let end := str
661             // Store "0123456789abcdef" in scratch space.
662             mstore(0x0f, 0x30313233343536373839616263646566)
663 
664             let w := not(1) // Tsk.
665             // We write the string from rightmost digit to leftmost digit.
666             // The following is essentially a do-while loop that also handles the zero case.
667             for { let temp := value } 1 {} {
668                 str := add(str, w) // `sub(str, 2)`.
669                 mstore8(add(str, 1), mload(and(temp, 15)))
670                 mstore8(str, mload(and(shr(4, temp), 15)))
671                 temp := shr(8, temp)
672                 if iszero(temp) { break }
673             }
674 
675             // Compute the string's length.
676             let strLength := sub(end, str)
677             // Move the pointer and write the length.
678             str := sub(str, 0x20)
679             mstore(str, strLength)
680         }



```

```
Base64.encode(bytes) (LlamaFactory.sol#3448-3519) uses assembly
	- INLINE ASM (LlamaFactory.sol#3467-3516)



    
3467         assembly {
3468             // Prepare the lookup table (skip the first "length" byte)
3469             let tablePtr := add(table, 1)
3470 
3471             // Prepare result pointer, jump over length
3472             let resultPtr := add(result, 32)
3473 
3474             // Run over the input, 3 bytes at a time
3475             for {
3476                 let dataPtr := data
3477                 let endPtr := add(data, mload(data))
3478             } lt(dataPtr, endPtr) {
3479 
3480             } {
3481                 // Advance 3 bytes
3482                 dataPtr := add(dataPtr, 3)
3483                 let input := mload(dataPtr)
3484 
3485                 // To write each character, shift the 3 bytes (18 bits) chunk
3486                 // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)
3487                 // and apply logical AND with 0x3F which is the number of
3488                 // the previous character in the ASCII table prior to the Base64 Table
3489                 // The result is then added to the table to get the character to write,
3490                 // and finally write it in the result pointer but with a left shift
3491                 // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits
3492 
3493                 mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))
3494                 resultPtr := add(resultPtr, 1) // Advance
3495 
3496                 mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))
3497                 resultPtr := add(resultPtr, 1) // Advance
3498 
3499                 mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))
3500                 resultPtr := add(resultPtr, 1) // Advance
3501 
3502                 mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))
3503                 resultPtr := add(resultPtr, 1) // Advance
3504             }
3505 
3506             // When data `bytes` is not exactly 3 bytes long
3507             // it is padded with `=` characters at the end
3508             switch mod(mload(data), 3)
3509             case 1 {
3510                 mstore8(sub(resultPtr, 1), 0x3d)
3511                 mstore8(sub(resultPtr, 2), 0x3d)
3512             }
3513             case 2 {
3514                 mstore8(sub(resultPtr, 1), 0x3d)
3515             }
3516         }



```

```
LibString.toHexStringNoPrefix(bytes) (LlamaFactory.sol#771-793) uses assembly
	- INLINE ASM (LlamaFactory.sol#773-792)



    
773         assembly {
774             let length := mload(raw)
775             str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.
776             mstore(str, add(length, length)) // Store the length of the output.
777 
778             // Store "0123456789abcdef" in scratch space.
779             mstore(0x0f, 0x30313233343536373839616263646566)
780 
781             let o := add(str, 0x20)
782             let end := add(raw, length)
783 
784             for {} iszero(eq(raw, end)) {} {
785                 raw := add(raw, 1)
786                 mstore8(add(o, 1), mload(and(mload(raw), 15)))
787                 mstore8(o, mload(and(shr(4, mload(raw)), 15)))
788                 o := add(o, 2)
789             }
790             mstore(o, 0) // Zeroize the slot after the string.
791             mstore(0x40, add(o, 0x20)) // Allocate the memory.
792         }



```

```
LibString.toHexStringNoPrefix(uint256,uint256) (LlamaFactory.sol#548-596) uses assembly
	- INLINE ASM (LlamaFactory.sol#554-595)



    
554         assembly {
555             // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes
556             // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.
557             // We add 0x20 to the total and round down to a multiple of 0x20.
558             // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.
559             str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))
560             // Allocate the memory.
561             mstore(0x40, add(str, 0x20))
562             // Zeroize the slot after the string.
563             mstore(str, 0)
564 
565             // Cache the end to calculate the length later.
566             let end := str
567             // Store "0123456789abcdef" in scratch space.
568             mstore(0x0f, 0x30313233343536373839616263646566)
569 
570             let start := sub(str, add(length, length))
571             let w := not(1) // Tsk.
572             let temp := value
573             // We write the string from rightmost digit to leftmost digit.
574             // The following is essentially a do-while loop that also handles the zero case.
575             for {} 1 {} {
576                 str := add(str, w) // `sub(str, 2)`.
577                 mstore8(add(str, 1), mload(and(temp, 15)))
578                 mstore8(str, mload(and(shr(4, temp), 15)))
579                 temp := shr(8, temp)
580                 if iszero(xor(str, start)) { break }
581             }
582 
583             if temp {
584                 // Store the function selector of `HexLengthInsufficient()`.
585                 mstore(0x00, 0x2194895a)
586                 // Revert with (offset, size).
587                 revert(0x1c, 0x04)
588             }
589 
590             // Compute the string's length.
591             let strLength := sub(end, str)
592             // Move the pointer and write the length.
593             str := sub(str, 0x20)
594             mstore(str, strLength)
595         }



```

```
Clones.cloneDeterministic(address,bytes32) (LlamaFactory.sol#50-63) uses assembly
	- INLINE ASM (LlamaFactory.sol#52-59)



    
52         assembly {
53             // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
54             // of the `implementation` address with the bytecode before the address.
55             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
56             // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
57             mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
58             instance := create2(0, 0x09, 0x37, salt)
59         }



```

```
LibString.toCase(string,bool) (LlamaFactory.sol#1314-1340) uses assembly
	- INLINE ASM (LlamaFactory.sol#1320-1339)



    
1320         assembly {
1321             let length := mload(subject)
1322             if length {
1323                 result := add(mload(0x40), 0x20)
1324                 subject := add(subject, 1)
1325                 let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)
1326                 let w := not(0)
1327                 for { let o := length } 1 {} {
1328                     o := add(o, w)
1329                     let b := and(0xff, mload(add(subject, o)))
1330                     mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))
1331                     if iszero(o) { break }
1332                 }
1333                 result := mload(0x40)
1334                 mstore(result, length) // Store the length.
1335                 let last := add(add(result, 0x20), length)
1336                 mstore(last, 0) // Zeroize the slot after the string.
1337                 mstore(0x40, add(last, 0x20)) // Allocate the memory.
1338             }
1339         }



```

```
LibString.runeCount(string) (LlamaFactory.sol#800-814) uses assembly
	- INLINE ASM (LlamaFactory.sol#802-813)



    
802         assembly {
803             if mload(s) {
804                 mstore(0x00, div(not(0), 255))
805                 mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)
806                 let o := add(s, 0x20)
807                 let end := add(o, mload(s))
808                 for { result := 1 } 1 { result := add(result, 1) } {
809                     o := add(o, byte(0, mload(shr(250, mload(o)))))
810                     if iszero(lt(o, end)) { break }
811                 }
812             }
813         }



```

```
LibString.packTwo(string,string) (LlamaFactory.sol#1483-1501) uses assembly
	- INLINE ASM (LlamaFactory.sol#1485-1500)



    
1485         assembly {
1486             let aLength := mload(a)
1487             // We don't need to zero right pad the strings,
1488             // since this is our own custom non-standard packing scheme.
1489             result :=
1490                 mul(
1491                     // Load the length and the bytes of `a` and `b`.
1492                     or(
1493                         shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),
1494                         mload(sub(add(b, 0x1e), aLength))
1495                     ),
1496                     // `totalLength != 0 && totalLength < 31`. Abuses underflow.
1497                     // Assumes that the lengths are valid and within the block gas limit.
1498                     lt(sub(add(aLength, mload(b)), 1), 0x1e)
1499                 )
1500         }



```

```
LibString.escapeHTML(string) (LlamaFactory.sol#1355-1386) uses assembly
	- INLINE ASM (LlamaFactory.sol#1357-1385)



    
1357         assembly {
1358             for {
1359                 let end := add(s, mload(s))
1360                 result := add(mload(0x40), 0x20)
1361                 // Store the bytes of the packed offsets and strides into the scratch space.
1362                 // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.
1363                 mstore(0x1f, 0x900094)
1364                 mstore(0x08, 0xc0000000a6ab)
1365                 // Store "&quot;&amp;&#39;&lt;&gt;" into the scratch space.
1366                 mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))
1367             } iszero(eq(s, end)) {} {
1368                 s := add(s, 1)
1369                 let c := and(mload(s), 0xff)
1370                 // Not in `["\"","'","&","<",">"]`.
1371                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
1372                     mstore8(result, c)
1373                     result := add(result, 1)
1374                     continue
1375                 }
1376                 let t := shr(248, mload(c))
1377                 mstore(result, mload(and(t, 0x1f)))
1378                 result := add(result, shr(5, t))
1379             }
1380             let last := result
1381             mstore(last, 0) // Zeroize the slot after the string.
1382             result := mload(0x40)
1383             mstore(result, sub(last, add(result, 0x20))) // Store the length.
1384             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1385         }



```

```
LibString.eq(string,string) (LlamaFactory.sol#1438-1442) uses assembly
	- INLINE ASM (LlamaFactory.sol#1439-1441)



    
1439         assembly {
1440             result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))
1441         }



```

```
LibString.toMinimalHexString(uint256) (LlamaFactory.sol#617-627) uses assembly
	- INLINE ASM (LlamaFactory.sol#620-626)



    
620         assembly {
621             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
622             let strLength := add(mload(str), 2) // Compute the length.
623             mstore(add(str, o), 0x3078) // Write the "0x" prefix, accounting for leading zero.
624             str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.
625             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
626         }



```

```
LibString.toHexString(bytes) (LlamaFactory.sol#758-767) uses assembly
	- INLINE ASM (LlamaFactory.sol#761-766)



    
761         assembly {
762             let strLength := add(mload(str), 2) // Compute the length.
763             mstore(str, 0x3078) // Write the "0x" prefix.
764             str := sub(str, 2) // Move the pointer.
765             mstore(str, strLength) // Write the length.
766         }



```

```
Checkpoints.sqrt(uint256) (LlamaFactory.sol#1765-1827) uses assembly
	- INLINE ASM (LlamaFactory.sol#1766-1826)



    
1766         assembly {
1767             let y := x // We start y at x, which will help us make our initial estimate.
1768 
1769             z := 181 // The "correct" value is 1, but this saves a multiplication later.
1770 
1771             // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad
1772             // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.
1773 
1774             // We check y >= 2^(k + 8) but shift right by k bits
1775             // each branch to ensure that if x >= 256, then y >= 256.
1776             if iszero(lt(y, 0x10000000000000000000000000000000000)) {
1777                 y := shr(128, y)
1778                 z := shl(64, z)
1779             }
1780             if iszero(lt(y, 0x1000000000000000000)) {
1781                 y := shr(64, y)
1782                 z := shl(32, z)
1783             }
1784             if iszero(lt(y, 0x10000000000)) {
1785                 y := shr(32, y)
1786                 z := shl(16, z)
1787             }
1788             if iszero(lt(y, 0x1000000)) {
1789                 y := shr(16, y)
1790                 z := shl(8, z)
1791             }
1792 
1793             // Goal was to get z*z*y within a small factor of x. More iterations could
1794             // get y in a tighter range. Currently, we will have y in [256, 256*2^16).
1795             // We ensured y >= 256 so that the relative difference between y and y+1 is small.
1796             // That's not possible if x < 256 but we can just verify those cases exhaustively.
1797 
1798             // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.
1799             // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.
1800             // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.
1801 
1802             // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range
1803             // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.
1804 
1805             // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate
1806             // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.
1807 
1808             // There is no overflow risk here since y < 2^136 after the first branch above.
1809             z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.
1810 
1811             // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.
1812             z := shr(1, add(z, div(x, z)))
1813             z := shr(1, add(z, div(x, z)))
1814             z := shr(1, add(z, div(x, z)))
1815             z := shr(1, add(z, div(x, z)))
1816             z := shr(1, add(z, div(x, z)))
1817             z := shr(1, add(z, div(x, z)))
1818             z := shr(1, add(z, div(x, z)))
1819 
1820             // If x+1 is a perfect square, the Babylonian method cycles between
1821             // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.
1822             // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division
1823             // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.
1824             // If you don't care whether the floor or ceil square root is returned, you can remove this statement.
1825             z := sub(z, lt(div(x, z), z))
1826         }



```

```
LibString.toHexStringChecksummed(address) (LlamaFactory.sol#687-704) uses assembly
	- INLINE ASM (LlamaFactory.sol#690-703)



    
690         assembly {
691             let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`
692             let o := add(str, 0x22)
693             let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `
694             let t := shl(240, 136) // `0b10001000 << 240`
695             for { let i := 0 } 1 {} {
696                 mstore(add(i, i), mul(t, byte(i, hashed)))
697                 i := add(i, 1)
698                 if eq(i, 20) { break }
699             }
700             mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))
701             o := add(o, 0x20)
702             mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))
703         }



```

```
LibString.toHexString(uint256) (LlamaFactory.sol#602-611) uses assembly
	- INLINE ASM (LlamaFactory.sol#605-610)



    
605         assembly {
606             let strLength := add(mload(str), 2) // Compute the length.
607             mstore(str, 0x3078) // Write the "0x" prefix.
608             str := sub(str, 2) // Move the pointer.
609             mstore(str, strLength) // Write the length.
610         }



```

```
LibString.split(string,string) (LlamaFactory.sol#1227-1272) uses assembly
	- INLINE ASM (LlamaFactory.sol#1234-1271)



    
1234         assembly {
1235             let w := not(0x1f)
1236             let indexPtr := add(indices, 0x20)
1237             let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))
1238             mstore(add(indicesEnd, w), mload(subject))
1239             mstore(indices, add(mload(indices), 1))
1240             let prevIndex := 0
1241             for {} 1 {} {
1242                 let index := mload(indexPtr)
1243                 mstore(indexPtr, 0x60)
1244                 if iszero(eq(index, prevIndex)) {
1245                     let element := mload(0x40)
1246                     let elementLength := sub(index, prevIndex)
1247                     mstore(element, elementLength)
1248                     // Copy the `subject` one word at a time, backwards.
1249                     for { let o := and(add(elementLength, 0x1f), w) } 1 {} {
1250                         mstore(add(element, o), mload(add(add(subject, prevIndex), o)))
1251                         o := add(o, w) // `sub(o, 0x20)`.
1252                         if iszero(o) { break }
1253                     }
1254                     // Zeroize the slot after the string.
1255                     mstore(add(add(element, 0x20), elementLength), 0)
1256                     // Allocate memory for the length and the bytes,
1257                     // rounded up to a multiple of 32.
1258                     mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))
1259                     // Store the `element` into the array.
1260                     mstore(indexPtr, element)
1261                 }
1262                 prevIndex := add(index, mload(delimiter))
1263                 indexPtr := add(indexPtr, 0x20)
1264                 if iszero(lt(indexPtr, indicesEnd)) { break }
1265             }
1266             result := indices
1267             if iszero(mload(delimiter)) {
1268                 result := add(indices, 0x20)
1269                 mstore(result, sub(mload(indices), 2))
1270             }
1271         }



```

```
LibString.startsWith(string,string) (LlamaFactory.sol#1042-1060) uses assembly
	- INLINE ASM (LlamaFactory.sol#1048-1059)



    
1048         assembly {
1049             let searchLength := mload(search)
1050             // Just using keccak256 directly is actually cheaper.
1051             // forgefmt: disable-next-item
1052             result := and(
1053                 iszero(gt(searchLength, mload(subject))),
1054                 eq(
1055                     keccak256(add(subject, 0x20), searchLength),
1056                     keccak256(add(search, 0x20), searchLength)
1057                 )
1058             )
1059         }



```

```
LibString.directReturn(string) (LlamaFactory.sol#1531-1544) uses assembly
	- INLINE ASM (LlamaFactory.sol#1532-1543)



    
1532         assembly {
1533             // Assumes that the string does not start from the scratch space.
1534             let retStart := sub(a, 0x20)
1535             let retSize := add(mload(a), 0x40)
1536             // Right pad with zeroes. Just in case the string is produced
1537             // by a method that doesn't zero right pad.
1538             mstore(add(retStart, retSize), 0)
1539             // Store the return offset.
1540             mstore(retStart, 0x20)
1541             // End the transaction, returning the string.
1542             return(retStart, retSize)
1543         }



```

```
LibString.toHexStringNoPrefix(address) (LlamaFactory.sol#721-754) uses assembly
	- INLINE ASM (LlamaFactory.sol#723-753)



    
723         assembly {
724             str := mload(0x40)
725 
726             // Allocate the memory.
727             // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,
728             // 0x02 bytes for the prefix, and 0x28 bytes for the digits.
729             // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.
730             mstore(0x40, add(str, 0x80))
731 
732             // Store "0123456789abcdef" in scratch space.
733             mstore(0x0f, 0x30313233343536373839616263646566)
734 
735             str := add(str, 2)
736             mstore(str, 40)
737 
738             let o := add(str, 0x20)
739             mstore(add(o, 40), 0)
740 
741             value := shl(96, value)
742 
743             // We write the string from rightmost digit to leftmost digit.
744             // The following is essentially a do-while loop that also handles the zero case.
745             for { let i := 0 } 1 {} {
746                 let p := add(o, add(i, i))
747                 let temp := byte(i, value)
748                 mstore8(add(p, 1), mload(and(temp, 15)))
749                 mstore8(p, mload(shr(4, temp)))
750                 i := add(i, 1)
751                 if eq(i, 20) { break }
752             }
753         }



```

```
LibString.replace(string,string,string) (LlamaFactory.sol#850-922) uses assembly
	- INLINE ASM (LlamaFactory.sol#856-921)



    
856         assembly {
857             let subjectLength := mload(subject)
858             let searchLength := mload(search)
859             let replacementLength := mload(replacement)
860 
861             subject := add(subject, 0x20)
862             search := add(search, 0x20)
863             replacement := add(replacement, 0x20)
864             result := add(mload(0x40), 0x20)
865 
866             let subjectEnd := add(subject, subjectLength)
867             if iszero(gt(searchLength, subjectLength)) {
868                 let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)
869                 let h := 0
870                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
871                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
872                 let s := mload(search)
873                 for {} 1 {} {
874                     let t := mload(subject)
875                     // Whether the first `searchLength % 32` bytes of
876                     // `subject` and `search` matches.
877                     if iszero(shr(m, xor(t, s))) {
878                         if h {
879                             if iszero(eq(keccak256(subject, searchLength), h)) {
880                                 mstore(result, t)
881                                 result := add(result, 1)
882                                 subject := add(subject, 1)
883                                 if iszero(lt(subject, subjectSearchEnd)) { break }
884                                 continue
885                             }
886                         }
887                         // Copy the `replacement` one word at a time.
888                         for { let o := 0 } 1 {} {
889                             mstore(add(result, o), mload(add(replacement, o)))
890                             o := add(o, 0x20)
891                             if iszero(lt(o, replacementLength)) { break }
892                         }
893                         result := add(result, replacementLength)
894                         subject := add(subject, searchLength)
895                         if searchLength {
896                             if iszero(lt(subject, subjectSearchEnd)) { break }
897                             continue
898                         }
899                     }
900                     mstore(result, t)
901                     result := add(result, 1)
902                     subject := add(subject, 1)
903                     if iszero(lt(subject, subjectSearchEnd)) { break }
904                 }
905             }
906 
907             let resultRemainder := result
908             result := add(mload(0x40), 0x20)
909             let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))
910             // Copy the rest of the string one word at a time.
911             for {} lt(subject, subjectEnd) {} {
912                 mstore(resultRemainder, mload(subject))
913                 resultRemainder := add(resultRemainder, 0x20)
914                 subject := add(subject, 0x20)
915             }
916             result := sub(result, 0x20)
917             let last := add(add(result, 0x20), k) // Zeroize the slot after the string.
918             mstore(last, 0)
919             mstore(0x40, add(last, 0x20)) // Allocate the memory.
920             mstore(result, k) // Store the length.
921         }



```

```
LibString.is7BitASCII(string) (LlamaFactory.sol#818-840) uses assembly
	- INLINE ASM (LlamaFactory.sol#820-839)



    
820         assembly {
821             let mask := shl(7, div(not(0), 255))
822             result := 1
823             let n := mload(s)
824             if n {
825                 let o := add(s, 0x20)
826                 let end := add(o, n)
827                 let last := mload(end)
828                 mstore(end, 0)
829                 for {} 1 {} {
830                     if and(mask, mload(o)) {
831                         result := 0
832                         break
833                     }
834                     o := add(o, 0x20)
835                     if iszero(lt(o, end)) { break }
836                 }
837                 mstore(end, last)
838             }
839         }



```

```
LibString.toMinimalHexStringNoPrefix(uint256) (LlamaFactory.sol#632-641) uses assembly
	- INLINE ASM (LlamaFactory.sol#635-640)



    
635         assembly {
636             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
637             let strLength := mload(str) // Get the length.
638             str := add(str, o) // Move the pointer, accounting for leading zero.
639             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
640         }



```

```
Clones.clone(address) (LlamaFactory.sol#28-41) uses assembly
	- INLINE ASM (LlamaFactory.sol#30-37)



    
30         assembly {
31             // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
32             // of the `implementation` address with the bytecode before the address.
33             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
34             // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
35             mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
36             instance := create(0, 0x09, 0x37)
37         }



```

### LlamaGovernanceScript.sol


```
Checkpoints._unsafeAccess(Checkpoints.Checkpoint[],uint256) (LlamaGovernanceScript.sol#1766-1775) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#1771-1774)



    
1771         assembly {
1772             mstore(0, self.slot)
1773             result.slot := add(keccak256(0, 0x20), pos)
1774         }



```

```
LibString.toHexStringNoPrefix(uint256) (LlamaGovernanceScript.sol#671-705) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#673-704)



    
673         assembly {
674             // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,
675             // 0x02 bytes for the prefix, and 0x40 bytes for the digits.
676             // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.
677             str := add(mload(0x40), 0x80)
678             // Allocate the memory.
679             mstore(0x40, add(str, 0x20))
680             // Zeroize the slot after the string.
681             mstore(str, 0)
682 
683             // Cache the end to calculate the length later.
684             let end := str
685             // Store "0123456789abcdef" in scratch space.
686             mstore(0x0f, 0x30313233343536373839616263646566)
687 
688             let w := not(1) // Tsk.
689             // We write the string from rightmost digit to leftmost digit.
690             // The following is essentially a do-while loop that also handles the zero case.
691             for { let temp := value } 1 {} {
692                 str := add(str, w) // `sub(str, 2)`.
693                 mstore8(add(str, 1), mload(and(temp, 15)))
694                 mstore8(str, mload(and(shr(4, temp), 15)))
695                 temp := shr(8, temp)
696                 if iszero(temp) { break }
697             }
698 
699             // Compute the string's length.
700             let strLength := sub(end, str)
701             // Move the pointer and write the length.
702             str := sub(str, 0x20)
703             mstore(str, strLength)
704         }



```

```
LibString.toHexStringNoPrefix(bytes) (LlamaGovernanceScript.sol#795-817) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#797-816)



    
797         assembly {
798             let length := mload(raw)
799             str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.
800             mstore(str, add(length, length)) // Store the length of the output.
801 
802             // Store "0123456789abcdef" in scratch space.
803             mstore(0x0f, 0x30313233343536373839616263646566)
804 
805             let o := add(str, 0x20)
806             let end := add(raw, length)
807 
808             for {} iszero(eq(raw, end)) {} {
809                 raw := add(raw, 1)
810                 mstore8(add(o, 1), mload(and(mload(raw), 15)))
811                 mstore8(o, mload(and(shr(4, mload(raw)), 15)))
812                 o := add(o, 2)
813             }
814             mstore(o, 0) // Zeroize the slot after the string.
815             mstore(0x40, add(o, 0x20)) // Allocate the memory.
816         }



```

```
LibString.escapeHTML(string) (LlamaGovernanceScript.sol#1379-1410) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#1381-1409)



    
1381         assembly {
1382             for {
1383                 let end := add(s, mload(s))
1384                 result := add(mload(0x40), 0x20)
1385                 // Store the bytes of the packed offsets and strides into the scratch space.
1386                 // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.
1387                 mstore(0x1f, 0x900094)
1388                 mstore(0x08, 0xc0000000a6ab)
1389                 // Store "&quot;&amp;&#39;&lt;&gt;" into the scratch space.
1390                 mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))
1391             } iszero(eq(s, end)) {} {
1392                 s := add(s, 1)
1393                 let c := and(mload(s), 0xff)
1394                 // Not in `["\"","'","&","<",">"]`.
1395                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
1396                     mstore8(result, c)
1397                     result := add(result, 1)
1398                     continue
1399                 }
1400                 let t := shr(248, mload(c))
1401                 mstore(result, mload(and(t, 0x1f)))
1402                 result := add(result, shr(5, t))
1403             }
1404             let last := result
1405             mstore(last, 0) // Zeroize the slot after the string.
1406             result := mload(0x40)
1407             mstore(result, sub(last, add(result, 0x20))) // Store the length.
1408             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1409         }



```

```
Clones.cloneDeterministic(address,bytes32) (LlamaGovernanceScript.sol#121-134) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#123-130)



    
123         assembly {
124             // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
125             // of the `implementation` address with the bytecode before the address.
126             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
127             // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
128             mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
129             instance := create2(0, 0x09, 0x37, salt)
130         }



```

```
Base64.encode(bytes) (LlamaGovernanceScript.sol#2579-2650) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#2598-2647)



    
2598         assembly {
2599             // Prepare the lookup table (skip the first "length" byte)
2600             let tablePtr := add(table, 1)
2601 
2602             // Prepare result pointer, jump over length
2603             let resultPtr := add(result, 32)
2604 
2605             // Run over the input, 3 bytes at a time
2606             for {
2607                 let dataPtr := data
2608                 let endPtr := add(data, mload(data))
2609             } lt(dataPtr, endPtr) {
2610 
2611             } {
2612                 // Advance 3 bytes
2613                 dataPtr := add(dataPtr, 3)
2614                 let input := mload(dataPtr)
2615 
2616                 // To write each character, shift the 3 bytes (18 bits) chunk
2617                 // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)
2618                 // and apply logical AND with 0x3F which is the number of
2619                 // the previous character in the ASCII table prior to the Base64 Table
2620                 // The result is then added to the table to get the character to write,
2621                 // and finally write it in the result pointer but with a left shift
2622                 // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits
2623 
2624                 mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))
2625                 resultPtr := add(resultPtr, 1) // Advance
2626 
2627                 mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))
2628                 resultPtr := add(resultPtr, 1) // Advance
2629 
2630                 mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))
2631                 resultPtr := add(resultPtr, 1) // Advance
2632 
2633                 mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))
2634                 resultPtr := add(resultPtr, 1) // Advance
2635             }
2636 
2637             // When data `bytes` is not exactly 3 bytes long
2638             // it is padded with `=` characters at the end
2639             switch mod(mload(data), 3)
2640             case 1 {
2641                 mstore8(sub(resultPtr, 1), 0x3d)
2642                 mstore8(sub(resultPtr, 2), 0x3d)
2643             }
2644             case 2 {
2645                 mstore8(sub(resultPtr, 1), 0x3d)
2646             }
2647         }



```

```
LibString.startsWith(string,string) (LlamaGovernanceScript.sol#1066-1084) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#1072-1083)



    
1072         assembly {
1073             let searchLength := mload(search)
1074             // Just using keccak256 directly is actually cheaper.
1075             // forgefmt: disable-next-item
1076             result := and(
1077                 iszero(gt(searchLength, mload(subject))),
1078                 eq(
1079                     keccak256(add(subject, 0x20), searchLength),
1080                     keccak256(add(search, 0x20), searchLength)
1081                 )
1082             )
1083         }



```

```
LibString.indexOf(string,string,uint256) (LlamaGovernanceScript.sol#951-1004) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#957-1003)



    
957         assembly {
958             for { let subjectLength := mload(subject) } 1 {} {
959                 if iszero(mload(search)) {
960                     if iszero(gt(from, subjectLength)) {
961                         result := from
962                         break
963                     }
964                     result := subjectLength
965                     break
966                 }
967                 let searchLength := mload(search)
968                 let subjectStart := add(subject, 0x20)
969 
970                 result := not(0) // Initialize to `NOT_FOUND`.
971 
972                 subject := add(subjectStart, from)
973                 let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)
974 
975                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
976                 let s := mload(add(search, 0x20))
977 
978                 if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }
979 
980                 if iszero(lt(searchLength, 0x20)) {
981                     for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
982                         if iszero(shr(m, xor(mload(subject), s))) {
983                             if eq(keccak256(subject, searchLength), h) {
984                                 result := sub(subject, subjectStart)
985                                 break
986                             }
987                         }
988                         subject := add(subject, 1)
989                         if iszero(lt(subject, end)) { break }
990                     }
991                     break
992                 }
993                 for {} 1 {} {
994                     if iszero(shr(m, xor(mload(subject), s))) {
995                         result := sub(subject, subjectStart)
996                         break
997                     }
998                     subject := add(subject, 1)
999                     if iszero(lt(subject, end)) { break }
1000                 }
1001                 break
1002             }
1003         }



```

```
LibString.indicesOf(string,string) (LlamaGovernanceScript.sol#1192-1248) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#1198-1247)



    
1198         assembly {
1199             let subjectLength := mload(subject)
1200             let searchLength := mload(search)
1201 
1202             if iszero(gt(searchLength, subjectLength)) {
1203                 subject := add(subject, 0x20)
1204                 search := add(search, 0x20)
1205                 result := add(mload(0x40), 0x20)
1206 
1207                 let subjectStart := subject
1208                 let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)
1209                 let h := 0
1210                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
1211                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
1212                 let s := mload(search)
1213                 for {} 1 {} {
1214                     let t := mload(subject)
1215                     // Whether the first `searchLength % 32` bytes of
1216                     // `subject` and `search` matches.
1217                     if iszero(shr(m, xor(t, s))) {
1218                         if h {
1219                             if iszero(eq(keccak256(subject, searchLength), h)) {
1220                                 subject := add(subject, 1)
1221                                 if iszero(lt(subject, subjectSearchEnd)) { break }
1222                                 continue
1223                             }
1224                         }
1225                         // Append to `result`.
1226                         mstore(result, sub(subject, subjectStart))
1227                         result := add(result, 0x20)
1228                         // Advance `subject` by `searchLength`.
1229                         subject := add(subject, searchLength)
1230                         if searchLength {
1231                             if iszero(lt(subject, subjectSearchEnd)) { break }
1232                             continue
1233                         }
1234                     }
1235                     subject := add(subject, 1)
1236                     if iszero(lt(subject, subjectSearchEnd)) { break }
1237                 }
1238                 let resultEnd := result
1239                 // Assign `result` to the free memory pointer.
1240                 result := mload(0x40)
1241                 // Store the length of `result`.
1242                 mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))
1243                 // Allocate memory for result.
1244                 // We allocate one more word, so this array can be recycled for {split}.
1245                 mstore(0x40, add(resultEnd, 0x20))
1246             }
1247         }



```

```
LibString.replace(string,string,string) (LlamaGovernanceScript.sol#874-946) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#880-945)



    
880         assembly {
881             let subjectLength := mload(subject)
882             let searchLength := mload(search)
883             let replacementLength := mload(replacement)
884 
885             subject := add(subject, 0x20)
886             search := add(search, 0x20)
887             replacement := add(replacement, 0x20)
888             result := add(mload(0x40), 0x20)
889 
890             let subjectEnd := add(subject, subjectLength)
891             if iszero(gt(searchLength, subjectLength)) {
892                 let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)
893                 let h := 0
894                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
895                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
896                 let s := mload(search)
897                 for {} 1 {} {
898                     let t := mload(subject)
899                     // Whether the first `searchLength % 32` bytes of
900                     // `subject` and `search` matches.
901                     if iszero(shr(m, xor(t, s))) {
902                         if h {
903                             if iszero(eq(keccak256(subject, searchLength), h)) {
904                                 mstore(result, t)
905                                 result := add(result, 1)
906                                 subject := add(subject, 1)
907                                 if iszero(lt(subject, subjectSearchEnd)) { break }
908                                 continue
909                             }
910                         }
911                         // Copy the `replacement` one word at a time.
912                         for { let o := 0 } 1 {} {
913                             mstore(add(result, o), mload(add(replacement, o)))
914                             o := add(o, 0x20)
915                             if iszero(lt(o, replacementLength)) { break }
916                         }
917                         result := add(result, replacementLength)
918                         subject := add(subject, searchLength)
919                         if searchLength {
920                             if iszero(lt(subject, subjectSearchEnd)) { break }
921                             continue
922                         }
923                     }
924                     mstore(result, t)
925                     result := add(result, 1)
926                     subject := add(subject, 1)
927                     if iszero(lt(subject, subjectSearchEnd)) { break }
928                 }
929             }
930 
931             let resultRemainder := result
932             result := add(mload(0x40), 0x20)
933             let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))
934             // Copy the rest of the string one word at a time.
935             for {} lt(subject, subjectEnd) {} {
936                 mstore(resultRemainder, mload(subject))
937                 resultRemainder := add(resultRemainder, 0x20)
938                 subject := add(subject, 0x20)
939             }
940             result := sub(result, 0x20)
941             let last := add(add(result, 0x20), k) // Zeroize the slot after the string.
942             mstore(last, 0)
943             mstore(0x40, add(last, 0x20)) // Allocate the memory.
944             mstore(result, k) // Store the length.
945         }



```

```
Clones.predictDeterministicAddress(address,bytes32,address) (LlamaGovernanceScript.sol#139-155) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#145-154)



    
145         assembly {
146             let ptr := mload(0x40)
147             mstore(add(ptr, 0x38), deployer)
148             mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)
149             mstore(add(ptr, 0x14), implementation)
150             mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)
151             mstore(add(ptr, 0x58), salt)
152             mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))
153             predicted := keccak256(add(ptr, 0x43), 0x55)
154         }



```

```
LibString.endsWith(string,string) (LlamaGovernanceScript.sol#1087-1112) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#1093-1111)



    
1093         assembly {
1094             let searchLength := mload(search)
1095             let subjectLength := mload(subject)
1096             // Whether `search` is not longer than `subject`.
1097             let withinRange := iszero(gt(searchLength, subjectLength))
1098             // Just using keccak256 directly is actually cheaper.
1099             // forgefmt: disable-next-item
1100             result := and(
1101                 withinRange,
1102                 eq(
1103                     keccak256(
1104                         // `subject + 0x20 + max(subjectLength - searchLength, 0)`.
1105                         add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),
1106                         searchLength
1107                     ),
1108                     keccak256(add(search, 0x20), searchLength)
1109                 )
1110             )
1111         }



```

```
LibString.split(string,string) (LlamaGovernanceScript.sol#1251-1296) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#1258-1295)



    
1258         assembly {
1259             let w := not(0x1f)
1260             let indexPtr := add(indices, 0x20)
1261             let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))
1262             mstore(add(indicesEnd, w), mload(subject))
1263             mstore(indices, add(mload(indices), 1))
1264             let prevIndex := 0
1265             for {} 1 {} {
1266                 let index := mload(indexPtr)
1267                 mstore(indexPtr, 0x60)
1268                 if iszero(eq(index, prevIndex)) {
1269                     let element := mload(0x40)
1270                     let elementLength := sub(index, prevIndex)
1271                     mstore(element, elementLength)
1272                     // Copy the `subject` one word at a time, backwards.
1273                     for { let o := and(add(elementLength, 0x1f), w) } 1 {} {
1274                         mstore(add(element, o), mload(add(add(subject, prevIndex), o)))
1275                         o := add(o, w) // `sub(o, 0x20)`.
1276                         if iszero(o) { break }
1277                     }
1278                     // Zeroize the slot after the string.
1279                     mstore(add(add(element, 0x20), elementLength), 0)
1280                     // Allocate memory for the length and the bytes,
1281                     // rounded up to a multiple of 32.
1282                     mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))
1283                     // Store the `element` into the array.
1284                     mstore(indexPtr, element)
1285                 }
1286                 prevIndex := add(index, mload(delimiter))
1287                 indexPtr := add(indexPtr, 0x20)
1288                 if iszero(lt(indexPtr, indicesEnd)) { break }
1289             }
1290             result := indices
1291             if iszero(mload(delimiter)) {
1292                 result := add(indices, 0x20)
1293                 mstore(result, sub(mload(indices), 2))
1294             }
1295         }



```

```
LibString.toMinimalHexStringNoPrefix(uint256) (LlamaGovernanceScript.sol#656-665) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#659-664)



    
659         assembly {
660             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
661             let strLength := mload(str) // Get the length.
662             str := add(str, o) // Move the pointer, accounting for leading zero.
663             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
664         }



```

```
LibString.packOne(string) (LlamaGovernanceScript.sol#1470-1484) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#1472-1483)



    
1472         assembly {
1473             // We don't need to zero right pad the string,
1474             // since this is our own custom non-standard packing scheme.
1475             result :=
1476                 mul(
1477                     // Load the length and the bytes.
1478                     mload(add(a, 0x1f)),
1479                     // `length != 0 && length < 32`. Abuses underflow.
1480                     // Assumes that the length is valid and within the block gas limit.
1481                     lt(sub(mload(a), 1), 0x1f)
1482                 )
1483         }



```

```
LibString.escapeJSON(string) (LlamaGovernanceScript.sol#1413-1459) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#1415-1458)



    
1415         assembly {
1416             for {
1417                 let end := add(s, mload(s))
1418                 result := add(mload(0x40), 0x20)
1419                 // Store "\\u0000" in scratch space.
1420                 // Store "0123456789abcdef" in scratch space.
1421                 // Also, store `{0x08:"b", 0x09:"t", 0x0a:"n", 0x0c:"f", 0x0d:"r"}`.
1422                 // into the scratch space.
1423                 mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)
1424                 // Bitmask for detecting `["\"","\\"]`.
1425                 let e := or(shl(0x22, 1), shl(0x5c, 1))
1426             } iszero(eq(s, end)) {} {
1427                 s := add(s, 1)
1428                 let c := and(mload(s), 0xff)
1429                 if iszero(lt(c, 0x20)) {
1430                     if iszero(and(shl(c, 1), e)) {
1431                         // Not in `["\"","\\"]`.
1432                         mstore8(result, c)
1433                         result := add(result, 1)
1434                         continue
1435                     }
1436                     mstore8(result, 0x5c) // "\\".
1437                     mstore8(add(result, 1), c)
1438                     result := add(result, 2)
1439                     continue
1440                 }
1441                 if iszero(and(shl(c, 1), 0x3700)) {
1442                     // Not in `["\b","\t","\n","\f","\d"]`.
1443                     mstore8(0x1d, mload(shr(4, c))) // Hex value.
1444                     mstore8(0x1e, mload(and(c, 15))) // Hex value.
1445                     mstore(result, mload(0x19)) // "\\u00XX".
1446                     result := add(result, 6)
1447                     continue
1448                 }
1449                 mstore8(result, 0x5c) // "\\".
1450                 mstore8(add(result, 1), mload(add(c, 8)))
1451                 result := add(result, 2)
1452             }
1453             let last := result
1454             mstore(last, 0) // Zeroize the slot after the string.
1455             result := mload(0x40)
1456             mstore(result, sub(last, add(result, 0x20))) // Store the length.
1457             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1458         }



```

```
LibString.toHexString(bytes) (LlamaGovernanceScript.sol#782-791) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#785-790)



    
785         assembly {
786             let strLength := add(mload(str), 2) // Compute the length.
787             mstore(str, 0x3078) // Write the "0x" prefix.
788             str := sub(str, 2) // Move the pointer.
789             mstore(str, strLength) // Write the length.
790         }



```

```
LibString.toMinimalHexString(uint256) (LlamaGovernanceScript.sol#641-651) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#644-650)



    
644         assembly {
645             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
646             let strLength := add(mload(str), 2) // Compute the length.
647             mstore(add(str, o), 0x3078) // Write the "0x" prefix, accounting for leading zero.
648             str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.
649             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
650         }



```

```
LibString.repeat(string,uint256) (LlamaGovernanceScript.sol#1115-1145) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#1121-1144)



    
1121         assembly {
1122             let subjectLength := mload(subject)
1123             if iszero(or(iszero(times), iszero(subjectLength))) {
1124                 subject := add(subject, 0x20)
1125                 result := mload(0x40)
1126                 let output := add(result, 0x20)
1127                 for {} 1 {} {
1128                     // Copy the `subject` one word at a time.
1129                     for { let o := 0 } 1 {} {
1130                         mstore(add(output, o), mload(add(subject, o)))
1131                         o := add(o, 0x20)
1132                         if iszero(lt(o, subjectLength)) { break }
1133                     }
1134                     output := add(output, subjectLength)
1135                     times := sub(times, 1)
1136                     if iszero(times) { break }
1137                 }
1138                 mstore(output, 0) // Zeroize the slot after the string.
1139                 let resultLength := sub(output, add(result, 0x20))
1140                 mstore(result, resultLength) // Store the length.
1141                 // Allocate the memory.
1142                 mstore(0x40, add(result, add(resultLength, 0x20)))
1143             }
1144         }



```

```
LibString.concat(string,string) (LlamaGovernanceScript.sol#1300-1334) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#1306-1333)



    
1306         assembly {
1307             let w := not(0x1f)
1308             result := mload(0x40)
1309             let aLength := mload(a)
1310             // Copy `a` one word at a time, backwards.
1311             for { let o := and(add(aLength, 0x20), w) } 1 {} {
1312                 mstore(add(result, o), mload(add(a, o)))
1313                 o := add(o, w) // `sub(o, 0x20)`.
1314                 if iszero(o) { break }
1315             }
1316             let bLength := mload(b)
1317             let output := add(result, aLength)
1318             // Copy `b` one word at a time, backwards.
1319             for { let o := and(add(bLength, 0x20), w) } 1 {} {
1320                 mstore(add(output, o), mload(add(b, o)))
1321                 o := add(o, w) // `sub(o, 0x20)`.
1322                 if iszero(o) { break }
1323             }
1324             let totalLength := add(aLength, bLength)
1325             let last := add(add(result, 0x20), totalLength)
1326             // Zeroize the slot after the string.
1327             mstore(last, 0)
1328             // Stores the length.
1329             mstore(result, totalLength)
1330             // Allocate memory for the length and the bytes,
1331             // rounded up to a multiple of 32.
1332             mstore(0x40, and(add(last, 0x1f), w))
1333         }



```

```
LibString.toHexStringChecksummed(address) (LlamaGovernanceScript.sol#711-728) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#714-727)



    
714         assembly {
715             let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`
716             let o := add(str, 0x22)
717             let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `
718             let t := shl(240, 136) // `0b10001000 << 240`
719             for { let i := 0 } 1 {} {
720                 mstore(add(i, i), mul(t, byte(i, hashed)))
721                 i := add(i, 1)
722                 if eq(i, 20) { break }
723             }
724             mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))
725             o := add(o, 0x20)
726             mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))
727         }



```

```
Checkpoints.sqrt(uint256) (LlamaGovernanceScript.sol#1789-1851) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#1790-1850)



    
1790         assembly {
1791             let y := x // We start y at x, which will help us make our initial estimate.
1792 
1793             z := 181 // The "correct" value is 1, but this saves a multiplication later.
1794 
1795             // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad
1796             // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.
1797 
1798             // We check y >= 2^(k + 8) but shift right by k bits
1799             // each branch to ensure that if x >= 256, then y >= 256.
1800             if iszero(lt(y, 0x10000000000000000000000000000000000)) {
1801                 y := shr(128, y)
1802                 z := shl(64, z)
1803             }
1804             if iszero(lt(y, 0x1000000000000000000)) {
1805                 y := shr(64, y)
1806                 z := shl(32, z)
1807             }
1808             if iszero(lt(y, 0x10000000000)) {
1809                 y := shr(32, y)
1810                 z := shl(16, z)
1811             }
1812             if iszero(lt(y, 0x1000000)) {
1813                 y := shr(16, y)
1814                 z := shl(8, z)
1815             }
1816 
1817             // Goal was to get z*z*y within a small factor of x. More iterations could
1818             // get y in a tighter range. Currently, we will have y in [256, 256*2^16).
1819             // We ensured y >= 256 so that the relative difference between y and y+1 is small.
1820             // That's not possible if x < 256 but we can just verify those cases exhaustively.
1821 
1822             // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.
1823             // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.
1824             // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.
1825 
1826             // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range
1827             // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.
1828 
1829             // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate
1830             // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.
1831 
1832             // There is no overflow risk here since y < 2^136 after the first branch above.
1833             z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.
1834 
1835             // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.
1836             z := shr(1, add(z, div(x, z)))
1837             z := shr(1, add(z, div(x, z)))
1838             z := shr(1, add(z, div(x, z)))
1839             z := shr(1, add(z, div(x, z)))
1840             z := shr(1, add(z, div(x, z)))
1841             z := shr(1, add(z, div(x, z)))
1842             z := shr(1, add(z, div(x, z)))
1843 
1844             // If x+1 is a perfect square, the Babylonian method cycles between
1845             // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.
1846             // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division
1847             // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.
1848             // If you don't care whether the floor or ceil square root is returned, you can remove this statement.
1849             z := sub(z, lt(div(x, z), z))
1850         }



```

```
LibString.toHexStringNoPrefix(uint256,uint256) (LlamaGovernanceScript.sol#572-620) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#578-619)



    
578         assembly {
579             // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes
580             // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.
581             // We add 0x20 to the total and round down to a multiple of 0x20.
582             // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.
583             str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))
584             // Allocate the memory.
585             mstore(0x40, add(str, 0x20))
586             // Zeroize the slot after the string.
587             mstore(str, 0)
588 
589             // Cache the end to calculate the length later.
590             let end := str
591             // Store "0123456789abcdef" in scratch space.
592             mstore(0x0f, 0x30313233343536373839616263646566)
593 
594             let start := sub(str, add(length, length))
595             let w := not(1) // Tsk.
596             let temp := value
597             // We write the string from rightmost digit to leftmost digit.
598             // The following is essentially a do-while loop that also handles the zero case.
599             for {} 1 {} {
600                 str := add(str, w) // `sub(str, 2)`.
601                 mstore8(add(str, 1), mload(and(temp, 15)))
602                 mstore8(str, mload(and(shr(4, temp), 15)))
603                 temp := shr(8, temp)
604                 if iszero(xor(str, start)) { break }
605             }
606 
607             if temp {
608                 // Store the function selector of `HexLengthInsufficient()`.
609                 mstore(0x00, 0x2194895a)
610                 // Revert with (offset, size).
611                 revert(0x1c, 0x04)
612             }
613 
614             // Compute the string's length.
615             let strLength := sub(end, str)
616             // Move the pointer and write the length.
617             str := sub(str, 0x20)
618             mstore(str, strLength)
619         }



```

```
LibString.directReturn(string) (LlamaGovernanceScript.sol#1555-1568) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#1556-1567)



    
1556         assembly {
1557             // Assumes that the string does not start from the scratch space.
1558             let retStart := sub(a, 0x20)
1559             let retSize := add(mload(a), 0x40)
1560             // Right pad with zeroes. Just in case the string is produced
1561             // by a method that doesn't zero right pad.
1562             mstore(add(retStart, retSize), 0)
1563             // Store the return offset.
1564             mstore(retStart, 0x20)
1565             // End the transaction, returning the string.
1566             return(retStart, retSize)
1567         }



```

```
LibString.is7BitASCII(string) (LlamaGovernanceScript.sol#842-864) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#844-863)



    
844         assembly {
845             let mask := shl(7, div(not(0), 255))
846             result := 1
847             let n := mload(s)
848             if n {
849                 let o := add(s, 0x20)
850                 let end := add(o, n)
851                 let last := mload(end)
852                 mstore(end, 0)
853                 for {} 1 {} {
854                     if and(mask, mload(o)) {
855                         result := 0
856                         break
857                     }
858                     o := add(o, 0x20)
859                     if iszero(lt(o, end)) { break }
860                 }
861                 mstore(end, last)
862             }
863         }



```

```
LibString.runeCount(string) (LlamaGovernanceScript.sol#824-838) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#826-837)



    
826         assembly {
827             if mload(s) {
828                 mstore(0x00, div(not(0), 255))
829                 mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)
830                 let o := add(s, 0x20)
831                 let end := add(o, mload(s))
832                 for { result := 1 } 1 { result := add(result, 1) } {
833                     o := add(o, byte(0, mload(shr(250, mload(o)))))
834                     if iszero(lt(o, end)) { break }
835                 }
836             }
837         }



```

```
LibString.toHexStringNoPrefix(address) (LlamaGovernanceScript.sol#745-778) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#747-777)



    
747         assembly {
748             str := mload(0x40)
749 
750             // Allocate the memory.
751             // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,
752             // 0x02 bytes for the prefix, and 0x28 bytes for the digits.
753             // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.
754             mstore(0x40, add(str, 0x80))
755 
756             // Store "0123456789abcdef" in scratch space.
757             mstore(0x0f, 0x30313233343536373839616263646566)
758 
759             str := add(str, 2)
760             mstore(str, 40)
761 
762             let o := add(str, 0x20)
763             mstore(add(o, 40), 0)
764 
765             value := shl(96, value)
766 
767             // We write the string from rightmost digit to leftmost digit.
768             // The following is essentially a do-while loop that also handles the zero case.
769             for { let i := 0 } 1 {} {
770                 let p := add(o, add(i, i))
771                 let temp := byte(i, value)
772                 mstore8(add(p, 1), mload(and(temp, 15)))
773                 mstore8(p, mload(shr(4, temp)))
774                 i := add(i, 1)
775                 if eq(i, 20) { break }
776             }
777         }



```

```
LibString.unpackOne(bytes32) (LlamaGovernanceScript.sol#1489-1503) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#1491-1502)



    
1491         assembly {
1492             // Grab the free memory pointer.
1493             result := mload(0x40)
1494             // Allocate 2 words (1 for the length, 1 for the bytes).
1495             mstore(0x40, add(result, 0x40))
1496             // Zeroize the length slot.
1497             mstore(result, 0)
1498             // Store the length and bytes.
1499             mstore(add(result, 0x1f), packed)
1500             // Right pad with zeroes.
1501             mstore(add(add(result, 0x20), mload(result)), 0)
1502         }



```

```
LibString.toHexString(address) (LlamaGovernanceScript.sol#732-741) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#735-740)



    
735         assembly {
736             let strLength := add(mload(str), 2) // Compute the length.
737             mstore(str, 0x3078) // Write the "0x" prefix.
738             str := sub(str, 2) // Move the pointer.
739             mstore(str, strLength) // Write the length.
740         }



```

```
LibString.slice(string,uint256,uint256) (LlamaGovernanceScript.sol#1149-1178) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#1155-1177)



    
1155         assembly {
1156             let subjectLength := mload(subject)
1157             if iszero(gt(subjectLength, end)) { end := subjectLength }
1158             if iszero(gt(subjectLength, start)) { start := subjectLength }
1159             if lt(start, end) {
1160                 result := mload(0x40)
1161                 let resultLength := sub(end, start)
1162                 mstore(result, resultLength)
1163                 subject := add(subject, start)
1164                 let w := not(0x1f)
1165                 // Copy the `subject` one word at a time, backwards.
1166                 for { let o := and(add(resultLength, 0x1f), w) } 1 {} {
1167                     mstore(add(result, o), mload(add(subject, o)))
1168                     o := add(o, w) // `sub(o, 0x20)`.
1169                     if iszero(o) { break }
1170                 }
1171                 // Zeroize the slot after the string.
1172                 mstore(add(add(result, 0x20), resultLength), 0)
1173                 // Allocate memory for the length and the bytes,
1174                 // rounded up to a multiple of 32.
1175                 mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))
1176             }
1177         }



```

```
LibString.toCase(string,bool) (LlamaGovernanceScript.sol#1338-1364) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#1344-1363)



    
1344         assembly {
1345             let length := mload(subject)
1346             if length {
1347                 result := add(mload(0x40), 0x20)
1348                 subject := add(subject, 1)
1349                 let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)
1350                 let w := not(0)
1351                 for { let o := length } 1 {} {
1352                     o := add(o, w)
1353                     let b := and(0xff, mload(add(subject, o)))
1354                     mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))
1355                     if iszero(o) { break }
1356                 }
1357                 result := mload(0x40)
1358                 mstore(result, length) // Store the length.
1359                 let last := add(add(result, 0x20), length)
1360                 mstore(last, 0) // Zeroize the slot after the string.
1361                 mstore(0x40, add(last, 0x20)) // Allocate the memory.
1362             }
1363         }



```

```
LibString.packTwo(string,string) (LlamaGovernanceScript.sol#1507-1525) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#1509-1524)



    
1509         assembly {
1510             let aLength := mload(a)
1511             // We don't need to zero right pad the strings,
1512             // since this is our own custom non-standard packing scheme.
1513             result :=
1514                 mul(
1515                     // Load the length and the bytes of `a` and `b`.
1516                     or(
1517                         shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),
1518                         mload(sub(add(b, 0x1e), aLength))
1519                     ),
1520                     // `totalLength != 0 && totalLength < 31`. Abuses underflow.
1521                     // Assumes that the lengths are valid and within the block gas limit.
1522                     lt(sub(add(aLength, mload(b)), 1), 0x1e)
1523                 )
1524         }



```

```
LibString.lastIndexOf(string,string,uint256) (LlamaGovernanceScript.sol#1020-1052) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#1026-1051)



    
1026         assembly {
1027             for {} 1 {} {
1028                 result := not(0) // Initialize to `NOT_FOUND`.
1029                 let searchLength := mload(search)
1030                 if gt(searchLength, mload(subject)) { break }
1031                 let w := result
1032 
1033                 let fromMax := sub(mload(subject), searchLength)
1034                 if iszero(gt(fromMax, from)) { from := fromMax }
1035 
1036                 let end := add(add(subject, 0x20), w)
1037                 subject := add(add(subject, 0x20), from)
1038                 if iszero(gt(subject, end)) { break }
1039                 // As this function is not too often used,
1040                 // we shall simply use keccak256 for smaller bytecode size.
1041                 for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
1042                     if eq(keccak256(subject, searchLength), h) {
1043                         result := sub(subject, add(end, 1))
1044                         break
1045                     }
1046                     subject := add(subject, w) // `sub(subject, 1)`.
1047                     if iszero(gt(subject, end)) { break }
1048                 }
1049                 break
1050             }
1051         }



```

```
LibString.unpackTwo(bytes32) (LlamaGovernanceScript.sol#1530-1552) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#1536-1551)



    
1536         assembly {
1537             // Grab the free memory pointer.
1538             resultA := mload(0x40)
1539             resultB := add(resultA, 0x40)
1540             // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.
1541             mstore(0x40, add(resultB, 0x40))
1542             // Zeroize the length slots.
1543             mstore(resultA, 0)
1544             mstore(resultB, 0)
1545             // Store the lengths and bytes.
1546             mstore(add(resultA, 0x1f), packed)
1547             mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))
1548             // Right pad with zeroes.
1549             mstore(add(add(resultA, 0x20), mload(resultA)), 0)
1550             mstore(add(add(resultB, 0x20), mload(resultB)), 0)
1551         }



```

```
LibString.toString(uint256) (LlamaGovernanceScript.sol#491-526) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#493-525)



    
493         assembly {
494             // The maximum value of a uint256 contains 78 digits (1 byte per digit), but
495             // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.
496             // We will need 1 word for the trailing zeros padding, 1 word for the length,
497             // and 3 words for a maximum of 78 digits.
498             str := add(mload(0x40), 0x80)
499             // Update the free memory pointer to allocate.
500             mstore(0x40, add(str, 0x20))
501             // Zeroize the slot after the string.
502             mstore(str, 0)
503 
504             // Cache the end of the memory to calculate the length later.
505             let end := str
506 
507             let w := not(0) // Tsk.
508             // We write the string from rightmost digit to leftmost digit.
509             // The following is essentially a do-while loop that also handles the zero case.
510             for { let temp := value } 1 {} {
511                 str := add(str, w) // `sub(str, 1)`.
512                 // Write the character to the pointer.
513                 // The ASCII index of the '0' character is 48.
514                 mstore8(str, add(48, mod(temp, 10)))
515                 // Keep dividing `temp` until zero.
516                 temp := div(temp, 10)
517                 if iszero(temp) { break }
518             }
519 
520             let length := sub(end, str)
521             // Move the pointer 32 bytes leftwards to make room for the length.
522             str := sub(str, 0x20)
523             // Store the length.
524             mstore(str, length)
525         }



```

```
LibString.toString(int256) (LlamaGovernanceScript.sol#529-545) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#537-544)



    
537         assembly {
538             // We still have some spare memory space on the left,
539             // as we have allocated 3 words (96 bytes) for up to 78 digits.
540             let length := mload(str) // Load the string length.
541             mstore(str, 0x2d) // Store the '-' character.
542             str := sub(str, 1) // Move back the string pointer by a byte.
543             mstore(str, add(length, 1)) // Update the string length.
544         }



```

```
Clones.clone(address) (LlamaGovernanceScript.sol#99-112) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#101-108)



    
101         assembly {
102             // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
103             // of the `implementation` address with the bytecode before the address.
104             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
105             // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
106             mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
107             instance := create(0, 0x09, 0x37)
108         }



```

```
LibString.eq(string,string) (LlamaGovernanceScript.sol#1462-1466) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#1463-1465)



    
1463         assembly {
1464             result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))
1465         }



```

```
LibString.toHexString(uint256) (LlamaGovernanceScript.sol#626-635) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#629-634)



    
629         assembly {
630             let strLength := add(mload(str), 2) // Compute the length.
631             mstore(str, 0x3078) // Write the "0x" prefix.
632             str := sub(str, 2) // Move the pointer.
633             mstore(str, strLength) // Write the length.
634         }



```

```
LibString.toHexString(uint256,uint256) (LlamaGovernanceScript.sol#556-565) uses assembly
	- INLINE ASM (LlamaGovernanceScript.sol#559-564)



    
559         assembly {
560             let strLength := add(mload(str), 2) // Compute the length.
561             mstore(str, 0x3078) // Write the "0x" prefix.
562             str := sub(str, 2) // Move the pointer.
563             mstore(str, strLength) // Write the length.
564         }



```

### LlamaPolicy.sol


```
LibString.toHexStringNoPrefix(address) (LlamaPolicy.sol#281-314) uses assembly
	- INLINE ASM (LlamaPolicy.sol#283-313)



    
283         assembly {
284             str := mload(0x40)
285 
286             // Allocate the memory.
287             // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,
288             // 0x02 bytes for the prefix, and 0x28 bytes for the digits.
289             // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.
290             mstore(0x40, add(str, 0x80))
291 
292             // Store "0123456789abcdef" in scratch space.
293             mstore(0x0f, 0x30313233343536373839616263646566)
294 
295             str := add(str, 2)
296             mstore(str, 40)
297 
298             let o := add(str, 0x20)
299             mstore(add(o, 40), 0)
300 
301             value := shl(96, value)
302 
303             // We write the string from rightmost digit to leftmost digit.
304             // The following is essentially a do-while loop that also handles the zero case.
305             for { let i := 0 } 1 {} {
306                 let p := add(o, add(i, i))
307                 let temp := byte(i, value)
308                 mstore8(add(p, 1), mload(and(temp, 15)))
309                 mstore8(p, mload(shr(4, temp)))
310                 i := add(i, 1)
311                 if eq(i, 20) { break }
312             }
313         }



```

```
LibString.slice(string,uint256,uint256) (LlamaPolicy.sol#685-714) uses assembly
	- INLINE ASM (LlamaPolicy.sol#691-713)



    
691         assembly {
692             let subjectLength := mload(subject)
693             if iszero(gt(subjectLength, end)) { end := subjectLength }
694             if iszero(gt(subjectLength, start)) { start := subjectLength }
695             if lt(start, end) {
696                 result := mload(0x40)
697                 let resultLength := sub(end, start)
698                 mstore(result, resultLength)
699                 subject := add(subject, start)
700                 let w := not(0x1f)
701                 // Copy the `subject` one word at a time, backwards.
702                 for { let o := and(add(resultLength, 0x1f), w) } 1 {} {
703                     mstore(add(result, o), mload(add(subject, o)))
704                     o := add(o, w) // `sub(o, 0x20)`.
705                     if iszero(o) { break }
706                 }
707                 // Zeroize the slot after the string.
708                 mstore(add(add(result, 0x20), resultLength), 0)
709                 // Allocate memory for the length and the bytes,
710                 // rounded up to a multiple of 32.
711                 mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))
712             }
713         }



```

```
LibString.toString(int256) (LlamaPolicy.sol#65-81) uses assembly
	- INLINE ASM (LlamaPolicy.sol#73-80)



    
73         assembly {
74             // We still have some spare memory space on the left,
75             // as we have allocated 3 words (96 bytes) for up to 78 digits.
76             let length := mload(str) // Load the string length.
77             mstore(str, 0x2d) // Store the '-' character.
78             str := sub(str, 1) // Move back the string pointer by a byte.
79             mstore(str, add(length, 1)) // Update the string length.
80         }



```

```
LibString.escapeHTML(string) (LlamaPolicy.sol#915-946) uses assembly
	- INLINE ASM (LlamaPolicy.sol#917-945)



    
917         assembly {
918             for {
919                 let end := add(s, mload(s))
920                 result := add(mload(0x40), 0x20)
921                 // Store the bytes of the packed offsets and strides into the scratch space.
922                 // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.
923                 mstore(0x1f, 0x900094)
924                 mstore(0x08, 0xc0000000a6ab)
925                 // Store "&quot;&amp;&#39;&lt;&gt;" into the scratch space.
926                 mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))
927             } iszero(eq(s, end)) {} {
928                 s := add(s, 1)
929                 let c := and(mload(s), 0xff)
930                 // Not in `["\"","'","&","<",">"]`.
931                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
932                     mstore8(result, c)
933                     result := add(result, 1)
934                     continue
935                 }
936                 let t := shr(248, mload(c))
937                 mstore(result, mload(and(t, 0x1f)))
938                 result := add(result, shr(5, t))
939             }
940             let last := result
941             mstore(last, 0) // Zeroize the slot after the string.
942             result := mload(0x40)
943             mstore(result, sub(last, add(result, 0x20))) // Store the length.
944             mstore(0x40, add(last, 0x20)) // Allocate the memory.
945         }



```

```
LibString.concat(string,string) (LlamaPolicy.sol#836-870) uses assembly
	- INLINE ASM (LlamaPolicy.sol#842-869)



    
842         assembly {
843             let w := not(0x1f)
844             result := mload(0x40)
845             let aLength := mload(a)
846             // Copy `a` one word at a time, backwards.
847             for { let o := and(add(aLength, 0x20), w) } 1 {} {
848                 mstore(add(result, o), mload(add(a, o)))
849                 o := add(o, w) // `sub(o, 0x20)`.
850                 if iszero(o) { break }
851             }
852             let bLength := mload(b)
853             let output := add(result, aLength)
854             // Copy `b` one word at a time, backwards.
855             for { let o := and(add(bLength, 0x20), w) } 1 {} {
856                 mstore(add(output, o), mload(add(b, o)))
857                 o := add(o, w) // `sub(o, 0x20)`.
858                 if iszero(o) { break }
859             }
860             let totalLength := add(aLength, bLength)
861             let last := add(add(result, 0x20), totalLength)
862             // Zeroize the slot after the string.
863             mstore(last, 0)
864             // Stores the length.
865             mstore(result, totalLength)
866             // Allocate memory for the length and the bytes,
867             // rounded up to a multiple of 32.
868             mstore(0x40, and(add(last, 0x1f), w))
869         }



```

```
LibString.repeat(string,uint256) (LlamaPolicy.sol#651-681) uses assembly
	- INLINE ASM (LlamaPolicy.sol#657-680)



    
657         assembly {
658             let subjectLength := mload(subject)
659             if iszero(or(iszero(times), iszero(subjectLength))) {
660                 subject := add(subject, 0x20)
661                 result := mload(0x40)
662                 let output := add(result, 0x20)
663                 for {} 1 {} {
664                     // Copy the `subject` one word at a time.
665                     for { let o := 0 } 1 {} {
666                         mstore(add(output, o), mload(add(subject, o)))
667                         o := add(o, 0x20)
668                         if iszero(lt(o, subjectLength)) { break }
669                     }
670                     output := add(output, subjectLength)
671                     times := sub(times, 1)
672                     if iszero(times) { break }
673                 }
674                 mstore(output, 0) // Zeroize the slot after the string.
675                 let resultLength := sub(output, add(result, 0x20))
676                 mstore(result, resultLength) // Store the length.
677                 // Allocate the memory.
678                 mstore(0x40, add(result, add(resultLength, 0x20)))
679             }
680         }



```

```
Clones.clone(address) (LlamaPolicy.sol#1811-1824) uses assembly
	- INLINE ASM (LlamaPolicy.sol#1813-1820)



    
1813         assembly {
1814             // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
1815             // of the `implementation` address with the bytecode before the address.
1816             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
1817             // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
1818             mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
1819             instance := create(0, 0x09, 0x37)
1820         }



```

```
LibString.runeCount(string) (LlamaPolicy.sol#360-374) uses assembly
	- INLINE ASM (LlamaPolicy.sol#362-373)



    
362         assembly {
363             if mload(s) {
364                 mstore(0x00, div(not(0), 255))
365                 mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)
366                 let o := add(s, 0x20)
367                 let end := add(o, mload(s))
368                 for { result := 1 } 1 { result := add(result, 1) } {
369                     o := add(o, byte(0, mload(shr(250, mload(o)))))
370                     if iszero(lt(o, end)) { break }
371                 }
372             }
373         }



```

```
LibString.packTwo(string,string) (LlamaPolicy.sol#1043-1061) uses assembly
	- INLINE ASM (LlamaPolicy.sol#1045-1060)



    
1045         assembly {
1046             let aLength := mload(a)
1047             // We don't need to zero right pad the strings,
1048             // since this is our own custom non-standard packing scheme.
1049             result :=
1050                 mul(
1051                     // Load the length and the bytes of `a` and `b`.
1052                     or(
1053                         shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),
1054                         mload(sub(add(b, 0x1e), aLength))
1055                     ),
1056                     // `totalLength != 0 && totalLength < 31`. Abuses underflow.
1057                     // Assumes that the lengths are valid and within the block gas limit.
1058                     lt(sub(add(aLength, mload(b)), 1), 0x1e)
1059                 )
1060         }



```

```
LibString.toHexStringNoPrefix(uint256,uint256) (LlamaPolicy.sol#108-156) uses assembly
	- INLINE ASM (LlamaPolicy.sol#114-155)



    
114         assembly {
115             // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes
116             // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.
117             // We add 0x20 to the total and round down to a multiple of 0x20.
118             // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.
119             str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))
120             // Allocate the memory.
121             mstore(0x40, add(str, 0x20))
122             // Zeroize the slot after the string.
123             mstore(str, 0)
124 
125             // Cache the end to calculate the length later.
126             let end := str
127             // Store "0123456789abcdef" in scratch space.
128             mstore(0x0f, 0x30313233343536373839616263646566)
129 
130             let start := sub(str, add(length, length))
131             let w := not(1) // Tsk.
132             let temp := value
133             // We write the string from rightmost digit to leftmost digit.
134             // The following is essentially a do-while loop that also handles the zero case.
135             for {} 1 {} {
136                 str := add(str, w) // `sub(str, 2)`.
137                 mstore8(add(str, 1), mload(and(temp, 15)))
138                 mstore8(str, mload(and(shr(4, temp), 15)))
139                 temp := shr(8, temp)
140                 if iszero(xor(str, start)) { break }
141             }
142 
143             if temp {
144                 // Store the function selector of `HexLengthInsufficient()`.
145                 mstore(0x00, 0x2194895a)
146                 // Revert with (offset, size).
147                 revert(0x1c, 0x04)
148             }
149 
150             // Compute the string's length.
151             let strLength := sub(end, str)
152             // Move the pointer and write the length.
153             str := sub(str, 0x20)
154             mstore(str, strLength)
155         }



```

```
LibString.directReturn(string) (LlamaPolicy.sol#1091-1104) uses assembly
	- INLINE ASM (LlamaPolicy.sol#1092-1103)



    
1092         assembly {
1093             // Assumes that the string does not start from the scratch space.
1094             let retStart := sub(a, 0x20)
1095             let retSize := add(mload(a), 0x40)
1096             // Right pad with zeroes. Just in case the string is produced
1097             // by a method that doesn't zero right pad.
1098             mstore(add(retStart, retSize), 0)
1099             // Store the return offset.
1100             mstore(retStart, 0x20)
1101             // End the transaction, returning the string.
1102             return(retStart, retSize)
1103         }



```

```
LibString.unpackOne(bytes32) (LlamaPolicy.sol#1025-1039) uses assembly
	- INLINE ASM (LlamaPolicy.sol#1027-1038)



    
1027         assembly {
1028             // Grab the free memory pointer.
1029             result := mload(0x40)
1030             // Allocate 2 words (1 for the length, 1 for the bytes).
1031             mstore(0x40, add(result, 0x40))
1032             // Zeroize the length slot.
1033             mstore(result, 0)
1034             // Store the length and bytes.
1035             mstore(add(result, 0x1f), packed)
1036             // Right pad with zeroes.
1037             mstore(add(add(result, 0x20), mload(result)), 0)
1038         }



```

```
Base64.encode(bytes) (LlamaPolicy.sol#1986-2057) uses assembly
	- INLINE ASM (LlamaPolicy.sol#2005-2054)



    
2005         assembly {
2006             // Prepare the lookup table (skip the first "length" byte)
2007             let tablePtr := add(table, 1)
2008 
2009             // Prepare result pointer, jump over length
2010             let resultPtr := add(result, 32)
2011 
2012             // Run over the input, 3 bytes at a time
2013             for {
2014                 let dataPtr := data
2015                 let endPtr := add(data, mload(data))
2016             } lt(dataPtr, endPtr) {
2017 
2018             } {
2019                 // Advance 3 bytes
2020                 dataPtr := add(dataPtr, 3)
2021                 let input := mload(dataPtr)
2022 
2023                 // To write each character, shift the 3 bytes (18 bits) chunk
2024                 // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)
2025                 // and apply logical AND with 0x3F which is the number of
2026                 // the previous character in the ASCII table prior to the Base64 Table
2027                 // The result is then added to the table to get the character to write,
2028                 // and finally write it in the result pointer but with a left shift
2029                 // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits
2030 
2031                 mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))
2032                 resultPtr := add(resultPtr, 1) // Advance
2033 
2034                 mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))
2035                 resultPtr := add(resultPtr, 1) // Advance
2036 
2037                 mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))
2038                 resultPtr := add(resultPtr, 1) // Advance
2039 
2040                 mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))
2041                 resultPtr := add(resultPtr, 1) // Advance
2042             }
2043 
2044             // When data `bytes` is not exactly 3 bytes long
2045             // it is padded with `=` characters at the end
2046             switch mod(mload(data), 3)
2047             case 1 {
2048                 mstore8(sub(resultPtr, 1), 0x3d)
2049                 mstore8(sub(resultPtr, 2), 0x3d)
2050             }
2051             case 2 {
2052                 mstore8(sub(resultPtr, 1), 0x3d)
2053             }
2054         }



```

```
LibString.is7BitASCII(string) (LlamaPolicy.sol#378-400) uses assembly
	- INLINE ASM (LlamaPolicy.sol#380-399)



    
380         assembly {
381             let mask := shl(7, div(not(0), 255))
382             result := 1
383             let n := mload(s)
384             if n {
385                 let o := add(s, 0x20)
386                 let end := add(o, n)
387                 let last := mload(end)
388                 mstore(end, 0)
389                 for {} 1 {} {
390                     if and(mask, mload(o)) {
391                         result := 0
392                         break
393                     }
394                     o := add(o, 0x20)
395                     if iszero(lt(o, end)) { break }
396                 }
397                 mstore(end, last)
398             }
399         }



```

```
LibString.split(string,string) (LlamaPolicy.sol#787-832) uses assembly
	- INLINE ASM (LlamaPolicy.sol#794-831)



    
794         assembly {
795             let w := not(0x1f)
796             let indexPtr := add(indices, 0x20)
797             let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))
798             mstore(add(indicesEnd, w), mload(subject))
799             mstore(indices, add(mload(indices), 1))
800             let prevIndex := 0
801             for {} 1 {} {
802                 let index := mload(indexPtr)
803                 mstore(indexPtr, 0x60)
804                 if iszero(eq(index, prevIndex)) {
805                     let element := mload(0x40)
806                     let elementLength := sub(index, prevIndex)
807                     mstore(element, elementLength)
808                     // Copy the `subject` one word at a time, backwards.
809                     for { let o := and(add(elementLength, 0x1f), w) } 1 {} {
810                         mstore(add(element, o), mload(add(add(subject, prevIndex), o)))
811                         o := add(o, w) // `sub(o, 0x20)`.
812                         if iszero(o) { break }
813                     }
814                     // Zeroize the slot after the string.
815                     mstore(add(add(element, 0x20), elementLength), 0)
816                     // Allocate memory for the length and the bytes,
817                     // rounded up to a multiple of 32.
818                     mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))
819                     // Store the `element` into the array.
820                     mstore(indexPtr, element)
821                 }
822                 prevIndex := add(index, mload(delimiter))
823                 indexPtr := add(indexPtr, 0x20)
824                 if iszero(lt(indexPtr, indicesEnd)) { break }
825             }
826             result := indices
827             if iszero(mload(delimiter)) {
828                 result := add(indices, 0x20)
829                 mstore(result, sub(mload(indices), 2))
830             }
831         }



```

```
LibString.toHexString(bytes) (LlamaPolicy.sol#318-327) uses assembly
	- INLINE ASM (LlamaPolicy.sol#321-326)



    
321         assembly {
322             let strLength := add(mload(str), 2) // Compute the length.
323             mstore(str, 0x3078) // Write the "0x" prefix.
324             str := sub(str, 2) // Move the pointer.
325             mstore(str, strLength) // Write the length.
326         }



```

```
LibString.toCase(string,bool) (LlamaPolicy.sol#874-900) uses assembly
	- INLINE ASM (LlamaPolicy.sol#880-899)



    
880         assembly {
881             let length := mload(subject)
882             if length {
883                 result := add(mload(0x40), 0x20)
884                 subject := add(subject, 1)
885                 let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)
886                 let w := not(0)
887                 for { let o := length } 1 {} {
888                     o := add(o, w)
889                     let b := and(0xff, mload(add(subject, o)))
890                     mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))
891                     if iszero(o) { break }
892                 }
893                 result := mload(0x40)
894                 mstore(result, length) // Store the length.
895                 let last := add(add(result, 0x20), length)
896                 mstore(last, 0) // Zeroize the slot after the string.
897                 mstore(0x40, add(last, 0x20)) // Allocate the memory.
898             }
899         }



```

```
LibString.indexOf(string,string,uint256) (LlamaPolicy.sol#487-540) uses assembly
	- INLINE ASM (LlamaPolicy.sol#493-539)



    
493         assembly {
494             for { let subjectLength := mload(subject) } 1 {} {
495                 if iszero(mload(search)) {
496                     if iszero(gt(from, subjectLength)) {
497                         result := from
498                         break
499                     }
500                     result := subjectLength
501                     break
502                 }
503                 let searchLength := mload(search)
504                 let subjectStart := add(subject, 0x20)
505 
506                 result := not(0) // Initialize to `NOT_FOUND`.
507 
508                 subject := add(subjectStart, from)
509                 let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)
510 
511                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
512                 let s := mload(add(search, 0x20))
513 
514                 if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }
515 
516                 if iszero(lt(searchLength, 0x20)) {
517                     for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
518                         if iszero(shr(m, xor(mload(subject), s))) {
519                             if eq(keccak256(subject, searchLength), h) {
520                                 result := sub(subject, subjectStart)
521                                 break
522                             }
523                         }
524                         subject := add(subject, 1)
525                         if iszero(lt(subject, end)) { break }
526                     }
527                     break
528                 }
529                 for {} 1 {} {
530                     if iszero(shr(m, xor(mload(subject), s))) {
531                         result := sub(subject, subjectStart)
532                         break
533                     }
534                     subject := add(subject, 1)
535                     if iszero(lt(subject, end)) { break }
536                 }
537                 break
538             }
539         }



```

```
LibString.toString(uint256) (LlamaPolicy.sol#27-62) uses assembly
	- INLINE ASM (LlamaPolicy.sol#29-61)



    
29         assembly {
30             // The maximum value of a uint256 contains 78 digits (1 byte per digit), but
31             // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.
32             // We will need 1 word for the trailing zeros padding, 1 word for the length,
33             // and 3 words for a maximum of 78 digits.
34             str := add(mload(0x40), 0x80)
35             // Update the free memory pointer to allocate.
36             mstore(0x40, add(str, 0x20))
37             // Zeroize the slot after the string.
38             mstore(str, 0)
39 
40             // Cache the end of the memory to calculate the length later.
41             let end := str
42 
43             let w := not(0) // Tsk.
44             // We write the string from rightmost digit to leftmost digit.
45             // The following is essentially a do-while loop that also handles the zero case.
46             for { let temp := value } 1 {} {
47                 str := add(str, w) // `sub(str, 1)`.
48                 // Write the character to the pointer.
49                 // The ASCII index of the '0' character is 48.
50                 mstore8(str, add(48, mod(temp, 10)))
51                 // Keep dividing `temp` until zero.
52                 temp := div(temp, 10)
53                 if iszero(temp) { break }
54             }
55 
56             let length := sub(end, str)
57             // Move the pointer 32 bytes leftwards to make room for the length.
58             str := sub(str, 0x20)
59             // Store the length.
60             mstore(str, length)
61         }



```

```
Clones.cloneDeterministic(address,bytes32) (LlamaPolicy.sol#1833-1846) uses assembly
	- INLINE ASM (LlamaPolicy.sol#1835-1842)



    
1835         assembly {
1836             // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
1837             // of the `implementation` address with the bytecode before the address.
1838             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
1839             // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
1840             mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
1841             instance := create2(0, 0x09, 0x37, salt)
1842         }



```

```
LibString.unpackTwo(bytes32) (LlamaPolicy.sol#1066-1088) uses assembly
	- INLINE ASM (LlamaPolicy.sol#1072-1087)



    
1072         assembly {
1073             // Grab the free memory pointer.
1074             resultA := mload(0x40)
1075             resultB := add(resultA, 0x40)
1076             // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.
1077             mstore(0x40, add(resultB, 0x40))
1078             // Zeroize the length slots.
1079             mstore(resultA, 0)
1080             mstore(resultB, 0)
1081             // Store the lengths and bytes.
1082             mstore(add(resultA, 0x1f), packed)
1083             mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))
1084             // Right pad with zeroes.
1085             mstore(add(add(resultA, 0x20), mload(resultA)), 0)
1086             mstore(add(add(resultB, 0x20), mload(resultB)), 0)
1087         }



```

```
Clones.predictDeterministicAddress(address,bytes32,address) (LlamaPolicy.sol#1851-1867) uses assembly
	- INLINE ASM (LlamaPolicy.sol#1857-1866)



    
1857         assembly {
1858             let ptr := mload(0x40)
1859             mstore(add(ptr, 0x38), deployer)
1860             mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)
1861             mstore(add(ptr, 0x14), implementation)
1862             mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)
1863             mstore(add(ptr, 0x58), salt)
1864             mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))
1865             predicted := keccak256(add(ptr, 0x43), 0x55)
1866         }



```

```
Checkpoints._unsafeAccess(Checkpoints.Checkpoint[],uint256) (LlamaPolicy.sol#1327-1336) uses assembly
	- INLINE ASM (LlamaPolicy.sol#1332-1335)



    
1332         assembly {
1333             mstore(0, self.slot)
1334             result.slot := add(keccak256(0, 0x20), pos)
1335         }



```

```
LibString.escapeJSON(string) (LlamaPolicy.sol#949-995) uses assembly
	- INLINE ASM (LlamaPolicy.sol#951-994)



    
951         assembly {
952             for {
953                 let end := add(s, mload(s))
954                 result := add(mload(0x40), 0x20)
955                 // Store "\\u0000" in scratch space.
956                 // Store "0123456789abcdef" in scratch space.
957                 // Also, store `{0x08:"b", 0x09:"t", 0x0a:"n", 0x0c:"f", 0x0d:"r"}`.
958                 // into the scratch space.
959                 mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)
960                 // Bitmask for detecting `["\"","\\"]`.
961                 let e := or(shl(0x22, 1), shl(0x5c, 1))
962             } iszero(eq(s, end)) {} {
963                 s := add(s, 1)
964                 let c := and(mload(s), 0xff)
965                 if iszero(lt(c, 0x20)) {
966                     if iszero(and(shl(c, 1), e)) {
967                         // Not in `["\"","\\"]`.
968                         mstore8(result, c)
969                         result := add(result, 1)
970                         continue
971                     }
972                     mstore8(result, 0x5c) // "\\".
973                     mstore8(add(result, 1), c)
974                     result := add(result, 2)
975                     continue
976                 }
977                 if iszero(and(shl(c, 1), 0x3700)) {
978                     // Not in `["\b","\t","\n","\f","\d"]`.
979                     mstore8(0x1d, mload(shr(4, c))) // Hex value.
980                     mstore8(0x1e, mload(and(c, 15))) // Hex value.
981                     mstore(result, mload(0x19)) // "\\u00XX".
982                     result := add(result, 6)
983                     continue
984                 }
985                 mstore8(result, 0x5c) // "\\".
986                 mstore8(add(result, 1), mload(add(c, 8)))
987                 result := add(result, 2)
988             }
989             let last := result
990             mstore(last, 0) // Zeroize the slot after the string.
991             result := mload(0x40)
992             mstore(result, sub(last, add(result, 0x20))) // Store the length.
993             mstore(0x40, add(last, 0x20)) // Allocate the memory.
994         }



```

```
LibString.toMinimalHexStringNoPrefix(uint256) (LlamaPolicy.sol#192-201) uses assembly
	- INLINE ASM (LlamaPolicy.sol#195-200)



    
195         assembly {
196             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
197             let strLength := mload(str) // Get the length.
198             str := add(str, o) // Move the pointer, accounting for leading zero.
199             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
200         }



```

```
LibString.indicesOf(string,string) (LlamaPolicy.sol#728-784) uses assembly
	- INLINE ASM (LlamaPolicy.sol#734-783)



    
734         assembly {
735             let subjectLength := mload(subject)
736             let searchLength := mload(search)
737 
738             if iszero(gt(searchLength, subjectLength)) {
739                 subject := add(subject, 0x20)
740                 search := add(search, 0x20)
741                 result := add(mload(0x40), 0x20)
742 
743                 let subjectStart := subject
744                 let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)
745                 let h := 0
746                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
747                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
748                 let s := mload(search)
749                 for {} 1 {} {
750                     let t := mload(subject)
751                     // Whether the first `searchLength % 32` bytes of
752                     // `subject` and `search` matches.
753                     if iszero(shr(m, xor(t, s))) {
754                         if h {
755                             if iszero(eq(keccak256(subject, searchLength), h)) {
756                                 subject := add(subject, 1)
757                                 if iszero(lt(subject, subjectSearchEnd)) { break }
758                                 continue
759                             }
760                         }
761                         // Append to `result`.
762                         mstore(result, sub(subject, subjectStart))
763                         result := add(result, 0x20)
764                         // Advance `subject` by `searchLength`.
765                         subject := add(subject, searchLength)
766                         if searchLength {
767                             if iszero(lt(subject, subjectSearchEnd)) { break }
768                             continue
769                         }
770                     }
771                     subject := add(subject, 1)
772                     if iszero(lt(subject, subjectSearchEnd)) { break }
773                 }
774                 let resultEnd := result
775                 // Assign `result` to the free memory pointer.
776                 result := mload(0x40)
777                 // Store the length of `result`.
778                 mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))
779                 // Allocate memory for result.
780                 // We allocate one more word, so this array can be recycled for {split}.
781                 mstore(0x40, add(resultEnd, 0x20))
782             }
783         }



```

```
LibString.toHexString(address) (LlamaPolicy.sol#268-277) uses assembly
	- INLINE ASM (LlamaPolicy.sol#271-276)



    
271         assembly {
272             let strLength := add(mload(str), 2) // Compute the length.
273             mstore(str, 0x3078) // Write the "0x" prefix.
274             str := sub(str, 2) // Move the pointer.
275             mstore(str, strLength) // Write the length.
276         }



```

```
LibString.eq(string,string) (LlamaPolicy.sol#998-1002) uses assembly
	- INLINE ASM (LlamaPolicy.sol#999-1001)



    
999         assembly {
1000             result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))
1001         }



```

```
LibString.toHexStringNoPrefix(uint256) (LlamaPolicy.sol#207-241) uses assembly
	- INLINE ASM (LlamaPolicy.sol#209-240)



    
209         assembly {
210             // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,
211             // 0x02 bytes for the prefix, and 0x40 bytes for the digits.
212             // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.
213             str := add(mload(0x40), 0x80)
214             // Allocate the memory.
215             mstore(0x40, add(str, 0x20))
216             // Zeroize the slot after the string.
217             mstore(str, 0)
218 
219             // Cache the end to calculate the length later.
220             let end := str
221             // Store "0123456789abcdef" in scratch space.
222             mstore(0x0f, 0x30313233343536373839616263646566)
223 
224             let w := not(1) // Tsk.
225             // We write the string from rightmost digit to leftmost digit.
226             // The following is essentially a do-while loop that also handles the zero case.
227             for { let temp := value } 1 {} {
228                 str := add(str, w) // `sub(str, 2)`.
229                 mstore8(add(str, 1), mload(and(temp, 15)))
230                 mstore8(str, mload(and(shr(4, temp), 15)))
231                 temp := shr(8, temp)
232                 if iszero(temp) { break }
233             }
234 
235             // Compute the string's length.
236             let strLength := sub(end, str)
237             // Move the pointer and write the length.
238             str := sub(str, 0x20)
239             mstore(str, strLength)
240         }



```

```
Checkpoints.sqrt(uint256) (LlamaPolicy.sol#1350-1412) uses assembly
	- INLINE ASM (LlamaPolicy.sol#1351-1411)



    
1351         assembly {
1352             let y := x // We start y at x, which will help us make our initial estimate.
1353 
1354             z := 181 // The "correct" value is 1, but this saves a multiplication later.
1355 
1356             // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad
1357             // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.
1358 
1359             // We check y >= 2^(k + 8) but shift right by k bits
1360             // each branch to ensure that if x >= 256, then y >= 256.
1361             if iszero(lt(y, 0x10000000000000000000000000000000000)) {
1362                 y := shr(128, y)
1363                 z := shl(64, z)
1364             }
1365             if iszero(lt(y, 0x1000000000000000000)) {
1366                 y := shr(64, y)
1367                 z := shl(32, z)
1368             }
1369             if iszero(lt(y, 0x10000000000)) {
1370                 y := shr(32, y)
1371                 z := shl(16, z)
1372             }
1373             if iszero(lt(y, 0x1000000)) {
1374                 y := shr(16, y)
1375                 z := shl(8, z)
1376             }
1377 
1378             // Goal was to get z*z*y within a small factor of x. More iterations could
1379             // get y in a tighter range. Currently, we will have y in [256, 256*2^16).
1380             // We ensured y >= 256 so that the relative difference between y and y+1 is small.
1381             // That's not possible if x < 256 but we can just verify those cases exhaustively.
1382 
1383             // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.
1384             // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.
1385             // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.
1386 
1387             // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range
1388             // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.
1389 
1390             // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate
1391             // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.
1392 
1393             // There is no overflow risk here since y < 2^136 after the first branch above.
1394             z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.
1395 
1396             // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.
1397             z := shr(1, add(z, div(x, z)))
1398             z := shr(1, add(z, div(x, z)))
1399             z := shr(1, add(z, div(x, z)))
1400             z := shr(1, add(z, div(x, z)))
1401             z := shr(1, add(z, div(x, z)))
1402             z := shr(1, add(z, div(x, z)))
1403             z := shr(1, add(z, div(x, z)))
1404 
1405             // If x+1 is a perfect square, the Babylonian method cycles between
1406             // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.
1407             // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division
1408             // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.
1409             // If you don't care whether the floor or ceil square root is returned, you can remove this statement.
1410             z := sub(z, lt(div(x, z), z))
1411         }



```

```
LibString.packOne(string) (LlamaPolicy.sol#1006-1020) uses assembly
	- INLINE ASM (LlamaPolicy.sol#1008-1019)



    
1008         assembly {
1009             // We don't need to zero right pad the string,
1010             // since this is our own custom non-standard packing scheme.
1011             result :=
1012                 mul(
1013                     // Load the length and the bytes.
1014                     mload(add(a, 0x1f)),
1015                     // `length != 0 && length < 32`. Abuses underflow.
1016                     // Assumes that the length is valid and within the block gas limit.
1017                     lt(sub(mload(a), 1), 0x1f)
1018                 )
1019         }



```

```
LibString.startsWith(string,string) (LlamaPolicy.sol#602-620) uses assembly
	- INLINE ASM (LlamaPolicy.sol#608-619)



    
608         assembly {
609             let searchLength := mload(search)
610             // Just using keccak256 directly is actually cheaper.
611             // forgefmt: disable-next-item
612             result := and(
613                 iszero(gt(searchLength, mload(subject))),
614                 eq(
615                     keccak256(add(subject, 0x20), searchLength),
616                     keccak256(add(search, 0x20), searchLength)
617                 )
618             )
619         }



```

```
LibString.toHexStringNoPrefix(bytes) (LlamaPolicy.sol#331-353) uses assembly
	- INLINE ASM (LlamaPolicy.sol#333-352)



    
333         assembly {
334             let length := mload(raw)
335             str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.
336             mstore(str, add(length, length)) // Store the length of the output.
337 
338             // Store "0123456789abcdef" in scratch space.
339             mstore(0x0f, 0x30313233343536373839616263646566)
340 
341             let o := add(str, 0x20)
342             let end := add(raw, length)
343 
344             for {} iszero(eq(raw, end)) {} {
345                 raw := add(raw, 1)
346                 mstore8(add(o, 1), mload(and(mload(raw), 15)))
347                 mstore8(o, mload(and(shr(4, mload(raw)), 15)))
348                 o := add(o, 2)
349             }
350             mstore(o, 0) // Zeroize the slot after the string.
351             mstore(0x40, add(o, 0x20)) // Allocate the memory.
352         }



```

```
LibString.toHexStringChecksummed(address) (LlamaPolicy.sol#247-264) uses assembly
	- INLINE ASM (LlamaPolicy.sol#250-263)



    
250         assembly {
251             let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`
252             let o := add(str, 0x22)
253             let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `
254             let t := shl(240, 136) // `0b10001000 << 240`
255             for { let i := 0 } 1 {} {
256                 mstore(add(i, i), mul(t, byte(i, hashed)))
257                 i := add(i, 1)
258                 if eq(i, 20) { break }
259             }
260             mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))
261             o := add(o, 0x20)
262             mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))
263         }



```

```
LibString.lastIndexOf(string,string,uint256) (LlamaPolicy.sol#556-588) uses assembly
	- INLINE ASM (LlamaPolicy.sol#562-587)



    
562         assembly {
563             for {} 1 {} {
564                 result := not(0) // Initialize to `NOT_FOUND`.
565                 let searchLength := mload(search)
566                 if gt(searchLength, mload(subject)) { break }
567                 let w := result
568 
569                 let fromMax := sub(mload(subject), searchLength)
570                 if iszero(gt(fromMax, from)) { from := fromMax }
571 
572                 let end := add(add(subject, 0x20), w)
573                 subject := add(add(subject, 0x20), from)
574                 if iszero(gt(subject, end)) { break }
575                 // As this function is not too often used,
576                 // we shall simply use keccak256 for smaller bytecode size.
577                 for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
578                     if eq(keccak256(subject, searchLength), h) {
579                         result := sub(subject, add(end, 1))
580                         break
581                     }
582                     subject := add(subject, w) // `sub(subject, 1)`.
583                     if iszero(gt(subject, end)) { break }
584                 }
585                 break
586             }
587         }



```

```
LibString.toHexString(uint256) (LlamaPolicy.sol#162-171) uses assembly
	- INLINE ASM (LlamaPolicy.sol#165-170)



    
165         assembly {
166             let strLength := add(mload(str), 2) // Compute the length.
167             mstore(str, 0x3078) // Write the "0x" prefix.
168             str := sub(str, 2) // Move the pointer.
169             mstore(str, strLength) // Write the length.
170         }



```

```
LibString.replace(string,string,string) (LlamaPolicy.sol#410-482) uses assembly
	- INLINE ASM (LlamaPolicy.sol#416-481)



    
416         assembly {
417             let subjectLength := mload(subject)
418             let searchLength := mload(search)
419             let replacementLength := mload(replacement)
420 
421             subject := add(subject, 0x20)
422             search := add(search, 0x20)
423             replacement := add(replacement, 0x20)
424             result := add(mload(0x40), 0x20)
425 
426             let subjectEnd := add(subject, subjectLength)
427             if iszero(gt(searchLength, subjectLength)) {
428                 let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)
429                 let h := 0
430                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
431                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
432                 let s := mload(search)
433                 for {} 1 {} {
434                     let t := mload(subject)
435                     // Whether the first `searchLength % 32` bytes of
436                     // `subject` and `search` matches.
437                     if iszero(shr(m, xor(t, s))) {
438                         if h {
439                             if iszero(eq(keccak256(subject, searchLength), h)) {
440                                 mstore(result, t)
441                                 result := add(result, 1)
442                                 subject := add(subject, 1)
443                                 if iszero(lt(subject, subjectSearchEnd)) { break }
444                                 continue
445                             }
446                         }
447                         // Copy the `replacement` one word at a time.
448                         for { let o := 0 } 1 {} {
449                             mstore(add(result, o), mload(add(replacement, o)))
450                             o := add(o, 0x20)
451                             if iszero(lt(o, replacementLength)) { break }
452                         }
453                         result := add(result, replacementLength)
454                         subject := add(subject, searchLength)
455                         if searchLength {
456                             if iszero(lt(subject, subjectSearchEnd)) { break }
457                             continue
458                         }
459                     }
460                     mstore(result, t)
461                     result := add(result, 1)
462                     subject := add(subject, 1)
463                     if iszero(lt(subject, subjectSearchEnd)) { break }
464                 }
465             }
466 
467             let resultRemainder := result
468             result := add(mload(0x40), 0x20)
469             let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))
470             // Copy the rest of the string one word at a time.
471             for {} lt(subject, subjectEnd) {} {
472                 mstore(resultRemainder, mload(subject))
473                 resultRemainder := add(resultRemainder, 0x20)
474                 subject := add(subject, 0x20)
475             }
476             result := sub(result, 0x20)
477             let last := add(add(result, 0x20), k) // Zeroize the slot after the string.
478             mstore(last, 0)
479             mstore(0x40, add(last, 0x20)) // Allocate the memory.
480             mstore(result, k) // Store the length.
481         }



```

```
LibString.toHexString(uint256,uint256) (LlamaPolicy.sol#92-101) uses assembly
	- INLINE ASM (LlamaPolicy.sol#95-100)



    
95         assembly {
96             let strLength := add(mload(str), 2) // Compute the length.
97             mstore(str, 0x3078) // Write the "0x" prefix.
98             str := sub(str, 2) // Move the pointer.
99             mstore(str, strLength) // Write the length.
100         }



```

```
LibString.endsWith(string,string) (LlamaPolicy.sol#623-648) uses assembly
	- INLINE ASM (LlamaPolicy.sol#629-647)



    
629         assembly {
630             let searchLength := mload(search)
631             let subjectLength := mload(subject)
632             // Whether `search` is not longer than `subject`.
633             let withinRange := iszero(gt(searchLength, subjectLength))
634             // Just using keccak256 directly is actually cheaper.
635             // forgefmt: disable-next-item
636             result := and(
637                 withinRange,
638                 eq(
639                     keccak256(
640                         // `subject + 0x20 + max(subjectLength - searchLength, 0)`.
641                         add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),
642                         searchLength
643                     ),
644                     keccak256(add(search, 0x20), searchLength)
645                 )
646             )
647         }



```

```
LibString.toMinimalHexString(uint256) (LlamaPolicy.sol#177-187) uses assembly
	- INLINE ASM (LlamaPolicy.sol#180-186)



    
180         assembly {
181             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
182             let strLength := add(mload(str), 2) // Compute the length.
183             mstore(add(str, o), 0x3078) // Write the "0x" prefix, accounting for leading zero.
184             str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.
185             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
186         }



```

### LlamaPolicyMetadata.sol


```
LibString.indicesOf(string,string) (LlamaPolicyMetadata.sol#816-872) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#822-871)



    
822         assembly {
823             let subjectLength := mload(subject)
824             let searchLength := mload(search)
825 
826             if iszero(gt(searchLength, subjectLength)) {
827                 subject := add(subject, 0x20)
828                 search := add(search, 0x20)
829                 result := add(mload(0x40), 0x20)
830 
831                 let subjectStart := subject
832                 let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)
833                 let h := 0
834                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
835                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
836                 let s := mload(search)
837                 for {} 1 {} {
838                     let t := mload(subject)
839                     // Whether the first `searchLength % 32` bytes of
840                     // `subject` and `search` matches.
841                     if iszero(shr(m, xor(t, s))) {
842                         if h {
843                             if iszero(eq(keccak256(subject, searchLength), h)) {
844                                 subject := add(subject, 1)
845                                 if iszero(lt(subject, subjectSearchEnd)) { break }
846                                 continue
847                             }
848                         }
849                         // Append to `result`.
850                         mstore(result, sub(subject, subjectStart))
851                         result := add(result, 0x20)
852                         // Advance `subject` by `searchLength`.
853                         subject := add(subject, searchLength)
854                         if searchLength {
855                             if iszero(lt(subject, subjectSearchEnd)) { break }
856                             continue
857                         }
858                     }
859                     subject := add(subject, 1)
860                     if iszero(lt(subject, subjectSearchEnd)) { break }
861                 }
862                 let resultEnd := result
863                 // Assign `result` to the free memory pointer.
864                 result := mload(0x40)
865                 // Store the length of `result`.
866                 mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))
867                 // Allocate memory for result.
868                 // We allocate one more word, so this array can be recycled for {split}.
869                 mstore(0x40, add(resultEnd, 0x20))
870             }
871         }



```

```
LibString.replace(string,string,string) (LlamaPolicyMetadata.sol#498-570) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#504-569)



    
504         assembly {
505             let subjectLength := mload(subject)
506             let searchLength := mload(search)
507             let replacementLength := mload(replacement)
508 
509             subject := add(subject, 0x20)
510             search := add(search, 0x20)
511             replacement := add(replacement, 0x20)
512             result := add(mload(0x40), 0x20)
513 
514             let subjectEnd := add(subject, subjectLength)
515             if iszero(gt(searchLength, subjectLength)) {
516                 let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)
517                 let h := 0
518                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
519                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
520                 let s := mload(search)
521                 for {} 1 {} {
522                     let t := mload(subject)
523                     // Whether the first `searchLength % 32` bytes of
524                     // `subject` and `search` matches.
525                     if iszero(shr(m, xor(t, s))) {
526                         if h {
527                             if iszero(eq(keccak256(subject, searchLength), h)) {
528                                 mstore(result, t)
529                                 result := add(result, 1)
530                                 subject := add(subject, 1)
531                                 if iszero(lt(subject, subjectSearchEnd)) { break }
532                                 continue
533                             }
534                         }
535                         // Copy the `replacement` one word at a time.
536                         for { let o := 0 } 1 {} {
537                             mstore(add(result, o), mload(add(replacement, o)))
538                             o := add(o, 0x20)
539                             if iszero(lt(o, replacementLength)) { break }
540                         }
541                         result := add(result, replacementLength)
542                         subject := add(subject, searchLength)
543                         if searchLength {
544                             if iszero(lt(subject, subjectSearchEnd)) { break }
545                             continue
546                         }
547                     }
548                     mstore(result, t)
549                     result := add(result, 1)
550                     subject := add(subject, 1)
551                     if iszero(lt(subject, subjectSearchEnd)) { break }
552                 }
553             }
554 
555             let resultRemainder := result
556             result := add(mload(0x40), 0x20)
557             let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))
558             // Copy the rest of the string one word at a time.
559             for {} lt(subject, subjectEnd) {} {
560                 mstore(resultRemainder, mload(subject))
561                 resultRemainder := add(resultRemainder, 0x20)
562                 subject := add(subject, 0x20)
563             }
564             result := sub(result, 0x20)
565             let last := add(add(result, 0x20), k) // Zeroize the slot after the string.
566             mstore(last, 0)
567             mstore(0x40, add(last, 0x20)) // Allocate the memory.
568             mstore(result, k) // Store the length.
569         }



```

```
Base64.encode(bytes) (LlamaPolicyMetadata.sol#18-89) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#37-86)



    
37         assembly {
38             // Prepare the lookup table (skip the first "length" byte)
39             let tablePtr := add(table, 1)
40 
41             // Prepare result pointer, jump over length
42             let resultPtr := add(result, 32)
43 
44             // Run over the input, 3 bytes at a time
45             for {
46                 let dataPtr := data
47                 let endPtr := add(data, mload(data))
48             } lt(dataPtr, endPtr) {
49 
50             } {
51                 // Advance 3 bytes
52                 dataPtr := add(dataPtr, 3)
53                 let input := mload(dataPtr)
54 
55                 // To write each character, shift the 3 bytes (18 bits) chunk
56                 // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)
57                 // and apply logical AND with 0x3F which is the number of
58                 // the previous character in the ASCII table prior to the Base64 Table
59                 // The result is then added to the table to get the character to write,
60                 // and finally write it in the result pointer but with a left shift
61                 // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits
62 
63                 mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))
64                 resultPtr := add(resultPtr, 1) // Advance
65 
66                 mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))
67                 resultPtr := add(resultPtr, 1) // Advance
68 
69                 mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))
70                 resultPtr := add(resultPtr, 1) // Advance
71 
72                 mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))
73                 resultPtr := add(resultPtr, 1) // Advance
74             }
75 
76             // When data `bytes` is not exactly 3 bytes long
77             // it is padded with `=` characters at the end
78             switch mod(mload(data), 3)
79             case 1 {
80                 mstore8(sub(resultPtr, 1), 0x3d)
81                 mstore8(sub(resultPtr, 2), 0x3d)
82             }
83             case 2 {
84                 mstore8(sub(resultPtr, 1), 0x3d)
85             }
86         }



```

```
LibString.toString(int256) (LlamaPolicyMetadata.sol#153-169) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#161-168)



    
161         assembly {
162             // We still have some spare memory space on the left,
163             // as we have allocated 3 words (96 bytes) for up to 78 digits.
164             let length := mload(str) // Load the string length.
165             mstore(str, 0x2d) // Store the '-' character.
166             str := sub(str, 1) // Move back the string pointer by a byte.
167             mstore(str, add(length, 1)) // Update the string length.
168         }



```

```
LibString.split(string,string) (LlamaPolicyMetadata.sol#875-920) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#882-919)



    
882         assembly {
883             let w := not(0x1f)
884             let indexPtr := add(indices, 0x20)
885             let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))
886             mstore(add(indicesEnd, w), mload(subject))
887             mstore(indices, add(mload(indices), 1))
888             let prevIndex := 0
889             for {} 1 {} {
890                 let index := mload(indexPtr)
891                 mstore(indexPtr, 0x60)
892                 if iszero(eq(index, prevIndex)) {
893                     let element := mload(0x40)
894                     let elementLength := sub(index, prevIndex)
895                     mstore(element, elementLength)
896                     // Copy the `subject` one word at a time, backwards.
897                     for { let o := and(add(elementLength, 0x1f), w) } 1 {} {
898                         mstore(add(element, o), mload(add(add(subject, prevIndex), o)))
899                         o := add(o, w) // `sub(o, 0x20)`.
900                         if iszero(o) { break }
901                     }
902                     // Zeroize the slot after the string.
903                     mstore(add(add(element, 0x20), elementLength), 0)
904                     // Allocate memory for the length and the bytes,
905                     // rounded up to a multiple of 32.
906                     mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))
907                     // Store the `element` into the array.
908                     mstore(indexPtr, element)
909                 }
910                 prevIndex := add(index, mload(delimiter))
911                 indexPtr := add(indexPtr, 0x20)
912                 if iszero(lt(indexPtr, indicesEnd)) { break }
913             }
914             result := indices
915             if iszero(mload(delimiter)) {
916                 result := add(indices, 0x20)
917                 mstore(result, sub(mload(indices), 2))
918             }
919         }



```

```
LibString.toHexStringNoPrefix(uint256,uint256) (LlamaPolicyMetadata.sol#196-244) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#202-243)



    
202         assembly {
203             // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes
204             // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.
205             // We add 0x20 to the total and round down to a multiple of 0x20.
206             // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.
207             str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))
208             // Allocate the memory.
209             mstore(0x40, add(str, 0x20))
210             // Zeroize the slot after the string.
211             mstore(str, 0)
212 
213             // Cache the end to calculate the length later.
214             let end := str
215             // Store "0123456789abcdef" in scratch space.
216             mstore(0x0f, 0x30313233343536373839616263646566)
217 
218             let start := sub(str, add(length, length))
219             let w := not(1) // Tsk.
220             let temp := value
221             // We write the string from rightmost digit to leftmost digit.
222             // The following is essentially a do-while loop that also handles the zero case.
223             for {} 1 {} {
224                 str := add(str, w) // `sub(str, 2)`.
225                 mstore8(add(str, 1), mload(and(temp, 15)))
226                 mstore8(str, mload(and(shr(4, temp), 15)))
227                 temp := shr(8, temp)
228                 if iszero(xor(str, start)) { break }
229             }
230 
231             if temp {
232                 // Store the function selector of `HexLengthInsufficient()`.
233                 mstore(0x00, 0x2194895a)
234                 // Revert with (offset, size).
235                 revert(0x1c, 0x04)
236             }
237 
238             // Compute the string's length.
239             let strLength := sub(end, str)
240             // Move the pointer and write the length.
241             str := sub(str, 0x20)
242             mstore(str, strLength)
243         }



```

```
LibString.startsWith(string,string) (LlamaPolicyMetadata.sol#690-708) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#696-707)



    
696         assembly {
697             let searchLength := mload(search)
698             // Just using keccak256 directly is actually cheaper.
699             // forgefmt: disable-next-item
700             result := and(
701                 iszero(gt(searchLength, mload(subject))),
702                 eq(
703                     keccak256(add(subject, 0x20), searchLength),
704                     keccak256(add(search, 0x20), searchLength)
705                 )
706             )
707         }



```

```
LibString.runeCount(string) (LlamaPolicyMetadata.sol#448-462) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#450-461)



    
450         assembly {
451             if mload(s) {
452                 mstore(0x00, div(not(0), 255))
453                 mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)
454                 let o := add(s, 0x20)
455                 let end := add(o, mload(s))
456                 for { result := 1 } 1 { result := add(result, 1) } {
457                     o := add(o, byte(0, mload(shr(250, mload(o)))))
458                     if iszero(lt(o, end)) { break }
459                 }
460             }
461         }



```

```
LibString.lastIndexOf(string,string,uint256) (LlamaPolicyMetadata.sol#644-676) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#650-675)



    
650         assembly {
651             for {} 1 {} {
652                 result := not(0) // Initialize to `NOT_FOUND`.
653                 let searchLength := mload(search)
654                 if gt(searchLength, mload(subject)) { break }
655                 let w := result
656 
657                 let fromMax := sub(mload(subject), searchLength)
658                 if iszero(gt(fromMax, from)) { from := fromMax }
659 
660                 let end := add(add(subject, 0x20), w)
661                 subject := add(add(subject, 0x20), from)
662                 if iszero(gt(subject, end)) { break }
663                 // As this function is not too often used,
664                 // we shall simply use keccak256 for smaller bytecode size.
665                 for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
666                     if eq(keccak256(subject, searchLength), h) {
667                         result := sub(subject, add(end, 1))
668                         break
669                     }
670                     subject := add(subject, w) // `sub(subject, 1)`.
671                     if iszero(gt(subject, end)) { break }
672                 }
673                 break
674             }
675         }



```

```
LibString.toHexStringNoPrefix(bytes) (LlamaPolicyMetadata.sol#419-441) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#421-440)



    
421         assembly {
422             let length := mload(raw)
423             str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.
424             mstore(str, add(length, length)) // Store the length of the output.
425 
426             // Store "0123456789abcdef" in scratch space.
427             mstore(0x0f, 0x30313233343536373839616263646566)
428 
429             let o := add(str, 0x20)
430             let end := add(raw, length)
431 
432             for {} iszero(eq(raw, end)) {} {
433                 raw := add(raw, 1)
434                 mstore8(add(o, 1), mload(and(mload(raw), 15)))
435                 mstore8(o, mload(and(shr(4, mload(raw)), 15)))
436                 o := add(o, 2)
437             }
438             mstore(o, 0) // Zeroize the slot after the string.
439             mstore(0x40, add(o, 0x20)) // Allocate the memory.
440         }



```

```
LibString.slice(string,uint256,uint256) (LlamaPolicyMetadata.sol#773-802) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#779-801)



    
779         assembly {
780             let subjectLength := mload(subject)
781             if iszero(gt(subjectLength, end)) { end := subjectLength }
782             if iszero(gt(subjectLength, start)) { start := subjectLength }
783             if lt(start, end) {
784                 result := mload(0x40)
785                 let resultLength := sub(end, start)
786                 mstore(result, resultLength)
787                 subject := add(subject, start)
788                 let w := not(0x1f)
789                 // Copy the `subject` one word at a time, backwards.
790                 for { let o := and(add(resultLength, 0x1f), w) } 1 {} {
791                     mstore(add(result, o), mload(add(subject, o)))
792                     o := add(o, w) // `sub(o, 0x20)`.
793                     if iszero(o) { break }
794                 }
795                 // Zeroize the slot after the string.
796                 mstore(add(add(result, 0x20), resultLength), 0)
797                 // Allocate memory for the length and the bytes,
798                 // rounded up to a multiple of 32.
799                 mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))
800             }
801         }



```

```
LibString.toCase(string,bool) (LlamaPolicyMetadata.sol#962-988) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#968-987)



    
968         assembly {
969             let length := mload(subject)
970             if length {
971                 result := add(mload(0x40), 0x20)
972                 subject := add(subject, 1)
973                 let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)
974                 let w := not(0)
975                 for { let o := length } 1 {} {
976                     o := add(o, w)
977                     let b := and(0xff, mload(add(subject, o)))
978                     mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))
979                     if iszero(o) { break }
980                 }
981                 result := mload(0x40)
982                 mstore(result, length) // Store the length.
983                 let last := add(add(result, 0x20), length)
984                 mstore(last, 0) // Zeroize the slot after the string.
985                 mstore(0x40, add(last, 0x20)) // Allocate the memory.
986             }
987         }



```

```
LibString.toHexString(uint256) (LlamaPolicyMetadata.sol#250-259) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#253-258)



    
253         assembly {
254             let strLength := add(mload(str), 2) // Compute the length.
255             mstore(str, 0x3078) // Write the "0x" prefix.
256             str := sub(str, 2) // Move the pointer.
257             mstore(str, strLength) // Write the length.
258         }



```

```
LibString.packTwo(string,string) (LlamaPolicyMetadata.sol#1131-1149) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#1133-1148)



    
1133         assembly {
1134             let aLength := mload(a)
1135             // We don't need to zero right pad the strings,
1136             // since this is our own custom non-standard packing scheme.
1137             result :=
1138                 mul(
1139                     // Load the length and the bytes of `a` and `b`.
1140                     or(
1141                         shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),
1142                         mload(sub(add(b, 0x1e), aLength))
1143                     ),
1144                     // `totalLength != 0 && totalLength < 31`. Abuses underflow.
1145                     // Assumes that the lengths are valid and within the block gas limit.
1146                     lt(sub(add(aLength, mload(b)), 1), 0x1e)
1147                 )
1148         }



```

```
LibString.escapeHTML(string) (LlamaPolicyMetadata.sol#1003-1034) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#1005-1033)



    
1005         assembly {
1006             for {
1007                 let end := add(s, mload(s))
1008                 result := add(mload(0x40), 0x20)
1009                 // Store the bytes of the packed offsets and strides into the scratch space.
1010                 // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.
1011                 mstore(0x1f, 0x900094)
1012                 mstore(0x08, 0xc0000000a6ab)
1013                 // Store "&quot;&amp;&#39;&lt;&gt;" into the scratch space.
1014                 mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))
1015             } iszero(eq(s, end)) {} {
1016                 s := add(s, 1)
1017                 let c := and(mload(s), 0xff)
1018                 // Not in `["\"","'","&","<",">"]`.
1019                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
1020                     mstore8(result, c)
1021                     result := add(result, 1)
1022                     continue
1023                 }
1024                 let t := shr(248, mload(c))
1025                 mstore(result, mload(and(t, 0x1f)))
1026                 result := add(result, shr(5, t))
1027             }
1028             let last := result
1029             mstore(last, 0) // Zeroize the slot after the string.
1030             result := mload(0x40)
1031             mstore(result, sub(last, add(result, 0x20))) // Store the length.
1032             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1033         }



```

```
LibString.toHexStringNoPrefix(address) (LlamaPolicyMetadata.sol#369-402) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#371-401)



    
371         assembly {
372             str := mload(0x40)
373 
374             // Allocate the memory.
375             // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,
376             // 0x02 bytes for the prefix, and 0x28 bytes for the digits.
377             // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.
378             mstore(0x40, add(str, 0x80))
379 
380             // Store "0123456789abcdef" in scratch space.
381             mstore(0x0f, 0x30313233343536373839616263646566)
382 
383             str := add(str, 2)
384             mstore(str, 40)
385 
386             let o := add(str, 0x20)
387             mstore(add(o, 40), 0)
388 
389             value := shl(96, value)
390 
391             // We write the string from rightmost digit to leftmost digit.
392             // The following is essentially a do-while loop that also handles the zero case.
393             for { let i := 0 } 1 {} {
394                 let p := add(o, add(i, i))
395                 let temp := byte(i, value)
396                 mstore8(add(p, 1), mload(and(temp, 15)))
397                 mstore8(p, mload(shr(4, temp)))
398                 i := add(i, 1)
399                 if eq(i, 20) { break }
400             }
401         }



```

```
LibString.concat(string,string) (LlamaPolicyMetadata.sol#924-958) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#930-957)



    
930         assembly {
931             let w := not(0x1f)
932             result := mload(0x40)
933             let aLength := mload(a)
934             // Copy `a` one word at a time, backwards.
935             for { let o := and(add(aLength, 0x20), w) } 1 {} {
936                 mstore(add(result, o), mload(add(a, o)))
937                 o := add(o, w) // `sub(o, 0x20)`.
938                 if iszero(o) { break }
939             }
940             let bLength := mload(b)
941             let output := add(result, aLength)
942             // Copy `b` one word at a time, backwards.
943             for { let o := and(add(bLength, 0x20), w) } 1 {} {
944                 mstore(add(output, o), mload(add(b, o)))
945                 o := add(o, w) // `sub(o, 0x20)`.
946                 if iszero(o) { break }
947             }
948             let totalLength := add(aLength, bLength)
949             let last := add(add(result, 0x20), totalLength)
950             // Zeroize the slot after the string.
951             mstore(last, 0)
952             // Stores the length.
953             mstore(result, totalLength)
954             // Allocate memory for the length and the bytes,
955             // rounded up to a multiple of 32.
956             mstore(0x40, and(add(last, 0x1f), w))
957         }



```

```
LibString.eq(string,string) (LlamaPolicyMetadata.sol#1086-1090) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#1087-1089)



    
1087         assembly {
1088             result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))
1089         }



```

```
LibString.unpackOne(bytes32) (LlamaPolicyMetadata.sol#1113-1127) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#1115-1126)



    
1115         assembly {
1116             // Grab the free memory pointer.
1117             result := mload(0x40)
1118             // Allocate 2 words (1 for the length, 1 for the bytes).
1119             mstore(0x40, add(result, 0x40))
1120             // Zeroize the length slot.
1121             mstore(result, 0)
1122             // Store the length and bytes.
1123             mstore(add(result, 0x1f), packed)
1124             // Right pad with zeroes.
1125             mstore(add(add(result, 0x20), mload(result)), 0)
1126         }



```

```
LibString.toMinimalHexStringNoPrefix(uint256) (LlamaPolicyMetadata.sol#280-289) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#283-288)



    
283         assembly {
284             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
285             let strLength := mload(str) // Get the length.
286             str := add(str, o) // Move the pointer, accounting for leading zero.
287             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
288         }



```

```
LibString.packOne(string) (LlamaPolicyMetadata.sol#1094-1108) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#1096-1107)



    
1096         assembly {
1097             // We don't need to zero right pad the string,
1098             // since this is our own custom non-standard packing scheme.
1099             result :=
1100                 mul(
1101                     // Load the length and the bytes.
1102                     mload(add(a, 0x1f)),
1103                     // `length != 0 && length < 32`. Abuses underflow.
1104                     // Assumes that the length is valid and within the block gas limit.
1105                     lt(sub(mload(a), 1), 0x1f)
1106                 )
1107         }



```

```
LibString.repeat(string,uint256) (LlamaPolicyMetadata.sol#739-769) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#745-768)



    
745         assembly {
746             let subjectLength := mload(subject)
747             if iszero(or(iszero(times), iszero(subjectLength))) {
748                 subject := add(subject, 0x20)
749                 result := mload(0x40)
750                 let output := add(result, 0x20)
751                 for {} 1 {} {
752                     // Copy the `subject` one word at a time.
753                     for { let o := 0 } 1 {} {
754                         mstore(add(output, o), mload(add(subject, o)))
755                         o := add(o, 0x20)
756                         if iszero(lt(o, subjectLength)) { break }
757                     }
758                     output := add(output, subjectLength)
759                     times := sub(times, 1)
760                     if iszero(times) { break }
761                 }
762                 mstore(output, 0) // Zeroize the slot after the string.
763                 let resultLength := sub(output, add(result, 0x20))
764                 mstore(result, resultLength) // Store the length.
765                 // Allocate the memory.
766                 mstore(0x40, add(result, add(resultLength, 0x20)))
767             }
768         }



```

```
LibString.escapeJSON(string) (LlamaPolicyMetadata.sol#1037-1083) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#1039-1082)



    
1039         assembly {
1040             for {
1041                 let end := add(s, mload(s))
1042                 result := add(mload(0x40), 0x20)
1043                 // Store "\\u0000" in scratch space.
1044                 // Store "0123456789abcdef" in scratch space.
1045                 // Also, store `{0x08:"b", 0x09:"t", 0x0a:"n", 0x0c:"f", 0x0d:"r"}`.
1046                 // into the scratch space.
1047                 mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)
1048                 // Bitmask for detecting `["\"","\\"]`.
1049                 let e := or(shl(0x22, 1), shl(0x5c, 1))
1050             } iszero(eq(s, end)) {} {
1051                 s := add(s, 1)
1052                 let c := and(mload(s), 0xff)
1053                 if iszero(lt(c, 0x20)) {
1054                     if iszero(and(shl(c, 1), e)) {
1055                         // Not in `["\"","\\"]`.
1056                         mstore8(result, c)
1057                         result := add(result, 1)
1058                         continue
1059                     }
1060                     mstore8(result, 0x5c) // "\\".
1061                     mstore8(add(result, 1), c)
1062                     result := add(result, 2)
1063                     continue
1064                 }
1065                 if iszero(and(shl(c, 1), 0x3700)) {
1066                     // Not in `["\b","\t","\n","\f","\d"]`.
1067                     mstore8(0x1d, mload(shr(4, c))) // Hex value.
1068                     mstore8(0x1e, mload(and(c, 15))) // Hex value.
1069                     mstore(result, mload(0x19)) // "\\u00XX".
1070                     result := add(result, 6)
1071                     continue
1072                 }
1073                 mstore8(result, 0x5c) // "\\".
1074                 mstore8(add(result, 1), mload(add(c, 8)))
1075                 result := add(result, 2)
1076             }
1077             let last := result
1078             mstore(last, 0) // Zeroize the slot after the string.
1079             result := mload(0x40)
1080             mstore(result, sub(last, add(result, 0x20))) // Store the length.
1081             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1082         }



```

```
LibString.toHexString(bytes) (LlamaPolicyMetadata.sol#406-415) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#409-414)



    
409         assembly {
410             let strLength := add(mload(str), 2) // Compute the length.
411             mstore(str, 0x3078) // Write the "0x" prefix.
412             str := sub(str, 2) // Move the pointer.
413             mstore(str, strLength) // Write the length.
414         }



```

```
LibString.directReturn(string) (LlamaPolicyMetadata.sol#1179-1192) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#1180-1191)



    
1180         assembly {
1181             // Assumes that the string does not start from the scratch space.
1182             let retStart := sub(a, 0x20)
1183             let retSize := add(mload(a), 0x40)
1184             // Right pad with zeroes. Just in case the string is produced
1185             // by a method that doesn't zero right pad.
1186             mstore(add(retStart, retSize), 0)
1187             // Store the return offset.
1188             mstore(retStart, 0x20)
1189             // End the transaction, returning the string.
1190             return(retStart, retSize)
1191         }



```

```
LibString.toMinimalHexString(uint256) (LlamaPolicyMetadata.sol#265-275) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#268-274)



    
268         assembly {
269             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
270             let strLength := add(mload(str), 2) // Compute the length.
271             mstore(add(str, o), 0x3078) // Write the "0x" prefix, accounting for leading zero.
272             str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.
273             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
274         }



```

```
LibString.toHexString(uint256,uint256) (LlamaPolicyMetadata.sol#180-189) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#183-188)



    
183         assembly {
184             let strLength := add(mload(str), 2) // Compute the length.
185             mstore(str, 0x3078) // Write the "0x" prefix.
186             str := sub(str, 2) // Move the pointer.
187             mstore(str, strLength) // Write the length.
188         }



```

```
LibString.unpackTwo(bytes32) (LlamaPolicyMetadata.sol#1154-1176) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#1160-1175)



    
1160         assembly {
1161             // Grab the free memory pointer.
1162             resultA := mload(0x40)
1163             resultB := add(resultA, 0x40)
1164             // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.
1165             mstore(0x40, add(resultB, 0x40))
1166             // Zeroize the length slots.
1167             mstore(resultA, 0)
1168             mstore(resultB, 0)
1169             // Store the lengths and bytes.
1170             mstore(add(resultA, 0x1f), packed)
1171             mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))
1172             // Right pad with zeroes.
1173             mstore(add(add(resultA, 0x20), mload(resultA)), 0)
1174             mstore(add(add(resultB, 0x20), mload(resultB)), 0)
1175         }



```

```
LibString.toHexStringChecksummed(address) (LlamaPolicyMetadata.sol#335-352) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#338-351)



    
338         assembly {
339             let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`
340             let o := add(str, 0x22)
341             let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `
342             let t := shl(240, 136) // `0b10001000 << 240`
343             for { let i := 0 } 1 {} {
344                 mstore(add(i, i), mul(t, byte(i, hashed)))
345                 i := add(i, 1)
346                 if eq(i, 20) { break }
347             }
348             mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))
349             o := add(o, 0x20)
350             mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))
351         }



```

```
LibString.endsWith(string,string) (LlamaPolicyMetadata.sol#711-736) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#717-735)



    
717         assembly {
718             let searchLength := mload(search)
719             let subjectLength := mload(subject)
720             // Whether `search` is not longer than `subject`.
721             let withinRange := iszero(gt(searchLength, subjectLength))
722             // Just using keccak256 directly is actually cheaper.
723             // forgefmt: disable-next-item
724             result := and(
725                 withinRange,
726                 eq(
727                     keccak256(
728                         // `subject + 0x20 + max(subjectLength - searchLength, 0)`.
729                         add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),
730                         searchLength
731                     ),
732                     keccak256(add(search, 0x20), searchLength)
733                 )
734             )
735         }



```

```
LibString.indexOf(string,string,uint256) (LlamaPolicyMetadata.sol#575-628) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#581-627)



    
581         assembly {
582             for { let subjectLength := mload(subject) } 1 {} {
583                 if iszero(mload(search)) {
584                     if iszero(gt(from, subjectLength)) {
585                         result := from
586                         break
587                     }
588                     result := subjectLength
589                     break
590                 }
591                 let searchLength := mload(search)
592                 let subjectStart := add(subject, 0x20)
593 
594                 result := not(0) // Initialize to `NOT_FOUND`.
595 
596                 subject := add(subjectStart, from)
597                 let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)
598 
599                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
600                 let s := mload(add(search, 0x20))
601 
602                 if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }
603 
604                 if iszero(lt(searchLength, 0x20)) {
605                     for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
606                         if iszero(shr(m, xor(mload(subject), s))) {
607                             if eq(keccak256(subject, searchLength), h) {
608                                 result := sub(subject, subjectStart)
609                                 break
610                             }
611                         }
612                         subject := add(subject, 1)
613                         if iszero(lt(subject, end)) { break }
614                     }
615                     break
616                 }
617                 for {} 1 {} {
618                     if iszero(shr(m, xor(mload(subject), s))) {
619                         result := sub(subject, subjectStart)
620                         break
621                     }
622                     subject := add(subject, 1)
623                     if iszero(lt(subject, end)) { break }
624                 }
625                 break
626             }
627         }



```

```
LibString.toString(uint256) (LlamaPolicyMetadata.sol#115-150) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#117-149)



    
117         assembly {
118             // The maximum value of a uint256 contains 78 digits (1 byte per digit), but
119             // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.
120             // We will need 1 word for the trailing zeros padding, 1 word for the length,
121             // and 3 words for a maximum of 78 digits.
122             str := add(mload(0x40), 0x80)
123             // Update the free memory pointer to allocate.
124             mstore(0x40, add(str, 0x20))
125             // Zeroize the slot after the string.
126             mstore(str, 0)
127 
128             // Cache the end of the memory to calculate the length later.
129             let end := str
130 
131             let w := not(0) // Tsk.
132             // We write the string from rightmost digit to leftmost digit.
133             // The following is essentially a do-while loop that also handles the zero case.
134             for { let temp := value } 1 {} {
135                 str := add(str, w) // `sub(str, 1)`.
136                 // Write the character to the pointer.
137                 // The ASCII index of the '0' character is 48.
138                 mstore8(str, add(48, mod(temp, 10)))
139                 // Keep dividing `temp` until zero.
140                 temp := div(temp, 10)
141                 if iszero(temp) { break }
142             }
143 
144             let length := sub(end, str)
145             // Move the pointer 32 bytes leftwards to make room for the length.
146             str := sub(str, 0x20)
147             // Store the length.
148             mstore(str, length)
149         }



```

```
LibString.toHexString(address) (LlamaPolicyMetadata.sol#356-365) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#359-364)



    
359         assembly {
360             let strLength := add(mload(str), 2) // Compute the length.
361             mstore(str, 0x3078) // Write the "0x" prefix.
362             str := sub(str, 2) // Move the pointer.
363             mstore(str, strLength) // Write the length.
364         }



```

```
LibString.toHexStringNoPrefix(uint256) (LlamaPolicyMetadata.sol#295-329) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#297-328)



    
297         assembly {
298             // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,
299             // 0x02 bytes for the prefix, and 0x40 bytes for the digits.
300             // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.
301             str := add(mload(0x40), 0x80)
302             // Allocate the memory.
303             mstore(0x40, add(str, 0x20))
304             // Zeroize the slot after the string.
305             mstore(str, 0)
306 
307             // Cache the end to calculate the length later.
308             let end := str
309             // Store "0123456789abcdef" in scratch space.
310             mstore(0x0f, 0x30313233343536373839616263646566)
311 
312             let w := not(1) // Tsk.
313             // We write the string from rightmost digit to leftmost digit.
314             // The following is essentially a do-while loop that also handles the zero case.
315             for { let temp := value } 1 {} {
316                 str := add(str, w) // `sub(str, 2)`.
317                 mstore8(add(str, 1), mload(and(temp, 15)))
318                 mstore8(str, mload(and(shr(4, temp), 15)))
319                 temp := shr(8, temp)
320                 if iszero(temp) { break }
321             }
322 
323             // Compute the string's length.
324             let strLength := sub(end, str)
325             // Move the pointer and write the length.
326             str := sub(str, 0x20)
327             mstore(str, strLength)
328         }



```

```
LibString.is7BitASCII(string) (LlamaPolicyMetadata.sol#466-488) uses assembly
	- INLINE ASM (LlamaPolicyMetadata.sol#468-487)



    
468         assembly {
469             let mask := shl(7, div(not(0), 255))
470             result := 1
471             let n := mload(s)
472             if n {
473                 let o := add(s, 0x20)
474                 let end := add(o, n)
475                 let last := mload(end)
476                 mstore(end, 0)
477                 for {} 1 {} {
478                     if and(mask, mload(o)) {
479                         result := 0
480                         break
481                     }
482                     o := add(o, 0x20)
483                     if iszero(lt(o, end)) { break }
484                 }
485                 mstore(end, last)
486             }
487         }



```

### LlamaRelativeQuorum.sol


```
LibString.toHexStringChecksummed(address) (LlamaRelativeQuorum.sol#943-960) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#946-959)



    
946         assembly {
947             let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`
948             let o := add(str, 0x22)
949             let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `
950             let t := shl(240, 136) // `0b10001000 << 240`
951             for { let i := 0 } 1 {} {
952                 mstore(add(i, i), mul(t, byte(i, hashed)))
953                 i := add(i, 1)
954                 if eq(i, 20) { break }
955             }
956             mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))
957             o := add(o, 0x20)
958             mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))
959         }



```

```
LibString.packOne(string) (LlamaRelativeQuorum.sol#1702-1716) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#1704-1715)



    
1704         assembly {
1705             // We don't need to zero right pad the string,
1706             // since this is our own custom non-standard packing scheme.
1707             result :=
1708                 mul(
1709                     // Load the length and the bytes.
1710                     mload(add(a, 0x1f)),
1711                     // `length != 0 && length < 32`. Abuses underflow.
1712                     // Assumes that the length is valid and within the block gas limit.
1713                     lt(sub(mload(a), 1), 0x1f)
1714                 )
1715         }



```

```
FixedPointMathLib.mulDivUp(uint256,uint256,uint256) (LlamaRelativeQuorum.sol#236-252) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#242-251)



    
242         assembly {
243             // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))
244             if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {
245                 revert(0, 0)
246             }
247 
248             // If x * y modulo the denominator is strictly greater than 0,
249             // 1 is added to round up the division of x * y by the denominator.
250             z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))
251         }



```

```
FixedPointMathLib.sqrt(uint256) (LlamaRelativeQuorum.sol#347-410) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#349-409)



    
349         assembly {
350             let y := x // We start y at x, which will help us make our initial estimate.
351 
352             z := 181 // The "correct" value is 1, but this saves a multiplication later.
353 
354             // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad
355             // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.
356 
357             // We check y >= 2^(k + 8) but shift right by k bits
358             // each branch to ensure that if x >= 256, then y >= 256.
359             if iszero(lt(y, 0x10000000000000000000000000000000000)) {
360                 y := shr(128, y)
361                 z := shl(64, z)
362             }
363             if iszero(lt(y, 0x1000000000000000000)) {
364                 y := shr(64, y)
365                 z := shl(32, z)
366             }
367             if iszero(lt(y, 0x10000000000)) {
368                 y := shr(32, y)
369                 z := shl(16, z)
370             }
371             if iszero(lt(y, 0x1000000)) {
372                 y := shr(16, y)
373                 z := shl(8, z)
374             }
375 
376             // Goal was to get z*z*y within a small factor of x. More iterations could
377             // get y in a tighter range. Currently, we will have y in [256, 256*2^16).
378             // We ensured y >= 256 so that the relative difference between y and y+1 is small.
379             // That's not possible if x < 256 but we can just verify those cases exhaustively.
380 
381             // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.
382             // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.
383             // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.
384 
385             // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range
386             // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.
387 
388             // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate
389             // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.
390 
391             // There is no overflow risk here since y < 2^136 after the first branch above.
392             z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.
393 
394             // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.
395             z := shr(1, add(z, div(x, z)))
396             z := shr(1, add(z, div(x, z)))
397             z := shr(1, add(z, div(x, z)))
398             z := shr(1, add(z, div(x, z)))
399             z := shr(1, add(z, div(x, z)))
400             z := shr(1, add(z, div(x, z)))
401             z := shr(1, add(z, div(x, z)))
402 
403             // If x+1 is a perfect square, the Babylonian method cycles between
404             // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.
405             // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division
406             // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.
407             // If you don't care whether the floor or ceil square root is returned, you can remove this statement.
408             z := sub(z, lt(div(x, z), z))
409         }



```

```
LibString.toHexStringNoPrefix(bytes) (LlamaRelativeQuorum.sol#1027-1049) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#1029-1048)



    
1029         assembly {
1030             let length := mload(raw)
1031             str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.
1032             mstore(str, add(length, length)) // Store the length of the output.
1033 
1034             // Store "0123456789abcdef" in scratch space.
1035             mstore(0x0f, 0x30313233343536373839616263646566)
1036 
1037             let o := add(str, 0x20)
1038             let end := add(raw, length)
1039 
1040             for {} iszero(eq(raw, end)) {} {
1041                 raw := add(raw, 1)
1042                 mstore8(add(o, 1), mload(and(mload(raw), 15)))
1043                 mstore8(o, mload(and(shr(4, mload(raw)), 15)))
1044                 o := add(o, 2)
1045             }
1046             mstore(o, 0) // Zeroize the slot after the string.
1047             mstore(0x40, add(o, 0x20)) // Allocate the memory.
1048         }



```

```
LibString.toString(int256) (LlamaRelativeQuorum.sol#761-777) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#769-776)



    
769         assembly {
770             // We still have some spare memory space on the left,
771             // as we have allocated 3 words (96 bytes) for up to 78 digits.
772             let length := mload(str) // Load the string length.
773             mstore(str, 0x2d) // Store the '-' character.
774             str := sub(str, 1) // Move back the string pointer by a byte.
775             mstore(str, add(length, 1)) // Update the string length.
776         }



```

```
Base64.encode(bytes) (LlamaRelativeQuorum.sol#2811-2882) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#2830-2879)



    
2830         assembly {
2831             // Prepare the lookup table (skip the first "length" byte)
2832             let tablePtr := add(table, 1)
2833 
2834             // Prepare result pointer, jump over length
2835             let resultPtr := add(result, 32)
2836 
2837             // Run over the input, 3 bytes at a time
2838             for {
2839                 let dataPtr := data
2840                 let endPtr := add(data, mload(data))
2841             } lt(dataPtr, endPtr) {
2842 
2843             } {
2844                 // Advance 3 bytes
2845                 dataPtr := add(dataPtr, 3)
2846                 let input := mload(dataPtr)
2847 
2848                 // To write each character, shift the 3 bytes (18 bits) chunk
2849                 // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)
2850                 // and apply logical AND with 0x3F which is the number of
2851                 // the previous character in the ASCII table prior to the Base64 Table
2852                 // The result is then added to the table to get the character to write,
2853                 // and finally write it in the result pointer but with a left shift
2854                 // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits
2855 
2856                 mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))
2857                 resultPtr := add(resultPtr, 1) // Advance
2858 
2859                 mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))
2860                 resultPtr := add(resultPtr, 1) // Advance
2861 
2862                 mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))
2863                 resultPtr := add(resultPtr, 1) // Advance
2864 
2865                 mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))
2866                 resultPtr := add(resultPtr, 1) // Advance
2867             }
2868 
2869             // When data `bytes` is not exactly 3 bytes long
2870             // it is padded with `=` characters at the end
2871             switch mod(mload(data), 3)
2872             case 1 {
2873                 mstore8(sub(resultPtr, 1), 0x3d)
2874                 mstore8(sub(resultPtr, 2), 0x3d)
2875             }
2876             case 2 {
2877                 mstore8(sub(resultPtr, 1), 0x3d)
2878             }
2879         }



```

```
FixedPointMathLib.unsafeDivUp(uint256,uint256) (LlamaRelativeQuorum.sol#430-437) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#432-436)



    
432         assembly {
433             // Add 1 to x * y if x % y > 0. Note this will
434             // return 0 instead of reverting if y is zero.
435             z := add(gt(mod(x, y), 0), div(x, y))
436         }



```

```
LibString.packTwo(string,string) (LlamaRelativeQuorum.sol#1739-1757) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#1741-1756)



    
1741         assembly {
1742             let aLength := mload(a)
1743             // We don't need to zero right pad the strings,
1744             // since this is our own custom non-standard packing scheme.
1745             result :=
1746                 mul(
1747                     // Load the length and the bytes of `a` and `b`.
1748                     or(
1749                         shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),
1750                         mload(sub(add(b, 0x1e), aLength))
1751                     ),
1752                     // `totalLength != 0 && totalLength < 31`. Abuses underflow.
1753                     // Assumes that the lengths are valid and within the block gas limit.
1754                     lt(sub(add(aLength, mload(b)), 1), 0x1e)
1755                 )
1756         }



```

```
LibString.toString(uint256) (LlamaRelativeQuorum.sol#723-758) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#725-757)



    
725         assembly {
726             // The maximum value of a uint256 contains 78 digits (1 byte per digit), but
727             // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.
728             // We will need 1 word for the trailing zeros padding, 1 word for the length,
729             // and 3 words for a maximum of 78 digits.
730             str := add(mload(0x40), 0x80)
731             // Update the free memory pointer to allocate.
732             mstore(0x40, add(str, 0x20))
733             // Zeroize the slot after the string.
734             mstore(str, 0)
735 
736             // Cache the end of the memory to calculate the length later.
737             let end := str
738 
739             let w := not(0) // Tsk.
740             // We write the string from rightmost digit to leftmost digit.
741             // The following is essentially a do-while loop that also handles the zero case.
742             for { let temp := value } 1 {} {
743                 str := add(str, w) // `sub(str, 1)`.
744                 // Write the character to the pointer.
745                 // The ASCII index of the '0' character is 48.
746                 mstore8(str, add(48, mod(temp, 10)))
747                 // Keep dividing `temp` until zero.
748                 temp := div(temp, 10)
749                 if iszero(temp) { break }
750             }
751 
752             let length := sub(end, str)
753             // Move the pointer 32 bytes leftwards to make room for the length.
754             str := sub(str, 0x20)
755             // Store the length.
756             mstore(str, length)
757         }



```

```
Clones.cloneDeterministic(address,bytes32) (LlamaRelativeQuorum.sol#536-549) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#538-545)



    
538         assembly {
539             // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
540             // of the `implementation` address with the bytecode before the address.
541             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
542             // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
543             mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
544             instance := create2(0, 0x09, 0x37, salt)
545         }



```

```
FixedPointMathLib.unsafeMod(uint256,uint256) (LlamaRelativeQuorum.sol#412-419) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#414-418)



    
414         assembly {
415             // Mod x by y. Note this will return
416             // 0 instead of reverting if y is zero.
417             z := mod(x, y)
418         }



```

```
LibString.runeCount(string) (LlamaRelativeQuorum.sol#1056-1070) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#1058-1069)



    
1058         assembly {
1059             if mload(s) {
1060                 mstore(0x00, div(not(0), 255))
1061                 mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)
1062                 let o := add(s, 0x20)
1063                 let end := add(o, mload(s))
1064                 for { result := 1 } 1 { result := add(result, 1) } {
1065                     o := add(o, byte(0, mload(shr(250, mload(o)))))
1066                     if iszero(lt(o, end)) { break }
1067                 }
1068             }
1069         }



```

```
LibString.toMinimalHexStringNoPrefix(uint256) (LlamaRelativeQuorum.sol#888-897) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#891-896)



    
891         assembly {
892             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
893             let strLength := mload(str) // Get the length.
894             str := add(str, o) // Move the pointer, accounting for leading zero.
895             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
896         }



```

```
LibString.toHexStringNoPrefix(uint256,uint256) (LlamaRelativeQuorum.sol#804-852) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#810-851)



    
810         assembly {
811             // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes
812             // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.
813             // We add 0x20 to the total and round down to a multiple of 0x20.
814             // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.
815             str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))
816             // Allocate the memory.
817             mstore(0x40, add(str, 0x20))
818             // Zeroize the slot after the string.
819             mstore(str, 0)
820 
821             // Cache the end to calculate the length later.
822             let end := str
823             // Store "0123456789abcdef" in scratch space.
824             mstore(0x0f, 0x30313233343536373839616263646566)
825 
826             let start := sub(str, add(length, length))
827             let w := not(1) // Tsk.
828             let temp := value
829             // We write the string from rightmost digit to leftmost digit.
830             // The following is essentially a do-while loop that also handles the zero case.
831             for {} 1 {} {
832                 str := add(str, w) // `sub(str, 2)`.
833                 mstore8(add(str, 1), mload(and(temp, 15)))
834                 mstore8(str, mload(and(shr(4, temp), 15)))
835                 temp := shr(8, temp)
836                 if iszero(xor(str, start)) { break }
837             }
838 
839             if temp {
840                 // Store the function selector of `HexLengthInsufficient()`.
841                 mstore(0x00, 0x2194895a)
842                 // Revert with (offset, size).
843                 revert(0x1c, 0x04)
844             }
845 
846             // Compute the string's length.
847             let strLength := sub(end, str)
848             // Move the pointer and write the length.
849             str := sub(str, 0x20)
850             mstore(str, strLength)
851         }



```

```
LibString.endsWith(string,string) (LlamaRelativeQuorum.sol#1319-1344) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#1325-1343)



    
1325         assembly {
1326             let searchLength := mload(search)
1327             let subjectLength := mload(subject)
1328             // Whether `search` is not longer than `subject`.
1329             let withinRange := iszero(gt(searchLength, subjectLength))
1330             // Just using keccak256 directly is actually cheaper.
1331             // forgefmt: disable-next-item
1332             result := and(
1333                 withinRange,
1334                 eq(
1335                     keccak256(
1336                         // `subject + 0x20 + max(subjectLength - searchLength, 0)`.
1337                         add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),
1338                         searchLength
1339                     ),
1340                     keccak256(add(search, 0x20), searchLength)
1341                 )
1342             )
1343         }



```

```
LibString.toHexStringNoPrefix(uint256) (LlamaRelativeQuorum.sol#903-937) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#905-936)



    
905         assembly {
906             // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,
907             // 0x02 bytes for the prefix, and 0x40 bytes for the digits.
908             // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.
909             str := add(mload(0x40), 0x80)
910             // Allocate the memory.
911             mstore(0x40, add(str, 0x20))
912             // Zeroize the slot after the string.
913             mstore(str, 0)
914 
915             // Cache the end to calculate the length later.
916             let end := str
917             // Store "0123456789abcdef" in scratch space.
918             mstore(0x0f, 0x30313233343536373839616263646566)
919 
920             let w := not(1) // Tsk.
921             // We write the string from rightmost digit to leftmost digit.
922             // The following is essentially a do-while loop that also handles the zero case.
923             for { let temp := value } 1 {} {
924                 str := add(str, w) // `sub(str, 2)`.
925                 mstore8(add(str, 1), mload(and(temp, 15)))
926                 mstore8(str, mload(and(shr(4, temp), 15)))
927                 temp := shr(8, temp)
928                 if iszero(temp) { break }
929             }
930 
931             // Compute the string's length.
932             let strLength := sub(end, str)
933             // Move the pointer and write the length.
934             str := sub(str, 0x20)
935             mstore(str, strLength)
936         }



```

```
LibString.toMinimalHexString(uint256) (LlamaRelativeQuorum.sol#873-883) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#876-882)



    
876         assembly {
877             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
878             let strLength := add(mload(str), 2) // Compute the length.
879             mstore(add(str, o), 0x3078) // Write the "0x" prefix, accounting for leading zero.
880             str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.
881             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
882         }



```

```
Checkpoints._unsafeAccess(Checkpoints.Checkpoint[],uint256) (LlamaRelativeQuorum.sol#1998-2007) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#2003-2006)



    
2003         assembly {
2004             mstore(0, self.slot)
2005             result.slot := add(keccak256(0, 0x20), pos)
2006         }



```

```
LibString.concat(string,string) (LlamaRelativeQuorum.sol#1532-1566) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#1538-1565)



    
1538         assembly {
1539             let w := not(0x1f)
1540             result := mload(0x40)
1541             let aLength := mload(a)
1542             // Copy `a` one word at a time, backwards.
1543             for { let o := and(add(aLength, 0x20), w) } 1 {} {
1544                 mstore(add(result, o), mload(add(a, o)))
1545                 o := add(o, w) // `sub(o, 0x20)`.
1546                 if iszero(o) { break }
1547             }
1548             let bLength := mload(b)
1549             let output := add(result, aLength)
1550             // Copy `b` one word at a time, backwards.
1551             for { let o := and(add(bLength, 0x20), w) } 1 {} {
1552                 mstore(add(output, o), mload(add(b, o)))
1553                 o := add(o, w) // `sub(o, 0x20)`.
1554                 if iszero(o) { break }
1555             }
1556             let totalLength := add(aLength, bLength)
1557             let last := add(add(result, 0x20), totalLength)
1558             // Zeroize the slot after the string.
1559             mstore(last, 0)
1560             // Stores the length.
1561             mstore(result, totalLength)
1562             // Allocate memory for the length and the bytes,
1563             // rounded up to a multiple of 32.
1564             mstore(0x40, and(add(last, 0x1f), w))
1565         }



```

```
LibString.eq(string,string) (LlamaRelativeQuorum.sol#1694-1698) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#1695-1697)



    
1695         assembly {
1696             result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))
1697         }



```

```
Checkpoints.sqrt(uint256) (LlamaRelativeQuorum.sol#2021-2083) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#2022-2082)



    
2022         assembly {
2023             let y := x // We start y at x, which will help us make our initial estimate.
2024 
2025             z := 181 // The "correct" value is 1, but this saves a multiplication later.
2026 
2027             // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad
2028             // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.
2029 
2030             // We check y >= 2^(k + 8) but shift right by k bits
2031             // each branch to ensure that if x >= 256, then y >= 256.
2032             if iszero(lt(y, 0x10000000000000000000000000000000000)) {
2033                 y := shr(128, y)
2034                 z := shl(64, z)
2035             }
2036             if iszero(lt(y, 0x1000000000000000000)) {
2037                 y := shr(64, y)
2038                 z := shl(32, z)
2039             }
2040             if iszero(lt(y, 0x10000000000)) {
2041                 y := shr(32, y)
2042                 z := shl(16, z)
2043             }
2044             if iszero(lt(y, 0x1000000)) {
2045                 y := shr(16, y)
2046                 z := shl(8, z)
2047             }
2048 
2049             // Goal was to get z*z*y within a small factor of x. More iterations could
2050             // get y in a tighter range. Currently, we will have y in [256, 256*2^16).
2051             // We ensured y >= 256 so that the relative difference between y and y+1 is small.
2052             // That's not possible if x < 256 but we can just verify those cases exhaustively.
2053 
2054             // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.
2055             // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.
2056             // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.
2057 
2058             // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range
2059             // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.
2060 
2061             // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate
2062             // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.
2063 
2064             // There is no overflow risk here since y < 2^136 after the first branch above.
2065             z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.
2066 
2067             // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.
2068             z := shr(1, add(z, div(x, z)))
2069             z := shr(1, add(z, div(x, z)))
2070             z := shr(1, add(z, div(x, z)))
2071             z := shr(1, add(z, div(x, z)))
2072             z := shr(1, add(z, div(x, z)))
2073             z := shr(1, add(z, div(x, z)))
2074             z := shr(1, add(z, div(x, z)))
2075 
2076             // If x+1 is a perfect square, the Babylonian method cycles between
2077             // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.
2078             // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division
2079             // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.
2080             // If you don't care whether the floor or ceil square root is returned, you can remove this statement.
2081             z := sub(z, lt(div(x, z), z))
2082         }



```

```
LibString.toHexString(uint256,uint256) (LlamaRelativeQuorum.sol#788-797) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#791-796)



    
791         assembly {
792             let strLength := add(mload(str), 2) // Compute the length.
793             mstore(str, 0x3078) // Write the "0x" prefix.
794             str := sub(str, 2) // Move the pointer.
795             mstore(str, strLength) // Write the length.
796         }



```

```
LibString.toCase(string,bool) (LlamaRelativeQuorum.sol#1570-1596) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#1576-1595)



    
1576         assembly {
1577             let length := mload(subject)
1578             if length {
1579                 result := add(mload(0x40), 0x20)
1580                 subject := add(subject, 1)
1581                 let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)
1582                 let w := not(0)
1583                 for { let o := length } 1 {} {
1584                     o := add(o, w)
1585                     let b := and(0xff, mload(add(subject, o)))
1586                     mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))
1587                     if iszero(o) { break }
1588                 }
1589                 result := mload(0x40)
1590                 mstore(result, length) // Store the length.
1591                 let last := add(add(result, 0x20), length)
1592                 mstore(last, 0) // Zeroize the slot after the string.
1593                 mstore(0x40, add(last, 0x20)) // Allocate the memory.
1594             }
1595         }



```

```
LibString.escapeHTML(string) (LlamaRelativeQuorum.sol#1611-1642) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#1613-1641)



    
1613         assembly {
1614             for {
1615                 let end := add(s, mload(s))
1616                 result := add(mload(0x40), 0x20)
1617                 // Store the bytes of the packed offsets and strides into the scratch space.
1618                 // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.
1619                 mstore(0x1f, 0x900094)
1620                 mstore(0x08, 0xc0000000a6ab)
1621                 // Store "&quot;&amp;&#39;&lt;&gt;" into the scratch space.
1622                 mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))
1623             } iszero(eq(s, end)) {} {
1624                 s := add(s, 1)
1625                 let c := and(mload(s), 0xff)
1626                 // Not in `["\"","'","&","<",">"]`.
1627                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
1628                     mstore8(result, c)
1629                     result := add(result, 1)
1630                     continue
1631                 }
1632                 let t := shr(248, mload(c))
1633                 mstore(result, mload(and(t, 0x1f)))
1634                 result := add(result, shr(5, t))
1635             }
1636             let last := result
1637             mstore(last, 0) // Zeroize the slot after the string.
1638             result := mload(0x40)
1639             mstore(result, sub(last, add(result, 0x20))) // Store the length.
1640             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1641         }



```

```
LibString.directReturn(string) (LlamaRelativeQuorum.sol#1787-1800) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#1788-1799)



    
1788         assembly {
1789             // Assumes that the string does not start from the scratch space.
1790             let retStart := sub(a, 0x20)
1791             let retSize := add(mload(a), 0x40)
1792             // Right pad with zeroes. Just in case the string is produced
1793             // by a method that doesn't zero right pad.
1794             mstore(add(retStart, retSize), 0)
1795             // Store the return offset.
1796             mstore(retStart, 0x20)
1797             // End the transaction, returning the string.
1798             return(retStart, retSize)
1799         }



```

```
LibString.repeat(string,uint256) (LlamaRelativeQuorum.sol#1347-1377) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#1353-1376)



    
1353         assembly {
1354             let subjectLength := mload(subject)
1355             if iszero(or(iszero(times), iszero(subjectLength))) {
1356                 subject := add(subject, 0x20)
1357                 result := mload(0x40)
1358                 let output := add(result, 0x20)
1359                 for {} 1 {} {
1360                     // Copy the `subject` one word at a time.
1361                     for { let o := 0 } 1 {} {
1362                         mstore(add(output, o), mload(add(subject, o)))
1363                         o := add(o, 0x20)
1364                         if iszero(lt(o, subjectLength)) { break }
1365                     }
1366                     output := add(output, subjectLength)
1367                     times := sub(times, 1)
1368                     if iszero(times) { break }
1369                 }
1370                 mstore(output, 0) // Zeroize the slot after the string.
1371                 let resultLength := sub(output, add(result, 0x20))
1372                 mstore(result, resultLength) // Store the length.
1373                 // Allocate the memory.
1374                 mstore(0x40, add(result, add(resultLength, 0x20)))
1375             }
1376         }



```

```
LibString.split(string,string) (LlamaRelativeQuorum.sol#1483-1528) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#1490-1527)



    
1490         assembly {
1491             let w := not(0x1f)
1492             let indexPtr := add(indices, 0x20)
1493             let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))
1494             mstore(add(indicesEnd, w), mload(subject))
1495             mstore(indices, add(mload(indices), 1))
1496             let prevIndex := 0
1497             for {} 1 {} {
1498                 let index := mload(indexPtr)
1499                 mstore(indexPtr, 0x60)
1500                 if iszero(eq(index, prevIndex)) {
1501                     let element := mload(0x40)
1502                     let elementLength := sub(index, prevIndex)
1503                     mstore(element, elementLength)
1504                     // Copy the `subject` one word at a time, backwards.
1505                     for { let o := and(add(elementLength, 0x1f), w) } 1 {} {
1506                         mstore(add(element, o), mload(add(add(subject, prevIndex), o)))
1507                         o := add(o, w) // `sub(o, 0x20)`.
1508                         if iszero(o) { break }
1509                     }
1510                     // Zeroize the slot after the string.
1511                     mstore(add(add(element, 0x20), elementLength), 0)
1512                     // Allocate memory for the length and the bytes,
1513                     // rounded up to a multiple of 32.
1514                     mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))
1515                     // Store the `element` into the array.
1516                     mstore(indexPtr, element)
1517                 }
1518                 prevIndex := add(index, mload(delimiter))
1519                 indexPtr := add(indexPtr, 0x20)
1520                 if iszero(lt(indexPtr, indicesEnd)) { break }
1521             }
1522             result := indices
1523             if iszero(mload(delimiter)) {
1524                 result := add(indices, 0x20)
1525                 mstore(result, sub(mload(indices), 2))
1526             }
1527         }



```

```
FixedPointMathLib.rpow(uint256,uint256,uint256) (LlamaRelativeQuorum.sol#254-341) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#260-340)



    
260         assembly {
261             switch x
262             case 0 {
263                 switch n
264                 case 0 {
265                     // 0 ** 0 = 1
266                     z := scalar
267                 }
268                 default {
269                     // 0 ** n = 0
270                     z := 0
271                 }
272             }
273             default {
274                 switch mod(n, 2)
275                 case 0 {
276                     // If n is even, store scalar in z for now.
277                     z := scalar
278                 }
279                 default {
280                     // If n is odd, store x in z for now.
281                     z := x
282                 }
283 
284                 // Shifting right by 1 is like dividing by 2.
285                 let half := shr(1, scalar)
286 
287                 for {
288                     // Shift n right by 1 before looping to halve it.
289                     n := shr(1, n)
290                 } n {
291                     // Shift n right by 1 each iteration to halve it.
292                     n := shr(1, n)
293                 } {
294                     // Revert immediately if x ** 2 would overflow.
295                     // Equivalent to iszero(eq(div(xx, x), x)) here.
296                     if shr(128, x) {
297                         revert(0, 0)
298                     }
299 
300                     // Store x squared.
301                     let xx := mul(x, x)
302 
303                     // Round to the nearest number.
304                     let xxRound := add(xx, half)
305 
306                     // Revert if xx + half overflowed.
307                     if lt(xxRound, xx) {
308                         revert(0, 0)
309                     }
310 
311                     // Set x to scaled xxRound.
312                     x := div(xxRound, scalar)
313 
314                     // If n is even:
315                     if mod(n, 2) {
316                         // Compute z * x.
317                         let zx := mul(z, x)
318 
319                         // If z * x overflowed:
320                         if iszero(eq(div(zx, x), z)) {
321                             // Revert if x is non-zero.
322                             if iszero(iszero(x)) {
323                                 revert(0, 0)
324                             }
325                         }
326 
327                         // Round to the nearest number.
328                         let zxRound := add(zx, half)
329 
330                         // Revert if zx + half overflowed.
331                         if lt(zxRound, zx) {
332                             revert(0, 0)
333                         }
334 
335                         // Return properly scaled zxRound.
336                         z := div(zxRound, scalar)
337                     }
338                 }
339             }
340         }



```

```
LibString.unpackTwo(bytes32) (LlamaRelativeQuorum.sol#1762-1784) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#1768-1783)



    
1768         assembly {
1769             // Grab the free memory pointer.
1770             resultA := mload(0x40)
1771             resultB := add(resultA, 0x40)
1772             // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.
1773             mstore(0x40, add(resultB, 0x40))
1774             // Zeroize the length slots.
1775             mstore(resultA, 0)
1776             mstore(resultB, 0)
1777             // Store the lengths and bytes.
1778             mstore(add(resultA, 0x1f), packed)
1779             mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))
1780             // Right pad with zeroes.
1781             mstore(add(add(resultA, 0x20), mload(resultA)), 0)
1782             mstore(add(add(resultB, 0x20), mload(resultB)), 0)
1783         }



```

```
LibString.lastIndexOf(string,string,uint256) (LlamaRelativeQuorum.sol#1252-1284) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#1258-1283)



    
1258         assembly {
1259             for {} 1 {} {
1260                 result := not(0) // Initialize to `NOT_FOUND`.
1261                 let searchLength := mload(search)
1262                 if gt(searchLength, mload(subject)) { break }
1263                 let w := result
1264 
1265                 let fromMax := sub(mload(subject), searchLength)
1266                 if iszero(gt(fromMax, from)) { from := fromMax }
1267 
1268                 let end := add(add(subject, 0x20), w)
1269                 subject := add(add(subject, 0x20), from)
1270                 if iszero(gt(subject, end)) { break }
1271                 // As this function is not too often used,
1272                 // we shall simply use keccak256 for smaller bytecode size.
1273                 for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
1274                     if eq(keccak256(subject, searchLength), h) {
1275                         result := sub(subject, add(end, 1))
1276                         break
1277                     }
1278                     subject := add(subject, w) // `sub(subject, 1)`.
1279                     if iszero(gt(subject, end)) { break }
1280                 }
1281                 break
1282             }
1283         }



```

```
LibString.is7BitASCII(string) (LlamaRelativeQuorum.sol#1074-1096) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#1076-1095)



    
1076         assembly {
1077             let mask := shl(7, div(not(0), 255))
1078             result := 1
1079             let n := mload(s)
1080             if n {
1081                 let o := add(s, 0x20)
1082                 let end := add(o, n)
1083                 let last := mload(end)
1084                 mstore(end, 0)
1085                 for {} 1 {} {
1086                     if and(mask, mload(o)) {
1087                         result := 0
1088                         break
1089                     }
1090                     o := add(o, 0x20)
1091                     if iszero(lt(o, end)) { break }
1092                 }
1093                 mstore(end, last)
1094             }
1095         }



```

```
LibString.startsWith(string,string) (LlamaRelativeQuorum.sol#1298-1316) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#1304-1315)



    
1304         assembly {
1305             let searchLength := mload(search)
1306             // Just using keccak256 directly is actually cheaper.
1307             // forgefmt: disable-next-item
1308             result := and(
1309                 iszero(gt(searchLength, mload(subject))),
1310                 eq(
1311                     keccak256(add(subject, 0x20), searchLength),
1312                     keccak256(add(search, 0x20), searchLength)
1313                 )
1314             )
1315         }



```

```
LibString.escapeJSON(string) (LlamaRelativeQuorum.sol#1645-1691) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#1647-1690)



    
1647         assembly {
1648             for {
1649                 let end := add(s, mload(s))
1650                 result := add(mload(0x40), 0x20)
1651                 // Store "\\u0000" in scratch space.
1652                 // Store "0123456789abcdef" in scratch space.
1653                 // Also, store `{0x08:"b", 0x09:"t", 0x0a:"n", 0x0c:"f", 0x0d:"r"}`.
1654                 // into the scratch space.
1655                 mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)
1656                 // Bitmask for detecting `["\"","\\"]`.
1657                 let e := or(shl(0x22, 1), shl(0x5c, 1))
1658             } iszero(eq(s, end)) {} {
1659                 s := add(s, 1)
1660                 let c := and(mload(s), 0xff)
1661                 if iszero(lt(c, 0x20)) {
1662                     if iszero(and(shl(c, 1), e)) {
1663                         // Not in `["\"","\\"]`.
1664                         mstore8(result, c)
1665                         result := add(result, 1)
1666                         continue
1667                     }
1668                     mstore8(result, 0x5c) // "\\".
1669                     mstore8(add(result, 1), c)
1670                     result := add(result, 2)
1671                     continue
1672                 }
1673                 if iszero(and(shl(c, 1), 0x3700)) {
1674                     // Not in `["\b","\t","\n","\f","\d"]`.
1675                     mstore8(0x1d, mload(shr(4, c))) // Hex value.
1676                     mstore8(0x1e, mload(and(c, 15))) // Hex value.
1677                     mstore(result, mload(0x19)) // "\\u00XX".
1678                     result := add(result, 6)
1679                     continue
1680                 }
1681                 mstore8(result, 0x5c) // "\\".
1682                 mstore8(add(result, 1), mload(add(c, 8)))
1683                 result := add(result, 2)
1684             }
1685             let last := result
1686             mstore(last, 0) // Zeroize the slot after the string.
1687             result := mload(0x40)
1688             mstore(result, sub(last, add(result, 0x20))) // Store the length.
1689             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1690         }



```

```
LibString.toHexString(address) (LlamaRelativeQuorum.sol#964-973) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#967-972)



    
967         assembly {
968             let strLength := add(mload(str), 2) // Compute the length.
969             mstore(str, 0x3078) // Write the "0x" prefix.
970             str := sub(str, 2) // Move the pointer.
971             mstore(str, strLength) // Write the length.
972         }



```

```
LibString.replace(string,string,string) (LlamaRelativeQuorum.sol#1106-1178) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#1112-1177)



    
1112         assembly {
1113             let subjectLength := mload(subject)
1114             let searchLength := mload(search)
1115             let replacementLength := mload(replacement)
1116 
1117             subject := add(subject, 0x20)
1118             search := add(search, 0x20)
1119             replacement := add(replacement, 0x20)
1120             result := add(mload(0x40), 0x20)
1121 
1122             let subjectEnd := add(subject, subjectLength)
1123             if iszero(gt(searchLength, subjectLength)) {
1124                 let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)
1125                 let h := 0
1126                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
1127                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
1128                 let s := mload(search)
1129                 for {} 1 {} {
1130                     let t := mload(subject)
1131                     // Whether the first `searchLength % 32` bytes of
1132                     // `subject` and `search` matches.
1133                     if iszero(shr(m, xor(t, s))) {
1134                         if h {
1135                             if iszero(eq(keccak256(subject, searchLength), h)) {
1136                                 mstore(result, t)
1137                                 result := add(result, 1)
1138                                 subject := add(subject, 1)
1139                                 if iszero(lt(subject, subjectSearchEnd)) { break }
1140                                 continue
1141                             }
1142                         }
1143                         // Copy the `replacement` one word at a time.
1144                         for { let o := 0 } 1 {} {
1145                             mstore(add(result, o), mload(add(replacement, o)))
1146                             o := add(o, 0x20)
1147                             if iszero(lt(o, replacementLength)) { break }
1148                         }
1149                         result := add(result, replacementLength)
1150                         subject := add(subject, searchLength)
1151                         if searchLength {
1152                             if iszero(lt(subject, subjectSearchEnd)) { break }
1153                             continue
1154                         }
1155                     }
1156                     mstore(result, t)
1157                     result := add(result, 1)
1158                     subject := add(subject, 1)
1159                     if iszero(lt(subject, subjectSearchEnd)) { break }
1160                 }
1161             }
1162 
1163             let resultRemainder := result
1164             result := add(mload(0x40), 0x20)
1165             let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))
1166             // Copy the rest of the string one word at a time.
1167             for {} lt(subject, subjectEnd) {} {
1168                 mstore(resultRemainder, mload(subject))
1169                 resultRemainder := add(resultRemainder, 0x20)
1170                 subject := add(subject, 0x20)
1171             }
1172             result := sub(result, 0x20)
1173             let last := add(add(result, 0x20), k) // Zeroize the slot after the string.
1174             mstore(last, 0)
1175             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1176             mstore(result, k) // Store the length.
1177         }



```

```
LibString.toHexString(uint256) (LlamaRelativeQuorum.sol#858-867) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#861-866)



    
861         assembly {
862             let strLength := add(mload(str), 2) // Compute the length.
863             mstore(str, 0x3078) // Write the "0x" prefix.
864             str := sub(str, 2) // Move the pointer.
865             mstore(str, strLength) // Write the length.
866         }



```

```
FixedPointMathLib.mulDivDown(uint256,uint256,uint256) (LlamaRelativeQuorum.sol#219-234) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#225-233)



    
225         assembly {
226             // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))
227             if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {
228                 revert(0, 0)
229             }
230 
231             // Divide x * y by the denominator.
232             z := div(mul(x, y), denominator)
233         }



```

```
Clones.clone(address) (LlamaRelativeQuorum.sol#514-527) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#516-523)



    
516         assembly {
517             // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
518             // of the `implementation` address with the bytecode before the address.
519             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
520             // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
521             mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
522             instance := create(0, 0x09, 0x37)
523         }



```

```
LibString.indexOf(string,string,uint256) (LlamaRelativeQuorum.sol#1183-1236) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#1189-1235)



    
1189         assembly {
1190             for { let subjectLength := mload(subject) } 1 {} {
1191                 if iszero(mload(search)) {
1192                     if iszero(gt(from, subjectLength)) {
1193                         result := from
1194                         break
1195                     }
1196                     result := subjectLength
1197                     break
1198                 }
1199                 let searchLength := mload(search)
1200                 let subjectStart := add(subject, 0x20)
1201 
1202                 result := not(0) // Initialize to `NOT_FOUND`.
1203 
1204                 subject := add(subjectStart, from)
1205                 let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)
1206 
1207                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
1208                 let s := mload(add(search, 0x20))
1209 
1210                 if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }
1211 
1212                 if iszero(lt(searchLength, 0x20)) {
1213                     for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
1214                         if iszero(shr(m, xor(mload(subject), s))) {
1215                             if eq(keccak256(subject, searchLength), h) {
1216                                 result := sub(subject, subjectStart)
1217                                 break
1218                             }
1219                         }
1220                         subject := add(subject, 1)
1221                         if iszero(lt(subject, end)) { break }
1222                     }
1223                     break
1224                 }
1225                 for {} 1 {} {
1226                     if iszero(shr(m, xor(mload(subject), s))) {
1227                         result := sub(subject, subjectStart)
1228                         break
1229                     }
1230                     subject := add(subject, 1)
1231                     if iszero(lt(subject, end)) { break }
1232                 }
1233                 break
1234             }
1235         }



```

```
LibString.unpackOne(bytes32) (LlamaRelativeQuorum.sol#1721-1735) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#1723-1734)



    
1723         assembly {
1724             // Grab the free memory pointer.
1725             result := mload(0x40)
1726             // Allocate 2 words (1 for the length, 1 for the bytes).
1727             mstore(0x40, add(result, 0x40))
1728             // Zeroize the length slot.
1729             mstore(result, 0)
1730             // Store the length and bytes.
1731             mstore(add(result, 0x1f), packed)
1732             // Right pad with zeroes.
1733             mstore(add(add(result, 0x20), mload(result)), 0)
1734         }



```

```
Clones.predictDeterministicAddress(address,bytes32,address) (LlamaRelativeQuorum.sol#554-570) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#560-569)



    
560         assembly {
561             let ptr := mload(0x40)
562             mstore(add(ptr, 0x38), deployer)
563             mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)
564             mstore(add(ptr, 0x14), implementation)
565             mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)
566             mstore(add(ptr, 0x58), salt)
567             mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))
568             predicted := keccak256(add(ptr, 0x43), 0x55)
569         }



```

```
LibString.slice(string,uint256,uint256) (LlamaRelativeQuorum.sol#1381-1410) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#1387-1409)



    
1387         assembly {
1388             let subjectLength := mload(subject)
1389             if iszero(gt(subjectLength, end)) { end := subjectLength }
1390             if iszero(gt(subjectLength, start)) { start := subjectLength }
1391             if lt(start, end) {
1392                 result := mload(0x40)
1393                 let resultLength := sub(end, start)
1394                 mstore(result, resultLength)
1395                 subject := add(subject, start)
1396                 let w := not(0x1f)
1397                 // Copy the `subject` one word at a time, backwards.
1398                 for { let o := and(add(resultLength, 0x1f), w) } 1 {} {
1399                     mstore(add(result, o), mload(add(subject, o)))
1400                     o := add(o, w) // `sub(o, 0x20)`.
1401                     if iszero(o) { break }
1402                 }
1403                 // Zeroize the slot after the string.
1404                 mstore(add(add(result, 0x20), resultLength), 0)
1405                 // Allocate memory for the length and the bytes,
1406                 // rounded up to a multiple of 32.
1407                 mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))
1408             }
1409         }



```

```
LibString.toHexString(bytes) (LlamaRelativeQuorum.sol#1014-1023) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#1017-1022)



    
1017         assembly {
1018             let strLength := add(mload(str), 2) // Compute the length.
1019             mstore(str, 0x3078) // Write the "0x" prefix.
1020             str := sub(str, 2) // Move the pointer.
1021             mstore(str, strLength) // Write the length.
1022         }



```

```
LibString.toHexStringNoPrefix(address) (LlamaRelativeQuorum.sol#977-1010) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#979-1009)



    
979         assembly {
980             str := mload(0x40)
981 
982             // Allocate the memory.
983             // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,
984             // 0x02 bytes for the prefix, and 0x28 bytes for the digits.
985             // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.
986             mstore(0x40, add(str, 0x80))
987 
988             // Store "0123456789abcdef" in scratch space.
989             mstore(0x0f, 0x30313233343536373839616263646566)
990 
991             str := add(str, 2)
992             mstore(str, 40)
993 
994             let o := add(str, 0x20)
995             mstore(add(o, 40), 0)
996 
997             value := shl(96, value)
998 
999             // We write the string from rightmost digit to leftmost digit.
1000             // The following is essentially a do-while loop that also handles the zero case.
1001             for { let i := 0 } 1 {} {
1002                 let p := add(o, add(i, i))
1003                 let temp := byte(i, value)
1004                 mstore8(add(p, 1), mload(and(temp, 15)))
1005                 mstore8(p, mload(shr(4, temp)))
1006                 i := add(i, 1)
1007                 if eq(i, 20) { break }
1008             }
1009         }



```

```
LibString.indicesOf(string,string) (LlamaRelativeQuorum.sol#1424-1480) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#1430-1479)



    
1430         assembly {
1431             let subjectLength := mload(subject)
1432             let searchLength := mload(search)
1433 
1434             if iszero(gt(searchLength, subjectLength)) {
1435                 subject := add(subject, 0x20)
1436                 search := add(search, 0x20)
1437                 result := add(mload(0x40), 0x20)
1438 
1439                 let subjectStart := subject
1440                 let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)
1441                 let h := 0
1442                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
1443                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
1444                 let s := mload(search)
1445                 for {} 1 {} {
1446                     let t := mload(subject)
1447                     // Whether the first `searchLength % 32` bytes of
1448                     // `subject` and `search` matches.
1449                     if iszero(shr(m, xor(t, s))) {
1450                         if h {
1451                             if iszero(eq(keccak256(subject, searchLength), h)) {
1452                                 subject := add(subject, 1)
1453                                 if iszero(lt(subject, subjectSearchEnd)) { break }
1454                                 continue
1455                             }
1456                         }
1457                         // Append to `result`.
1458                         mstore(result, sub(subject, subjectStart))
1459                         result := add(result, 0x20)
1460                         // Advance `subject` by `searchLength`.
1461                         subject := add(subject, searchLength)
1462                         if searchLength {
1463                             if iszero(lt(subject, subjectSearchEnd)) { break }
1464                             continue
1465                         }
1466                     }
1467                     subject := add(subject, 1)
1468                     if iszero(lt(subject, subjectSearchEnd)) { break }
1469                 }
1470                 let resultEnd := result
1471                 // Assign `result` to the free memory pointer.
1472                 result := mload(0x40)
1473                 // Store the length of `result`.
1474                 mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))
1475                 // Allocate memory for result.
1476                 // We allocate one more word, so this array can be recycled for {split}.
1477                 mstore(0x40, add(resultEnd, 0x20))
1478             }
1479         }



```

```
FixedPointMathLib.unsafeDiv(uint256,uint256) (LlamaRelativeQuorum.sol#421-428) uses assembly
	- INLINE ASM (LlamaRelativeQuorum.sol#423-427)



    
423         assembly {
424             // Divide x by y. Note this will return
425             // 0 instead of reverting if y is zero.
426             r := div(x, y)
427         }



```

## costly-loop
### Severity: Informational

### LlamaAbsolutePeerReview.sol


```
LlamaPolicy._initializeRole(RoleDescription) (LlamaAbsolutePeerReview.sol#2652-2655) has costly operations inside a loop:
	- numRoles += 1 (LlamaAbsolutePeerReview.sol#2653)



    
2653     numRoles += 1;



```

### LlamaAbsoluteQuorum.sol


```
LlamaPolicy._initializeRole(RoleDescription) (LlamaAbsoluteQuorum.sol#2652-2655) has costly operations inside a loop:
	- numRoles += 1 (LlamaAbsoluteQuorum.sol#2653)



    
2653     numRoles += 1;



```

### LlamaAccount.sol


```
LlamaPolicy._initializeRole(RoleDescription) (LlamaAccount.sol#3810-3813) has costly operations inside a loop:
	- numRoles += 1 (LlamaAccount.sol#3811)



    
3811     numRoles += 1;



```

### LlamaCore.sol


```
LlamaPolicy._initializeRole(RoleDescription) (LlamaCore.sol#2872-2875) has costly operations inside a loop:
	- numRoles += 1 (LlamaCore.sol#2873)



    
2873     numRoles += 1;



```

### LlamaFactory.sol


```
LlamaPolicy._initializeRole(RoleDescription) (LlamaFactory.sol#2399-2402) has costly operations inside a loop:
	- numRoles += 1 (LlamaFactory.sol#2400)



    
2400     numRoles += 1;



```

### LlamaGovernanceScript.sol


```
LlamaPolicy._initializeRole(RoleDescription) (LlamaGovernanceScript.sol#2420-2423) has costly operations inside a loop:
	- numRoles += 1 (LlamaGovernanceScript.sol#2421)



    
2421     numRoles += 1;



```

### LlamaPolicy.sol


```
LlamaPolicy._initializeRole(RoleDescription) (LlamaPolicy.sol#3850-3853) has costly operations inside a loop:
	- numRoles += 1 (LlamaPolicy.sol#3851)



    
3851     numRoles += 1;



```

### LlamaRelativeQuorum.sol


```
LlamaPolicy._initializeRole(RoleDescription) (LlamaRelativeQuorum.sol#2652-2655) has costly operations inside a loop:
	- numRoles += 1 (LlamaRelativeQuorum.sol#2653)



    
2653     numRoles += 1;



```

## cyclomatic-complexity
### Severity: Informational

### LlamaAbsolutePeerReview.sol


```
LibString.replace(string,string,string) (LlamaAbsolutePeerReview.sol#1106-1178) has a high cyclomatic complexity (14).



    
1106     function replace(string memory subject, string memory search, string memory replacement)
1107         internal
1108         pure
1109         returns (string memory result)
1110     {
1111         /// @solidity memory-safe-assembly
1112         assembly {
1113             let subjectLength := mload(subject)
1114             let searchLength := mload(search)
1115             let replacementLength := mload(replacement)
1116 
1117             subject := add(subject, 0x20)
1118             search := add(search, 0x20)
1119             replacement := add(replacement, 0x20)
1120             result := add(mload(0x40), 0x20)
1121 
1122             let subjectEnd := add(subject, subjectLength)
1123             if iszero(gt(searchLength, subjectLength)) {
1124                 let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)
1125                 let h := 0
1126                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
1127                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
1128                 let s := mload(search)
1129                 for {} 1 {} {
1130                     let t := mload(subject)
1131                     // Whether the first `searchLength % 32` bytes of
1132                     // `subject` and `search` matches.
1133                     if iszero(shr(m, xor(t, s))) {
1134                         if h {
1135                             if iszero(eq(keccak256(subject, searchLength), h)) {
1136                                 mstore(result, t)
1137                                 result := add(result, 1)
1138                                 subject := add(subject, 1)
1139                                 if iszero(lt(subject, subjectSearchEnd)) { break }
1140                                 continue
1141                             }
1142                         }
1143                         // Copy the `replacement` one word at a time.
1144                         for { let o := 0 } 1 {} {
1145                             mstore(add(result, o), mload(add(replacement, o)))
1146                             o := add(o, 0x20)
1147                             if iszero(lt(o, replacementLength)) { break }
1148                         }
1149                         result := add(result, replacementLength)
1150                         subject := add(subject, searchLength)
1151                         if searchLength {
1152                             if iszero(lt(subject, subjectSearchEnd)) { break }
1153                             continue
1154                         }
1155                     }
1156                     mstore(result, t)
1157                     result := add(result, 1)
1158                     subject := add(subject, 1)
1159                     if iszero(lt(subject, subjectSearchEnd)) { break }
1160                 }
1161             }
1162 
1163             let resultRemainder := result
1164             result := add(mload(0x40), 0x20)
1165             let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))
1166             // Copy the rest of the string one word at a time.
1167             for {} lt(subject, subjectEnd) {} {
1168                 mstore(resultRemainder, mload(subject))
1169                 resultRemainder := add(resultRemainder, 0x20)
1170                 subject := add(subject, 0x20)
1171             }
1172             result := sub(result, 0x20)
1173             let last := add(add(result, 0x20), k) // Zeroize the slot after the string.
1174             mstore(last, 0)
1175             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1176             mstore(result, k) // Store the length.
1177         }
1178     }



```

```
LibString.indexOf(string,string,uint256) (LlamaAbsolutePeerReview.sol#1183-1236) has a high cyclomatic complexity (13).



    
1183     function indexOf(string memory subject, string memory search, uint256 from)
1184         internal
1185         pure
1186         returns (uint256 result)
1187     {
1188         /// @solidity memory-safe-assembly
1189         assembly {
1190             for { let subjectLength := mload(subject) } 1 {} {
1191                 if iszero(mload(search)) {
1192                     if iszero(gt(from, subjectLength)) {
1193                         result := from
1194                         break
1195                     }
1196                     result := subjectLength
1197                     break
1198                 }
1199                 let searchLength := mload(search)
1200                 let subjectStart := add(subject, 0x20)
1201 
1202                 result := not(0) // Initialize to `NOT_FOUND`.
1203 
1204                 subject := add(subjectStart, from)
1205                 let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)
1206 
1207                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
1208                 let s := mload(add(search, 0x20))
1209 
1210                 if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }
1211 
1212                 if iszero(lt(searchLength, 0x20)) {
1213                     for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
1214                         if iszero(shr(m, xor(mload(subject), s))) {
1215                             if eq(keccak256(subject, searchLength), h) {
1216                                 result := sub(subject, subjectStart)
1217                                 break
1218                             }
1219                         }
1220                         subject := add(subject, 1)
1221                         if iszero(lt(subject, end)) { break }
1222                     }
1223                     break
1224                 }
1225                 for {} 1 {} {
1226                     if iszero(shr(m, xor(mload(subject), s))) {
1227                         result := sub(subject, subjectStart)
1228                         break
1229                     }
1230                     subject := add(subject, 1)
1231                     if iszero(lt(subject, end)) { break }
1232                 }
1233                 break
1234             }
1235         }
1236     }



```

### LlamaAbsoluteQuorum.sol


```
LibString.replace(string,string,string) (LlamaAbsoluteQuorum.sol#1106-1178) has a high cyclomatic complexity (14).



    
1106     function replace(string memory subject, string memory search, string memory replacement)
1107         internal
1108         pure
1109         returns (string memory result)
1110     {
1111         /// @solidity memory-safe-assembly
1112         assembly {
1113             let subjectLength := mload(subject)
1114             let searchLength := mload(search)
1115             let replacementLength := mload(replacement)
1116 
1117             subject := add(subject, 0x20)
1118             search := add(search, 0x20)
1119             replacement := add(replacement, 0x20)
1120             result := add(mload(0x40), 0x20)
1121 
1122             let subjectEnd := add(subject, subjectLength)
1123             if iszero(gt(searchLength, subjectLength)) {
1124                 let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)
1125                 let h := 0
1126                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
1127                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
1128                 let s := mload(search)
1129                 for {} 1 {} {
1130                     let t := mload(subject)
1131                     // Whether the first `searchLength % 32` bytes of
1132                     // `subject` and `search` matches.
1133                     if iszero(shr(m, xor(t, s))) {
1134                         if h {
1135                             if iszero(eq(keccak256(subject, searchLength), h)) {
1136                                 mstore(result, t)
1137                                 result := add(result, 1)
1138                                 subject := add(subject, 1)
1139                                 if iszero(lt(subject, subjectSearchEnd)) { break }
1140                                 continue
1141                             }
1142                         }
1143                         // Copy the `replacement` one word at a time.
1144                         for { let o := 0 } 1 {} {
1145                             mstore(add(result, o), mload(add(replacement, o)))
1146                             o := add(o, 0x20)
1147                             if iszero(lt(o, replacementLength)) { break }
1148                         }
1149                         result := add(result, replacementLength)
1150                         subject := add(subject, searchLength)
1151                         if searchLength {
1152                             if iszero(lt(subject, subjectSearchEnd)) { break }
1153                             continue
1154                         }
1155                     }
1156                     mstore(result, t)
1157                     result := add(result, 1)
1158                     subject := add(subject, 1)
1159                     if iszero(lt(subject, subjectSearchEnd)) { break }
1160                 }
1161             }
1162 
1163             let resultRemainder := result
1164             result := add(mload(0x40), 0x20)
1165             let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))
1166             // Copy the rest of the string one word at a time.
1167             for {} lt(subject, subjectEnd) {} {
1168                 mstore(resultRemainder, mload(subject))
1169                 resultRemainder := add(resultRemainder, 0x20)
1170                 subject := add(subject, 0x20)
1171             }
1172             result := sub(result, 0x20)
1173             let last := add(add(result, 0x20), k) // Zeroize the slot after the string.
1174             mstore(last, 0)
1175             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1176             mstore(result, k) // Store the length.
1177         }
1178     }



```

```
LibString.indexOf(string,string,uint256) (LlamaAbsoluteQuorum.sol#1183-1236) has a high cyclomatic complexity (13).



    
1183     function indexOf(string memory subject, string memory search, uint256 from)
1184         internal
1185         pure
1186         returns (uint256 result)
1187     {
1188         /// @solidity memory-safe-assembly
1189         assembly {
1190             for { let subjectLength := mload(subject) } 1 {} {
1191                 if iszero(mload(search)) {
1192                     if iszero(gt(from, subjectLength)) {
1193                         result := from
1194                         break
1195                     }
1196                     result := subjectLength
1197                     break
1198                 }
1199                 let searchLength := mload(search)
1200                 let subjectStart := add(subject, 0x20)
1201 
1202                 result := not(0) // Initialize to `NOT_FOUND`.
1203 
1204                 subject := add(subjectStart, from)
1205                 let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)
1206 
1207                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
1208                 let s := mload(add(search, 0x20))
1209 
1210                 if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }
1211 
1212                 if iszero(lt(searchLength, 0x20)) {
1213                     for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
1214                         if iszero(shr(m, xor(mload(subject), s))) {
1215                             if eq(keccak256(subject, searchLength), h) {
1216                                 result := sub(subject, subjectStart)
1217                                 break
1218                             }
1219                         }
1220                         subject := add(subject, 1)
1221                         if iszero(lt(subject, end)) { break }
1222                     }
1223                     break
1224                 }
1225                 for {} 1 {} {
1226                     if iszero(shr(m, xor(mload(subject), s))) {
1227                         result := sub(subject, subjectStart)
1228                         break
1229                     }
1230                     subject := add(subject, 1)
1231                     if iszero(lt(subject, end)) { break }
1232                 }
1233                 break
1234             }
1235         }
1236     }



```

### LlamaAccount.sol


```
LibString.replace(string,string,string) (LlamaAccount.sol#1666-1738) has a high cyclomatic complexity (14).



    
1666     function replace(string memory subject, string memory search, string memory replacement)
1667         internal
1668         pure
1669         returns (string memory result)
1670     {
1671         /// @solidity memory-safe-assembly
1672         assembly {
1673             let subjectLength := mload(subject)
1674             let searchLength := mload(search)
1675             let replacementLength := mload(replacement)
1676 
1677             subject := add(subject, 0x20)
1678             search := add(search, 0x20)
1679             replacement := add(replacement, 0x20)
1680             result := add(mload(0x40), 0x20)
1681 
1682             let subjectEnd := add(subject, subjectLength)
1683             if iszero(gt(searchLength, subjectLength)) {
1684                 let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)
1685                 let h := 0
1686                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
1687                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
1688                 let s := mload(search)
1689                 for {} 1 {} {
1690                     let t := mload(subject)
1691                     // Whether the first `searchLength % 32` bytes of
1692                     // `subject` and `search` matches.
1693                     if iszero(shr(m, xor(t, s))) {
1694                         if h {
1695                             if iszero(eq(keccak256(subject, searchLength), h)) {
1696                                 mstore(result, t)
1697                                 result := add(result, 1)
1698                                 subject := add(subject, 1)
1699                                 if iszero(lt(subject, subjectSearchEnd)) { break }
1700                                 continue
1701                             }
1702                         }
1703                         // Copy the `replacement` one word at a time.
1704                         for { let o := 0 } 1 {} {
1705                             mstore(add(result, o), mload(add(replacement, o)))
1706                             o := add(o, 0x20)
1707                             if iszero(lt(o, replacementLength)) { break }
1708                         }
1709                         result := add(result, replacementLength)
1710                         subject := add(subject, searchLength)
1711                         if searchLength {
1712                             if iszero(lt(subject, subjectSearchEnd)) { break }
1713                             continue
1714                         }
1715                     }
1716                     mstore(result, t)
1717                     result := add(result, 1)
1718                     subject := add(subject, 1)
1719                     if iszero(lt(subject, subjectSearchEnd)) { break }
1720                 }
1721             }
1722 
1723             let resultRemainder := result
1724             result := add(mload(0x40), 0x20)
1725             let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))
1726             // Copy the rest of the string one word at a time.
1727             for {} lt(subject, subjectEnd) {} {
1728                 mstore(resultRemainder, mload(subject))
1729                 resultRemainder := add(resultRemainder, 0x20)
1730                 subject := add(subject, 0x20)
1731             }
1732             result := sub(result, 0x20)
1733             let last := add(add(result, 0x20), k) // Zeroize the slot after the string.
1734             mstore(last, 0)
1735             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1736             mstore(result, k) // Store the length.
1737         }
1738     }



```

```
LibString.indexOf(string,string,uint256) (LlamaAccount.sol#1743-1796) has a high cyclomatic complexity (13).



    
1743     function indexOf(string memory subject, string memory search, uint256 from)
1744         internal
1745         pure
1746         returns (uint256 result)
1747     {
1748         /// @solidity memory-safe-assembly
1749         assembly {
1750             for { let subjectLength := mload(subject) } 1 {} {
1751                 if iszero(mload(search)) {
1752                     if iszero(gt(from, subjectLength)) {
1753                         result := from
1754                         break
1755                     }
1756                     result := subjectLength
1757                     break
1758                 }
1759                 let searchLength := mload(search)
1760                 let subjectStart := add(subject, 0x20)
1761 
1762                 result := not(0) // Initialize to `NOT_FOUND`.
1763 
1764                 subject := add(subjectStart, from)
1765                 let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)
1766 
1767                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
1768                 let s := mload(add(search, 0x20))
1769 
1770                 if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }
1771 
1772                 if iszero(lt(searchLength, 0x20)) {
1773                     for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
1774                         if iszero(shr(m, xor(mload(subject), s))) {
1775                             if eq(keccak256(subject, searchLength), h) {
1776                                 result := sub(subject, subjectStart)
1777                                 break
1778                             }
1779                         }
1780                         subject := add(subject, 1)
1781                         if iszero(lt(subject, end)) { break }
1782                     }
1783                     break
1784                 }
1785                 for {} 1 {} {
1786                     if iszero(shr(m, xor(mload(subject), s))) {
1787                         result := sub(subject, subjectStart)
1788                         break
1789                     }
1790                     subject := add(subject, 1)
1791                     if iszero(lt(subject, end)) { break }
1792                 }
1793                 break
1794             }
1795         }
1796     }



```

### LlamaCore.sol


```
LibString.replace(string,string,string) (LlamaCore.sol#703-775) has a high cyclomatic complexity (14).



    
703     function replace(string memory subject, string memory search, string memory replacement)
704         internal
705         pure
706         returns (string memory result)
707     {
708         /// @solidity memory-safe-assembly
709         assembly {
710             let subjectLength := mload(subject)
711             let searchLength := mload(search)
712             let replacementLength := mload(replacement)
713 
714             subject := add(subject, 0x20)
715             search := add(search, 0x20)
716             replacement := add(replacement, 0x20)
717             result := add(mload(0x40), 0x20)
718 
719             let subjectEnd := add(subject, subjectLength)
720             if iszero(gt(searchLength, subjectLength)) {
721                 let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)
722                 let h := 0
723                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
724                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
725                 let s := mload(search)
726                 for {} 1 {} {
727                     let t := mload(subject)
728                     // Whether the first `searchLength % 32` bytes of
729                     // `subject` and `search` matches.
730                     if iszero(shr(m, xor(t, s))) {
731                         if h {
732                             if iszero(eq(keccak256(subject, searchLength), h)) {
733                                 mstore(result, t)
734                                 result := add(result, 1)
735                                 subject := add(subject, 1)
736                                 if iszero(lt(subject, subjectSearchEnd)) { break }
737                                 continue
738                             }
739                         }
740                         // Copy the `replacement` one word at a time.
741                         for { let o := 0 } 1 {} {
742                             mstore(add(result, o), mload(add(replacement, o)))
743                             o := add(o, 0x20)
744                             if iszero(lt(o, replacementLength)) { break }
745                         }
746                         result := add(result, replacementLength)
747                         subject := add(subject, searchLength)
748                         if searchLength {
749                             if iszero(lt(subject, subjectSearchEnd)) { break }
750                             continue
751                         }
752                     }
753                     mstore(result, t)
754                     result := add(result, 1)
755                     subject := add(subject, 1)
756                     if iszero(lt(subject, subjectSearchEnd)) { break }
757                 }
758             }
759 
760             let resultRemainder := result
761             result := add(mload(0x40), 0x20)
762             let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))
763             // Copy the rest of the string one word at a time.
764             for {} lt(subject, subjectEnd) {} {
765                 mstore(resultRemainder, mload(subject))
766                 resultRemainder := add(resultRemainder, 0x20)
767                 subject := add(subject, 0x20)
768             }
769             result := sub(result, 0x20)
770             let last := add(add(result, 0x20), k) // Zeroize the slot after the string.
771             mstore(last, 0)
772             mstore(0x40, add(last, 0x20)) // Allocate the memory.
773             mstore(result, k) // Store the length.
774         }
775     }



```

```
LibString.indexOf(string,string,uint256) (LlamaCore.sol#780-833) has a high cyclomatic complexity (13).



    
780     function indexOf(string memory subject, string memory search, uint256 from)
781         internal
782         pure
783         returns (uint256 result)
784     {
785         /// @solidity memory-safe-assembly
786         assembly {
787             for { let subjectLength := mload(subject) } 1 {} {
788                 if iszero(mload(search)) {
789                     if iszero(gt(from, subjectLength)) {
790                         result := from
791                         break
792                     }
793                     result := subjectLength
794                     break
795                 }
796                 let searchLength := mload(search)
797                 let subjectStart := add(subject, 0x20)
798 
799                 result := not(0) // Initialize to `NOT_FOUND`.
800 
801                 subject := add(subjectStart, from)
802                 let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)
803 
804                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
805                 let s := mload(add(search, 0x20))
806 
807                 if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }
808 
809                 if iszero(lt(searchLength, 0x20)) {
810                     for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
811                         if iszero(shr(m, xor(mload(subject), s))) {
812                             if eq(keccak256(subject, searchLength), h) {
813                                 result := sub(subject, subjectStart)
814                                 break
815                             }
816                         }
817                         subject := add(subject, 1)
818                         if iszero(lt(subject, end)) { break }
819                     }
820                     break
821                 }
822                 for {} 1 {} {
823                     if iszero(shr(m, xor(mload(subject), s))) {
824                         result := sub(subject, subjectStart)
825                         break
826                     }
827                     subject := add(subject, 1)
828                     if iszero(lt(subject, end)) { break }
829                 }
830                 break
831             }
832         }
833     }



```

### LlamaFactory.sol


```
LibString.replace(string,string,string) (LlamaFactory.sol#850-922) has a high cyclomatic complexity (14).



    
850     function replace(string memory subject, string memory search, string memory replacement)
851         internal
852         pure
853         returns (string memory result)
854     {
855         /// @solidity memory-safe-assembly
856         assembly {
857             let subjectLength := mload(subject)
858             let searchLength := mload(search)
859             let replacementLength := mload(replacement)
860 
861             subject := add(subject, 0x20)
862             search := add(search, 0x20)
863             replacement := add(replacement, 0x20)
864             result := add(mload(0x40), 0x20)
865 
866             let subjectEnd := add(subject, subjectLength)
867             if iszero(gt(searchLength, subjectLength)) {
868                 let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)
869                 let h := 0
870                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
871                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
872                 let s := mload(search)
873                 for {} 1 {} {
874                     let t := mload(subject)
875                     // Whether the first `searchLength % 32` bytes of
876                     // `subject` and `search` matches.
877                     if iszero(shr(m, xor(t, s))) {
878                         if h {
879                             if iszero(eq(keccak256(subject, searchLength), h)) {
880                                 mstore(result, t)
881                                 result := add(result, 1)
882                                 subject := add(subject, 1)
883                                 if iszero(lt(subject, subjectSearchEnd)) { break }
884                                 continue
885                             }
886                         }
887                         // Copy the `replacement` one word at a time.
888                         for { let o := 0 } 1 {} {
889                             mstore(add(result, o), mload(add(replacement, o)))
890                             o := add(o, 0x20)
891                             if iszero(lt(o, replacementLength)) { break }
892                         }
893                         result := add(result, replacementLength)
894                         subject := add(subject, searchLength)
895                         if searchLength {
896                             if iszero(lt(subject, subjectSearchEnd)) { break }
897                             continue
898                         }
899                     }
900                     mstore(result, t)
901                     result := add(result, 1)
902                     subject := add(subject, 1)
903                     if iszero(lt(subject, subjectSearchEnd)) { break }
904                 }
905             }
906 
907             let resultRemainder := result
908             result := add(mload(0x40), 0x20)
909             let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))
910             // Copy the rest of the string one word at a time.
911             for {} lt(subject, subjectEnd) {} {
912                 mstore(resultRemainder, mload(subject))
913                 resultRemainder := add(resultRemainder, 0x20)
914                 subject := add(subject, 0x20)
915             }
916             result := sub(result, 0x20)
917             let last := add(add(result, 0x20), k) // Zeroize the slot after the string.
918             mstore(last, 0)
919             mstore(0x40, add(last, 0x20)) // Allocate the memory.
920             mstore(result, k) // Store the length.
921         }
922     }



```

```
LibString.indexOf(string,string,uint256) (LlamaFactory.sol#927-980) has a high cyclomatic complexity (13).



    
927     function indexOf(string memory subject, string memory search, uint256 from)
928         internal
929         pure
930         returns (uint256 result)
931     {
932         /// @solidity memory-safe-assembly
933         assembly {
934             for { let subjectLength := mload(subject) } 1 {} {
935                 if iszero(mload(search)) {
936                     if iszero(gt(from, subjectLength)) {
937                         result := from
938                         break
939                     }
940                     result := subjectLength
941                     break
942                 }
943                 let searchLength := mload(search)
944                 let subjectStart := add(subject, 0x20)
945 
946                 result := not(0) // Initialize to `NOT_FOUND`.
947 
948                 subject := add(subjectStart, from)
949                 let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)
950 
951                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
952                 let s := mload(add(search, 0x20))
953 
954                 if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }
955 
956                 if iszero(lt(searchLength, 0x20)) {
957                     for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
958                         if iszero(shr(m, xor(mload(subject), s))) {
959                             if eq(keccak256(subject, searchLength), h) {
960                                 result := sub(subject, subjectStart)
961                                 break
962                             }
963                         }
964                         subject := add(subject, 1)
965                         if iszero(lt(subject, end)) { break }
966                     }
967                     break
968                 }
969                 for {} 1 {} {
970                     if iszero(shr(m, xor(mload(subject), s))) {
971                         result := sub(subject, subjectStart)
972                         break
973                     }
974                     subject := add(subject, 1)
975                     if iszero(lt(subject, end)) { break }
976                 }
977                 break
978             }
979         }
980     }



```

### LlamaGovernanceScript.sol


```
LibString.replace(string,string,string) (LlamaGovernanceScript.sol#874-946) has a high cyclomatic complexity (14).



    
874     function replace(string memory subject, string memory search, string memory replacement)
875         internal
876         pure
877         returns (string memory result)
878     {
879         /// @solidity memory-safe-assembly
880         assembly {
881             let subjectLength := mload(subject)
882             let searchLength := mload(search)
883             let replacementLength := mload(replacement)
884 
885             subject := add(subject, 0x20)
886             search := add(search, 0x20)
887             replacement := add(replacement, 0x20)
888             result := add(mload(0x40), 0x20)
889 
890             let subjectEnd := add(subject, subjectLength)
891             if iszero(gt(searchLength, subjectLength)) {
892                 let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)
893                 let h := 0
894                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
895                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
896                 let s := mload(search)
897                 for {} 1 {} {
898                     let t := mload(subject)
899                     // Whether the first `searchLength % 32` bytes of
900                     // `subject` and `search` matches.
901                     if iszero(shr(m, xor(t, s))) {
902                         if h {
903                             if iszero(eq(keccak256(subject, searchLength), h)) {
904                                 mstore(result, t)
905                                 result := add(result, 1)
906                                 subject := add(subject, 1)
907                                 if iszero(lt(subject, subjectSearchEnd)) { break }
908                                 continue
909                             }
910                         }
911                         // Copy the `replacement` one word at a time.
912                         for { let o := 0 } 1 {} {
913                             mstore(add(result, o), mload(add(replacement, o)))
914                             o := add(o, 0x20)
915                             if iszero(lt(o, replacementLength)) { break }
916                         }
917                         result := add(result, replacementLength)
918                         subject := add(subject, searchLength)
919                         if searchLength {
920                             if iszero(lt(subject, subjectSearchEnd)) { break }
921                             continue
922                         }
923                     }
924                     mstore(result, t)
925                     result := add(result, 1)
926                     subject := add(subject, 1)
927                     if iszero(lt(subject, subjectSearchEnd)) { break }
928                 }
929             }
930 
931             let resultRemainder := result
932             result := add(mload(0x40), 0x20)
933             let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))
934             // Copy the rest of the string one word at a time.
935             for {} lt(subject, subjectEnd) {} {
936                 mstore(resultRemainder, mload(subject))
937                 resultRemainder := add(resultRemainder, 0x20)
938                 subject := add(subject, 0x20)
939             }
940             result := sub(result, 0x20)
941             let last := add(add(result, 0x20), k) // Zeroize the slot after the string.
942             mstore(last, 0)
943             mstore(0x40, add(last, 0x20)) // Allocate the memory.
944             mstore(result, k) // Store the length.
945         }
946     }



```

```
LibString.indexOf(string,string,uint256) (LlamaGovernanceScript.sol#951-1004) has a high cyclomatic complexity (13).



    
951     function indexOf(string memory subject, string memory search, uint256 from)
952         internal
953         pure
954         returns (uint256 result)
955     {
956         /// @solidity memory-safe-assembly
957         assembly {
958             for { let subjectLength := mload(subject) } 1 {} {
959                 if iszero(mload(search)) {
960                     if iszero(gt(from, subjectLength)) {
961                         result := from
962                         break
963                     }
964                     result := subjectLength
965                     break
966                 }
967                 let searchLength := mload(search)
968                 let subjectStart := add(subject, 0x20)
969 
970                 result := not(0) // Initialize to `NOT_FOUND`.
971 
972                 subject := add(subjectStart, from)
973                 let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)
974 
975                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
976                 let s := mload(add(search, 0x20))
977 
978                 if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }
979 
980                 if iszero(lt(searchLength, 0x20)) {
981                     for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
982                         if iszero(shr(m, xor(mload(subject), s))) {
983                             if eq(keccak256(subject, searchLength), h) {
984                                 result := sub(subject, subjectStart)
985                                 break
986                             }
987                         }
988                         subject := add(subject, 1)
989                         if iszero(lt(subject, end)) { break }
990                     }
991                     break
992                 }
993                 for {} 1 {} {
994                     if iszero(shr(m, xor(mload(subject), s))) {
995                         result := sub(subject, subjectStart)
996                         break
997                     }
998                     subject := add(subject, 1)
999                     if iszero(lt(subject, end)) { break }
1000                 }
1001                 break
1002             }
1003         }
1004     }



```

### LlamaPolicy.sol


```
LibString.replace(string,string,string) (LlamaPolicy.sol#410-482) has a high cyclomatic complexity (14).



    
410     function replace(string memory subject, string memory search, string memory replacement)
411         internal
412         pure
413         returns (string memory result)
414     {
415         /// @solidity memory-safe-assembly
416         assembly {
417             let subjectLength := mload(subject)
418             let searchLength := mload(search)
419             let replacementLength := mload(replacement)
420 
421             subject := add(subject, 0x20)
422             search := add(search, 0x20)
423             replacement := add(replacement, 0x20)
424             result := add(mload(0x40), 0x20)
425 
426             let subjectEnd := add(subject, subjectLength)
427             if iszero(gt(searchLength, subjectLength)) {
428                 let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)
429                 let h := 0
430                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
431                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
432                 let s := mload(search)
433                 for {} 1 {} {
434                     let t := mload(subject)
435                     // Whether the first `searchLength % 32` bytes of
436                     // `subject` and `search` matches.
437                     if iszero(shr(m, xor(t, s))) {
438                         if h {
439                             if iszero(eq(keccak256(subject, searchLength), h)) {
440                                 mstore(result, t)
441                                 result := add(result, 1)
442                                 subject := add(subject, 1)
443                                 if iszero(lt(subject, subjectSearchEnd)) { break }
444                                 continue
445                             }
446                         }
447                         // Copy the `replacement` one word at a time.
448                         for { let o := 0 } 1 {} {
449                             mstore(add(result, o), mload(add(replacement, o)))
450                             o := add(o, 0x20)
451                             if iszero(lt(o, replacementLength)) { break }
452                         }
453                         result := add(result, replacementLength)
454                         subject := add(subject, searchLength)
455                         if searchLength {
456                             if iszero(lt(subject, subjectSearchEnd)) { break }
457                             continue
458                         }
459                     }
460                     mstore(result, t)
461                     result := add(result, 1)
462                     subject := add(subject, 1)
463                     if iszero(lt(subject, subjectSearchEnd)) { break }
464                 }
465             }
466 
467             let resultRemainder := result
468             result := add(mload(0x40), 0x20)
469             let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))
470             // Copy the rest of the string one word at a time.
471             for {} lt(subject, subjectEnd) {} {
472                 mstore(resultRemainder, mload(subject))
473                 resultRemainder := add(resultRemainder, 0x20)
474                 subject := add(subject, 0x20)
475             }
476             result := sub(result, 0x20)
477             let last := add(add(result, 0x20), k) // Zeroize the slot after the string.
478             mstore(last, 0)
479             mstore(0x40, add(last, 0x20)) // Allocate the memory.
480             mstore(result, k) // Store the length.
481         }
482     }



```

```
LibString.indexOf(string,string,uint256) (LlamaPolicy.sol#487-540) has a high cyclomatic complexity (13).



    
487     function indexOf(string memory subject, string memory search, uint256 from)
488         internal
489         pure
490         returns (uint256 result)
491     {
492         /// @solidity memory-safe-assembly
493         assembly {
494             for { let subjectLength := mload(subject) } 1 {} {
495                 if iszero(mload(search)) {
496                     if iszero(gt(from, subjectLength)) {
497                         result := from
498                         break
499                     }
500                     result := subjectLength
501                     break
502                 }
503                 let searchLength := mload(search)
504                 let subjectStart := add(subject, 0x20)
505 
506                 result := not(0) // Initialize to `NOT_FOUND`.
507 
508                 subject := add(subjectStart, from)
509                 let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)
510 
511                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
512                 let s := mload(add(search, 0x20))
513 
514                 if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }
515 
516                 if iszero(lt(searchLength, 0x20)) {
517                     for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
518                         if iszero(shr(m, xor(mload(subject), s))) {
519                             if eq(keccak256(subject, searchLength), h) {
520                                 result := sub(subject, subjectStart)
521                                 break
522                             }
523                         }
524                         subject := add(subject, 1)
525                         if iszero(lt(subject, end)) { break }
526                     }
527                     break
528                 }
529                 for {} 1 {} {
530                     if iszero(shr(m, xor(mload(subject), s))) {
531                         result := sub(subject, subjectStart)
532                         break
533                     }
534                     subject := add(subject, 1)
535                     if iszero(lt(subject, end)) { break }
536                 }
537                 break
538             }
539         }
540     }



```

### LlamaPolicyMetadata.sol


```
LibString.replace(string,string,string) (LlamaPolicyMetadata.sol#498-570) has a high cyclomatic complexity (14).



    
498     function replace(string memory subject, string memory search, string memory replacement)
499         internal
500         pure
501         returns (string memory result)
502     {
503         /// @solidity memory-safe-assembly
504         assembly {
505             let subjectLength := mload(subject)
506             let searchLength := mload(search)
507             let replacementLength := mload(replacement)
508 
509             subject := add(subject, 0x20)
510             search := add(search, 0x20)
511             replacement := add(replacement, 0x20)
512             result := add(mload(0x40), 0x20)
513 
514             let subjectEnd := add(subject, subjectLength)
515             if iszero(gt(searchLength, subjectLength)) {
516                 let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)
517                 let h := 0
518                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
519                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
520                 let s := mload(search)
521                 for {} 1 {} {
522                     let t := mload(subject)
523                     // Whether the first `searchLength % 32` bytes of
524                     // `subject` and `search` matches.
525                     if iszero(shr(m, xor(t, s))) {
526                         if h {
527                             if iszero(eq(keccak256(subject, searchLength), h)) {
528                                 mstore(result, t)
529                                 result := add(result, 1)
530                                 subject := add(subject, 1)
531                                 if iszero(lt(subject, subjectSearchEnd)) { break }
532                                 continue
533                             }
534                         }
535                         // Copy the `replacement` one word at a time.
536                         for { let o := 0 } 1 {} {
537                             mstore(add(result, o), mload(add(replacement, o)))
538                             o := add(o, 0x20)
539                             if iszero(lt(o, replacementLength)) { break }
540                         }
541                         result := add(result, replacementLength)
542                         subject := add(subject, searchLength)
543                         if searchLength {
544                             if iszero(lt(subject, subjectSearchEnd)) { break }
545                             continue
546                         }
547                     }
548                     mstore(result, t)
549                     result := add(result, 1)
550                     subject := add(subject, 1)
551                     if iszero(lt(subject, subjectSearchEnd)) { break }
552                 }
553             }
554 
555             let resultRemainder := result
556             result := add(mload(0x40), 0x20)
557             let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))
558             // Copy the rest of the string one word at a time.
559             for {} lt(subject, subjectEnd) {} {
560                 mstore(resultRemainder, mload(subject))
561                 resultRemainder := add(resultRemainder, 0x20)
562                 subject := add(subject, 0x20)
563             }
564             result := sub(result, 0x20)
565             let last := add(add(result, 0x20), k) // Zeroize the slot after the string.
566             mstore(last, 0)
567             mstore(0x40, add(last, 0x20)) // Allocate the memory.
568             mstore(result, k) // Store the length.
569         }
570     }



```

```
LibString.indexOf(string,string,uint256) (LlamaPolicyMetadata.sol#575-628) has a high cyclomatic complexity (13).



    
575     function indexOf(string memory subject, string memory search, uint256 from)
576         internal
577         pure
578         returns (uint256 result)
579     {
580         /// @solidity memory-safe-assembly
581         assembly {
582             for { let subjectLength := mload(subject) } 1 {} {
583                 if iszero(mload(search)) {
584                     if iszero(gt(from, subjectLength)) {
585                         result := from
586                         break
587                     }
588                     result := subjectLength
589                     break
590                 }
591                 let searchLength := mload(search)
592                 let subjectStart := add(subject, 0x20)
593 
594                 result := not(0) // Initialize to `NOT_FOUND`.
595 
596                 subject := add(subjectStart, from)
597                 let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)
598 
599                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
600                 let s := mload(add(search, 0x20))
601 
602                 if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }
603 
604                 if iszero(lt(searchLength, 0x20)) {
605                     for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
606                         if iszero(shr(m, xor(mload(subject), s))) {
607                             if eq(keccak256(subject, searchLength), h) {
608                                 result := sub(subject, subjectStart)
609                                 break
610                             }
611                         }
612                         subject := add(subject, 1)
613                         if iszero(lt(subject, end)) { break }
614                     }
615                     break
616                 }
617                 for {} 1 {} {
618                     if iszero(shr(m, xor(mload(subject), s))) {
619                         result := sub(subject, subjectStart)
620                         break
621                     }
622                     subject := add(subject, 1)
623                     if iszero(lt(subject, end)) { break }
624                 }
625                 break
626             }
627         }
628     }



```

### LlamaRelativeQuorum.sol


```
LibString.replace(string,string,string) (LlamaRelativeQuorum.sol#1106-1178) has a high cyclomatic complexity (14).



    
1106     function replace(string memory subject, string memory search, string memory replacement)
1107         internal
1108         pure
1109         returns (string memory result)
1110     {
1111         /// @solidity memory-safe-assembly
1112         assembly {
1113             let subjectLength := mload(subject)
1114             let searchLength := mload(search)
1115             let replacementLength := mload(replacement)
1116 
1117             subject := add(subject, 0x20)
1118             search := add(search, 0x20)
1119             replacement := add(replacement, 0x20)
1120             result := add(mload(0x40), 0x20)
1121 
1122             let subjectEnd := add(subject, subjectLength)
1123             if iszero(gt(searchLength, subjectLength)) {
1124                 let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)
1125                 let h := 0
1126                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
1127                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
1128                 let s := mload(search)
1129                 for {} 1 {} {
1130                     let t := mload(subject)
1131                     // Whether the first `searchLength % 32` bytes of
1132                     // `subject` and `search` matches.
1133                     if iszero(shr(m, xor(t, s))) {
1134                         if h {
1135                             if iszero(eq(keccak256(subject, searchLength), h)) {
1136                                 mstore(result, t)
1137                                 result := add(result, 1)
1138                                 subject := add(subject, 1)
1139                                 if iszero(lt(subject, subjectSearchEnd)) { break }
1140                                 continue
1141                             }
1142                         }
1143                         // Copy the `replacement` one word at a time.
1144                         for { let o := 0 } 1 {} {
1145                             mstore(add(result, o), mload(add(replacement, o)))
1146                             o := add(o, 0x20)
1147                             if iszero(lt(o, replacementLength)) { break }
1148                         }
1149                         result := add(result, replacementLength)
1150                         subject := add(subject, searchLength)
1151                         if searchLength {
1152                             if iszero(lt(subject, subjectSearchEnd)) { break }
1153                             continue
1154                         }
1155                     }
1156                     mstore(result, t)
1157                     result := add(result, 1)
1158                     subject := add(subject, 1)
1159                     if iszero(lt(subject, subjectSearchEnd)) { break }
1160                 }
1161             }
1162 
1163             let resultRemainder := result
1164             result := add(mload(0x40), 0x20)
1165             let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))
1166             // Copy the rest of the string one word at a time.
1167             for {} lt(subject, subjectEnd) {} {
1168                 mstore(resultRemainder, mload(subject))
1169                 resultRemainder := add(resultRemainder, 0x20)
1170                 subject := add(subject, 0x20)
1171             }
1172             result := sub(result, 0x20)
1173             let last := add(add(result, 0x20), k) // Zeroize the slot after the string.
1174             mstore(last, 0)
1175             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1176             mstore(result, k) // Store the length.
1177         }
1178     }



```

```
LibString.indexOf(string,string,uint256) (LlamaRelativeQuorum.sol#1183-1236) has a high cyclomatic complexity (13).



    
1183     function indexOf(string memory subject, string memory search, uint256 from)
1184         internal
1185         pure
1186         returns (uint256 result)
1187     {
1188         /// @solidity memory-safe-assembly
1189         assembly {
1190             for { let subjectLength := mload(subject) } 1 {} {
1191                 if iszero(mload(search)) {
1192                     if iszero(gt(from, subjectLength)) {
1193                         result := from
1194                         break
1195                     }
1196                     result := subjectLength
1197                     break
1198                 }
1199                 let searchLength := mload(search)
1200                 let subjectStart := add(subject, 0x20)
1201 
1202                 result := not(0) // Initialize to `NOT_FOUND`.
1203 
1204                 subject := add(subjectStart, from)
1205                 let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)
1206 
1207                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
1208                 let s := mload(add(search, 0x20))
1209 
1210                 if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }
1211 
1212                 if iszero(lt(searchLength, 0x20)) {
1213                     for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
1214                         if iszero(shr(m, xor(mload(subject), s))) {
1215                             if eq(keccak256(subject, searchLength), h) {
1216                                 result := sub(subject, subjectStart)
1217                                 break
1218                             }
1219                         }
1220                         subject := add(subject, 1)
1221                         if iszero(lt(subject, end)) { break }
1222                     }
1223                     break
1224                 }
1225                 for {} 1 {} {
1226                     if iszero(shr(m, xor(mload(subject), s))) {
1227                         result := sub(subject, subjectStart)
1228                         break
1229                     }
1230                     subject := add(subject, 1)
1231                     if iszero(lt(subject, end)) { break }
1232                 }
1233                 break
1234             }
1235         }
1236     }



```

## dead-code
### Severity: Informational

### LlamaAbsolutePeerReview.sol


```
LibString.indexOf(string,string) (LlamaAbsolutePeerReview.sol#1241-1247) is never used and should be removed



    
1241     function indexOf(string memory subject, string memory search)
1242         internal
1243         pure
1244         returns (uint256 result)
1245     {
1246         result = indexOf(subject, search, 0);
1247     }



```

```
Initializable._isInitializing() (LlamaAbsolutePeerReview.sol#182-184) is never used and should be removed



    
182     function _isInitializing() internal view returns (bool) {
183         return _initializing;
184     }



```

```
FixedPointMathLib.unsafeMod(uint256,uint256) (LlamaAbsolutePeerReview.sol#412-419) is never used and should be removed



    
412     function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {
413         /// @solidity memory-safe-assembly
414         assembly {
415             // Mod x by y. Note this will return
416             // 0 instead of reverting if y is zero.
417             z := mod(x, y)
418         }
419     }



```

```
LibString.indexOf(string,string,uint256) (LlamaAbsolutePeerReview.sol#1183-1236) is never used and should be removed



    
1183     function indexOf(string memory subject, string memory search, uint256 from)
1184         internal
1185         pure
1186         returns (uint256 result)
1187     {
1188         /// @solidity memory-safe-assembly
1189         assembly {
1190             for { let subjectLength := mload(subject) } 1 {} {
1191                 if iszero(mload(search)) {
1192                     if iszero(gt(from, subjectLength)) {
1193                         result := from
1194                         break
1195                     }
1196                     result := subjectLength
1197                     break
1198                 }
1199                 let searchLength := mload(search)
1200                 let subjectStart := add(subject, 0x20)
1201 
1202                 result := not(0) // Initialize to `NOT_FOUND`.
1203 
1204                 subject := add(subjectStart, from)
1205                 let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)
1206 
1207                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
1208                 let s := mload(add(search, 0x20))
1209 
1210                 if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }
1211 
1212                 if iszero(lt(searchLength, 0x20)) {
1213                     for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
1214                         if iszero(shr(m, xor(mload(subject), s))) {
1215                             if eq(keccak256(subject, searchLength), h) {
1216                                 result := sub(subject, subjectStart)
1217                                 break
1218                             }
1219                         }
1220                         subject := add(subject, 1)
1221                         if iszero(lt(subject, end)) { break }
1222                     }
1223                     break
1224                 }
1225                 for {} 1 {} {
1226                     if iszero(shr(m, xor(mload(subject), s))) {
1227                         result := sub(subject, subjectStart)
1228                         break
1229                     }
1230                     subject := add(subject, 1)
1231                     if iszero(lt(subject, end)) { break }
1232                 }
1233                 break
1234             }
1235         }
1236     }



```

```
FixedPointMathLib.rpow(uint256,uint256,uint256) (LlamaAbsolutePeerReview.sol#254-341) is never used and should be removed



    
254     function rpow(
255         uint256 x,
256         uint256 n,
257         uint256 scalar
258     ) internal pure returns (uint256 z) {
259         /// @solidity memory-safe-assembly
260         assembly {
261             switch x
262             case 0 {
263                 switch n
264                 case 0 {
265                     // 0 ** 0 = 1
266                     z := scalar
267                 }
268                 default {
269                     // 0 ** n = 0
270                     z := 0
271                 }
272             }
273             default {
274                 switch mod(n, 2)
275                 case 0 {
276                     // If n is even, store scalar in z for now.
277                     z := scalar
278                 }
279                 default {
280                     // If n is odd, store x in z for now.
281                     z := x
282                 }
283 
284                 // Shifting right by 1 is like dividing by 2.
285                 let half := shr(1, scalar)
286 
287                 for {
288                     // Shift n right by 1 before looping to halve it.
289                     n := shr(1, n)
290                 } n {
291                     // Shift n right by 1 each iteration to halve it.
292                     n := shr(1, n)
293                 } {
294                     // Revert immediately if x ** 2 would overflow.
295                     // Equivalent to iszero(eq(div(xx, x), x)) here.
296                     if shr(128, x) {
297                         revert(0, 0)
298                     }
299 
300                     // Store x squared.
301                     let xx := mul(x, x)
302 
303                     // Round to the nearest number.
304                     let xxRound := add(xx, half)
305 
306                     // Revert if xx + half overflowed.
307                     if lt(xxRound, xx) {
308                         revert(0, 0)
309                     }
310 
311                     // Set x to scaled xxRound.
312                     x := div(xxRound, scalar)
313 
314                     // If n is even:
315                     if mod(n, 2) {
316                         // Compute z * x.
317                         let zx := mul(z, x)
318 
319                         // If z * x overflowed:
320                         if iszero(eq(div(zx, x), z)) {
321                             // Revert if x is non-zero.
322                             if iszero(iszero(x)) {
323                                 revert(0, 0)
324                             }
325                         }
326 
327                         // Round to the nearest number.
328                         let zxRound := add(zx, half)
329 
330                         // Revert if zx + half overflowed.
331                         if lt(zxRound, zx) {
332                             revert(0, 0)
333                         }
334 
335                         // Return properly scaled zxRound.
336                         z := div(zxRound, scalar)
337                     }
338                 }
339             }
340         }
341     }



```

```
Clones.predictDeterministicAddress(address,bytes32) (LlamaAbsolutePeerReview.sol#575-580) is never used and should be removed



    
575     function predictDeterministicAddress(
576         address implementation,
577         bytes32 salt
578     ) internal view returns (address predicted) {
579         return predictDeterministicAddress(implementation, salt, address(this));
580     }



```

```
LibString.toHexString(bytes) (LlamaAbsolutePeerReview.sol#1014-1023) is never used and should be removed



    
1014     function toHexString(bytes memory raw) internal pure returns (string memory str) {
1015         str = toHexStringNoPrefix(raw);
1016         /// @solidity memory-safe-assembly
1017         assembly {
1018             let strLength := add(mload(str), 2) // Compute the length.
1019             mstore(str, 0x3078) // Write the "0x" prefix.
1020             str := sub(str, 2) // Move the pointer.
1021             mstore(str, strLength) // Write the length.
1022         }
1023     }



```

```
LibString.toHexString(uint256,uint256) (LlamaAbsolutePeerReview.sol#788-797) is never used and should be removed



    
788     function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {
789         str = toHexStringNoPrefix(value, length);
790         /// @solidity memory-safe-assembly
791         assembly {
792             let strLength := add(mload(str), 2) // Compute the length.
793             mstore(str, 0x3078) // Write the "0x" prefix.
794             str := sub(str, 2) // Move the pointer.
795             mstore(str, strLength) // Write the length.
796         }
797     }



```

```
LibString.escapeJSON(string) (LlamaAbsolutePeerReview.sol#1645-1691) is never used and should be removed



    
1645     function escapeJSON(string memory s) internal pure returns (string memory result) {
1646         /// @solidity memory-safe-assembly
1647         assembly {
1648             for {
1649                 let end := add(s, mload(s))
1650                 result := add(mload(0x40), 0x20)
1651                 // Store "\\u0000" in scratch space.
1652                 // Store "0123456789abcdef" in scratch space.
1653                 // Also, store `{0x08:"b", 0x09:"t", 0x0a:"n", 0x0c:"f", 0x0d:"r"}`.
1654                 // into the scratch space.
1655                 mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)
1656                 // Bitmask for detecting `["\"","\\"]`.
1657                 let e := or(shl(0x22, 1), shl(0x5c, 1))
1658             } iszero(eq(s, end)) {} {
1659                 s := add(s, 1)
1660                 let c := and(mload(s), 0xff)
1661                 if iszero(lt(c, 0x20)) {
1662                     if iszero(and(shl(c, 1), e)) {
1663                         // Not in `["\"","\\"]`.
1664                         mstore8(result, c)
1665                         result := add(result, 1)
1666                         continue
1667                     }
1668                     mstore8(result, 0x5c) // "\\".
1669                     mstore8(add(result, 1), c)
1670                     result := add(result, 2)
1671                     continue
1672                 }
1673                 if iszero(and(shl(c, 1), 0x3700)) {
1674                     // Not in `["\b","\t","\n","\f","\d"]`.
1675                     mstore8(0x1d, mload(shr(4, c))) // Hex value.
1676                     mstore8(0x1e, mload(and(c, 15))) // Hex value.
1677                     mstore(result, mload(0x19)) // "\\u00XX".
1678                     result := add(result, 6)
1679                     continue
1680                 }
1681                 mstore8(result, 0x5c) // "\\".
1682                 mstore8(add(result, 1), mload(add(c, 8)))
1683                 result := add(result, 2)
1684             }
1685             let last := result
1686             mstore(last, 0) // Zeroize the slot after the string.
1687             result := mload(0x40)
1688             mstore(result, sub(last, add(result, 0x20))) // Store the length.
1689             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1690         }
1691     }



```

```
FixedPointMathLib.mulDivUp(uint256,uint256,uint256) (LlamaAbsolutePeerReview.sol#236-252) is never used and should be removed



    
236     function mulDivUp(
237         uint256 x,
238         uint256 y,
239         uint256 denominator
240     ) internal pure returns (uint256 z) {
241         /// @solidity memory-safe-assembly
242         assembly {
243             // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))
244             if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {
245                 revert(0, 0)
246             }
247 
248             // If x * y modulo the denominator is strictly greater than 0,
249             // 1 is added to round up the division of x * y by the denominator.
250             z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))
251         }
252     }



```

```
LibString.toHexStringNoPrefix(bytes) (LlamaAbsolutePeerReview.sol#1027-1049) is never used and should be removed



    
1027     function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {
1028         /// @solidity memory-safe-assembly
1029         assembly {
1030             let length := mload(raw)
1031             str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.
1032             mstore(str, add(length, length)) // Store the length of the output.
1033 
1034             // Store "0123456789abcdef" in scratch space.
1035             mstore(0x0f, 0x30313233343536373839616263646566)
1036 
1037             let o := add(str, 0x20)
1038             let end := add(raw, length)
1039 
1040             for {} iszero(eq(raw, end)) {} {
1041                 raw := add(raw, 1)
1042                 mstore8(add(o, 1), mload(and(mload(raw), 15)))
1043                 mstore8(o, mload(and(shr(4, mload(raw)), 15)))
1044                 o := add(o, 2)
1045             }
1046             mstore(o, 0) // Zeroize the slot after the string.
1047             mstore(0x40, add(o, 0x20)) // Allocate the memory.
1048         }
1049     }



```

```
LibString.lastIndexOf(string,string) (LlamaAbsolutePeerReview.sol#1289-1295) is never used and should be removed



    
1289     function lastIndexOf(string memory subject, string memory search)
1290         internal
1291         pure
1292         returns (uint256 result)
1293     {
1294         result = lastIndexOf(subject, search, uint256(int256(-1)));
1295     }



```

```
LibString.startsWith(string,string) (LlamaAbsolutePeerReview.sol#1298-1316) is never used and should be removed



    
1298     function startsWith(string memory subject, string memory search)
1299         internal
1300         pure
1301         returns (bool result)
1302     {
1303         /// @solidity memory-safe-assembly
1304         assembly {
1305             let searchLength := mload(search)
1306             // Just using keccak256 directly is actually cheaper.
1307             // forgefmt: disable-next-item
1308             result := and(
1309                 iszero(gt(searchLength, mload(subject))),
1310                 eq(
1311                     keccak256(add(subject, 0x20), searchLength),
1312                     keccak256(add(search, 0x20), searchLength)
1313                 )
1314             )
1315         }
1316     }



```

```
FixedPointMathLib.unsafeDiv(uint256,uint256) (LlamaAbsolutePeerReview.sol#421-428) is never used and should be removed



    
421     function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {
422         /// @solidity memory-safe-assembly
423         assembly {
424             // Divide x by y. Note this will return
425             // 0 instead of reverting if y is zero.
426             r := div(x, y)
427         }
428     }



```

```
LibString.lastIndexOf(string,string,uint256) (LlamaAbsolutePeerReview.sol#1252-1284) is never used and should be removed



    
1252     function lastIndexOf(string memory subject, string memory search, uint256 from)
1253         internal
1254         pure
1255         returns (uint256 result)
1256     {
1257         /// @solidity memory-safe-assembly
1258         assembly {
1259             for {} 1 {} {
1260                 result := not(0) // Initialize to `NOT_FOUND`.
1261                 let searchLength := mload(search)
1262                 if gt(searchLength, mload(subject)) { break }
1263                 let w := result
1264 
1265                 let fromMax := sub(mload(subject), searchLength)
1266                 if iszero(gt(fromMax, from)) { from := fromMax }
1267 
1268                 let end := add(add(subject, 0x20), w)
1269                 subject := add(add(subject, 0x20), from)
1270                 if iszero(gt(subject, end)) { break }
1271                 // As this function is not too often used,
1272                 // we shall simply use keccak256 for smaller bytecode size.
1273                 for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
1274                     if eq(keccak256(subject, searchLength), h) {
1275                         result := sub(subject, add(end, 1))
1276                         break
1277                     }
1278                     subject := add(subject, w) // `sub(subject, 1)`.
1279                     if iszero(gt(subject, end)) { break }
1280                 }
1281                 break
1282             }
1283         }
1284     }



```

```
LibString.toString(int256) (LlamaAbsolutePeerReview.sol#761-777) is never used and should be removed



    
761     function toString(int256 value) internal pure returns (string memory str) {
762         if (value >= 0) {
763             return toString(uint256(value));
764         }
765         unchecked {
766             str = toString(uint256(-value));
767         }
768         /// @solidity memory-safe-assembly
769         assembly {
770             // We still have some spare memory space on the left,
771             // as we have allocated 3 words (96 bytes) for up to 78 digits.
772             let length := mload(str) // Load the string length.
773             mstore(str, 0x2d) // Store the '-' character.
774             str := sub(str, 1) // Move back the string pointer by a byte.
775             mstore(str, add(length, 1)) // Update the string length.
776         }
777     }



```

```
Clones.predictDeterministicAddress(address,bytes32,address) (LlamaAbsolutePeerReview.sol#554-570) is never used and should be removed



    
554     function predictDeterministicAddress(
555         address implementation,
556         bytes32 salt,
557         address deployer
558     ) internal pure returns (address predicted) {
559         /// @solidity memory-safe-assembly
560         assembly {
561             let ptr := mload(0x40)
562             mstore(add(ptr, 0x38), deployer)
563             mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)
564             mstore(add(ptr, 0x14), implementation)
565             mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)
566             mstore(add(ptr, 0x58), salt)
567             mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))
568             predicted := keccak256(add(ptr, 0x43), 0x55)
569         }
570     }



```

```
LibString.directReturn(string) (LlamaAbsolutePeerReview.sol#1787-1800) is never used and should be removed



    
1787     function directReturn(string memory a) internal pure {
1788         assembly {
1789             // Assumes that the string does not start from the scratch space.
1790             let retStart := sub(a, 0x20)
1791             let retSize := add(mload(a), 0x40)
1792             // Right pad with zeroes. Just in case the string is produced
1793             // by a method that doesn't zero right pad.
1794             mstore(add(retStart, retSize), 0)
1795             // Store the return offset.
1796             mstore(retStart, 0x20)
1797             // End the transaction, returning the string.
1798             return(retStart, retSize)
1799         }
1800     }



```

```
LibString.toMinimalHexStringNoPrefix(uint256) (LlamaAbsolutePeerReview.sol#888-897) is never used and should be removed



    
888     function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {
889         str = toHexStringNoPrefix(value);
890         /// @solidity memory-safe-assembly
891         assembly {
892             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
893             let strLength := mload(str) // Get the length.
894             str := add(str, o) // Move the pointer, accounting for leading zero.
895             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
896         }
897     }



```

```
LibString.toMinimalHexString(uint256) (LlamaAbsolutePeerReview.sol#873-883) is never used and should be removed



    
873     function toMinimalHexString(uint256 value) internal pure returns (string memory str) {
874         str = toHexStringNoPrefix(value);
875         /// @solidity memory-safe-assembly
876         assembly {
877             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
878             let strLength := add(mload(str), 2) // Compute the length.
879             mstore(add(str, o), 0x3078) // Write the "0x" prefix, accounting for leading zero.
880             str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.
881             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
882         }
883     }



```

```
FixedPointMathLib.divWadDown(uint256,uint256) (LlamaAbsolutePeerReview.sol#207-209) is never used and should be removed



    
207     function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {
208         return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.
209     }



```

```
FixedPointMathLib.mulWadUp(uint256,uint256) (LlamaAbsolutePeerReview.sol#203-205) is never used and should be removed



    
203     function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {
204         return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.
205     }



```

```
LibString.toHexString(uint256) (LlamaAbsolutePeerReview.sol#858-867) is never used and should be removed



    
858     function toHexString(uint256 value) internal pure returns (string memory str) {
859         str = toHexStringNoPrefix(value);
860         /// @solidity memory-safe-assembly
861         assembly {
862             let strLength := add(mload(str), 2) // Compute the length.
863             mstore(str, 0x3078) // Write the "0x" prefix.
864             str := sub(str, 2) // Move the pointer.
865             mstore(str, strLength) // Write the length.
866         }
867     }



```

```
ERC721NonTransferableMinimalProxy._safeMint(address,uint256,bytes) (LlamaAbsolutePeerReview.sol#2255-2264) is never used and should be removed



    
2255   function _safeMint(address to, uint256 id, bytes memory data) internal virtual {
2256     _mint(to, id);
2257 
2258     require(
2259       to.code.length == 0
2260         || ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data)
2261           == ERC721TokenReceiver.onERC721Received.selector,
2262       "UNSAFE_RECIPIENT"
2263     );
2264   }



```

```
LibString.indicesOf(string,string) (LlamaAbsolutePeerReview.sol#1424-1480) is never used and should be removed



    
1424     function indicesOf(string memory subject, string memory search)
1425         internal
1426         pure
1427         returns (uint256[] memory result)
1428     {
1429         /// @solidity memory-safe-assembly
1430         assembly {
1431             let subjectLength := mload(subject)
1432             let searchLength := mload(search)
1433 
1434             if iszero(gt(searchLength, subjectLength)) {
1435                 subject := add(subject, 0x20)
1436                 search := add(search, 0x20)
1437                 result := add(mload(0x40), 0x20)
1438 
1439                 let subjectStart := subject
1440                 let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)
1441                 let h := 0
1442                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
1443                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
1444                 let s := mload(search)
1445                 for {} 1 {} {
1446                     let t := mload(subject)
1447                     // Whether the first `searchLength % 32` bytes of
1448                     // `subject` and `search` matches.
1449                     if iszero(shr(m, xor(t, s))) {
1450                         if h {
1451                             if iszero(eq(keccak256(subject, searchLength), h)) {
1452                                 subject := add(subject, 1)
1453                                 if iszero(lt(subject, subjectSearchEnd)) { break }
1454                                 continue
1455                             }
1456                         }
1457                         // Append to `result`.
1458                         mstore(result, sub(subject, subjectStart))
1459                         result := add(result, 0x20)
1460                         // Advance `subject` by `searchLength`.
1461                         subject := add(subject, searchLength)
1462                         if searchLength {
1463                             if iszero(lt(subject, subjectSearchEnd)) { break }
1464                             continue
1465                         }
1466                     }
1467                     subject := add(subject, 1)
1468                     if iszero(lt(subject, subjectSearchEnd)) { break }
1469                 }
1470                 let resultEnd := result
1471                 // Assign `result` to the free memory pointer.
1472                 result := mload(0x40)
1473                 // Store the length of `result`.
1474                 mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))
1475                 // Allocate memory for result.
1476                 // We allocate one more word, so this array can be recycled for {split}.
1477                 mstore(0x40, add(resultEnd, 0x20))
1478             }
1479         }
1480     }



```

```
Initializable._checkInitializing() (LlamaAbsolutePeerReview.sol#148-152) is never used and should be removed



    
148     function _checkInitializing() internal view virtual {
149         if (!_initializing) {
150             revert NotInitializing();
151         }
152     }



```

```
FixedPointMathLib.mulDivDown(uint256,uint256,uint256) (LlamaAbsolutePeerReview.sol#219-234) is never used and should be removed



    
219     function mulDivDown(
220         uint256 x,
221         uint256 y,
222         uint256 denominator
223     ) internal pure returns (uint256 z) {
224         /// @solidity memory-safe-assembly
225         assembly {
226             // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))
227             if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {
228                 revert(0, 0)
229             }
230 
231             // Divide x * y by the denominator.
232             z := div(mul(x, y), denominator)
233         }
234     }



```

```
LibString.unpackOne(bytes32) (LlamaAbsolutePeerReview.sol#1721-1735) is never used and should be removed



    
1721     function unpackOne(bytes32 packed) internal pure returns (string memory result) {
1722         /// @solidity memory-safe-assembly
1723         assembly {
1724             // Grab the free memory pointer.
1725             result := mload(0x40)
1726             // Allocate 2 words (1 for the length, 1 for the bytes).
1727             mstore(0x40, add(result, 0x40))
1728             // Zeroize the length slot.
1729             mstore(result, 0)
1730             // Store the length and bytes.
1731             mstore(add(result, 0x1f), packed)
1732             // Right pad with zeroes.
1733             mstore(add(add(result, 0x20), mload(result)), 0)
1734         }
1735     }



```

```
LibString.toString(uint256) (LlamaAbsolutePeerReview.sol#723-758) is never used and should be removed



    
723     function toString(uint256 value) internal pure returns (string memory str) {
724         /// @solidity memory-safe-assembly
725         assembly {
726             // The maximum value of a uint256 contains 78 digits (1 byte per digit), but
727             // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.
728             // We will need 1 word for the trailing zeros padding, 1 word for the length,
729             // and 3 words for a maximum of 78 digits.
730             str := add(mload(0x40), 0x80)
731             // Update the free memory pointer to allocate.
732             mstore(0x40, add(str, 0x20))
733             // Zeroize the slot after the string.
734             mstore(str, 0)
735 
736             // Cache the end of the memory to calculate the length later.
737             let end := str
738 
739             let w := not(0) // Tsk.
740             // We write the string from rightmost digit to leftmost digit.
741             // The following is essentially a do-while loop that also handles the zero case.
742             for { let temp := value } 1 {} {
743                 str := add(str, w) // `sub(str, 1)`.
744                 // Write the character to the pointer.
745                 // The ASCII index of the '0' character is 48.
746                 mstore8(str, add(48, mod(temp, 10)))
747                 // Keep dividing `temp` until zero.
748                 temp := div(temp, 10)
749                 if iszero(temp) { break }
750             }
751 
752             let length := sub(end, str)
753             // Move the pointer 32 bytes leftwards to make room for the length.
754             str := sub(str, 0x20)
755             // Store the length.
756             mstore(str, length)
757         }
758     }



```

```
ERC721NonTransferableMinimalProxy._safeMint(address,uint256) (LlamaAbsolutePeerReview.sol#2244-2253) is never used and should be removed



    
2244   function _safeMint(address to, uint256 id) internal virtual {
2245     _mint(to, id);
2246 
2247     require(
2248       to.code.length == 0
2249         || ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "")
2250           == ERC721TokenReceiver.onERC721Received.selector,
2251       "UNSAFE_RECIPIENT"
2252     );
2253   }



```

```
LibString.packOne(string) (LlamaAbsolutePeerReview.sol#1702-1716) is never used and should be removed



    
1702     function packOne(string memory a) internal pure returns (bytes32 result) {
1703         /// @solidity memory-safe-assembly
1704         assembly {
1705             // We don't need to zero right pad the string,
1706             // since this is our own custom non-standard packing scheme.
1707             result :=
1708                 mul(
1709                     // Load the length and the bytes.
1710                     mload(add(a, 0x1f)),
1711                     // `length != 0 && length < 32`. Abuses underflow.
1712                     // Assumes that the length is valid and within the block gas limit.
1713                     lt(sub(mload(a), 1), 0x1f)
1714                 )
1715         }
1716     }



```

```
LibString.runeCount(string) (LlamaAbsolutePeerReview.sol#1056-1070) is never used and should be removed



    
1056     function runeCount(string memory s) internal pure returns (uint256 result) {
1057         /// @solidity memory-safe-assembly
1058         assembly {
1059             if mload(s) {
1060                 mstore(0x00, div(not(0), 255))
1061                 mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)
1062                 let o := add(s, 0x20)
1063                 let end := add(o, mload(s))
1064                 for { result := 1 } 1 { result := add(result, 1) } {
1065                     o := add(o, byte(0, mload(shr(250, mload(o)))))
1066                     if iszero(lt(o, end)) { break }
1067                 }
1068             }
1069         }
1070     }



```

```
LibString.unpackTwo(bytes32) (LlamaAbsolutePeerReview.sol#1762-1784) is never used and should be removed



    
1762     function unpackTwo(bytes32 packed)
1763         internal
1764         pure
1765         returns (string memory resultA, string memory resultB)
1766     {
1767         /// @solidity memory-safe-assembly
1768         assembly {
1769             // Grab the free memory pointer.
1770             resultA := mload(0x40)
1771             resultB := add(resultA, 0x40)
1772             // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.
1773             mstore(0x40, add(resultB, 0x40))
1774             // Zeroize the length slots.
1775             mstore(resultA, 0)
1776             mstore(resultB, 0)
1777             // Store the lengths and bytes.
1778             mstore(add(resultA, 0x1f), packed)
1779             mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))
1780             // Right pad with zeroes.
1781             mstore(add(add(resultA, 0x20), mload(resultA)), 0)
1782             mstore(add(add(resultB, 0x20), mload(resultB)), 0)
1783         }
1784     }



```

```
LibString.endsWith(string,string) (LlamaAbsolutePeerReview.sol#1319-1344) is never used and should be removed



    
1319     function endsWith(string memory subject, string memory search)
1320         internal
1321         pure
1322         returns (bool result)
1323     {
1324         /// @solidity memory-safe-assembly
1325         assembly {
1326             let searchLength := mload(search)
1327             let subjectLength := mload(subject)
1328             // Whether `search` is not longer than `subject`.
1329             let withinRange := iszero(gt(searchLength, subjectLength))
1330             // Just using keccak256 directly is actually cheaper.
1331             // forgefmt: disable-next-item
1332             result := and(
1333                 withinRange,
1334                 eq(
1335                     keccak256(
1336                         // `subject + 0x20 + max(subjectLength - searchLength, 0)`.
1337                         add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),
1338                         searchLength
1339                     ),
1340                     keccak256(add(search, 0x20), searchLength)
1341                 )
1342             )
1343         }
1344     }



```

```
FixedPointMathLib.divWadUp(uint256,uint256) (LlamaAbsolutePeerReview.sol#211-213) is never used and should be removed



    
211     function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {
212         return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.
213     }



```

```
LibString.escapeHTML(string) (LlamaAbsolutePeerReview.sol#1611-1642) is never used and should be removed



    
1611     function escapeHTML(string memory s) internal pure returns (string memory result) {
1612         /// @solidity memory-safe-assembly
1613         assembly {
1614             for {
1615                 let end := add(s, mload(s))
1616                 result := add(mload(0x40), 0x20)
1617                 // Store the bytes of the packed offsets and strides into the scratch space.
1618                 // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.
1619                 mstore(0x1f, 0x900094)
1620                 mstore(0x08, 0xc0000000a6ab)
1621                 // Store "&quot;&amp;&#39;&lt;&gt;" into the scratch space.
1622                 mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))
1623             } iszero(eq(s, end)) {} {
1624                 s := add(s, 1)
1625                 let c := and(mload(s), 0xff)
1626                 // Not in `["\"","'","&","<",">"]`.
1627                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
1628                     mstore8(result, c)
1629                     result := add(result, 1)
1630                     continue
1631                 }
1632                 let t := shr(248, mload(c))
1633                 mstore(result, mload(and(t, 0x1f)))
1634                 result := add(result, shr(5, t))
1635             }
1636             let last := result
1637             mstore(last, 0) // Zeroize the slot after the string.
1638             result := mload(0x40)
1639             mstore(result, sub(last, add(result, 0x20))) // Store the length.
1640             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1641         }
1642     }



```

```
LibString.toHexStringChecksummed(address) (LlamaAbsolutePeerReview.sol#943-960) is never used and should be removed



    
943     function toHexStringChecksummed(address value) internal pure returns (string memory str) {
944         str = toHexString(value);
945         /// @solidity memory-safe-assembly
946         assembly {
947             let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`
948             let o := add(str, 0x22)
949             let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `
950             let t := shl(240, 136) // `0b10001000 << 240`
951             for { let i := 0 } 1 {} {
952                 mstore(add(i, i), mul(t, byte(i, hashed)))
953                 i := add(i, 1)
954                 if eq(i, 20) { break }
955             }
956             mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))
957             o := add(o, 0x20)
958             mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))
959         }
960     }



```

```
LibString.toHexStringNoPrefix(uint256) (LlamaAbsolutePeerReview.sol#903-937) is never used and should be removed



    
903     function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {
904         /// @solidity memory-safe-assembly
905         assembly {
906             // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,
907             // 0x02 bytes for the prefix, and 0x40 bytes for the digits.
908             // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.
909             str := add(mload(0x40), 0x80)
910             // Allocate the memory.
911             mstore(0x40, add(str, 0x20))
912             // Zeroize the slot after the string.
913             mstore(str, 0)
914 
915             // Cache the end to calculate the length later.
916             let end := str
917             // Store "0123456789abcdef" in scratch space.
918             mstore(0x0f, 0x30313233343536373839616263646566)
919 
920             let w := not(1) // Tsk.
921             // We write the string from rightmost digit to leftmost digit.
922             // The following is essentially a do-while loop that also handles the zero case.
923             for { let temp := value } 1 {} {
924                 str := add(str, w) // `sub(str, 2)`.
925                 mstore8(add(str, 1), mload(and(temp, 15)))
926                 mstore8(str, mload(and(shr(4, temp), 15)))
927                 temp := shr(8, temp)
928                 if iszero(temp) { break }
929             }
930 
931             // Compute the string's length.
932             let strLength := sub(end, str)
933             // Move the pointer and write the length.
934             str := sub(str, 0x20)
935             mstore(str, strLength)
936         }
937     }



```

```
Clones.clone(address) (LlamaAbsolutePeerReview.sol#514-527) is never used and should be removed



    
514     function clone(address implementation) internal returns (address instance) {
515         /// @solidity memory-safe-assembly
516         assembly {
517             // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
518             // of the `implementation` address with the bytecode before the address.
519             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
520             // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
521             mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
522             instance := create(0, 0x09, 0x37)
523         }
524         if (instance == address(0)) {
525             revert ERC1167FailedCreateClone();
526         }
527     }



```

```
LibString.is7BitASCII(string) (LlamaAbsolutePeerReview.sol#1074-1096) is never used and should be removed



    
1074     function is7BitASCII(string memory s) internal pure returns (bool result) {
1075         /// @solidity memory-safe-assembly
1076         assembly {
1077             let mask := shl(7, div(not(0), 255))
1078             result := 1
1079             let n := mload(s)
1080             if n {
1081                 let o := add(s, 0x20)
1082                 let end := add(o, n)
1083                 let last := mload(end)
1084                 mstore(end, 0)
1085                 for {} 1 {} {
1086                     if and(mask, mload(o)) {
1087                         result := 0
1088                         break
1089                     }
1090                     o := add(o, 0x20)
1091                     if iszero(lt(o, end)) { break }
1092                 }
1093                 mstore(end, last)
1094             }
1095         }
1096     }



```

```
Initializable._getInitializedVersion() (LlamaAbsolutePeerReview.sol#175-177) is never used and should be removed



    
175     function _getInitializedVersion() internal view returns (uint8) {
176         return _initialized;
177     }



```

```
Checkpoints.length(Checkpoints.History) (LlamaAbsolutePeerReview.sol#1912-1914) is never used and should be removed



    
1912     function length(History storage self) internal view returns (uint256) {
1913         return self._checkpoints.length;
1914     }



```

```
FixedPointMathLib.sqrt(uint256) (LlamaAbsolutePeerReview.sol#347-410) is never used and should be removed



    
347     function sqrt(uint256 x) internal pure returns (uint256 z) {
348         /// @solidity memory-safe-assembly
349         assembly {
350             let y := x // We start y at x, which will help us make our initial estimate.
351 
352             z := 181 // The "correct" value is 1, but this saves a multiplication later.
353 
354             // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad
355             // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.
356 
357             // We check y >= 2^(k + 8) but shift right by k bits
358             // each branch to ensure that if x >= 256, then y >= 256.
359             if iszero(lt(y, 0x10000000000000000000000000000000000)) {
360                 y := shr(128, y)
361                 z := shl(64, z)
362             }
363             if iszero(lt(y, 0x1000000000000000000)) {
364                 y := shr(64, y)
365                 z := shl(32, z)
366             }
367             if iszero(lt(y, 0x10000000000)) {
368                 y := shr(32, y)
369                 z := shl(16, z)
370             }
371             if iszero(lt(y, 0x1000000)) {
372                 y := shr(16, y)
373                 z := shl(8, z)
374             }
375 
376             // Goal was to get z*z*y within a small factor of x. More iterations could
377             // get y in a tighter range. Currently, we will have y in [256, 256*2^16).
378             // We ensured y >= 256 so that the relative difference between y and y+1 is small.
379             // That's not possible if x < 256 but we can just verify those cases exhaustively.
380 
381             // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.
382             // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.
383             // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.
384 
385             // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range
386             // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.
387 
388             // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate
389             // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.
390 
391             // There is no overflow risk here since y < 2^136 after the first branch above.
392             z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.
393 
394             // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.
395             z := shr(1, add(z, div(x, z)))
396             z := shr(1, add(z, div(x, z)))
397             z := shr(1, add(z, div(x, z)))
398             z := shr(1, add(z, div(x, z)))
399             z := shr(1, add(z, div(x, z)))
400             z := shr(1, add(z, div(x, z)))
401             z := shr(1, add(z, div(x, z)))
402 
403             // If x+1 is a perfect square, the Babylonian method cycles between
404             // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.
405             // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division
406             // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.
407             // If you don't care whether the floor or ceil square root is returned, you can remove this statement.
408             z := sub(z, lt(div(x, z), z))
409         }
410     }



```

```
LibString.slice(string,uint256) (LlamaAbsolutePeerReview.sol#1414-1420) is never used and should be removed



    
1414     function slice(string memory subject, uint256 start)
1415         internal
1416         pure
1417         returns (string memory result)
1418     {
1419         result = slice(subject, start, uint256(int256(-1)));
1420     }



```

```
FixedPointMathLib.mulWadDown(uint256,uint256) (LlamaAbsolutePeerReview.sol#199-201) is never used and should be removed



    
199     function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {
200         return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.
201     }



```

```
LibString.concat(string,string) (LlamaAbsolutePeerReview.sol#1532-1566) is never used and should be removed



    
1532     function concat(string memory a, string memory b)
1533         internal
1534         pure
1535         returns (string memory result)
1536     {
1537         /// @solidity memory-safe-assembly
1538         assembly {
1539             let w := not(0x1f)
1540             result := mload(0x40)
1541             let aLength := mload(a)
1542             // Copy `a` one word at a time, backwards.
1543             for { let o := and(add(aLength, 0x20), w) } 1 {} {
1544                 mstore(add(result, o), mload(add(a, o)))
1545                 o := add(o, w) // `sub(o, 0x20)`.
1546                 if iszero(o) { break }
1547             }
1548             let bLength := mload(b)
1549             let output := add(result, aLength)
1550             // Copy `b` one word at a time, backwards.
1551             for { let o := and(add(bLength, 0x20), w) } 1 {} {
1552                 mstore(add(output, o), mload(add(b, o)))
1553                 o := add(o, w) // `sub(o, 0x20)`.
1554                 if iszero(o) { break }
1555             }
1556             let totalLength := add(aLength, bLength)
1557             let last := add(add(result, 0x20), totalLength)
1558             // Zeroize the slot after the string.
1559             mstore(last, 0)
1560             // Stores the length.
1561             mstore(result, totalLength)
1562             // Allocate memory for the length and the bytes,
1563             // rounded up to a multiple of 32.
1564             mstore(0x40, and(add(last, 0x1f), w))
1565         }
1566     }



```

```
LibString.toHexStringNoPrefix(uint256,uint256) (LlamaAbsolutePeerReview.sol#804-852) is never used and should be removed



    
804     function toHexStringNoPrefix(uint256 value, uint256 length)
805         internal
806         pure
807         returns (string memory str)
808     {
809         /// @solidity memory-safe-assembly
810         assembly {
811             // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes
812             // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.
813             // We add 0x20 to the total and round down to a multiple of 0x20.
814             // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.
815             str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))
816             // Allocate the memory.
817             mstore(0x40, add(str, 0x20))
818             // Zeroize the slot after the string.
819             mstore(str, 0)
820 
821             // Cache the end to calculate the length later.
822             let end := str
823             // Store "0123456789abcdef" in scratch space.
824             mstore(0x0f, 0x30313233343536373839616263646566)
825 
826             let start := sub(str, add(length, length))
827             let w := not(1) // Tsk.
828             let temp := value
829             // We write the string from rightmost digit to leftmost digit.
830             // The following is essentially a do-while loop that also handles the zero case.
831             for {} 1 {} {
832                 str := add(str, w) // `sub(str, 2)`.
833                 mstore8(add(str, 1), mload(and(temp, 15)))
834                 mstore8(str, mload(and(shr(4, temp), 15)))
835                 temp := shr(8, temp)
836                 if iszero(xor(str, start)) { break }
837             }
838 
839             if temp {
840                 // Store the function selector of `HexLengthInsufficient()`.
841                 mstore(0x00, 0x2194895a)
842                 // Revert with (offset, size).
843                 revert(0x1c, 0x04)
844             }
845 
846             // Compute the string's length.
847             let strLength := sub(end, str)
848             // Move the pointer and write the length.
849             str := sub(str, 0x20)
850             mstore(str, strLength)
851         }
852     }



```

```
Checkpoints._lowerBinaryLookup(Checkpoints.Checkpoint[],uint64,uint256,uint256) (LlamaAbsolutePeerReview.sol#1981-1996) is never used and should be removed



    
1981     function _lowerBinaryLookup(
1982         Checkpoint[] storage self,
1983         uint64 timestamp,
1984         uint256 low,
1985         uint256 high
1986     ) private view returns (uint256) {
1987         while (low < high) {
1988             uint256 mid = average(low, high);
1989             if (_unsafeAccess(self, mid).timestamp < timestamp) {
1990                 low = mid + 1;
1991             } else {
1992                 high = mid;
1993             }
1994         }
1995         return high;
1996     }



```

```
LibString.split(string,string) (LlamaAbsolutePeerReview.sol#1483-1528) is never used and should be removed



    
1483     function split(string memory subject, string memory delimiter)
1484         internal
1485         pure
1486         returns (string[] memory result)
1487     {
1488         uint256[] memory indices = indicesOf(subject, delimiter);
1489         /// @solidity memory-safe-assembly
1490         assembly {
1491             let w := not(0x1f)
1492             let indexPtr := add(indices, 0x20)
1493             let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))
1494             mstore(add(indicesEnd, w), mload(subject))
1495             mstore(indices, add(mload(indices), 1))
1496             let prevIndex := 0
1497             for {} 1 {} {
1498                 let index := mload(indexPtr)
1499                 mstore(indexPtr, 0x60)
1500                 if iszero(eq(index, prevIndex)) {
1501                     let element := mload(0x40)
1502                     let elementLength := sub(index, prevIndex)
1503                     mstore(element, elementLength)
1504                     // Copy the `subject` one word at a time, backwards.
1505                     for { let o := and(add(elementLength, 0x1f), w) } 1 {} {
1506                         mstore(add(element, o), mload(add(add(subject, prevIndex), o)))
1507                         o := add(o, w) // `sub(o, 0x20)`.
1508                         if iszero(o) { break }
1509                     }
1510                     // Zeroize the slot after the string.
1511                     mstore(add(add(element, 0x20), elementLength), 0)
1512                     // Allocate memory for the length and the bytes,
1513                     // rounded up to a multiple of 32.
1514                     mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))
1515                     // Store the `element` into the array.
1516                     mstore(indexPtr, element)
1517                 }
1518                 prevIndex := add(index, mload(delimiter))
1519                 indexPtr := add(indexPtr, 0x20)
1520                 if iszero(lt(indexPtr, indicesEnd)) { break }
1521             }
1522             result := indices
1523             if iszero(mload(delimiter)) {
1524                 result := add(indices, 0x20)
1525                 mstore(result, sub(mload(indices), 2))
1526             }
1527         }
1528     }



```

```
LibString.lower(string) (LlamaAbsolutePeerReview.sol#1600-1602) is never used and should be removed



    
1600     function lower(string memory subject) internal pure returns (string memory result) {
1601         result = toCase(subject, false);
1602     }



```

```
LibString.packTwo(string,string) (LlamaAbsolutePeerReview.sol#1739-1757) is never used and should be removed



    
1739     function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {
1740         /// @solidity memory-safe-assembly
1741         assembly {
1742             let aLength := mload(a)
1743             // We don't need to zero right pad the strings,
1744             // since this is our own custom non-standard packing scheme.
1745             result :=
1746                 mul(
1747                     // Load the length and the bytes of `a` and `b`.
1748                     or(
1749                         shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),
1750                         mload(sub(add(b, 0x1e), aLength))
1751                     ),
1752                     // `totalLength != 0 && totalLength < 31`. Abuses underflow.
1753                     // Assumes that the lengths are valid and within the block gas limit.
1754                     lt(sub(add(aLength, mload(b)), 1), 0x1e)
1755                 )
1756         }
1757     }



```

```
LibString.eq(string,string) (LlamaAbsolutePeerReview.sol#1694-1698) is never used and should be removed



    
1694     function eq(string memory a, string memory b) internal pure returns (bool result) {
1695         assembly {
1696             result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))
1697         }
1698     }



```

```
FixedPointMathLib.unsafeDivUp(uint256,uint256) (LlamaAbsolutePeerReview.sol#430-437) is never used and should be removed



    
430     function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {
431         /// @solidity memory-safe-assembly
432         assembly {
433             // Add 1 to x * y if x % y > 0. Note this will
434             // return 0 instead of reverting if y is zero.
435             z := add(gt(mod(x, y), 0), div(x, y))
436         }
437     }



```

```
LibString.repeat(string,uint256) (LlamaAbsolutePeerReview.sol#1347-1377) is never used and should be removed



    
1347     function repeat(string memory subject, uint256 times)
1348         internal
1349         pure
1350         returns (string memory result)
1351     {
1352         /// @solidity memory-safe-assembly
1353         assembly {
1354             let subjectLength := mload(subject)
1355             if iszero(or(iszero(times), iszero(subjectLength))) {
1356                 subject := add(subject, 0x20)
1357                 result := mload(0x40)
1358                 let output := add(result, 0x20)
1359                 for {} 1 {} {
1360                     // Copy the `subject` one word at a time.
1361                     for { let o := 0 } 1 {} {
1362                         mstore(add(output, o), mload(add(subject, o)))
1363                         o := add(o, 0x20)
1364                         if iszero(lt(o, subjectLength)) { break }
1365                     }
1366                     output := add(output, subjectLength)
1367                     times := sub(times, 1)
1368                     if iszero(times) { break }
1369                 }
1370                 mstore(output, 0) // Zeroize the slot after the string.
1371                 let resultLength := sub(output, add(result, 0x20))
1372                 mstore(result, resultLength) // Store the length.
1373                 // Allocate the memory.
1374                 mstore(0x40, add(result, add(resultLength, 0x20)))
1375             }
1376         }
1377     }



```

### LlamaAbsoluteQuorum.sol


```
LibString.indexOf(string,string) (LlamaAbsoluteQuorum.sol#1241-1247) is never used and should be removed



    
1241     function indexOf(string memory subject, string memory search)
1242         internal
1243         pure
1244         returns (uint256 result)
1245     {
1246         result = indexOf(subject, search, 0);
1247     }



```

```
Initializable._isInitializing() (LlamaAbsoluteQuorum.sol#182-184) is never used and should be removed



    
182     function _isInitializing() internal view returns (bool) {
183         return _initializing;
184     }



```

```
FixedPointMathLib.unsafeMod(uint256,uint256) (LlamaAbsoluteQuorum.sol#412-419) is never used and should be removed



    
412     function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {
413         /// @solidity memory-safe-assembly
414         assembly {
415             // Mod x by y. Note this will return
416             // 0 instead of reverting if y is zero.
417             z := mod(x, y)
418         }
419     }



```

```
LibString.indexOf(string,string,uint256) (LlamaAbsoluteQuorum.sol#1183-1236) is never used and should be removed



    
1183     function indexOf(string memory subject, string memory search, uint256 from)
1184         internal
1185         pure
1186         returns (uint256 result)
1187     {
1188         /// @solidity memory-safe-assembly
1189         assembly {
1190             for { let subjectLength := mload(subject) } 1 {} {
1191                 if iszero(mload(search)) {
1192                     if iszero(gt(from, subjectLength)) {
1193                         result := from
1194                         break
1195                     }
1196                     result := subjectLength
1197                     break
1198                 }
1199                 let searchLength := mload(search)
1200                 let subjectStart := add(subject, 0x20)
1201 
1202                 result := not(0) // Initialize to `NOT_FOUND`.
1203 
1204                 subject := add(subjectStart, from)
1205                 let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)
1206 
1207                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
1208                 let s := mload(add(search, 0x20))
1209 
1210                 if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }
1211 
1212                 if iszero(lt(searchLength, 0x20)) {
1213                     for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
1214                         if iszero(shr(m, xor(mload(subject), s))) {
1215                             if eq(keccak256(subject, searchLength), h) {
1216                                 result := sub(subject, subjectStart)
1217                                 break
1218                             }
1219                         }
1220                         subject := add(subject, 1)
1221                         if iszero(lt(subject, end)) { break }
1222                     }
1223                     break
1224                 }
1225                 for {} 1 {} {
1226                     if iszero(shr(m, xor(mload(subject), s))) {
1227                         result := sub(subject, subjectStart)
1228                         break
1229                     }
1230                     subject := add(subject, 1)
1231                     if iszero(lt(subject, end)) { break }
1232                 }
1233                 break
1234             }
1235         }
1236     }



```

```
FixedPointMathLib.rpow(uint256,uint256,uint256) (LlamaAbsoluteQuorum.sol#254-341) is never used and should be removed



    
254     function rpow(
255         uint256 x,
256         uint256 n,
257         uint256 scalar
258     ) internal pure returns (uint256 z) {
259         /// @solidity memory-safe-assembly
260         assembly {
261             switch x
262             case 0 {
263                 switch n
264                 case 0 {
265                     // 0 ** 0 = 1
266                     z := scalar
267                 }
268                 default {
269                     // 0 ** n = 0
270                     z := 0
271                 }
272             }
273             default {
274                 switch mod(n, 2)
275                 case 0 {
276                     // If n is even, store scalar in z for now.
277                     z := scalar
278                 }
279                 default {
280                     // If n is odd, store x in z for now.
281                     z := x
282                 }
283 
284                 // Shifting right by 1 is like dividing by 2.
285                 let half := shr(1, scalar)
286 
287                 for {
288                     // Shift n right by 1 before looping to halve it.
289                     n := shr(1, n)
290                 } n {
291                     // Shift n right by 1 each iteration to halve it.
292                     n := shr(1, n)
293                 } {
294                     // Revert immediately if x ** 2 would overflow.
295                     // Equivalent to iszero(eq(div(xx, x), x)) here.
296                     if shr(128, x) {
297                         revert(0, 0)
298                     }
299 
300                     // Store x squared.
301                     let xx := mul(x, x)
302 
303                     // Round to the nearest number.
304                     let xxRound := add(xx, half)
305 
306                     // Revert if xx + half overflowed.
307                     if lt(xxRound, xx) {
308                         revert(0, 0)
309                     }
310 
311                     // Set x to scaled xxRound.
312                     x := div(xxRound, scalar)
313 
314                     // If n is even:
315                     if mod(n, 2) {
316                         // Compute z * x.
317                         let zx := mul(z, x)
318 
319                         // If z * x overflowed:
320                         if iszero(eq(div(zx, x), z)) {
321                             // Revert if x is non-zero.
322                             if iszero(iszero(x)) {
323                                 revert(0, 0)
324                             }
325                         }
326 
327                         // Round to the nearest number.
328                         let zxRound := add(zx, half)
329 
330                         // Revert if zx + half overflowed.
331                         if lt(zxRound, zx) {
332                             revert(0, 0)
333                         }
334 
335                         // Return properly scaled zxRound.
336                         z := div(zxRound, scalar)
337                     }
338                 }
339             }
340         }
341     }



```

```
Clones.predictDeterministicAddress(address,bytes32) (LlamaAbsoluteQuorum.sol#575-580) is never used and should be removed



    
575     function predictDeterministicAddress(
576         address implementation,
577         bytes32 salt
578     ) internal view returns (address predicted) {
579         return predictDeterministicAddress(implementation, salt, address(this));
580     }



```

```
LibString.toHexString(bytes) (LlamaAbsoluteQuorum.sol#1014-1023) is never used and should be removed



    
1014     function toHexString(bytes memory raw) internal pure returns (string memory str) {
1015         str = toHexStringNoPrefix(raw);
1016         /// @solidity memory-safe-assembly
1017         assembly {
1018             let strLength := add(mload(str), 2) // Compute the length.
1019             mstore(str, 0x3078) // Write the "0x" prefix.
1020             str := sub(str, 2) // Move the pointer.
1021             mstore(str, strLength) // Write the length.
1022         }
1023     }



```

```
LibString.toHexString(uint256,uint256) (LlamaAbsoluteQuorum.sol#788-797) is never used and should be removed



    
788     function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {
789         str = toHexStringNoPrefix(value, length);
790         /// @solidity memory-safe-assembly
791         assembly {
792             let strLength := add(mload(str), 2) // Compute the length.
793             mstore(str, 0x3078) // Write the "0x" prefix.
794             str := sub(str, 2) // Move the pointer.
795             mstore(str, strLength) // Write the length.
796         }
797     }



```

```
LibString.escapeJSON(string) (LlamaAbsoluteQuorum.sol#1645-1691) is never used and should be removed



    
1645     function escapeJSON(string memory s) internal pure returns (string memory result) {
1646         /// @solidity memory-safe-assembly
1647         assembly {
1648             for {
1649                 let end := add(s, mload(s))
1650                 result := add(mload(0x40), 0x20)
1651                 // Store "\\u0000" in scratch space.
1652                 // Store "0123456789abcdef" in scratch space.
1653                 // Also, store `{0x08:"b", 0x09:"t", 0x0a:"n", 0x0c:"f", 0x0d:"r"}`.
1654                 // into the scratch space.
1655                 mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)
1656                 // Bitmask for detecting `["\"","\\"]`.
1657                 let e := or(shl(0x22, 1), shl(0x5c, 1))
1658             } iszero(eq(s, end)) {} {
1659                 s := add(s, 1)
1660                 let c := and(mload(s), 0xff)
1661                 if iszero(lt(c, 0x20)) {
1662                     if iszero(and(shl(c, 1), e)) {
1663                         // Not in `["\"","\\"]`.
1664                         mstore8(result, c)
1665                         result := add(result, 1)
1666                         continue
1667                     }
1668                     mstore8(result, 0x5c) // "\\".
1669                     mstore8(add(result, 1), c)
1670                     result := add(result, 2)
1671                     continue
1672                 }
1673                 if iszero(and(shl(c, 1), 0x3700)) {
1674                     // Not in `["\b","\t","\n","\f","\d"]`.
1675                     mstore8(0x1d, mload(shr(4, c))) // Hex value.
1676                     mstore8(0x1e, mload(and(c, 15))) // Hex value.
1677                     mstore(result, mload(0x19)) // "\\u00XX".
1678                     result := add(result, 6)
1679                     continue
1680                 }
1681                 mstore8(result, 0x5c) // "\\".
1682                 mstore8(add(result, 1), mload(add(c, 8)))
1683                 result := add(result, 2)
1684             }
1685             let last := result
1686             mstore(last, 0) // Zeroize the slot after the string.
1687             result := mload(0x40)
1688             mstore(result, sub(last, add(result, 0x20))) // Store the length.
1689             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1690         }
1691     }



```

```
FixedPointMathLib.mulDivUp(uint256,uint256,uint256) (LlamaAbsoluteQuorum.sol#236-252) is never used and should be removed



    
236     function mulDivUp(
237         uint256 x,
238         uint256 y,
239         uint256 denominator
240     ) internal pure returns (uint256 z) {
241         /// @solidity memory-safe-assembly
242         assembly {
243             // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))
244             if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {
245                 revert(0, 0)
246             }
247 
248             // If x * y modulo the denominator is strictly greater than 0,
249             // 1 is added to round up the division of x * y by the denominator.
250             z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))
251         }
252     }



```

```
LibString.toHexStringNoPrefix(bytes) (LlamaAbsoluteQuorum.sol#1027-1049) is never used and should be removed



    
1027     function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {
1028         /// @solidity memory-safe-assembly
1029         assembly {
1030             let length := mload(raw)
1031             str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.
1032             mstore(str, add(length, length)) // Store the length of the output.
1033 
1034             // Store "0123456789abcdef" in scratch space.
1035             mstore(0x0f, 0x30313233343536373839616263646566)
1036 
1037             let o := add(str, 0x20)
1038             let end := add(raw, length)
1039 
1040             for {} iszero(eq(raw, end)) {} {
1041                 raw := add(raw, 1)
1042                 mstore8(add(o, 1), mload(and(mload(raw), 15)))
1043                 mstore8(o, mload(and(shr(4, mload(raw)), 15)))
1044                 o := add(o, 2)
1045             }
1046             mstore(o, 0) // Zeroize the slot after the string.
1047             mstore(0x40, add(o, 0x20)) // Allocate the memory.
1048         }
1049     }



```

```
LibString.lastIndexOf(string,string) (LlamaAbsoluteQuorum.sol#1289-1295) is never used and should be removed



    
1289     function lastIndexOf(string memory subject, string memory search)
1290         internal
1291         pure
1292         returns (uint256 result)
1293     {
1294         result = lastIndexOf(subject, search, uint256(int256(-1)));
1295     }



```

```
LibString.startsWith(string,string) (LlamaAbsoluteQuorum.sol#1298-1316) is never used and should be removed



    
1298     function startsWith(string memory subject, string memory search)
1299         internal
1300         pure
1301         returns (bool result)
1302     {
1303         /// @solidity memory-safe-assembly
1304         assembly {
1305             let searchLength := mload(search)
1306             // Just using keccak256 directly is actually cheaper.
1307             // forgefmt: disable-next-item
1308             result := and(
1309                 iszero(gt(searchLength, mload(subject))),
1310                 eq(
1311                     keccak256(add(subject, 0x20), searchLength),
1312                     keccak256(add(search, 0x20), searchLength)
1313                 )
1314             )
1315         }
1316     }



```

```
FixedPointMathLib.unsafeDiv(uint256,uint256) (LlamaAbsoluteQuorum.sol#421-428) is never used and should be removed



    
421     function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {
422         /// @solidity memory-safe-assembly
423         assembly {
424             // Divide x by y. Note this will return
425             // 0 instead of reverting if y is zero.
426             r := div(x, y)
427         }
428     }



```

```
LibString.lastIndexOf(string,string,uint256) (LlamaAbsoluteQuorum.sol#1252-1284) is never used and should be removed



    
1252     function lastIndexOf(string memory subject, string memory search, uint256 from)
1253         internal
1254         pure
1255         returns (uint256 result)
1256     {
1257         /// @solidity memory-safe-assembly
1258         assembly {
1259             for {} 1 {} {
1260                 result := not(0) // Initialize to `NOT_FOUND`.
1261                 let searchLength := mload(search)
1262                 if gt(searchLength, mload(subject)) { break }
1263                 let w := result
1264 
1265                 let fromMax := sub(mload(subject), searchLength)
1266                 if iszero(gt(fromMax, from)) { from := fromMax }
1267 
1268                 let end := add(add(subject, 0x20), w)
1269                 subject := add(add(subject, 0x20), from)
1270                 if iszero(gt(subject, end)) { break }
1271                 // As this function is not too often used,
1272                 // we shall simply use keccak256 for smaller bytecode size.
1273                 for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
1274                     if eq(keccak256(subject, searchLength), h) {
1275                         result := sub(subject, add(end, 1))
1276                         break
1277                     }
1278                     subject := add(subject, w) // `sub(subject, 1)`.
1279                     if iszero(gt(subject, end)) { break }
1280                 }
1281                 break
1282             }
1283         }
1284     }



```

```
LibString.toString(int256) (LlamaAbsoluteQuorum.sol#761-777) is never used and should be removed



    
761     function toString(int256 value) internal pure returns (string memory str) {
762         if (value >= 0) {
763             return toString(uint256(value));
764         }
765         unchecked {
766             str = toString(uint256(-value));
767         }
768         /// @solidity memory-safe-assembly
769         assembly {
770             // We still have some spare memory space on the left,
771             // as we have allocated 3 words (96 bytes) for up to 78 digits.
772             let length := mload(str) // Load the string length.
773             mstore(str, 0x2d) // Store the '-' character.
774             str := sub(str, 1) // Move back the string pointer by a byte.
775             mstore(str, add(length, 1)) // Update the string length.
776         }
777     }



```

```
Clones.predictDeterministicAddress(address,bytes32,address) (LlamaAbsoluteQuorum.sol#554-570) is never used and should be removed



    
554     function predictDeterministicAddress(
555         address implementation,
556         bytes32 salt,
557         address deployer
558     ) internal pure returns (address predicted) {
559         /// @solidity memory-safe-assembly
560         assembly {
561             let ptr := mload(0x40)
562             mstore(add(ptr, 0x38), deployer)
563             mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)
564             mstore(add(ptr, 0x14), implementation)
565             mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)
566             mstore(add(ptr, 0x58), salt)
567             mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))
568             predicted := keccak256(add(ptr, 0x43), 0x55)
569         }
570     }



```

```
LibString.directReturn(string) (LlamaAbsoluteQuorum.sol#1787-1800) is never used and should be removed



    
1787     function directReturn(string memory a) internal pure {
1788         assembly {
1789             // Assumes that the string does not start from the scratch space.
1790             let retStart := sub(a, 0x20)
1791             let retSize := add(mload(a), 0x40)
1792             // Right pad with zeroes. Just in case the string is produced
1793             // by a method that doesn't zero right pad.
1794             mstore(add(retStart, retSize), 0)
1795             // Store the return offset.
1796             mstore(retStart, 0x20)
1797             // End the transaction, returning the string.
1798             return(retStart, retSize)
1799         }
1800     }



```

```
LibString.toMinimalHexStringNoPrefix(uint256) (LlamaAbsoluteQuorum.sol#888-897) is never used and should be removed



    
888     function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {
889         str = toHexStringNoPrefix(value);
890         /// @solidity memory-safe-assembly
891         assembly {
892             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
893             let strLength := mload(str) // Get the length.
894             str := add(str, o) // Move the pointer, accounting for leading zero.
895             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
896         }
897     }



```

```
LibString.toMinimalHexString(uint256) (LlamaAbsoluteQuorum.sol#873-883) is never used and should be removed



    
873     function toMinimalHexString(uint256 value) internal pure returns (string memory str) {
874         str = toHexStringNoPrefix(value);
875         /// @solidity memory-safe-assembly
876         assembly {
877             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
878             let strLength := add(mload(str), 2) // Compute the length.
879             mstore(add(str, o), 0x3078) // Write the "0x" prefix, accounting for leading zero.
880             str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.
881             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
882         }
883     }



```

```
FixedPointMathLib.divWadDown(uint256,uint256) (LlamaAbsoluteQuorum.sol#207-209) is never used and should be removed



    
207     function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {
208         return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.
209     }



```

```
FixedPointMathLib.mulWadUp(uint256,uint256) (LlamaAbsoluteQuorum.sol#203-205) is never used and should be removed



    
203     function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {
204         return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.
205     }



```

```
LibString.toHexString(uint256) (LlamaAbsoluteQuorum.sol#858-867) is never used and should be removed



    
858     function toHexString(uint256 value) internal pure returns (string memory str) {
859         str = toHexStringNoPrefix(value);
860         /// @solidity memory-safe-assembly
861         assembly {
862             let strLength := add(mload(str), 2) // Compute the length.
863             mstore(str, 0x3078) // Write the "0x" prefix.
864             str := sub(str, 2) // Move the pointer.
865             mstore(str, strLength) // Write the length.
866         }
867     }



```

```
ERC721NonTransferableMinimalProxy._safeMint(address,uint256,bytes) (LlamaAbsoluteQuorum.sol#2255-2264) is never used and should be removed



    
2255   function _safeMint(address to, uint256 id, bytes memory data) internal virtual {
2256     _mint(to, id);
2257 
2258     require(
2259       to.code.length == 0
2260         || ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data)
2261           == ERC721TokenReceiver.onERC721Received.selector,
2262       "UNSAFE_RECIPIENT"
2263     );
2264   }



```

```
LibString.indicesOf(string,string) (LlamaAbsoluteQuorum.sol#1424-1480) is never used and should be removed



    
1424     function indicesOf(string memory subject, string memory search)
1425         internal
1426         pure
1427         returns (uint256[] memory result)
1428     {
1429         /// @solidity memory-safe-assembly
1430         assembly {
1431             let subjectLength := mload(subject)
1432             let searchLength := mload(search)
1433 
1434             if iszero(gt(searchLength, subjectLength)) {
1435                 subject := add(subject, 0x20)
1436                 search := add(search, 0x20)
1437                 result := add(mload(0x40), 0x20)
1438 
1439                 let subjectStart := subject
1440                 let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)
1441                 let h := 0
1442                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
1443                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
1444                 let s := mload(search)
1445                 for {} 1 {} {
1446                     let t := mload(subject)
1447                     // Whether the first `searchLength % 32` bytes of
1448                     // `subject` and `search` matches.
1449                     if iszero(shr(m, xor(t, s))) {
1450                         if h {
1451                             if iszero(eq(keccak256(subject, searchLength), h)) {
1452                                 subject := add(subject, 1)
1453                                 if iszero(lt(subject, subjectSearchEnd)) { break }
1454                                 continue
1455                             }
1456                         }
1457                         // Append to `result`.
1458                         mstore(result, sub(subject, subjectStart))
1459                         result := add(result, 0x20)
1460                         // Advance `subject` by `searchLength`.
1461                         subject := add(subject, searchLength)
1462                         if searchLength {
1463                             if iszero(lt(subject, subjectSearchEnd)) { break }
1464                             continue
1465                         }
1466                     }
1467                     subject := add(subject, 1)
1468                     if iszero(lt(subject, subjectSearchEnd)) { break }
1469                 }
1470                 let resultEnd := result
1471                 // Assign `result` to the free memory pointer.
1472                 result := mload(0x40)
1473                 // Store the length of `result`.
1474                 mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))
1475                 // Allocate memory for result.
1476                 // We allocate one more word, so this array can be recycled for {split}.
1477                 mstore(0x40, add(resultEnd, 0x20))
1478             }
1479         }
1480     }



```

```
Initializable._checkInitializing() (LlamaAbsoluteQuorum.sol#148-152) is never used and should be removed



    
148     function _checkInitializing() internal view virtual {
149         if (!_initializing) {
150             revert NotInitializing();
151         }
152     }



```

```
FixedPointMathLib.mulDivDown(uint256,uint256,uint256) (LlamaAbsoluteQuorum.sol#219-234) is never used and should be removed



    
219     function mulDivDown(
220         uint256 x,
221         uint256 y,
222         uint256 denominator
223     ) internal pure returns (uint256 z) {
224         /// @solidity memory-safe-assembly
225         assembly {
226             // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))
227             if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {
228                 revert(0, 0)
229             }
230 
231             // Divide x * y by the denominator.
232             z := div(mul(x, y), denominator)
233         }
234     }



```

```
LibString.unpackOne(bytes32) (LlamaAbsoluteQuorum.sol#1721-1735) is never used and should be removed



    
1721     function unpackOne(bytes32 packed) internal pure returns (string memory result) {
1722         /// @solidity memory-safe-assembly
1723         assembly {
1724             // Grab the free memory pointer.
1725             result := mload(0x40)
1726             // Allocate 2 words (1 for the length, 1 for the bytes).
1727             mstore(0x40, add(result, 0x40))
1728             // Zeroize the length slot.
1729             mstore(result, 0)
1730             // Store the length and bytes.
1731             mstore(add(result, 0x1f), packed)
1732             // Right pad with zeroes.
1733             mstore(add(add(result, 0x20), mload(result)), 0)
1734         }
1735     }



```

```
LibString.toString(uint256) (LlamaAbsoluteQuorum.sol#723-758) is never used and should be removed



    
723     function toString(uint256 value) internal pure returns (string memory str) {
724         /// @solidity memory-safe-assembly
725         assembly {
726             // The maximum value of a uint256 contains 78 digits (1 byte per digit), but
727             // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.
728             // We will need 1 word for the trailing zeros padding, 1 word for the length,
729             // and 3 words for a maximum of 78 digits.
730             str := add(mload(0x40), 0x80)
731             // Update the free memory pointer to allocate.
732             mstore(0x40, add(str, 0x20))
733             // Zeroize the slot after the string.
734             mstore(str, 0)
735 
736             // Cache the end of the memory to calculate the length later.
737             let end := str
738 
739             let w := not(0) // Tsk.
740             // We write the string from rightmost digit to leftmost digit.
741             // The following is essentially a do-while loop that also handles the zero case.
742             for { let temp := value } 1 {} {
743                 str := add(str, w) // `sub(str, 1)`.
744                 // Write the character to the pointer.
745                 // The ASCII index of the '0' character is 48.
746                 mstore8(str, add(48, mod(temp, 10)))
747                 // Keep dividing `temp` until zero.
748                 temp := div(temp, 10)
749                 if iszero(temp) { break }
750             }
751 
752             let length := sub(end, str)
753             // Move the pointer 32 bytes leftwards to make room for the length.
754             str := sub(str, 0x20)
755             // Store the length.
756             mstore(str, length)
757         }
758     }



```

```
ERC721NonTransferableMinimalProxy._safeMint(address,uint256) (LlamaAbsoluteQuorum.sol#2244-2253) is never used and should be removed



    
2244   function _safeMint(address to, uint256 id) internal virtual {
2245     _mint(to, id);
2246 
2247     require(
2248       to.code.length == 0
2249         || ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "")
2250           == ERC721TokenReceiver.onERC721Received.selector,
2251       "UNSAFE_RECIPIENT"
2252     );
2253   }



```

```
LibString.packOne(string) (LlamaAbsoluteQuorum.sol#1702-1716) is never used and should be removed



    
1702     function packOne(string memory a) internal pure returns (bytes32 result) {
1703         /// @solidity memory-safe-assembly
1704         assembly {
1705             // We don't need to zero right pad the string,
1706             // since this is our own custom non-standard packing scheme.
1707             result :=
1708                 mul(
1709                     // Load the length and the bytes.
1710                     mload(add(a, 0x1f)),
1711                     // `length != 0 && length < 32`. Abuses underflow.
1712                     // Assumes that the length is valid and within the block gas limit.
1713                     lt(sub(mload(a), 1), 0x1f)
1714                 )
1715         }
1716     }



```

```
LibString.runeCount(string) (LlamaAbsoluteQuorum.sol#1056-1070) is never used and should be removed



    
1056     function runeCount(string memory s) internal pure returns (uint256 result) {
1057         /// @solidity memory-safe-assembly
1058         assembly {
1059             if mload(s) {
1060                 mstore(0x00, div(not(0), 255))
1061                 mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)
1062                 let o := add(s, 0x20)
1063                 let end := add(o, mload(s))
1064                 for { result := 1 } 1 { result := add(result, 1) } {
1065                     o := add(o, byte(0, mload(shr(250, mload(o)))))
1066                     if iszero(lt(o, end)) { break }
1067                 }
1068             }
1069         }
1070     }



```

```
LibString.unpackTwo(bytes32) (LlamaAbsoluteQuorum.sol#1762-1784) is never used and should be removed



    
1762     function unpackTwo(bytes32 packed)
1763         internal
1764         pure
1765         returns (string memory resultA, string memory resultB)
1766     {
1767         /// @solidity memory-safe-assembly
1768         assembly {
1769             // Grab the free memory pointer.
1770             resultA := mload(0x40)
1771             resultB := add(resultA, 0x40)
1772             // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.
1773             mstore(0x40, add(resultB, 0x40))
1774             // Zeroize the length slots.
1775             mstore(resultA, 0)
1776             mstore(resultB, 0)
1777             // Store the lengths and bytes.
1778             mstore(add(resultA, 0x1f), packed)
1779             mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))
1780             // Right pad with zeroes.
1781             mstore(add(add(resultA, 0x20), mload(resultA)), 0)
1782             mstore(add(add(resultB, 0x20), mload(resultB)), 0)
1783         }
1784     }



```

```
LibString.endsWith(string,string) (LlamaAbsoluteQuorum.sol#1319-1344) is never used and should be removed



    
1319     function endsWith(string memory subject, string memory search)
1320         internal
1321         pure
1322         returns (bool result)
1323     {
1324         /// @solidity memory-safe-assembly
1325         assembly {
1326             let searchLength := mload(search)
1327             let subjectLength := mload(subject)
1328             // Whether `search` is not longer than `subject`.
1329             let withinRange := iszero(gt(searchLength, subjectLength))
1330             // Just using keccak256 directly is actually cheaper.
1331             // forgefmt: disable-next-item
1332             result := and(
1333                 withinRange,
1334                 eq(
1335                     keccak256(
1336                         // `subject + 0x20 + max(subjectLength - searchLength, 0)`.
1337                         add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),
1338                         searchLength
1339                     ),
1340                     keccak256(add(search, 0x20), searchLength)
1341                 )
1342             )
1343         }
1344     }



```

```
FixedPointMathLib.divWadUp(uint256,uint256) (LlamaAbsoluteQuorum.sol#211-213) is never used and should be removed



    
211     function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {
212         return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.
213     }



```

```
LibString.escapeHTML(string) (LlamaAbsoluteQuorum.sol#1611-1642) is never used and should be removed



    
1611     function escapeHTML(string memory s) internal pure returns (string memory result) {
1612         /// @solidity memory-safe-assembly
1613         assembly {
1614             for {
1615                 let end := add(s, mload(s))
1616                 result := add(mload(0x40), 0x20)
1617                 // Store the bytes of the packed offsets and strides into the scratch space.
1618                 // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.
1619                 mstore(0x1f, 0x900094)
1620                 mstore(0x08, 0xc0000000a6ab)
1621                 // Store "&quot;&amp;&#39;&lt;&gt;" into the scratch space.
1622                 mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))
1623             } iszero(eq(s, end)) {} {
1624                 s := add(s, 1)
1625                 let c := and(mload(s), 0xff)
1626                 // Not in `["\"","'","&","<",">"]`.
1627                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
1628                     mstore8(result, c)
1629                     result := add(result, 1)
1630                     continue
1631                 }
1632                 let t := shr(248, mload(c))
1633                 mstore(result, mload(and(t, 0x1f)))
1634                 result := add(result, shr(5, t))
1635             }
1636             let last := result
1637             mstore(last, 0) // Zeroize the slot after the string.
1638             result := mload(0x40)
1639             mstore(result, sub(last, add(result, 0x20))) // Store the length.
1640             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1641         }
1642     }



```

```
LibString.toHexStringChecksummed(address) (LlamaAbsoluteQuorum.sol#943-960) is never used and should be removed



    
943     function toHexStringChecksummed(address value) internal pure returns (string memory str) {
944         str = toHexString(value);
945         /// @solidity memory-safe-assembly
946         assembly {
947             let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`
948             let o := add(str, 0x22)
949             let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `
950             let t := shl(240, 136) // `0b10001000 << 240`
951             for { let i := 0 } 1 {} {
952                 mstore(add(i, i), mul(t, byte(i, hashed)))
953                 i := add(i, 1)
954                 if eq(i, 20) { break }
955             }
956             mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))
957             o := add(o, 0x20)
958             mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))
959         }
960     }



```

```
LibString.toHexStringNoPrefix(uint256) (LlamaAbsoluteQuorum.sol#903-937) is never used and should be removed



    
903     function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {
904         /// @solidity memory-safe-assembly
905         assembly {
906             // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,
907             // 0x02 bytes for the prefix, and 0x40 bytes for the digits.
908             // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.
909             str := add(mload(0x40), 0x80)
910             // Allocate the memory.
911             mstore(0x40, add(str, 0x20))
912             // Zeroize the slot after the string.
913             mstore(str, 0)
914 
915             // Cache the end to calculate the length later.
916             let end := str
917             // Store "0123456789abcdef" in scratch space.
918             mstore(0x0f, 0x30313233343536373839616263646566)
919 
920             let w := not(1) // Tsk.
921             // We write the string from rightmost digit to leftmost digit.
922             // The following is essentially a do-while loop that also handles the zero case.
923             for { let temp := value } 1 {} {
924                 str := add(str, w) // `sub(str, 2)`.
925                 mstore8(add(str, 1), mload(and(temp, 15)))
926                 mstore8(str, mload(and(shr(4, temp), 15)))
927                 temp := shr(8, temp)
928                 if iszero(temp) { break }
929             }
930 
931             // Compute the string's length.
932             let strLength := sub(end, str)
933             // Move the pointer and write the length.
934             str := sub(str, 0x20)
935             mstore(str, strLength)
936         }
937     }



```

```
Clones.clone(address) (LlamaAbsoluteQuorum.sol#514-527) is never used and should be removed



    
514     function clone(address implementation) internal returns (address instance) {
515         /// @solidity memory-safe-assembly
516         assembly {
517             // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
518             // of the `implementation` address with the bytecode before the address.
519             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
520             // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
521             mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
522             instance := create(0, 0x09, 0x37)
523         }
524         if (instance == address(0)) {
525             revert ERC1167FailedCreateClone();
526         }
527     }



```

```
LibString.is7BitASCII(string) (LlamaAbsoluteQuorum.sol#1074-1096) is never used and should be removed



    
1074     function is7BitASCII(string memory s) internal pure returns (bool result) {
1075         /// @solidity memory-safe-assembly
1076         assembly {
1077             let mask := shl(7, div(not(0), 255))
1078             result := 1
1079             let n := mload(s)
1080             if n {
1081                 let o := add(s, 0x20)
1082                 let end := add(o, n)
1083                 let last := mload(end)
1084                 mstore(end, 0)
1085                 for {} 1 {} {
1086                     if and(mask, mload(o)) {
1087                         result := 0
1088                         break
1089                     }
1090                     o := add(o, 0x20)
1091                     if iszero(lt(o, end)) { break }
1092                 }
1093                 mstore(end, last)
1094             }
1095         }
1096     }



```

```
Initializable._getInitializedVersion() (LlamaAbsoluteQuorum.sol#175-177) is never used and should be removed



    
175     function _getInitializedVersion() internal view returns (uint8) {
176         return _initialized;
177     }



```

```
Checkpoints.length(Checkpoints.History) (LlamaAbsoluteQuorum.sol#1912-1914) is never used and should be removed



    
1912     function length(History storage self) internal view returns (uint256) {
1913         return self._checkpoints.length;
1914     }



```

```
FixedPointMathLib.sqrt(uint256) (LlamaAbsoluteQuorum.sol#347-410) is never used and should be removed



    
347     function sqrt(uint256 x) internal pure returns (uint256 z) {
348         /// @solidity memory-safe-assembly
349         assembly {
350             let y := x // We start y at x, which will help us make our initial estimate.
351 
352             z := 181 // The "correct" value is 1, but this saves a multiplication later.
353 
354             // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad
355             // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.
356 
357             // We check y >= 2^(k + 8) but shift right by k bits
358             // each branch to ensure that if x >= 256, then y >= 256.
359             if iszero(lt(y, 0x10000000000000000000000000000000000)) {
360                 y := shr(128, y)
361                 z := shl(64, z)
362             }
363             if iszero(lt(y, 0x1000000000000000000)) {
364                 y := shr(64, y)
365                 z := shl(32, z)
366             }
367             if iszero(lt(y, 0x10000000000)) {
368                 y := shr(32, y)
369                 z := shl(16, z)
370             }
371             if iszero(lt(y, 0x1000000)) {
372                 y := shr(16, y)
373                 z := shl(8, z)
374             }
375 
376             // Goal was to get z*z*y within a small factor of x. More iterations could
377             // get y in a tighter range. Currently, we will have y in [256, 256*2^16).
378             // We ensured y >= 256 so that the relative difference between y and y+1 is small.
379             // That's not possible if x < 256 but we can just verify those cases exhaustively.
380 
381             // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.
382             // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.
383             // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.
384 
385             // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range
386             // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.
387 
388             // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate
389             // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.
390 
391             // There is no overflow risk here since y < 2^136 after the first branch above.
392             z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.
393 
394             // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.
395             z := shr(1, add(z, div(x, z)))
396             z := shr(1, add(z, div(x, z)))
397             z := shr(1, add(z, div(x, z)))
398             z := shr(1, add(z, div(x, z)))
399             z := shr(1, add(z, div(x, z)))
400             z := shr(1, add(z, div(x, z)))
401             z := shr(1, add(z, div(x, z)))
402 
403             // If x+1 is a perfect square, the Babylonian method cycles between
404             // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.
405             // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division
406             // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.
407             // If you don't care whether the floor or ceil square root is returned, you can remove this statement.
408             z := sub(z, lt(div(x, z), z))
409         }
410     }



```

```
LibString.slice(string,uint256) (LlamaAbsoluteQuorum.sol#1414-1420) is never used and should be removed



    
1414     function slice(string memory subject, uint256 start)
1415         internal
1416         pure
1417         returns (string memory result)
1418     {
1419         result = slice(subject, start, uint256(int256(-1)));
1420     }



```

```
FixedPointMathLib.mulWadDown(uint256,uint256) (LlamaAbsoluteQuorum.sol#199-201) is never used and should be removed



    
199     function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {
200         return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.
201     }



```

```
LibString.concat(string,string) (LlamaAbsoluteQuorum.sol#1532-1566) is never used and should be removed



    
1532     function concat(string memory a, string memory b)
1533         internal
1534         pure
1535         returns (string memory result)
1536     {
1537         /// @solidity memory-safe-assembly
1538         assembly {
1539             let w := not(0x1f)
1540             result := mload(0x40)
1541             let aLength := mload(a)
1542             // Copy `a` one word at a time, backwards.
1543             for { let o := and(add(aLength, 0x20), w) } 1 {} {
1544                 mstore(add(result, o), mload(add(a, o)))
1545                 o := add(o, w) // `sub(o, 0x20)`.
1546                 if iszero(o) { break }
1547             }
1548             let bLength := mload(b)
1549             let output := add(result, aLength)
1550             // Copy `b` one word at a time, backwards.
1551             for { let o := and(add(bLength, 0x20), w) } 1 {} {
1552                 mstore(add(output, o), mload(add(b, o)))
1553                 o := add(o, w) // `sub(o, 0x20)`.
1554                 if iszero(o) { break }
1555             }
1556             let totalLength := add(aLength, bLength)
1557             let last := add(add(result, 0x20), totalLength)
1558             // Zeroize the slot after the string.
1559             mstore(last, 0)
1560             // Stores the length.
1561             mstore(result, totalLength)
1562             // Allocate memory for the length and the bytes,
1563             // rounded up to a multiple of 32.
1564             mstore(0x40, and(add(last, 0x1f), w))
1565         }
1566     }



```

```
LibString.toHexStringNoPrefix(uint256,uint256) (LlamaAbsoluteQuorum.sol#804-852) is never used and should be removed



    
804     function toHexStringNoPrefix(uint256 value, uint256 length)
805         internal
806         pure
807         returns (string memory str)
808     {
809         /// @solidity memory-safe-assembly
810         assembly {
811             // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes
812             // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.
813             // We add 0x20 to the total and round down to a multiple of 0x20.
814             // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.
815             str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))
816             // Allocate the memory.
817             mstore(0x40, add(str, 0x20))
818             // Zeroize the slot after the string.
819             mstore(str, 0)
820 
821             // Cache the end to calculate the length later.
822             let end := str
823             // Store "0123456789abcdef" in scratch space.
824             mstore(0x0f, 0x30313233343536373839616263646566)
825 
826             let start := sub(str, add(length, length))
827             let w := not(1) // Tsk.
828             let temp := value
829             // We write the string from rightmost digit to leftmost digit.
830             // The following is essentially a do-while loop that also handles the zero case.
831             for {} 1 {} {
832                 str := add(str, w) // `sub(str, 2)`.
833                 mstore8(add(str, 1), mload(and(temp, 15)))
834                 mstore8(str, mload(and(shr(4, temp), 15)))
835                 temp := shr(8, temp)
836                 if iszero(xor(str, start)) { break }
837             }
838 
839             if temp {
840                 // Store the function selector of `HexLengthInsufficient()`.
841                 mstore(0x00, 0x2194895a)
842                 // Revert with (offset, size).
843                 revert(0x1c, 0x04)
844             }
845 
846             // Compute the string's length.
847             let strLength := sub(end, str)
848             // Move the pointer and write the length.
849             str := sub(str, 0x20)
850             mstore(str, strLength)
851         }
852     }



```

```
Checkpoints._lowerBinaryLookup(Checkpoints.Checkpoint[],uint64,uint256,uint256) (LlamaAbsoluteQuorum.sol#1981-1996) is never used and should be removed



    
1981     function _lowerBinaryLookup(
1982         Checkpoint[] storage self,
1983         uint64 timestamp,
1984         uint256 low,
1985         uint256 high
1986     ) private view returns (uint256) {
1987         while (low < high) {
1988             uint256 mid = average(low, high);
1989             if (_unsafeAccess(self, mid).timestamp < timestamp) {
1990                 low = mid + 1;
1991             } else {
1992                 high = mid;
1993             }
1994         }
1995         return high;
1996     }



```

```
LibString.split(string,string) (LlamaAbsoluteQuorum.sol#1483-1528) is never used and should be removed



    
1483     function split(string memory subject, string memory delimiter)
1484         internal
1485         pure
1486         returns (string[] memory result)
1487     {
1488         uint256[] memory indices = indicesOf(subject, delimiter);
1489         /// @solidity memory-safe-assembly
1490         assembly {
1491             let w := not(0x1f)
1492             let indexPtr := add(indices, 0x20)
1493             let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))
1494             mstore(add(indicesEnd, w), mload(subject))
1495             mstore(indices, add(mload(indices), 1))
1496             let prevIndex := 0
1497             for {} 1 {} {
1498                 let index := mload(indexPtr)
1499                 mstore(indexPtr, 0x60)
1500                 if iszero(eq(index, prevIndex)) {
1501                     let element := mload(0x40)
1502                     let elementLength := sub(index, prevIndex)
1503                     mstore(element, elementLength)
1504                     // Copy the `subject` one word at a time, backwards.
1505                     for { let o := and(add(elementLength, 0x1f), w) } 1 {} {
1506                         mstore(add(element, o), mload(add(add(subject, prevIndex), o)))
1507                         o := add(o, w) // `sub(o, 0x20)`.
1508                         if iszero(o) { break }
1509                     }
1510                     // Zeroize the slot after the string.
1511                     mstore(add(add(element, 0x20), elementLength), 0)
1512                     // Allocate memory for the length and the bytes,
1513                     // rounded up to a multiple of 32.
1514                     mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))
1515                     // Store the `element` into the array.
1516                     mstore(indexPtr, element)
1517                 }
1518                 prevIndex := add(index, mload(delimiter))
1519                 indexPtr := add(indexPtr, 0x20)
1520                 if iszero(lt(indexPtr, indicesEnd)) { break }
1521             }
1522             result := indices
1523             if iszero(mload(delimiter)) {
1524                 result := add(indices, 0x20)
1525                 mstore(result, sub(mload(indices), 2))
1526             }
1527         }
1528     }



```

```
LibString.lower(string) (LlamaAbsoluteQuorum.sol#1600-1602) is never used and should be removed



    
1600     function lower(string memory subject) internal pure returns (string memory result) {
1601         result = toCase(subject, false);
1602     }



```

```
LibString.packTwo(string,string) (LlamaAbsoluteQuorum.sol#1739-1757) is never used and should be removed



    
1739     function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {
1740         /// @solidity memory-safe-assembly
1741         assembly {
1742             let aLength := mload(a)
1743             // We don't need to zero right pad the strings,
1744             // since this is our own custom non-standard packing scheme.
1745             result :=
1746                 mul(
1747                     // Load the length and the bytes of `a` and `b`.
1748                     or(
1749                         shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),
1750                         mload(sub(add(b, 0x1e), aLength))
1751                     ),
1752                     // `totalLength != 0 && totalLength < 31`. Abuses underflow.
1753                     // Assumes that the lengths are valid and within the block gas limit.
1754                     lt(sub(add(aLength, mload(b)), 1), 0x1e)
1755                 )
1756         }
1757     }



```

```
LibString.eq(string,string) (LlamaAbsoluteQuorum.sol#1694-1698) is never used and should be removed



    
1694     function eq(string memory a, string memory b) internal pure returns (bool result) {
1695         assembly {
1696             result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))
1697         }
1698     }



```

```
FixedPointMathLib.unsafeDivUp(uint256,uint256) (LlamaAbsoluteQuorum.sol#430-437) is never used and should be removed



    
430     function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {
431         /// @solidity memory-safe-assembly
432         assembly {
433             // Add 1 to x * y if x % y > 0. Note this will
434             // return 0 instead of reverting if y is zero.
435             z := add(gt(mod(x, y), 0), div(x, y))
436         }
437     }



```

```
LibString.repeat(string,uint256) (LlamaAbsoluteQuorum.sol#1347-1377) is never used and should be removed



    
1347     function repeat(string memory subject, uint256 times)
1348         internal
1349         pure
1350         returns (string memory result)
1351     {
1352         /// @solidity memory-safe-assembly
1353         assembly {
1354             let subjectLength := mload(subject)
1355             if iszero(or(iszero(times), iszero(subjectLength))) {
1356                 subject := add(subject, 0x20)
1357                 result := mload(0x40)
1358                 let output := add(result, 0x20)
1359                 for {} 1 {} {
1360                     // Copy the `subject` one word at a time.
1361                     for { let o := 0 } 1 {} {
1362                         mstore(add(output, o), mload(add(subject, o)))
1363                         o := add(o, 0x20)
1364                         if iszero(lt(o, subjectLength)) { break }
1365                     }
1366                     output := add(output, subjectLength)
1367                     times := sub(times, 1)
1368                     if iszero(times) { break }
1369                 }
1370                 mstore(output, 0) // Zeroize the slot after the string.
1371                 let resultLength := sub(output, add(result, 0x20))
1372                 mstore(result, resultLength) // Store the length.
1373                 // Allocate the memory.
1374                 mstore(0x40, add(result, add(resultLength, 0x20)))
1375             }
1376         }
1377     }



```

### LlamaAccount.sol


```
LibString.indexOf(string,string) (LlamaAccount.sol#1801-1807) is never used and should be removed



    
1801     function indexOf(string memory subject, string memory search)
1802         internal
1803         pure
1804         returns (uint256 result)
1805     {
1806         result = indexOf(subject, search, 0);
1807     }



```

```
Initializable._isInitializing() (LlamaAccount.sol#182-184) is never used and should be removed



    
182     function _isInitializing() internal view returns (bool) {
183         return _initializing;
184     }



```

```
Address.functionCallWithValue(address,bytes,uint256) (LlamaAccount.sol#417-419) is never used and should be removed



    
417     function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
418         return functionCallWithValue(target, data, value, defaultRevert);
419     }



```

```
LibString.indexOf(string,string,uint256) (LlamaAccount.sol#1743-1796) is never used and should be removed



    
1743     function indexOf(string memory subject, string memory search, uint256 from)
1744         internal
1745         pure
1746         returns (uint256 result)
1747     {
1748         /// @solidity memory-safe-assembly
1749         assembly {
1750             for { let subjectLength := mload(subject) } 1 {} {
1751                 if iszero(mload(search)) {
1752                     if iszero(gt(from, subjectLength)) {
1753                         result := from
1754                         break
1755                     }
1756                     result := subjectLength
1757                     break
1758                 }
1759                 let searchLength := mload(search)
1760                 let subjectStart := add(subject, 0x20)
1761 
1762                 result := not(0) // Initialize to `NOT_FOUND`.
1763 
1764                 subject := add(subjectStart, from)
1765                 let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)
1766 
1767                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
1768                 let s := mload(add(search, 0x20))
1769 
1770                 if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }
1771 
1772                 if iszero(lt(searchLength, 0x20)) {
1773                     for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
1774                         if iszero(shr(m, xor(mload(subject), s))) {
1775                             if eq(keccak256(subject, searchLength), h) {
1776                                 result := sub(subject, subjectStart)
1777                                 break
1778                             }
1779                         }
1780                         subject := add(subject, 1)
1781                         if iszero(lt(subject, end)) { break }
1782                     }
1783                     break
1784                 }
1785                 for {} 1 {} {
1786                     if iszero(shr(m, xor(mload(subject), s))) {
1787                         result := sub(subject, subjectStart)
1788                         break
1789                     }
1790                     subject := add(subject, 1)
1791                     if iszero(lt(subject, end)) { break }
1792                 }
1793                 break
1794             }
1795         }
1796     }



```

```
Address.verifyCallResult(bool,bytes,function()) (LlamaAccount.sol#524-534) is never used and should be removed



    
524     function verifyCallResult(
525         bool success,
526         bytes memory returndata,
527         function() internal view customRevert
528     ) internal view returns (bytes memory) {
529         if (success) {
530             return returndata;
531         } else {
532             _revert(returndata, customRevert);
533         }
534     }



```

```
Clones.predictDeterministicAddress(address,bytes32) (LlamaAccount.sol#1252-1257) is never used and should be removed



    
1252     function predictDeterministicAddress(
1253         address implementation,
1254         bytes32 salt
1255     ) internal view returns (address predicted) {
1256         return predictDeterministicAddress(implementation, salt, address(this));
1257     }



```

```
LibString.toHexString(bytes) (LlamaAccount.sol#1574-1583) is never used and should be removed



    
1574     function toHexString(bytes memory raw) internal pure returns (string memory str) {
1575         str = toHexStringNoPrefix(raw);
1576         /// @solidity memory-safe-assembly
1577         assembly {
1578             let strLength := add(mload(str), 2) // Compute the length.
1579             mstore(str, 0x3078) // Write the "0x" prefix.
1580             str := sub(str, 2) // Move the pointer.
1581             mstore(str, strLength) // Write the length.
1582         }
1583     }



```

```
LibString.toHexString(uint256,uint256) (LlamaAccount.sol#1348-1357) is never used and should be removed



    
1348     function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {
1349         str = toHexStringNoPrefix(value, length);
1350         /// @solidity memory-safe-assembly
1351         assembly {
1352             let strLength := add(mload(str), 2) // Compute the length.
1353             mstore(str, 0x3078) // Write the "0x" prefix.
1354             str := sub(str, 2) // Move the pointer.
1355             mstore(str, strLength) // Write the length.
1356         }
1357     }



```

```
LibString.escapeJSON(string) (LlamaAccount.sol#2205-2251) is never used and should be removed



    
2205     function escapeJSON(string memory s) internal pure returns (string memory result) {
2206         /// @solidity memory-safe-assembly
2207         assembly {
2208             for {
2209                 let end := add(s, mload(s))
2210                 result := add(mload(0x40), 0x20)
2211                 // Store "\\u0000" in scratch space.
2212                 // Store "0123456789abcdef" in scratch space.
2213                 // Also, store `{0x08:"b", 0x09:"t", 0x0a:"n", 0x0c:"f", 0x0d:"r"}`.
2214                 // into the scratch space.
2215                 mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)
2216                 // Bitmask for detecting `["\"","\\"]`.
2217                 let e := or(shl(0x22, 1), shl(0x5c, 1))
2218             } iszero(eq(s, end)) {} {
2219                 s := add(s, 1)
2220                 let c := and(mload(s), 0xff)
2221                 if iszero(lt(c, 0x20)) {
2222                     if iszero(and(shl(c, 1), e)) {
2223                         // Not in `["\"","\\"]`.
2224                         mstore8(result, c)
2225                         result := add(result, 1)
2226                         continue
2227                     }
2228                     mstore8(result, 0x5c) // "\\".
2229                     mstore8(add(result, 1), c)
2230                     result := add(result, 2)
2231                     continue
2232                 }
2233                 if iszero(and(shl(c, 1), 0x3700)) {
2234                     // Not in `["\b","\t","\n","\f","\d"]`.
2235                     mstore8(0x1d, mload(shr(4, c))) // Hex value.
2236                     mstore8(0x1e, mload(and(c, 15))) // Hex value.
2237                     mstore(result, mload(0x19)) // "\\u00XX".
2238                     result := add(result, 6)
2239                     continue
2240                 }
2241                 mstore8(result, 0x5c) // "\\".
2242                 mstore8(add(result, 1), mload(add(c, 8)))
2243                 result := add(result, 2)
2244             }
2245             let last := result
2246             mstore(last, 0) // Zeroize the slot after the string.
2247             result := mload(0x40)
2248             mstore(result, sub(last, add(result, 0x20))) // Store the length.
2249             mstore(0x40, add(last, 0x20)) // Allocate the memory.
2250         }
2251     }



```

```
LibString.toHexStringNoPrefix(bytes) (LlamaAccount.sol#1587-1609) is never used and should be removed



    
1587     function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {
1588         /// @solidity memory-safe-assembly
1589         assembly {
1590             let length := mload(raw)
1591             str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.
1592             mstore(str, add(length, length)) // Store the length of the output.
1593 
1594             // Store "0123456789abcdef" in scratch space.
1595             mstore(0x0f, 0x30313233343536373839616263646566)
1596 
1597             let o := add(str, 0x20)
1598             let end := add(raw, length)
1599 
1600             for {} iszero(eq(raw, end)) {} {
1601                 raw := add(raw, 1)
1602                 mstore8(add(o, 1), mload(and(mload(raw), 15)))
1603                 mstore8(o, mload(and(shr(4, mload(raw)), 15)))
1604                 o := add(o, 2)
1605             }
1606             mstore(o, 0) // Zeroize the slot after the string.
1607             mstore(0x40, add(o, 0x20)) // Allocate the memory.
1608         }
1609     }



```

```
LibString.lastIndexOf(string,string) (LlamaAccount.sol#1849-1855) is never used and should be removed



    
1849     function lastIndexOf(string memory subject, string memory search)
1850         internal
1851         pure
1852         returns (uint256 result)
1853     {
1854         result = lastIndexOf(subject, search, uint256(int256(-1)));
1855     }



```

```
LibString.startsWith(string,string) (LlamaAccount.sol#1858-1876) is never used and should be removed



    
1858     function startsWith(string memory subject, string memory search)
1859         internal
1860         pure
1861         returns (bool result)
1862     {
1863         /// @solidity memory-safe-assembly
1864         assembly {
1865             let searchLength := mload(search)
1866             // Just using keccak256 directly is actually cheaper.
1867             // forgefmt: disable-next-item
1868             result := and(
1869                 iszero(gt(searchLength, mload(subject))),
1870                 eq(
1871                     keccak256(add(subject, 0x20), searchLength),
1872                     keccak256(add(search, 0x20), searchLength)
1873                 )
1874             )
1875         }
1876     }



```

```
LibString.lastIndexOf(string,string,uint256) (LlamaAccount.sol#1812-1844) is never used and should be removed



    
1812     function lastIndexOf(string memory subject, string memory search, uint256 from)
1813         internal
1814         pure
1815         returns (uint256 result)
1816     {
1817         /// @solidity memory-safe-assembly
1818         assembly {
1819             for {} 1 {} {
1820                 result := not(0) // Initialize to `NOT_FOUND`.
1821                 let searchLength := mload(search)
1822                 if gt(searchLength, mload(subject)) { break }
1823                 let w := result
1824 
1825                 let fromMax := sub(mload(subject), searchLength)
1826                 if iszero(gt(fromMax, from)) { from := fromMax }
1827 
1828                 let end := add(add(subject, 0x20), w)
1829                 subject := add(add(subject, 0x20), from)
1830                 if iszero(gt(subject, end)) { break }
1831                 // As this function is not too often used,
1832                 // we shall simply use keccak256 for smaller bytecode size.
1833                 for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
1834                     if eq(keccak256(subject, searchLength), h) {
1835                         result := sub(subject, add(end, 1))
1836                         break
1837                     }
1838                     subject := add(subject, w) // `sub(subject, 1)`.
1839                     if iszero(gt(subject, end)) { break }
1840                 }
1841                 break
1842             }
1843         }
1844     }



```

```
LibString.toString(int256) (LlamaAccount.sol#1321-1337) is never used and should be removed



    
1321     function toString(int256 value) internal pure returns (string memory str) {
1322         if (value >= 0) {
1323             return toString(uint256(value));
1324         }
1325         unchecked {
1326             str = toString(uint256(-value));
1327         }
1328         /// @solidity memory-safe-assembly
1329         assembly {
1330             // We still have some spare memory space on the left,
1331             // as we have allocated 3 words (96 bytes) for up to 78 digits.
1332             let length := mload(str) // Load the string length.
1333             mstore(str, 0x2d) // Store the '-' character.
1334             str := sub(str, 1) // Move back the string pointer by a byte.
1335             mstore(str, add(length, 1)) // Update the string length.
1336         }
1337     }



```

```
Clones.predictDeterministicAddress(address,bytes32,address) (LlamaAccount.sol#1231-1247) is never used and should be removed



    
1231     function predictDeterministicAddress(
1232         address implementation,
1233         bytes32 salt,
1234         address deployer
1235     ) internal pure returns (address predicted) {
1236         /// @solidity memory-safe-assembly
1237         assembly {
1238             let ptr := mload(0x40)
1239             mstore(add(ptr, 0x38), deployer)
1240             mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)
1241             mstore(add(ptr, 0x14), implementation)
1242             mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)
1243             mstore(add(ptr, 0x58), salt)
1244             mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))
1245             predicted := keccak256(add(ptr, 0x43), 0x55)
1246         }
1247     }



```

```
Address.functionDelegateCall(address,bytes) (LlamaAccount.sol#467-469) is never used and should be removed



    
467     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
468         return functionDelegateCall(target, data, defaultRevert);
469     }



```

```
SafeERC20.safeIncreaseAllowance(IERC20,address,uint256) (LlamaAccount.sol#601-604) is never used and should be removed



    
601     function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
602         uint256 oldAllowance = token.allowance(address(this), spender);
603         forceApprove(token, spender, oldAllowance + value);
604     }



```

```
SafeERC20.safePermit(IERC20Permit,address,address,uint256,uint256,uint8,bytes32,bytes32) (LlamaAccount.sol#638-654) is never used and should be removed



    
638     function safePermit(
639         IERC20Permit token,
640         address owner,
641         address spender,
642         uint256 value,
643         uint256 deadline,
644         uint8 v,
645         bytes32 r,
646         bytes32 s
647     ) internal {
648         uint256 nonceBefore = token.nonces(owner);
649         token.permit(owner, spender, value, deadline, v, r, s);
650         uint256 nonceAfter = token.nonces(owner);
651         if (nonceAfter != nonceBefore + 1) {
652             revert SafeERC20FailedOperation(address(token));
653         }
654     }



```

```
LibString.directReturn(string) (LlamaAccount.sol#2347-2360) is never used and should be removed



    
2347     function directReturn(string memory a) internal pure {
2348         assembly {
2349             // Assumes that the string does not start from the scratch space.
2350             let retStart := sub(a, 0x20)
2351             let retSize := add(mload(a), 0x40)
2352             // Right pad with zeroes. Just in case the string is produced
2353             // by a method that doesn't zero right pad.
2354             mstore(add(retStart, retSize), 0)
2355             // Store the return offset.
2356             mstore(retStart, 0x20)
2357             // End the transaction, returning the string.
2358             return(retStart, retSize)
2359         }
2360     }



```

```
Address.functionDelegateCall(address,bytes,function()) (LlamaAccount.sol#475-482) is never used and should be removed



    
475     function functionDelegateCall(
476         address target,
477         bytes memory data,
478         function() internal view customRevert
479     ) internal returns (bytes memory) {
480         (bool success, bytes memory returndata) = target.delegatecall(data);
481         return verifyCallResultFromTarget(target, success, returndata, customRevert);
482     }



```

```
LibString.toMinimalHexStringNoPrefix(uint256) (LlamaAccount.sol#1448-1457) is never used and should be removed



    
1448     function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {
1449         str = toHexStringNoPrefix(value);
1450         /// @solidity memory-safe-assembly
1451         assembly {
1452             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
1453             let strLength := mload(str) // Get the length.
1454             str := add(str, o) // Move the pointer, accounting for leading zero.
1455             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
1456         }
1457     }



```

```
LibString.toMinimalHexString(uint256) (LlamaAccount.sol#1433-1443) is never used and should be removed



    
1433     function toMinimalHexString(uint256 value) internal pure returns (string memory str) {
1434         str = toHexStringNoPrefix(value);
1435         /// @solidity memory-safe-assembly
1436         assembly {
1437             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
1438             let strLength := add(mload(str), 2) // Compute the length.
1439             mstore(add(str, o), 0x3078) // Write the "0x" prefix, accounting for leading zero.
1440             str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.
1441             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
1442         }
1443     }



```

```
SafeERC20.safeTransferFrom(IERC20,address,address,uint256) (LlamaAccount.sol#593-595) is never used and should be removed



    
593     function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
594         _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));
595     }



```

```
Address.functionStaticCall(address,bytes,function()) (LlamaAccount.sol#454-461) is never used and should be removed



    
454     function functionStaticCall(
455         address target,
456         bytes memory data,
457         function() internal view customRevert
458     ) internal view returns (bytes memory) {
459         (bool success, bytes memory returndata) = target.staticcall(data);
460         return verifyCallResultFromTarget(target, success, returndata, customRevert);
461     }



```

```
LibString.toHexString(uint256) (LlamaAccount.sol#1418-1427) is never used and should be removed



    
1418     function toHexString(uint256 value) internal pure returns (string memory str) {
1419         str = toHexStringNoPrefix(value);
1420         /// @solidity memory-safe-assembly
1421         assembly {
1422             let strLength := add(mload(str), 2) // Compute the length.
1423             mstore(str, 0x3078) // Write the "0x" prefix.
1424             str := sub(str, 2) // Move the pointer.
1425             mstore(str, strLength) // Write the length.
1426         }
1427     }



```

```
ERC721NonTransferableMinimalProxy._safeMint(address,uint256,bytes) (LlamaAccount.sol#2815-2824) is never used and should be removed



    
2815   function _safeMint(address to, uint256 id, bytes memory data) internal virtual {
2816     _mint(to, id);
2817 
2818     require(
2819       to.code.length == 0
2820         || ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data)
2821           == ERC721TokenReceiver.onERC721Received.selector,
2822       "UNSAFE_RECIPIENT"
2823     );
2824   }



```

```
LibString.indicesOf(string,string) (LlamaAccount.sol#1984-2040) is never used and should be removed



    
1984     function indicesOf(string memory subject, string memory search)
1985         internal
1986         pure
1987         returns (uint256[] memory result)
1988     {
1989         /// @solidity memory-safe-assembly
1990         assembly {
1991             let subjectLength := mload(subject)
1992             let searchLength := mload(search)
1993 
1994             if iszero(gt(searchLength, subjectLength)) {
1995                 subject := add(subject, 0x20)
1996                 search := add(search, 0x20)
1997                 result := add(mload(0x40), 0x20)
1998 
1999                 let subjectStart := subject
2000                 let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)
2001                 let h := 0
2002                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
2003                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
2004                 let s := mload(search)
2005                 for {} 1 {} {
2006                     let t := mload(subject)
2007                     // Whether the first `searchLength % 32` bytes of
2008                     // `subject` and `search` matches.
2009                     if iszero(shr(m, xor(t, s))) {
2010                         if h {
2011                             if iszero(eq(keccak256(subject, searchLength), h)) {
2012                                 subject := add(subject, 1)
2013                                 if iszero(lt(subject, subjectSearchEnd)) { break }
2014                                 continue
2015                             }
2016                         }
2017                         // Append to `result`.
2018                         mstore(result, sub(subject, subjectStart))
2019                         result := add(result, 0x20)
2020                         // Advance `subject` by `searchLength`.
2021                         subject := add(subject, searchLength)
2022                         if searchLength {
2023                             if iszero(lt(subject, subjectSearchEnd)) { break }
2024                             continue
2025                         }
2026                     }
2027                     subject := add(subject, 1)
2028                     if iszero(lt(subject, subjectSearchEnd)) { break }
2029                 }
2030                 let resultEnd := result
2031                 // Assign `result` to the free memory pointer.
2032                 result := mload(0x40)
2033                 // Store the length of `result`.
2034                 mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))
2035                 // Allocate memory for result.
2036                 // We allocate one more word, so this array can be recycled for {split}.
2037                 mstore(0x40, add(resultEnd, 0x20))
2038             }
2039         }
2040     }



```

```
Initializable._checkInitializing() (LlamaAccount.sol#148-152) is never used and should be removed



    
148     function _checkInitializing() internal view virtual {
149         if (!_initializing) {
150             revert NotInitializing();
151         }
152     }



```

```
Address.functionCall(address,bytes,function()) (LlamaAccount.sol#400-406) is never used and should be removed



    
400     function functionCall(
401         address target,
402         bytes memory data,
403         function() internal view customRevert
404     ) internal returns (bytes memory) {
405         return functionCallWithValue(target, data, 0, customRevert);
406     }



```

```
LibString.unpackOne(bytes32) (LlamaAccount.sol#2281-2295) is never used and should be removed



    
2281     function unpackOne(bytes32 packed) internal pure returns (string memory result) {
2282         /// @solidity memory-safe-assembly
2283         assembly {
2284             // Grab the free memory pointer.
2285             result := mload(0x40)
2286             // Allocate 2 words (1 for the length, 1 for the bytes).
2287             mstore(0x40, add(result, 0x40))
2288             // Zeroize the length slot.
2289             mstore(result, 0)
2290             // Store the length and bytes.
2291             mstore(add(result, 0x1f), packed)
2292             // Right pad with zeroes.
2293             mstore(add(add(result, 0x20), mload(result)), 0)
2294         }
2295     }



```

```
LibString.toString(uint256) (LlamaAccount.sol#1283-1318) is never used and should be removed



    
1283     function toString(uint256 value) internal pure returns (string memory str) {
1284         /// @solidity memory-safe-assembly
1285         assembly {
1286             // The maximum value of a uint256 contains 78 digits (1 byte per digit), but
1287             // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.
1288             // We will need 1 word for the trailing zeros padding, 1 word for the length,
1289             // and 3 words for a maximum of 78 digits.
1290             str := add(mload(0x40), 0x80)
1291             // Update the free memory pointer to allocate.
1292             mstore(0x40, add(str, 0x20))
1293             // Zeroize the slot after the string.
1294             mstore(str, 0)
1295 
1296             // Cache the end of the memory to calculate the length later.
1297             let end := str
1298 
1299             let w := not(0) // Tsk.
1300             // We write the string from rightmost digit to leftmost digit.
1301             // The following is essentially a do-while loop that also handles the zero case.
1302             for { let temp := value } 1 {} {
1303                 str := add(str, w) // `sub(str, 1)`.
1304                 // Write the character to the pointer.
1305                 // The ASCII index of the '0' character is 48.
1306                 mstore8(str, add(48, mod(temp, 10)))
1307                 // Keep dividing `temp` until zero.
1308                 temp := div(temp, 10)
1309                 if iszero(temp) { break }
1310             }
1311 
1312             let length := sub(end, str)
1313             // Move the pointer 32 bytes leftwards to make room for the length.
1314             str := sub(str, 0x20)
1315             // Store the length.
1316             mstore(str, length)
1317         }
1318     }



```

```
ERC721NonTransferableMinimalProxy._safeMint(address,uint256) (LlamaAccount.sol#2804-2813) is never used and should be removed



    
2804   function _safeMint(address to, uint256 id) internal virtual {
2805     _mint(to, id);
2806 
2807     require(
2808       to.code.length == 0
2809         || ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "")
2810           == ERC721TokenReceiver.onERC721Received.selector,
2811       "UNSAFE_RECIPIENT"
2812     );
2813   }



```

```
LibString.packOne(string) (LlamaAccount.sol#2262-2276) is never used and should be removed



    
2262     function packOne(string memory a) internal pure returns (bytes32 result) {
2263         /// @solidity memory-safe-assembly
2264         assembly {
2265             // We don't need to zero right pad the string,
2266             // since this is our own custom non-standard packing scheme.
2267             result :=
2268                 mul(
2269                     // Load the length and the bytes.
2270                     mload(add(a, 0x1f)),
2271                     // `length != 0 && length < 32`. Abuses underflow.
2272                     // Assumes that the length is valid and within the block gas limit.
2273                     lt(sub(mload(a), 1), 0x1f)
2274                 )
2275         }
2276     }



```

```
Address.functionStaticCall(address,bytes) (LlamaAccount.sol#446-448) is never used and should be removed



    
446     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
447         return functionStaticCall(target, data, defaultRevert);
448     }



```

```
LibString.runeCount(string) (LlamaAccount.sol#1616-1630) is never used and should be removed



    
1616     function runeCount(string memory s) internal pure returns (uint256 result) {
1617         /// @solidity memory-safe-assembly
1618         assembly {
1619             if mload(s) {
1620                 mstore(0x00, div(not(0), 255))
1621                 mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)
1622                 let o := add(s, 0x20)
1623                 let end := add(o, mload(s))
1624                 for { result := 1 } 1 { result := add(result, 1) } {
1625                     o := add(o, byte(0, mload(shr(250, mload(o)))))
1626                     if iszero(lt(o, end)) { break }
1627                 }
1628             }
1629         }
1630     }



```

```
LibString.unpackTwo(bytes32) (LlamaAccount.sol#2322-2344) is never used and should be removed



    
2322     function unpackTwo(bytes32 packed)
2323         internal
2324         pure
2325         returns (string memory resultA, string memory resultB)
2326     {
2327         /// @solidity memory-safe-assembly
2328         assembly {
2329             // Grab the free memory pointer.
2330             resultA := mload(0x40)
2331             resultB := add(resultA, 0x40)
2332             // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.
2333             mstore(0x40, add(resultB, 0x40))
2334             // Zeroize the length slots.
2335             mstore(resultA, 0)
2336             mstore(resultB, 0)
2337             // Store the lengths and bytes.
2338             mstore(add(resultA, 0x1f), packed)
2339             mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))
2340             // Right pad with zeroes.
2341             mstore(add(add(resultA, 0x20), mload(resultA)), 0)
2342             mstore(add(add(resultB, 0x20), mload(resultB)), 0)
2343         }
2344     }



```

```
LibString.endsWith(string,string) (LlamaAccount.sol#1879-1904) is never used and should be removed



    
1879     function endsWith(string memory subject, string memory search)
1880         internal
1881         pure
1882         returns (bool result)
1883     {
1884         /// @solidity memory-safe-assembly
1885         assembly {
1886             let searchLength := mload(search)
1887             let subjectLength := mload(subject)
1888             // Whether `search` is not longer than `subject`.
1889             let withinRange := iszero(gt(searchLength, subjectLength))
1890             // Just using keccak256 directly is actually cheaper.
1891             // forgefmt: disable-next-item
1892             result := and(
1893                 withinRange,
1894                 eq(
1895                     keccak256(
1896                         // `subject + 0x20 + max(subjectLength - searchLength, 0)`.
1897                         add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),
1898                         searchLength
1899                     ),
1900                     keccak256(add(search, 0x20), searchLength)
1901                 )
1902             )
1903         }
1904     }



```

```
LibString.escapeHTML(string) (LlamaAccount.sol#2171-2202) is never used and should be removed



    
2171     function escapeHTML(string memory s) internal pure returns (string memory result) {
2172         /// @solidity memory-safe-assembly
2173         assembly {
2174             for {
2175                 let end := add(s, mload(s))
2176                 result := add(mload(0x40), 0x20)
2177                 // Store the bytes of the packed offsets and strides into the scratch space.
2178                 // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.
2179                 mstore(0x1f, 0x900094)
2180                 mstore(0x08, 0xc0000000a6ab)
2181                 // Store "&quot;&amp;&#39;&lt;&gt;" into the scratch space.
2182                 mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))
2183             } iszero(eq(s, end)) {} {
2184                 s := add(s, 1)
2185                 let c := and(mload(s), 0xff)
2186                 // Not in `["\"","'","&","<",">"]`.
2187                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
2188                     mstore8(result, c)
2189                     result := add(result, 1)
2190                     continue
2191                 }
2192                 let t := shr(248, mload(c))
2193                 mstore(result, mload(and(t, 0x1f)))
2194                 result := add(result, shr(5, t))
2195             }
2196             let last := result
2197             mstore(last, 0) // Zeroize the slot after the string.
2198             result := mload(0x40)
2199             mstore(result, sub(last, add(result, 0x20))) // Store the length.
2200             mstore(0x40, add(last, 0x20)) // Allocate the memory.
2201         }
2202     }



```

```
LibString.toHexStringChecksummed(address) (LlamaAccount.sol#1503-1520) is never used and should be removed



    
1503     function toHexStringChecksummed(address value) internal pure returns (string memory str) {
1504         str = toHexString(value);
1505         /// @solidity memory-safe-assembly
1506         assembly {
1507             let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`
1508             let o := add(str, 0x22)
1509             let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `
1510             let t := shl(240, 136) // `0b10001000 << 240`
1511             for { let i := 0 } 1 {} {
1512                 mstore(add(i, i), mul(t, byte(i, hashed)))
1513                 i := add(i, 1)
1514                 if eq(i, 20) { break }
1515             }
1516             mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))
1517             o := add(o, 0x20)
1518             mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))
1519         }
1520     }



```

```
LibString.toHexStringNoPrefix(uint256) (LlamaAccount.sol#1463-1497) is never used and should be removed



    
1463     function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {
1464         /// @solidity memory-safe-assembly
1465         assembly {
1466             // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,
1467             // 0x02 bytes for the prefix, and 0x40 bytes for the digits.
1468             // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.
1469             str := add(mload(0x40), 0x80)
1470             // Allocate the memory.
1471             mstore(0x40, add(str, 0x20))
1472             // Zeroize the slot after the string.
1473             mstore(str, 0)
1474 
1475             // Cache the end to calculate the length later.
1476             let end := str
1477             // Store "0123456789abcdef" in scratch space.
1478             mstore(0x0f, 0x30313233343536373839616263646566)
1479 
1480             let w := not(1) // Tsk.
1481             // We write the string from rightmost digit to leftmost digit.
1482             // The following is essentially a do-while loop that also handles the zero case.
1483             for { let temp := value } 1 {} {
1484                 str := add(str, w) // `sub(str, 2)`.
1485                 mstore8(add(str, 1), mload(and(temp, 15)))
1486                 mstore8(str, mload(and(shr(4, temp), 15)))
1487                 temp := shr(8, temp)
1488                 if iszero(temp) { break }
1489             }
1490 
1491             // Compute the string's length.
1492             let strLength := sub(end, str)
1493             // Move the pointer and write the length.
1494             str := sub(str, 0x20)
1495             mstore(str, strLength)
1496         }
1497     }



```

```
Clones.clone(address) (LlamaAccount.sol#1191-1204) is never used and should be removed



    
1191     function clone(address implementation) internal returns (address instance) {
1192         /// @solidity memory-safe-assembly
1193         assembly {
1194             // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
1195             // of the `implementation` address with the bytecode before the address.
1196             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
1197             // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
1198             mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
1199             instance := create(0, 0x09, 0x37)
1200         }
1201         if (instance == address(0)) {
1202             revert ERC1167FailedCreateClone();
1203         }
1204     }



```

```
LibString.is7BitASCII(string) (LlamaAccount.sol#1634-1656) is never used and should be removed



    
1634     function is7BitASCII(string memory s) internal pure returns (bool result) {
1635         /// @solidity memory-safe-assembly
1636         assembly {
1637             let mask := shl(7, div(not(0), 255))
1638             result := 1
1639             let n := mload(s)
1640             if n {
1641                 let o := add(s, 0x20)
1642                 let end := add(o, n)
1643                 let last := mload(end)
1644                 mstore(end, 0)
1645                 for {} 1 {} {
1646                     if and(mask, mload(o)) {
1647                         result := 0
1648                         break
1649                     }
1650                     o := add(o, 0x20)
1651                     if iszero(lt(o, end)) { break }
1652                 }
1653                 mstore(end, last)
1654             }
1655         }
1656     }



```

```
SafeERC20._callOptionalReturnBool(IERC20,bytes) (LlamaAccount.sol#681-688) is never used and should be removed



    
681     function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {
682         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
683         // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false
684         // and not revert is the subcall reverts.
685 
686         (bool success, bytes memory returndata) = address(token).call(data);
687         return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;
688     }



```

```
Initializable._getInitializedVersion() (LlamaAccount.sol#175-177) is never used and should be removed



    
175     function _getInitializedVersion() internal view returns (uint8) {
176         return _initialized;
177     }



```

```
Address.defaultRevert() (LlamaAccount.sol#539-541) is never used and should be removed



    
539     function defaultRevert() internal pure {
540         revert FailedInnerCall();
541     }



```

```
SafeERC20.forceApprove(IERC20,address,uint256) (LlamaAccount.sol#625-632) is never used and should be removed



    
625     function forceApprove(IERC20 token, address spender, uint256 value) internal {
626         bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));
627 
628         if (!_callOptionalReturnBool(token, approvalCall)) {
629             _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));
630             _callOptionalReturn(token, approvalCall);
631         }
632     }



```

```
Checkpoints.length(Checkpoints.History) (LlamaAccount.sol#2472-2474) is never used and should be removed



    
2472     function length(History storage self) internal view returns (uint256) {
2473         return self._checkpoints.length;
2474     }



```

```
LibString.slice(string,uint256) (LlamaAccount.sol#1974-1980) is never used and should be removed



    
1974     function slice(string memory subject, uint256 start)
1975         internal
1976         pure
1977         returns (string memory result)
1978     {
1979         result = slice(subject, start, uint256(int256(-1)));
1980     }



```

```
SafeERC20.safeDecreaseAllowance(IERC20,address,uint256) (LlamaAccount.sol#610-618) is never used and should be removed



    
610     function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {
611         unchecked {
612             uint256 currentAllowance = token.allowance(address(this), spender);
613             if (currentAllowance < requestedDecrease) {
614                 revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);
615             }
616             forceApprove(token, spender, currentAllowance - requestedDecrease);
617         }
618     }



```

```
LibString.concat(string,string) (LlamaAccount.sol#2092-2126) is never used and should be removed



    
2092     function concat(string memory a, string memory b)
2093         internal
2094         pure
2095         returns (string memory result)
2096     {
2097         /// @solidity memory-safe-assembly
2098         assembly {
2099             let w := not(0x1f)
2100             result := mload(0x40)
2101             let aLength := mload(a)
2102             // Copy `a` one word at a time, backwards.
2103             for { let o := and(add(aLength, 0x20), w) } 1 {} {
2104                 mstore(add(result, o), mload(add(a, o)))
2105                 o := add(o, w) // `sub(o, 0x20)`.
2106                 if iszero(o) { break }
2107             }
2108             let bLength := mload(b)
2109             let output := add(result, aLength)
2110             // Copy `b` one word at a time, backwards.
2111             for { let o := and(add(bLength, 0x20), w) } 1 {} {
2112                 mstore(add(output, o), mload(add(b, o)))
2113                 o := add(o, w) // `sub(o, 0x20)`.
2114                 if iszero(o) { break }
2115             }
2116             let totalLength := add(aLength, bLength)
2117             let last := add(add(result, 0x20), totalLength)
2118             // Zeroize the slot after the string.
2119             mstore(last, 0)
2120             // Stores the length.
2121             mstore(result, totalLength)
2122             // Allocate memory for the length and the bytes,
2123             // rounded up to a multiple of 32.
2124             mstore(0x40, and(add(last, 0x1f), w))
2125         }
2126     }



```

```
LibString.toHexStringNoPrefix(uint256,uint256) (LlamaAccount.sol#1364-1412) is never used and should be removed



    
1364     function toHexStringNoPrefix(uint256 value, uint256 length)
1365         internal
1366         pure
1367         returns (string memory str)
1368     {
1369         /// @solidity memory-safe-assembly
1370         assembly {
1371             // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes
1372             // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.
1373             // We add 0x20 to the total and round down to a multiple of 0x20.
1374             // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.
1375             str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))
1376             // Allocate the memory.
1377             mstore(0x40, add(str, 0x20))
1378             // Zeroize the slot after the string.
1379             mstore(str, 0)
1380 
1381             // Cache the end to calculate the length later.
1382             let end := str
1383             // Store "0123456789abcdef" in scratch space.
1384             mstore(0x0f, 0x30313233343536373839616263646566)
1385 
1386             let start := sub(str, add(length, length))
1387             let w := not(1) // Tsk.
1388             let temp := value
1389             // We write the string from rightmost digit to leftmost digit.
1390             // The following is essentially a do-while loop that also handles the zero case.
1391             for {} 1 {} {
1392                 str := add(str, w) // `sub(str, 2)`.
1393                 mstore8(add(str, 1), mload(and(temp, 15)))
1394                 mstore8(str, mload(and(shr(4, temp), 15)))
1395                 temp := shr(8, temp)
1396                 if iszero(xor(str, start)) { break }
1397             }
1398 
1399             if temp {
1400                 // Store the function selector of `HexLengthInsufficient()`.
1401                 mstore(0x00, 0x2194895a)
1402                 // Revert with (offset, size).
1403                 revert(0x1c, 0x04)
1404             }
1405 
1406             // Compute the string's length.
1407             let strLength := sub(end, str)
1408             // Move the pointer and write the length.
1409             str := sub(str, 0x20)
1410             mstore(str, strLength)
1411         }
1412     }



```

```
Checkpoints._lowerBinaryLookup(Checkpoints.Checkpoint[],uint64,uint256,uint256) (LlamaAccount.sol#2541-2556) is never used and should be removed



    
2541     function _lowerBinaryLookup(
2542         Checkpoint[] storage self,
2543         uint64 timestamp,
2544         uint256 low,
2545         uint256 high
2546     ) private view returns (uint256) {
2547         while (low < high) {
2548             uint256 mid = average(low, high);
2549             if (_unsafeAccess(self, mid).timestamp < timestamp) {
2550                 low = mid + 1;
2551             } else {
2552                 high = mid;
2553             }
2554         }
2555         return high;
2556     }



```

```
Address.verifyCallResult(bool,bytes) (LlamaAccount.sol#512-514) is never used and should be removed



    
512     function verifyCallResult(bool success, bytes memory returndata) internal view returns (bytes memory) {
513         return verifyCallResult(success, returndata, defaultRevert);
514     }



```

```
LibString.split(string,string) (LlamaAccount.sol#2043-2088) is never used and should be removed



    
2043     function split(string memory subject, string memory delimiter)
2044         internal
2045         pure
2046         returns (string[] memory result)
2047     {
2048         uint256[] memory indices = indicesOf(subject, delimiter);
2049         /// @solidity memory-safe-assembly
2050         assembly {
2051             let w := not(0x1f)
2052             let indexPtr := add(indices, 0x20)
2053             let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))
2054             mstore(add(indicesEnd, w), mload(subject))
2055             mstore(indices, add(mload(indices), 1))
2056             let prevIndex := 0
2057             for {} 1 {} {
2058                 let index := mload(indexPtr)
2059                 mstore(indexPtr, 0x60)
2060                 if iszero(eq(index, prevIndex)) {
2061                     let element := mload(0x40)
2062                     let elementLength := sub(index, prevIndex)
2063                     mstore(element, elementLength)
2064                     // Copy the `subject` one word at a time, backwards.
2065                     for { let o := and(add(elementLength, 0x1f), w) } 1 {} {
2066                         mstore(add(element, o), mload(add(add(subject, prevIndex), o)))
2067                         o := add(o, w) // `sub(o, 0x20)`.
2068                         if iszero(o) { break }
2069                     }
2070                     // Zeroize the slot after the string.
2071                     mstore(add(add(element, 0x20), elementLength), 0)
2072                     // Allocate memory for the length and the bytes,
2073                     // rounded up to a multiple of 32.
2074                     mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))
2075                     // Store the `element` into the array.
2076                     mstore(indexPtr, element)
2077                 }
2078                 prevIndex := add(index, mload(delimiter))
2079                 indexPtr := add(indexPtr, 0x20)
2080                 if iszero(lt(indexPtr, indicesEnd)) { break }
2081             }
2082             result := indices
2083             if iszero(mload(delimiter)) {
2084                 result := add(indices, 0x20)
2085                 mstore(result, sub(mload(indices), 2))
2086             }
2087         }
2088     }



```

```
LibString.lower(string) (LlamaAccount.sol#2160-2162) is never used and should be removed



    
2160     function lower(string memory subject) internal pure returns (string memory result) {
2161         result = toCase(subject, false);
2162     }



```

```
LibString.packTwo(string,string) (LlamaAccount.sol#2299-2317) is never used and should be removed



    
2299     function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {
2300         /// @solidity memory-safe-assembly
2301         assembly {
2302             let aLength := mload(a)
2303             // We don't need to zero right pad the strings,
2304             // since this is our own custom non-standard packing scheme.
2305             result :=
2306                 mul(
2307                     // Load the length and the bytes of `a` and `b`.
2308                     or(
2309                         shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),
2310                         mload(sub(add(b, 0x1e), aLength))
2311                     ),
2312                     // `totalLength != 0 && totalLength < 31`. Abuses underflow.
2313                     // Assumes that the lengths are valid and within the block gas limit.
2314                     lt(sub(add(aLength, mload(b)), 1), 0x1e)
2315                 )
2316         }
2317     }



```

```
LibString.eq(string,string) (LlamaAccount.sol#2254-2258) is never used and should be removed



    
2254     function eq(string memory a, string memory b) internal pure returns (bool result) {
2255         assembly {
2256             result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))
2257         }
2258     }



```

```
LibString.repeat(string,uint256) (LlamaAccount.sol#1907-1937) is never used and should be removed



    
1907     function repeat(string memory subject, uint256 times)
1908         internal
1909         pure
1910         returns (string memory result)
1911     {
1912         /// @solidity memory-safe-assembly
1913         assembly {
1914             let subjectLength := mload(subject)
1915             if iszero(or(iszero(times), iszero(subjectLength))) {
1916                 subject := add(subject, 0x20)
1917                 result := mload(0x40)
1918                 let output := add(result, 0x20)
1919                 for {} 1 {} {
1920                     // Copy the `subject` one word at a time.
1921                     for { let o := 0 } 1 {} {
1922                         mstore(add(output, o), mload(add(subject, o)))
1923                         o := add(o, 0x20)
1924                         if iszero(lt(o, subjectLength)) { break }
1925                     }
1926                     output := add(output, subjectLength)
1927                     times := sub(times, 1)
1928                     if iszero(times) { break }
1929                 }
1930                 mstore(output, 0) // Zeroize the slot after the string.
1931                 let resultLength := sub(output, add(result, 0x20))
1932                 mstore(result, resultLength) // Store the length.
1933                 // Allocate the memory.
1934                 mstore(0x40, add(result, add(resultLength, 0x20)))
1935             }
1936         }
1937     }



```

### LlamaCore.sol


```
LibString.indexOf(string,string) (LlamaCore.sol#838-844) is never used and should be removed



    
838     function indexOf(string memory subject, string memory search)
839         internal
840         pure
841         returns (uint256 result)
842     {
843         result = indexOf(subject, search, 0);
844     }



```

```
Initializable._isInitializing() (LlamaCore.sol#275-277) is never used and should be removed



    
275     function _isInitializing() internal view returns (bool) {
276         return _initializing;
277     }



```

```
LibString.indexOf(string,string,uint256) (LlamaCore.sol#780-833) is never used and should be removed



    
780     function indexOf(string memory subject, string memory search, uint256 from)
781         internal
782         pure
783         returns (uint256 result)
784     {
785         /// @solidity memory-safe-assembly
786         assembly {
787             for { let subjectLength := mload(subject) } 1 {} {
788                 if iszero(mload(search)) {
789                     if iszero(gt(from, subjectLength)) {
790                         result := from
791                         break
792                     }
793                     result := subjectLength
794                     break
795                 }
796                 let searchLength := mload(search)
797                 let subjectStart := add(subject, 0x20)
798 
799                 result := not(0) // Initialize to `NOT_FOUND`.
800 
801                 subject := add(subjectStart, from)
802                 let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)
803 
804                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
805                 let s := mload(add(search, 0x20))
806 
807                 if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }
808 
809                 if iszero(lt(searchLength, 0x20)) {
810                     for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
811                         if iszero(shr(m, xor(mload(subject), s))) {
812                             if eq(keccak256(subject, searchLength), h) {
813                                 result := sub(subject, subjectStart)
814                                 break
815                             }
816                         }
817                         subject := add(subject, 1)
818                         if iszero(lt(subject, end)) { break }
819                     }
820                     break
821                 }
822                 for {} 1 {} {
823                     if iszero(shr(m, xor(mload(subject), s))) {
824                         result := sub(subject, subjectStart)
825                         break
826                     }
827                     subject := add(subject, 1)
828                     if iszero(lt(subject, end)) { break }
829                 }
830                 break
831             }
832         }
833     }



```

```
Clones.predictDeterministicAddress(address,bytes32) (LlamaCore.sol#89-94) is never used and should be removed



    
89     function predictDeterministicAddress(
90         address implementation,
91         bytes32 salt
92     ) internal view returns (address predicted) {
93         return predictDeterministicAddress(implementation, salt, address(this));
94     }



```

```
LibString.toHexString(bytes) (LlamaCore.sol#611-620) is never used and should be removed



    
611     function toHexString(bytes memory raw) internal pure returns (string memory str) {
612         str = toHexStringNoPrefix(raw);
613         /// @solidity memory-safe-assembly
614         assembly {
615             let strLength := add(mload(str), 2) // Compute the length.
616             mstore(str, 0x3078) // Write the "0x" prefix.
617             str := sub(str, 2) // Move the pointer.
618             mstore(str, strLength) // Write the length.
619         }
620     }



```

```
LibString.toHexString(uint256,uint256) (LlamaCore.sol#385-394) is never used and should be removed



    
385     function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {
386         str = toHexStringNoPrefix(value, length);
387         /// @solidity memory-safe-assembly
388         assembly {
389             let strLength := add(mload(str), 2) // Compute the length.
390             mstore(str, 0x3078) // Write the "0x" prefix.
391             str := sub(str, 2) // Move the pointer.
392             mstore(str, strLength) // Write the length.
393         }
394     }



```

```
LibString.escapeJSON(string) (LlamaCore.sol#1242-1288) is never used and should be removed



    
1242     function escapeJSON(string memory s) internal pure returns (string memory result) {
1243         /// @solidity memory-safe-assembly
1244         assembly {
1245             for {
1246                 let end := add(s, mload(s))
1247                 result := add(mload(0x40), 0x20)
1248                 // Store "\\u0000" in scratch space.
1249                 // Store "0123456789abcdef" in scratch space.
1250                 // Also, store `{0x08:"b", 0x09:"t", 0x0a:"n", 0x0c:"f", 0x0d:"r"}`.
1251                 // into the scratch space.
1252                 mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)
1253                 // Bitmask for detecting `["\"","\\"]`.
1254                 let e := or(shl(0x22, 1), shl(0x5c, 1))
1255             } iszero(eq(s, end)) {} {
1256                 s := add(s, 1)
1257                 let c := and(mload(s), 0xff)
1258                 if iszero(lt(c, 0x20)) {
1259                     if iszero(and(shl(c, 1), e)) {
1260                         // Not in `["\"","\\"]`.
1261                         mstore8(result, c)
1262                         result := add(result, 1)
1263                         continue
1264                     }
1265                     mstore8(result, 0x5c) // "\\".
1266                     mstore8(add(result, 1), c)
1267                     result := add(result, 2)
1268                     continue
1269                 }
1270                 if iszero(and(shl(c, 1), 0x3700)) {
1271                     // Not in `["\b","\t","\n","\f","\d"]`.
1272                     mstore8(0x1d, mload(shr(4, c))) // Hex value.
1273                     mstore8(0x1e, mload(and(c, 15))) // Hex value.
1274                     mstore(result, mload(0x19)) // "\\u00XX".
1275                     result := add(result, 6)
1276                     continue
1277                 }
1278                 mstore8(result, 0x5c) // "\\".
1279                 mstore8(add(result, 1), mload(add(c, 8)))
1280                 result := add(result, 2)
1281             }
1282             let last := result
1283             mstore(last, 0) // Zeroize the slot after the string.
1284             result := mload(0x40)
1285             mstore(result, sub(last, add(result, 0x20))) // Store the length.
1286             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1287         }
1288     }



```

```
LibString.toHexStringNoPrefix(bytes) (LlamaCore.sol#624-646) is never used and should be removed



    
624     function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {
625         /// @solidity memory-safe-assembly
626         assembly {
627             let length := mload(raw)
628             str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.
629             mstore(str, add(length, length)) // Store the length of the output.
630 
631             // Store "0123456789abcdef" in scratch space.
632             mstore(0x0f, 0x30313233343536373839616263646566)
633 
634             let o := add(str, 0x20)
635             let end := add(raw, length)
636 
637             for {} iszero(eq(raw, end)) {} {
638                 raw := add(raw, 1)
639                 mstore8(add(o, 1), mload(and(mload(raw), 15)))
640                 mstore8(o, mload(and(shr(4, mload(raw)), 15)))
641                 o := add(o, 2)
642             }
643             mstore(o, 0) // Zeroize the slot after the string.
644             mstore(0x40, add(o, 0x20)) // Allocate the memory.
645         }
646     }



```

```
LibString.lastIndexOf(string,string) (LlamaCore.sol#886-892) is never used and should be removed



    
886     function lastIndexOf(string memory subject, string memory search)
887         internal
888         pure
889         returns (uint256 result)
890     {
891         result = lastIndexOf(subject, search, uint256(int256(-1)));
892     }



```

```
LibString.startsWith(string,string) (LlamaCore.sol#895-913) is never used and should be removed



    
895     function startsWith(string memory subject, string memory search)
896         internal
897         pure
898         returns (bool result)
899     {
900         /// @solidity memory-safe-assembly
901         assembly {
902             let searchLength := mload(search)
903             // Just using keccak256 directly is actually cheaper.
904             // forgefmt: disable-next-item
905             result := and(
906                 iszero(gt(searchLength, mload(subject))),
907                 eq(
908                     keccak256(add(subject, 0x20), searchLength),
909                     keccak256(add(search, 0x20), searchLength)
910                 )
911             )
912         }
913     }



```

```
LibString.lastIndexOf(string,string,uint256) (LlamaCore.sol#849-881) is never used and should be removed



    
849     function lastIndexOf(string memory subject, string memory search, uint256 from)
850         internal
851         pure
852         returns (uint256 result)
853     {
854         /// @solidity memory-safe-assembly
855         assembly {
856             for {} 1 {} {
857                 result := not(0) // Initialize to `NOT_FOUND`.
858                 let searchLength := mload(search)
859                 if gt(searchLength, mload(subject)) { break }
860                 let w := result
861 
862                 let fromMax := sub(mload(subject), searchLength)
863                 if iszero(gt(fromMax, from)) { from := fromMax }
864 
865                 let end := add(add(subject, 0x20), w)
866                 subject := add(add(subject, 0x20), from)
867                 if iszero(gt(subject, end)) { break }
868                 // As this function is not too often used,
869                 // we shall simply use keccak256 for smaller bytecode size.
870                 for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
871                     if eq(keccak256(subject, searchLength), h) {
872                         result := sub(subject, add(end, 1))
873                         break
874                     }
875                     subject := add(subject, w) // `sub(subject, 1)`.
876                     if iszero(gt(subject, end)) { break }
877                 }
878                 break
879             }
880         }
881     }



```

```
LibString.toString(int256) (LlamaCore.sol#358-374) is never used and should be removed



    
358     function toString(int256 value) internal pure returns (string memory str) {
359         if (value >= 0) {
360             return toString(uint256(value));
361         }
362         unchecked {
363             str = toString(uint256(-value));
364         }
365         /// @solidity memory-safe-assembly
366         assembly {
367             // We still have some spare memory space on the left,
368             // as we have allocated 3 words (96 bytes) for up to 78 digits.
369             let length := mload(str) // Load the string length.
370             mstore(str, 0x2d) // Store the '-' character.
371             str := sub(str, 1) // Move back the string pointer by a byte.
372             mstore(str, add(length, 1)) // Update the string length.
373         }
374     }



```

```
Clones.predictDeterministicAddress(address,bytes32,address) (LlamaCore.sol#68-84) is never used and should be removed



    
68     function predictDeterministicAddress(
69         address implementation,
70         bytes32 salt,
71         address deployer
72     ) internal pure returns (address predicted) {
73         /// @solidity memory-safe-assembly
74         assembly {
75             let ptr := mload(0x40)
76             mstore(add(ptr, 0x38), deployer)
77             mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)
78             mstore(add(ptr, 0x14), implementation)
79             mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)
80             mstore(add(ptr, 0x58), salt)
81             mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))
82             predicted := keccak256(add(ptr, 0x43), 0x55)
83         }
84     }



```

```
LibString.directReturn(string) (LlamaCore.sol#1384-1397) is never used and should be removed



    
1384     function directReturn(string memory a) internal pure {
1385         assembly {
1386             // Assumes that the string does not start from the scratch space.
1387             let retStart := sub(a, 0x20)
1388             let retSize := add(mload(a), 0x40)
1389             // Right pad with zeroes. Just in case the string is produced
1390             // by a method that doesn't zero right pad.
1391             mstore(add(retStart, retSize), 0)
1392             // Store the return offset.
1393             mstore(retStart, 0x20)
1394             // End the transaction, returning the string.
1395             return(retStart, retSize)
1396         }
1397     }



```

```
LibString.toMinimalHexStringNoPrefix(uint256) (LlamaCore.sol#485-494) is never used and should be removed



    
485     function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {
486         str = toHexStringNoPrefix(value);
487         /// @solidity memory-safe-assembly
488         assembly {
489             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
490             let strLength := mload(str) // Get the length.
491             str := add(str, o) // Move the pointer, accounting for leading zero.
492             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
493         }
494     }



```

```
LibString.toMinimalHexString(uint256) (LlamaCore.sol#470-480) is never used and should be removed



    
470     function toMinimalHexString(uint256 value) internal pure returns (string memory str) {
471         str = toHexStringNoPrefix(value);
472         /// @solidity memory-safe-assembly
473         assembly {
474             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
475             let strLength := add(mload(str), 2) // Compute the length.
476             mstore(add(str, o), 0x3078) // Write the "0x" prefix, accounting for leading zero.
477             str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.
478             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
479         }
480     }



```

```
LibString.toHexString(uint256) (LlamaCore.sol#455-464) is never used and should be removed



    
455     function toHexString(uint256 value) internal pure returns (string memory str) {
456         str = toHexStringNoPrefix(value);
457         /// @solidity memory-safe-assembly
458         assembly {
459             let strLength := add(mload(str), 2) // Compute the length.
460             mstore(str, 0x3078) // Write the "0x" prefix.
461             str := sub(str, 2) // Move the pointer.
462             mstore(str, strLength) // Write the length.
463         }
464     }



```

```
ERC721NonTransferableMinimalProxy._safeMint(address,uint256,bytes) (LlamaCore.sol#1877-1886) is never used and should be removed



    
1877   function _safeMint(address to, uint256 id, bytes memory data) internal virtual {
1878     _mint(to, id);
1879 
1880     require(
1881       to.code.length == 0
1882         || ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data)
1883           == ERC721TokenReceiver.onERC721Received.selector,
1884       "UNSAFE_RECIPIENT"
1885     );
1886   }



```

```
LibString.indicesOf(string,string) (LlamaCore.sol#1021-1077) is never used and should be removed



    
1021     function indicesOf(string memory subject, string memory search)
1022         internal
1023         pure
1024         returns (uint256[] memory result)
1025     {
1026         /// @solidity memory-safe-assembly
1027         assembly {
1028             let subjectLength := mload(subject)
1029             let searchLength := mload(search)
1030 
1031             if iszero(gt(searchLength, subjectLength)) {
1032                 subject := add(subject, 0x20)
1033                 search := add(search, 0x20)
1034                 result := add(mload(0x40), 0x20)
1035 
1036                 let subjectStart := subject
1037                 let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)
1038                 let h := 0
1039                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
1040                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
1041                 let s := mload(search)
1042                 for {} 1 {} {
1043                     let t := mload(subject)
1044                     // Whether the first `searchLength % 32` bytes of
1045                     // `subject` and `search` matches.
1046                     if iszero(shr(m, xor(t, s))) {
1047                         if h {
1048                             if iszero(eq(keccak256(subject, searchLength), h)) {
1049                                 subject := add(subject, 1)
1050                                 if iszero(lt(subject, subjectSearchEnd)) { break }
1051                                 continue
1052                             }
1053                         }
1054                         // Append to `result`.
1055                         mstore(result, sub(subject, subjectStart))
1056                         result := add(result, 0x20)
1057                         // Advance `subject` by `searchLength`.
1058                         subject := add(subject, searchLength)
1059                         if searchLength {
1060                             if iszero(lt(subject, subjectSearchEnd)) { break }
1061                             continue
1062                         }
1063                     }
1064                     subject := add(subject, 1)
1065                     if iszero(lt(subject, subjectSearchEnd)) { break }
1066                 }
1067                 let resultEnd := result
1068                 // Assign `result` to the free memory pointer.
1069                 result := mload(0x40)
1070                 // Store the length of `result`.
1071                 mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))
1072                 // Allocate memory for result.
1073                 // We allocate one more word, so this array can be recycled for {split}.
1074                 mstore(0x40, add(resultEnd, 0x20))
1075             }
1076         }
1077     }



```

```
Initializable._checkInitializing() (LlamaCore.sol#241-245) is never used and should be removed



    
241     function _checkInitializing() internal view virtual {
242         if (!_initializing) {
243             revert NotInitializing();
244         }
245     }



```

```
LibString.unpackOne(bytes32) (LlamaCore.sol#1318-1332) is never used and should be removed



    
1318     function unpackOne(bytes32 packed) internal pure returns (string memory result) {
1319         /// @solidity memory-safe-assembly
1320         assembly {
1321             // Grab the free memory pointer.
1322             result := mload(0x40)
1323             // Allocate 2 words (1 for the length, 1 for the bytes).
1324             mstore(0x40, add(result, 0x40))
1325             // Zeroize the length slot.
1326             mstore(result, 0)
1327             // Store the length and bytes.
1328             mstore(add(result, 0x1f), packed)
1329             // Right pad with zeroes.
1330             mstore(add(add(result, 0x20), mload(result)), 0)
1331         }
1332     }



```

```
LibString.toString(uint256) (LlamaCore.sol#320-355) is never used and should be removed



    
320     function toString(uint256 value) internal pure returns (string memory str) {
321         /// @solidity memory-safe-assembly
322         assembly {
323             // The maximum value of a uint256 contains 78 digits (1 byte per digit), but
324             // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.
325             // We will need 1 word for the trailing zeros padding, 1 word for the length,
326             // and 3 words for a maximum of 78 digits.
327             str := add(mload(0x40), 0x80)
328             // Update the free memory pointer to allocate.
329             mstore(0x40, add(str, 0x20))
330             // Zeroize the slot after the string.
331             mstore(str, 0)
332 
333             // Cache the end of the memory to calculate the length later.
334             let end := str
335 
336             let w := not(0) // Tsk.
337             // We write the string from rightmost digit to leftmost digit.
338             // The following is essentially a do-while loop that also handles the zero case.
339             for { let temp := value } 1 {} {
340                 str := add(str, w) // `sub(str, 1)`.
341                 // Write the character to the pointer.
342                 // The ASCII index of the '0' character is 48.
343                 mstore8(str, add(48, mod(temp, 10)))
344                 // Keep dividing `temp` until zero.
345                 temp := div(temp, 10)
346                 if iszero(temp) { break }
347             }
348 
349             let length := sub(end, str)
350             // Move the pointer 32 bytes leftwards to make room for the length.
351             str := sub(str, 0x20)
352             // Store the length.
353             mstore(str, length)
354         }
355     }



```

```
ERC721NonTransferableMinimalProxy._safeMint(address,uint256) (LlamaCore.sol#1866-1875) is never used and should be removed



    
1866   function _safeMint(address to, uint256 id) internal virtual {
1867     _mint(to, id);
1868 
1869     require(
1870       to.code.length == 0
1871         || ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "")
1872           == ERC721TokenReceiver.onERC721Received.selector,
1873       "UNSAFE_RECIPIENT"
1874     );
1875   }



```

```
LibString.packOne(string) (LlamaCore.sol#1299-1313) is never used and should be removed



    
1299     function packOne(string memory a) internal pure returns (bytes32 result) {
1300         /// @solidity memory-safe-assembly
1301         assembly {
1302             // We don't need to zero right pad the string,
1303             // since this is our own custom non-standard packing scheme.
1304             result :=
1305                 mul(
1306                     // Load the length and the bytes.
1307                     mload(add(a, 0x1f)),
1308                     // `length != 0 && length < 32`. Abuses underflow.
1309                     // Assumes that the length is valid and within the block gas limit.
1310                     lt(sub(mload(a), 1), 0x1f)
1311                 )
1312         }
1313     }



```

```
LibString.runeCount(string) (LlamaCore.sol#653-667) is never used and should be removed



    
653     function runeCount(string memory s) internal pure returns (uint256 result) {
654         /// @solidity memory-safe-assembly
655         assembly {
656             if mload(s) {
657                 mstore(0x00, div(not(0), 255))
658                 mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)
659                 let o := add(s, 0x20)
660                 let end := add(o, mload(s))
661                 for { result := 1 } 1 { result := add(result, 1) } {
662                     o := add(o, byte(0, mload(shr(250, mload(o)))))
663                     if iszero(lt(o, end)) { break }
664                 }
665             }
666         }
667     }



```

```
LibString.unpackTwo(bytes32) (LlamaCore.sol#1359-1381) is never used and should be removed



    
1359     function unpackTwo(bytes32 packed)
1360         internal
1361         pure
1362         returns (string memory resultA, string memory resultB)
1363     {
1364         /// @solidity memory-safe-assembly
1365         assembly {
1366             // Grab the free memory pointer.
1367             resultA := mload(0x40)
1368             resultB := add(resultA, 0x40)
1369             // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.
1370             mstore(0x40, add(resultB, 0x40))
1371             // Zeroize the length slots.
1372             mstore(resultA, 0)
1373             mstore(resultB, 0)
1374             // Store the lengths and bytes.
1375             mstore(add(resultA, 0x1f), packed)
1376             mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))
1377             // Right pad with zeroes.
1378             mstore(add(add(resultA, 0x20), mload(resultA)), 0)
1379             mstore(add(add(resultB, 0x20), mload(resultB)), 0)
1380         }
1381     }



```

```
LibString.endsWith(string,string) (LlamaCore.sol#916-941) is never used and should be removed



    
916     function endsWith(string memory subject, string memory search)
917         internal
918         pure
919         returns (bool result)
920     {
921         /// @solidity memory-safe-assembly
922         assembly {
923             let searchLength := mload(search)
924             let subjectLength := mload(subject)
925             // Whether `search` is not longer than `subject`.
926             let withinRange := iszero(gt(searchLength, subjectLength))
927             // Just using keccak256 directly is actually cheaper.
928             // forgefmt: disable-next-item
929             result := and(
930                 withinRange,
931                 eq(
932                     keccak256(
933                         // `subject + 0x20 + max(subjectLength - searchLength, 0)`.
934                         add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),
935                         searchLength
936                     ),
937                     keccak256(add(search, 0x20), searchLength)
938                 )
939             )
940         }
941     }



```

```
LibString.escapeHTML(string) (LlamaCore.sol#1208-1239) is never used and should be removed



    
1208     function escapeHTML(string memory s) internal pure returns (string memory result) {
1209         /// @solidity memory-safe-assembly
1210         assembly {
1211             for {
1212                 let end := add(s, mload(s))
1213                 result := add(mload(0x40), 0x20)
1214                 // Store the bytes of the packed offsets and strides into the scratch space.
1215                 // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.
1216                 mstore(0x1f, 0x900094)
1217                 mstore(0x08, 0xc0000000a6ab)
1218                 // Store "&quot;&amp;&#39;&lt;&gt;" into the scratch space.
1219                 mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))
1220             } iszero(eq(s, end)) {} {
1221                 s := add(s, 1)
1222                 let c := and(mload(s), 0xff)
1223                 // Not in `["\"","'","&","<",">"]`.
1224                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
1225                     mstore8(result, c)
1226                     result := add(result, 1)
1227                     continue
1228                 }
1229                 let t := shr(248, mload(c))
1230                 mstore(result, mload(and(t, 0x1f)))
1231                 result := add(result, shr(5, t))
1232             }
1233             let last := result
1234             mstore(last, 0) // Zeroize the slot after the string.
1235             result := mload(0x40)
1236             mstore(result, sub(last, add(result, 0x20))) // Store the length.
1237             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1238         }
1239     }



```

```
LibString.toHexStringChecksummed(address) (LlamaCore.sol#540-557) is never used and should be removed



    
540     function toHexStringChecksummed(address value) internal pure returns (string memory str) {
541         str = toHexString(value);
542         /// @solidity memory-safe-assembly
543         assembly {
544             let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`
545             let o := add(str, 0x22)
546             let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `
547             let t := shl(240, 136) // `0b10001000 << 240`
548             for { let i := 0 } 1 {} {
549                 mstore(add(i, i), mul(t, byte(i, hashed)))
550                 i := add(i, 1)
551                 if eq(i, 20) { break }
552             }
553             mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))
554             o := add(o, 0x20)
555             mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))
556         }
557     }



```

```
LibString.toHexStringNoPrefix(uint256) (LlamaCore.sol#500-534) is never used and should be removed



    
500     function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {
501         /// @solidity memory-safe-assembly
502         assembly {
503             // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,
504             // 0x02 bytes for the prefix, and 0x40 bytes for the digits.
505             // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.
506             str := add(mload(0x40), 0x80)
507             // Allocate the memory.
508             mstore(0x40, add(str, 0x20))
509             // Zeroize the slot after the string.
510             mstore(str, 0)
511 
512             // Cache the end to calculate the length later.
513             let end := str
514             // Store "0123456789abcdef" in scratch space.
515             mstore(0x0f, 0x30313233343536373839616263646566)
516 
517             let w := not(1) // Tsk.
518             // We write the string from rightmost digit to leftmost digit.
519             // The following is essentially a do-while loop that also handles the zero case.
520             for { let temp := value } 1 {} {
521                 str := add(str, w) // `sub(str, 2)`.
522                 mstore8(add(str, 1), mload(and(temp, 15)))
523                 mstore8(str, mload(and(shr(4, temp), 15)))
524                 temp := shr(8, temp)
525                 if iszero(temp) { break }
526             }
527 
528             // Compute the string's length.
529             let strLength := sub(end, str)
530             // Move the pointer and write the length.
531             str := sub(str, 0x20)
532             mstore(str, strLength)
533         }
534     }



```

```
Clones.clone(address) (LlamaCore.sol#28-41) is never used and should be removed



    
28     function clone(address implementation) internal returns (address instance) {
29         /// @solidity memory-safe-assembly
30         assembly {
31             // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
32             // of the `implementation` address with the bytecode before the address.
33             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
34             // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
35             mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
36             instance := create(0, 0x09, 0x37)
37         }
38         if (instance == address(0)) {
39             revert ERC1167FailedCreateClone();
40         }
41     }



```

```
LibString.is7BitASCII(string) (LlamaCore.sol#671-693) is never used and should be removed



    
671     function is7BitASCII(string memory s) internal pure returns (bool result) {
672         /// @solidity memory-safe-assembly
673         assembly {
674             let mask := shl(7, div(not(0), 255))
675             result := 1
676             let n := mload(s)
677             if n {
678                 let o := add(s, 0x20)
679                 let end := add(o, n)
680                 let last := mload(end)
681                 mstore(end, 0)
682                 for {} 1 {} {
683                     if and(mask, mload(o)) {
684                         result := 0
685                         break
686                     }
687                     o := add(o, 0x20)
688                     if iszero(lt(o, end)) { break }
689                 }
690                 mstore(end, last)
691             }
692         }
693     }



```

```
Initializable._getInitializedVersion() (LlamaCore.sol#268-270) is never used and should be removed



    
268     function _getInitializedVersion() internal view returns (uint8) {
269         return _initialized;
270     }



```

```
Checkpoints.length(Checkpoints.History) (LlamaCore.sol#1534-1536) is never used and should be removed



    
1534     function length(History storage self) internal view returns (uint256) {
1535         return self._checkpoints.length;
1536     }



```

```
LibString.slice(string,uint256) (LlamaCore.sol#1011-1017) is never used and should be removed



    
1011     function slice(string memory subject, uint256 start)
1012         internal
1013         pure
1014         returns (string memory result)
1015     {
1016         result = slice(subject, start, uint256(int256(-1)));
1017     }



```

```
LibString.concat(string,string) (LlamaCore.sol#1129-1163) is never used and should be removed



    
1129     function concat(string memory a, string memory b)
1130         internal
1131         pure
1132         returns (string memory result)
1133     {
1134         /// @solidity memory-safe-assembly
1135         assembly {
1136             let w := not(0x1f)
1137             result := mload(0x40)
1138             let aLength := mload(a)
1139             // Copy `a` one word at a time, backwards.
1140             for { let o := and(add(aLength, 0x20), w) } 1 {} {
1141                 mstore(add(result, o), mload(add(a, o)))
1142                 o := add(o, w) // `sub(o, 0x20)`.
1143                 if iszero(o) { break }
1144             }
1145             let bLength := mload(b)
1146             let output := add(result, aLength)
1147             // Copy `b` one word at a time, backwards.
1148             for { let o := and(add(bLength, 0x20), w) } 1 {} {
1149                 mstore(add(output, o), mload(add(b, o)))
1150                 o := add(o, w) // `sub(o, 0x20)`.
1151                 if iszero(o) { break }
1152             }
1153             let totalLength := add(aLength, bLength)
1154             let last := add(add(result, 0x20), totalLength)
1155             // Zeroize the slot after the string.
1156             mstore(last, 0)
1157             // Stores the length.
1158             mstore(result, totalLength)
1159             // Allocate memory for the length and the bytes,
1160             // rounded up to a multiple of 32.
1161             mstore(0x40, and(add(last, 0x1f), w))
1162         }
1163     }



```

```
LibString.toHexStringNoPrefix(uint256,uint256) (LlamaCore.sol#401-449) is never used and should be removed



    
401     function toHexStringNoPrefix(uint256 value, uint256 length)
402         internal
403         pure
404         returns (string memory str)
405     {
406         /// @solidity memory-safe-assembly
407         assembly {
408             // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes
409             // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.
410             // We add 0x20 to the total and round down to a multiple of 0x20.
411             // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.
412             str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))
413             // Allocate the memory.
414             mstore(0x40, add(str, 0x20))
415             // Zeroize the slot after the string.
416             mstore(str, 0)
417 
418             // Cache the end to calculate the length later.
419             let end := str
420             // Store "0123456789abcdef" in scratch space.
421             mstore(0x0f, 0x30313233343536373839616263646566)
422 
423             let start := sub(str, add(length, length))
424             let w := not(1) // Tsk.
425             let temp := value
426             // We write the string from rightmost digit to leftmost digit.
427             // The following is essentially a do-while loop that also handles the zero case.
428             for {} 1 {} {
429                 str := add(str, w) // `sub(str, 2)`.
430                 mstore8(add(str, 1), mload(and(temp, 15)))
431                 mstore8(str, mload(and(shr(4, temp), 15)))
432                 temp := shr(8, temp)
433                 if iszero(xor(str, start)) { break }
434             }
435 
436             if temp {
437                 // Store the function selector of `HexLengthInsufficient()`.
438                 mstore(0x00, 0x2194895a)
439                 // Revert with (offset, size).
440                 revert(0x1c, 0x04)
441             }
442 
443             // Compute the string's length.
444             let strLength := sub(end, str)
445             // Move the pointer and write the length.
446             str := sub(str, 0x20)
447             mstore(str, strLength)
448         }
449     }



```

```
Checkpoints._lowerBinaryLookup(Checkpoints.Checkpoint[],uint64,uint256,uint256) (LlamaCore.sol#1603-1618) is never used and should be removed



    
1603     function _lowerBinaryLookup(
1604         Checkpoint[] storage self,
1605         uint64 timestamp,
1606         uint256 low,
1607         uint256 high
1608     ) private view returns (uint256) {
1609         while (low < high) {
1610             uint256 mid = average(low, high);
1611             if (_unsafeAccess(self, mid).timestamp < timestamp) {
1612                 low = mid + 1;
1613             } else {
1614                 high = mid;
1615             }
1616         }
1617         return high;
1618     }



```

```
LibString.split(string,string) (LlamaCore.sol#1080-1125) is never used and should be removed



    
1080     function split(string memory subject, string memory delimiter)
1081         internal
1082         pure
1083         returns (string[] memory result)
1084     {
1085         uint256[] memory indices = indicesOf(subject, delimiter);
1086         /// @solidity memory-safe-assembly
1087         assembly {
1088             let w := not(0x1f)
1089             let indexPtr := add(indices, 0x20)
1090             let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))
1091             mstore(add(indicesEnd, w), mload(subject))
1092             mstore(indices, add(mload(indices), 1))
1093             let prevIndex := 0
1094             for {} 1 {} {
1095                 let index := mload(indexPtr)
1096                 mstore(indexPtr, 0x60)
1097                 if iszero(eq(index, prevIndex)) {
1098                     let element := mload(0x40)
1099                     let elementLength := sub(index, prevIndex)
1100                     mstore(element, elementLength)
1101                     // Copy the `subject` one word at a time, backwards.
1102                     for { let o := and(add(elementLength, 0x1f), w) } 1 {} {
1103                         mstore(add(element, o), mload(add(add(subject, prevIndex), o)))
1104                         o := add(o, w) // `sub(o, 0x20)`.
1105                         if iszero(o) { break }
1106                     }
1107                     // Zeroize the slot after the string.
1108                     mstore(add(add(element, 0x20), elementLength), 0)
1109                     // Allocate memory for the length and the bytes,
1110                     // rounded up to a multiple of 32.
1111                     mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))
1112                     // Store the `element` into the array.
1113                     mstore(indexPtr, element)
1114                 }
1115                 prevIndex := add(index, mload(delimiter))
1116                 indexPtr := add(indexPtr, 0x20)
1117                 if iszero(lt(indexPtr, indicesEnd)) { break }
1118             }
1119             result := indices
1120             if iszero(mload(delimiter)) {
1121                 result := add(indices, 0x20)
1122                 mstore(result, sub(mload(indices), 2))
1123             }
1124         }
1125     }



```

```
LibString.lower(string) (LlamaCore.sol#1197-1199) is never used and should be removed



    
1197     function lower(string memory subject) internal pure returns (string memory result) {
1198         result = toCase(subject, false);
1199     }



```

```
LibString.packTwo(string,string) (LlamaCore.sol#1336-1354) is never used and should be removed



    
1336     function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {
1337         /// @solidity memory-safe-assembly
1338         assembly {
1339             let aLength := mload(a)
1340             // We don't need to zero right pad the strings,
1341             // since this is our own custom non-standard packing scheme.
1342             result :=
1343                 mul(
1344                     // Load the length and the bytes of `a` and `b`.
1345                     or(
1346                         shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),
1347                         mload(sub(add(b, 0x1e), aLength))
1348                     ),
1349                     // `totalLength != 0 && totalLength < 31`. Abuses underflow.
1350                     // Assumes that the lengths are valid and within the block gas limit.
1351                     lt(sub(add(aLength, mload(b)), 1), 0x1e)
1352                 )
1353         }
1354     }



```

```
LibString.eq(string,string) (LlamaCore.sol#1291-1295) is never used and should be removed



    
1291     function eq(string memory a, string memory b) internal pure returns (bool result) {
1292         assembly {
1293             result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))
1294         }
1295     }



```

```
LibString.repeat(string,uint256) (LlamaCore.sol#944-974) is never used and should be removed



    
944     function repeat(string memory subject, uint256 times)
945         internal
946         pure
947         returns (string memory result)
948     {
949         /// @solidity memory-safe-assembly
950         assembly {
951             let subjectLength := mload(subject)
952             if iszero(or(iszero(times), iszero(subjectLength))) {
953                 subject := add(subject, 0x20)
954                 result := mload(0x40)
955                 let output := add(result, 0x20)
956                 for {} 1 {} {
957                     // Copy the `subject` one word at a time.
958                     for { let o := 0 } 1 {} {
959                         mstore(add(output, o), mload(add(subject, o)))
960                         o := add(o, 0x20)
961                         if iszero(lt(o, subjectLength)) { break }
962                     }
963                     output := add(output, subjectLength)
964                     times := sub(times, 1)
965                     if iszero(times) { break }
966                 }
967                 mstore(output, 0) // Zeroize the slot after the string.
968                 let resultLength := sub(output, add(result, 0x20))
969                 mstore(result, resultLength) // Store the length.
970                 // Allocate the memory.
971                 mstore(0x40, add(result, add(resultLength, 0x20)))
972             }
973         }
974     }



```

### LlamaFactory.sol


```
LibString.indexOf(string,string) (LlamaFactory.sol#985-991) is never used and should be removed



    
985     function indexOf(string memory subject, string memory search)
986         internal
987         pure
988         returns (uint256 result)
989     {
990         result = indexOf(subject, search, 0);
991     }



```

```
Initializable._isInitializing() (LlamaFactory.sol#342-344) is never used and should be removed



    
342     function _isInitializing() internal view returns (bool) {
343         return _initializing;
344     }



```

```
LibString.indexOf(string,string,uint256) (LlamaFactory.sol#927-980) is never used and should be removed



    
927     function indexOf(string memory subject, string memory search, uint256 from)
928         internal
929         pure
930         returns (uint256 result)
931     {
932         /// @solidity memory-safe-assembly
933         assembly {
934             for { let subjectLength := mload(subject) } 1 {} {
935                 if iszero(mload(search)) {
936                     if iszero(gt(from, subjectLength)) {
937                         result := from
938                         break
939                     }
940                     result := subjectLength
941                     break
942                 }
943                 let searchLength := mload(search)
944                 let subjectStart := add(subject, 0x20)
945 
946                 result := not(0) // Initialize to `NOT_FOUND`.
947 
948                 subject := add(subjectStart, from)
949                 let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)
950 
951                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
952                 let s := mload(add(search, 0x20))
953 
954                 if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }
955 
956                 if iszero(lt(searchLength, 0x20)) {
957                     for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
958                         if iszero(shr(m, xor(mload(subject), s))) {
959                             if eq(keccak256(subject, searchLength), h) {
960                                 result := sub(subject, subjectStart)
961                                 break
962                             }
963                         }
964                         subject := add(subject, 1)
965                         if iszero(lt(subject, end)) { break }
966                     }
967                     break
968                 }
969                 for {} 1 {} {
970                     if iszero(shr(m, xor(mload(subject), s))) {
971                         result := sub(subject, subjectStart)
972                         break
973                     }
974                     subject := add(subject, 1)
975                     if iszero(lt(subject, end)) { break }
976                 }
977                 break
978             }
979         }
980     }



```

```
Clones.predictDeterministicAddress(address,bytes32) (LlamaFactory.sol#89-94) is never used and should be removed



    
89     function predictDeterministicAddress(
90         address implementation,
91         bytes32 salt
92     ) internal view returns (address predicted) {
93         return predictDeterministicAddress(implementation, salt, address(this));
94     }



```

```
LibString.toHexString(bytes) (LlamaFactory.sol#758-767) is never used and should be removed



    
758     function toHexString(bytes memory raw) internal pure returns (string memory str) {
759         str = toHexStringNoPrefix(raw);
760         /// @solidity memory-safe-assembly
761         assembly {
762             let strLength := add(mload(str), 2) // Compute the length.
763             mstore(str, 0x3078) // Write the "0x" prefix.
764             str := sub(str, 2) // Move the pointer.
765             mstore(str, strLength) // Write the length.
766         }
767     }



```

```
LibString.toHexString(uint256,uint256) (LlamaFactory.sol#532-541) is never used and should be removed



    
532     function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {
533         str = toHexStringNoPrefix(value, length);
534         /// @solidity memory-safe-assembly
535         assembly {
536             let strLength := add(mload(str), 2) // Compute the length.
537             mstore(str, 0x3078) // Write the "0x" prefix.
538             str := sub(str, 2) // Move the pointer.
539             mstore(str, strLength) // Write the length.
540         }
541     }



```

```
LibString.escapeJSON(string) (LlamaFactory.sol#1389-1435) is never used and should be removed



    
1389     function escapeJSON(string memory s) internal pure returns (string memory result) {
1390         /// @solidity memory-safe-assembly
1391         assembly {
1392             for {
1393                 let end := add(s, mload(s))
1394                 result := add(mload(0x40), 0x20)
1395                 // Store "\\u0000" in scratch space.
1396                 // Store "0123456789abcdef" in scratch space.
1397                 // Also, store `{0x08:"b", 0x09:"t", 0x0a:"n", 0x0c:"f", 0x0d:"r"}`.
1398                 // into the scratch space.
1399                 mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)
1400                 // Bitmask for detecting `["\"","\\"]`.
1401                 let e := or(shl(0x22, 1), shl(0x5c, 1))
1402             } iszero(eq(s, end)) {} {
1403                 s := add(s, 1)
1404                 let c := and(mload(s), 0xff)
1405                 if iszero(lt(c, 0x20)) {
1406                     if iszero(and(shl(c, 1), e)) {
1407                         // Not in `["\"","\\"]`.
1408                         mstore8(result, c)
1409                         result := add(result, 1)
1410                         continue
1411                     }
1412                     mstore8(result, 0x5c) // "\\".
1413                     mstore8(add(result, 1), c)
1414                     result := add(result, 2)
1415                     continue
1416                 }
1417                 if iszero(and(shl(c, 1), 0x3700)) {
1418                     // Not in `["\b","\t","\n","\f","\d"]`.
1419                     mstore8(0x1d, mload(shr(4, c))) // Hex value.
1420                     mstore8(0x1e, mload(and(c, 15))) // Hex value.
1421                     mstore(result, mload(0x19)) // "\\u00XX".
1422                     result := add(result, 6)
1423                     continue
1424                 }
1425                 mstore8(result, 0x5c) // "\\".
1426                 mstore8(add(result, 1), mload(add(c, 8)))
1427                 result := add(result, 2)
1428             }
1429             let last := result
1430             mstore(last, 0) // Zeroize the slot after the string.
1431             result := mload(0x40)
1432             mstore(result, sub(last, add(result, 0x20))) // Store the length.
1433             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1434         }
1435     }



```

```
LibString.toHexStringNoPrefix(bytes) (LlamaFactory.sol#771-793) is never used and should be removed



    
771     function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {
772         /// @solidity memory-safe-assembly
773         assembly {
774             let length := mload(raw)
775             str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.
776             mstore(str, add(length, length)) // Store the length of the output.
777 
778             // Store "0123456789abcdef" in scratch space.
779             mstore(0x0f, 0x30313233343536373839616263646566)
780 
781             let o := add(str, 0x20)
782             let end := add(raw, length)
783 
784             for {} iszero(eq(raw, end)) {} {
785                 raw := add(raw, 1)
786                 mstore8(add(o, 1), mload(and(mload(raw), 15)))
787                 mstore8(o, mload(and(shr(4, mload(raw)), 15)))
788                 o := add(o, 2)
789             }
790             mstore(o, 0) // Zeroize the slot after the string.
791             mstore(0x40, add(o, 0x20)) // Allocate the memory.
792         }
793     }



```

```
LibString.lastIndexOf(string,string) (LlamaFactory.sol#1033-1039) is never used and should be removed



    
1033     function lastIndexOf(string memory subject, string memory search)
1034         internal
1035         pure
1036         returns (uint256 result)
1037     {
1038         result = lastIndexOf(subject, search, uint256(int256(-1)));
1039     }



```

```
LibString.startsWith(string,string) (LlamaFactory.sol#1042-1060) is never used and should be removed



    
1042     function startsWith(string memory subject, string memory search)
1043         internal
1044         pure
1045         returns (bool result)
1046     {
1047         /// @solidity memory-safe-assembly
1048         assembly {
1049             let searchLength := mload(search)
1050             // Just using keccak256 directly is actually cheaper.
1051             // forgefmt: disable-next-item
1052             result := and(
1053                 iszero(gt(searchLength, mload(subject))),
1054                 eq(
1055                     keccak256(add(subject, 0x20), searchLength),
1056                     keccak256(add(search, 0x20), searchLength)
1057                 )
1058             )
1059         }
1060     }



```

```
LibString.lastIndexOf(string,string,uint256) (LlamaFactory.sol#996-1028) is never used and should be removed



    
996     function lastIndexOf(string memory subject, string memory search, uint256 from)
997         internal
998         pure
999         returns (uint256 result)
1000     {
1001         /// @solidity memory-safe-assembly
1002         assembly {
1003             for {} 1 {} {
1004                 result := not(0) // Initialize to `NOT_FOUND`.
1005                 let searchLength := mload(search)
1006                 if gt(searchLength, mload(subject)) { break }
1007                 let w := result
1008 
1009                 let fromMax := sub(mload(subject), searchLength)
1010                 if iszero(gt(fromMax, from)) { from := fromMax }
1011 
1012                 let end := add(add(subject, 0x20), w)
1013                 subject := add(add(subject, 0x20), from)
1014                 if iszero(gt(subject, end)) { break }
1015                 // As this function is not too often used,
1016                 // we shall simply use keccak256 for smaller bytecode size.
1017                 for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
1018                     if eq(keccak256(subject, searchLength), h) {
1019                         result := sub(subject, add(end, 1))
1020                         break
1021                     }
1022                     subject := add(subject, w) // `sub(subject, 1)`.
1023                     if iszero(gt(subject, end)) { break }
1024                 }
1025                 break
1026             }
1027         }
1028     }



```

```
LibString.toString(int256) (LlamaFactory.sol#505-521) is never used and should be removed



    
505     function toString(int256 value) internal pure returns (string memory str) {
506         if (value >= 0) {
507             return toString(uint256(value));
508         }
509         unchecked {
510             str = toString(uint256(-value));
511         }
512         /// @solidity memory-safe-assembly
513         assembly {
514             // We still have some spare memory space on the left,
515             // as we have allocated 3 words (96 bytes) for up to 78 digits.
516             let length := mload(str) // Load the string length.
517             mstore(str, 0x2d) // Store the '-' character.
518             str := sub(str, 1) // Move back the string pointer by a byte.
519             mstore(str, add(length, 1)) // Update the string length.
520         }
521     }



```

```
Clones.predictDeterministicAddress(address,bytes32,address) (LlamaFactory.sol#68-84) is never used and should be removed



    
68     function predictDeterministicAddress(
69         address implementation,
70         bytes32 salt,
71         address deployer
72     ) internal pure returns (address predicted) {
73         /// @solidity memory-safe-assembly
74         assembly {
75             let ptr := mload(0x40)
76             mstore(add(ptr, 0x38), deployer)
77             mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)
78             mstore(add(ptr, 0x14), implementation)
79             mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)
80             mstore(add(ptr, 0x58), salt)
81             mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))
82             predicted := keccak256(add(ptr, 0x43), 0x55)
83         }
84     }



```

```
LibString.directReturn(string) (LlamaFactory.sol#1531-1544) is never used and should be removed



    
1531     function directReturn(string memory a) internal pure {
1532         assembly {
1533             // Assumes that the string does not start from the scratch space.
1534             let retStart := sub(a, 0x20)
1535             let retSize := add(mload(a), 0x40)
1536             // Right pad with zeroes. Just in case the string is produced
1537             // by a method that doesn't zero right pad.
1538             mstore(add(retStart, retSize), 0)
1539             // Store the return offset.
1540             mstore(retStart, 0x20)
1541             // End the transaction, returning the string.
1542             return(retStart, retSize)
1543         }
1544     }



```

```
LibString.toMinimalHexStringNoPrefix(uint256) (LlamaFactory.sol#632-641) is never used and should be removed



    
632     function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {
633         str = toHexStringNoPrefix(value);
634         /// @solidity memory-safe-assembly
635         assembly {
636             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
637             let strLength := mload(str) // Get the length.
638             str := add(str, o) // Move the pointer, accounting for leading zero.
639             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
640         }
641     }



```

```
LibString.toMinimalHexString(uint256) (LlamaFactory.sol#617-627) is never used and should be removed



    
617     function toMinimalHexString(uint256 value) internal pure returns (string memory str) {
618         str = toHexStringNoPrefix(value);
619         /// @solidity memory-safe-assembly
620         assembly {
621             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
622             let strLength := add(mload(str), 2) // Compute the length.
623             mstore(add(str, o), 0x3078) // Write the "0x" prefix, accounting for leading zero.
624             str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.
625             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
626         }
627     }



```

```
LibString.toHexString(uint256) (LlamaFactory.sol#602-611) is never used and should be removed



    
602     function toHexString(uint256 value) internal pure returns (string memory str) {
603         str = toHexStringNoPrefix(value);
604         /// @solidity memory-safe-assembly
605         assembly {
606             let strLength := add(mload(str), 2) // Compute the length.
607             mstore(str, 0x3078) // Write the "0x" prefix.
608             str := sub(str, 2) // Move the pointer.
609             mstore(str, strLength) // Write the length.
610         }
611     }



```

```
ERC721NonTransferableMinimalProxy._safeMint(address,uint256,bytes) (LlamaFactory.sol#1999-2008) is never used and should be removed



    
1999   function _safeMint(address to, uint256 id, bytes memory data) internal virtual {
2000     _mint(to, id);
2001 
2002     require(
2003       to.code.length == 0
2004         || ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data)
2005           == ERC721TokenReceiver.onERC721Received.selector,
2006       "UNSAFE_RECIPIENT"
2007     );
2008   }



```

```
LibString.indicesOf(string,string) (LlamaFactory.sol#1168-1224) is never used and should be removed



    
1168     function indicesOf(string memory subject, string memory search)
1169         internal
1170         pure
1171         returns (uint256[] memory result)
1172     {
1173         /// @solidity memory-safe-assembly
1174         assembly {
1175             let subjectLength := mload(subject)
1176             let searchLength := mload(search)
1177 
1178             if iszero(gt(searchLength, subjectLength)) {
1179                 subject := add(subject, 0x20)
1180                 search := add(search, 0x20)
1181                 result := add(mload(0x40), 0x20)
1182 
1183                 let subjectStart := subject
1184                 let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)
1185                 let h := 0
1186                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
1187                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
1188                 let s := mload(search)
1189                 for {} 1 {} {
1190                     let t := mload(subject)
1191                     // Whether the first `searchLength % 32` bytes of
1192                     // `subject` and `search` matches.
1193                     if iszero(shr(m, xor(t, s))) {
1194                         if h {
1195                             if iszero(eq(keccak256(subject, searchLength), h)) {
1196                                 subject := add(subject, 1)
1197                                 if iszero(lt(subject, subjectSearchEnd)) { break }
1198                                 continue
1199                             }
1200                         }
1201                         // Append to `result`.
1202                         mstore(result, sub(subject, subjectStart))
1203                         result := add(result, 0x20)
1204                         // Advance `subject` by `searchLength`.
1205                         subject := add(subject, searchLength)
1206                         if searchLength {
1207                             if iszero(lt(subject, subjectSearchEnd)) { break }
1208                             continue
1209                         }
1210                     }
1211                     subject := add(subject, 1)
1212                     if iszero(lt(subject, subjectSearchEnd)) { break }
1213                 }
1214                 let resultEnd := result
1215                 // Assign `result` to the free memory pointer.
1216                 result := mload(0x40)
1217                 // Store the length of `result`.
1218                 mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))
1219                 // Allocate memory for result.
1220                 // We allocate one more word, so this array can be recycled for {split}.
1221                 mstore(0x40, add(resultEnd, 0x20))
1222             }
1223         }
1224     }



```

```
Initializable._checkInitializing() (LlamaFactory.sol#308-312) is never used and should be removed



    
308     function _checkInitializing() internal view virtual {
309         if (!_initializing) {
310             revert NotInitializing();
311         }
312     }



```

```
LibString.unpackOne(bytes32) (LlamaFactory.sol#1465-1479) is never used and should be removed



    
1465     function unpackOne(bytes32 packed) internal pure returns (string memory result) {
1466         /// @solidity memory-safe-assembly
1467         assembly {
1468             // Grab the free memory pointer.
1469             result := mload(0x40)
1470             // Allocate 2 words (1 for the length, 1 for the bytes).
1471             mstore(0x40, add(result, 0x40))
1472             // Zeroize the length slot.
1473             mstore(result, 0)
1474             // Store the length and bytes.
1475             mstore(add(result, 0x1f), packed)
1476             // Right pad with zeroes.
1477             mstore(add(add(result, 0x20), mload(result)), 0)
1478         }
1479     }



```

```
LibString.toString(uint256) (LlamaFactory.sol#467-502) is never used and should be removed



    
467     function toString(uint256 value) internal pure returns (string memory str) {
468         /// @solidity memory-safe-assembly
469         assembly {
470             // The maximum value of a uint256 contains 78 digits (1 byte per digit), but
471             // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.
472             // We will need 1 word for the trailing zeros padding, 1 word for the length,
473             // and 3 words for a maximum of 78 digits.
474             str := add(mload(0x40), 0x80)
475             // Update the free memory pointer to allocate.
476             mstore(0x40, add(str, 0x20))
477             // Zeroize the slot after the string.
478             mstore(str, 0)
479 
480             // Cache the end of the memory to calculate the length later.
481             let end := str
482 
483             let w := not(0) // Tsk.
484             // We write the string from rightmost digit to leftmost digit.
485             // The following is essentially a do-while loop that also handles the zero case.
486             for { let temp := value } 1 {} {
487                 str := add(str, w) // `sub(str, 1)`.
488                 // Write the character to the pointer.
489                 // The ASCII index of the '0' character is 48.
490                 mstore8(str, add(48, mod(temp, 10)))
491                 // Keep dividing `temp` until zero.
492                 temp := div(temp, 10)
493                 if iszero(temp) { break }
494             }
495 
496             let length := sub(end, str)
497             // Move the pointer 32 bytes leftwards to make room for the length.
498             str := sub(str, 0x20)
499             // Store the length.
500             mstore(str, length)
501         }
502     }



```

```
ERC721NonTransferableMinimalProxy._safeMint(address,uint256) (LlamaFactory.sol#1988-1997) is never used and should be removed



    
1988   function _safeMint(address to, uint256 id) internal virtual {
1989     _mint(to, id);
1990 
1991     require(
1992       to.code.length == 0
1993         || ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "")
1994           == ERC721TokenReceiver.onERC721Received.selector,
1995       "UNSAFE_RECIPIENT"
1996     );
1997   }



```

```
LibString.packOne(string) (LlamaFactory.sol#1446-1460) is never used and should be removed



    
1446     function packOne(string memory a) internal pure returns (bytes32 result) {
1447         /// @solidity memory-safe-assembly
1448         assembly {
1449             // We don't need to zero right pad the string,
1450             // since this is our own custom non-standard packing scheme.
1451             result :=
1452                 mul(
1453                     // Load the length and the bytes.
1454                     mload(add(a, 0x1f)),
1455                     // `length != 0 && length < 32`. Abuses underflow.
1456                     // Assumes that the length is valid and within the block gas limit.
1457                     lt(sub(mload(a), 1), 0x1f)
1458                 )
1459         }
1460     }



```

```
LibString.runeCount(string) (LlamaFactory.sol#800-814) is never used and should be removed



    
800     function runeCount(string memory s) internal pure returns (uint256 result) {
801         /// @solidity memory-safe-assembly
802         assembly {
803             if mload(s) {
804                 mstore(0x00, div(not(0), 255))
805                 mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)
806                 let o := add(s, 0x20)
807                 let end := add(o, mload(s))
808                 for { result := 1 } 1 { result := add(result, 1) } {
809                     o := add(o, byte(0, mload(shr(250, mload(o)))))
810                     if iszero(lt(o, end)) { break }
811                 }
812             }
813         }
814     }



```

```
LibString.unpackTwo(bytes32) (LlamaFactory.sol#1506-1528) is never used and should be removed



    
1506     function unpackTwo(bytes32 packed)
1507         internal
1508         pure
1509         returns (string memory resultA, string memory resultB)
1510     {
1511         /// @solidity memory-safe-assembly
1512         assembly {
1513             // Grab the free memory pointer.
1514             resultA := mload(0x40)
1515             resultB := add(resultA, 0x40)
1516             // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.
1517             mstore(0x40, add(resultB, 0x40))
1518             // Zeroize the length slots.
1519             mstore(resultA, 0)
1520             mstore(resultB, 0)
1521             // Store the lengths and bytes.
1522             mstore(add(resultA, 0x1f), packed)
1523             mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))
1524             // Right pad with zeroes.
1525             mstore(add(add(resultA, 0x20), mload(resultA)), 0)
1526             mstore(add(add(resultB, 0x20), mload(resultB)), 0)
1527         }
1528     }



```

```
LibString.endsWith(string,string) (LlamaFactory.sol#1063-1088) is never used and should be removed



    
1063     function endsWith(string memory subject, string memory search)
1064         internal
1065         pure
1066         returns (bool result)
1067     {
1068         /// @solidity memory-safe-assembly
1069         assembly {
1070             let searchLength := mload(search)
1071             let subjectLength := mload(subject)
1072             // Whether `search` is not longer than `subject`.
1073             let withinRange := iszero(gt(searchLength, subjectLength))
1074             // Just using keccak256 directly is actually cheaper.
1075             // forgefmt: disable-next-item
1076             result := and(
1077                 withinRange,
1078                 eq(
1079                     keccak256(
1080                         // `subject + 0x20 + max(subjectLength - searchLength, 0)`.
1081                         add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),
1082                         searchLength
1083                     ),
1084                     keccak256(add(search, 0x20), searchLength)
1085                 )
1086             )
1087         }
1088     }



```

```
LibString.escapeHTML(string) (LlamaFactory.sol#1355-1386) is never used and should be removed



    
1355     function escapeHTML(string memory s) internal pure returns (string memory result) {
1356         /// @solidity memory-safe-assembly
1357         assembly {
1358             for {
1359                 let end := add(s, mload(s))
1360                 result := add(mload(0x40), 0x20)
1361                 // Store the bytes of the packed offsets and strides into the scratch space.
1362                 // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.
1363                 mstore(0x1f, 0x900094)
1364                 mstore(0x08, 0xc0000000a6ab)
1365                 // Store "&quot;&amp;&#39;&lt;&gt;" into the scratch space.
1366                 mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))
1367             } iszero(eq(s, end)) {} {
1368                 s := add(s, 1)
1369                 let c := and(mload(s), 0xff)
1370                 // Not in `["\"","'","&","<",">"]`.
1371                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
1372                     mstore8(result, c)
1373                     result := add(result, 1)
1374                     continue
1375                 }
1376                 let t := shr(248, mload(c))
1377                 mstore(result, mload(and(t, 0x1f)))
1378                 result := add(result, shr(5, t))
1379             }
1380             let last := result
1381             mstore(last, 0) // Zeroize the slot after the string.
1382             result := mload(0x40)
1383             mstore(result, sub(last, add(result, 0x20))) // Store the length.
1384             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1385         }
1386     }



```

```
LibString.toHexStringChecksummed(address) (LlamaFactory.sol#687-704) is never used and should be removed



    
687     function toHexStringChecksummed(address value) internal pure returns (string memory str) {
688         str = toHexString(value);
689         /// @solidity memory-safe-assembly
690         assembly {
691             let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`
692             let o := add(str, 0x22)
693             let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `
694             let t := shl(240, 136) // `0b10001000 << 240`
695             for { let i := 0 } 1 {} {
696                 mstore(add(i, i), mul(t, byte(i, hashed)))
697                 i := add(i, 1)
698                 if eq(i, 20) { break }
699             }
700             mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))
701             o := add(o, 0x20)
702             mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))
703         }
704     }



```

```
LibString.toHexStringNoPrefix(uint256) (LlamaFactory.sol#647-681) is never used and should be removed



    
647     function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {
648         /// @solidity memory-safe-assembly
649         assembly {
650             // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,
651             // 0x02 bytes for the prefix, and 0x40 bytes for the digits.
652             // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.
653             str := add(mload(0x40), 0x80)
654             // Allocate the memory.
655             mstore(0x40, add(str, 0x20))
656             // Zeroize the slot after the string.
657             mstore(str, 0)
658 
659             // Cache the end to calculate the length later.
660             let end := str
661             // Store "0123456789abcdef" in scratch space.
662             mstore(0x0f, 0x30313233343536373839616263646566)
663 
664             let w := not(1) // Tsk.
665             // We write the string from rightmost digit to leftmost digit.
666             // The following is essentially a do-while loop that also handles the zero case.
667             for { let temp := value } 1 {} {
668                 str := add(str, w) // `sub(str, 2)`.
669                 mstore8(add(str, 1), mload(and(temp, 15)))
670                 mstore8(str, mload(and(shr(4, temp), 15)))
671                 temp := shr(8, temp)
672                 if iszero(temp) { break }
673             }
674 
675             // Compute the string's length.
676             let strLength := sub(end, str)
677             // Move the pointer and write the length.
678             str := sub(str, 0x20)
679             mstore(str, strLength)
680         }
681     }



```

```
Clones.clone(address) (LlamaFactory.sol#28-41) is never used and should be removed



    
28     function clone(address implementation) internal returns (address instance) {
29         /// @solidity memory-safe-assembly
30         assembly {
31             // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
32             // of the `implementation` address with the bytecode before the address.
33             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
34             // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
35             mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
36             instance := create(0, 0x09, 0x37)
37         }
38         if (instance == address(0)) {
39             revert ERC1167FailedCreateClone();
40         }
41     }



```

```
LibString.is7BitASCII(string) (LlamaFactory.sol#818-840) is never used and should be removed



    
818     function is7BitASCII(string memory s) internal pure returns (bool result) {
819         /// @solidity memory-safe-assembly
820         assembly {
821             let mask := shl(7, div(not(0), 255))
822             result := 1
823             let n := mload(s)
824             if n {
825                 let o := add(s, 0x20)
826                 let end := add(o, n)
827                 let last := mload(end)
828                 mstore(end, 0)
829                 for {} 1 {} {
830                     if and(mask, mload(o)) {
831                         result := 0
832                         break
833                     }
834                     o := add(o, 0x20)
835                     if iszero(lt(o, end)) { break }
836                 }
837                 mstore(end, last)
838             }
839         }
840     }



```

```
Initializable._getInitializedVersion() (LlamaFactory.sol#335-337) is never used and should be removed



    
335     function _getInitializedVersion() internal view returns (uint8) {
336         return _initialized;
337     }



```

```
Checkpoints.length(Checkpoints.History) (LlamaFactory.sol#1656-1658) is never used and should be removed



    
1656     function length(History storage self) internal view returns (uint256) {
1657         return self._checkpoints.length;
1658     }



```

```
LibString.slice(string,uint256) (LlamaFactory.sol#1158-1164) is never used and should be removed



    
1158     function slice(string memory subject, uint256 start)
1159         internal
1160         pure
1161         returns (string memory result)
1162     {
1163         result = slice(subject, start, uint256(int256(-1)));
1164     }



```

```
LibString.concat(string,string) (LlamaFactory.sol#1276-1310) is never used and should be removed



    
1276     function concat(string memory a, string memory b)
1277         internal
1278         pure
1279         returns (string memory result)
1280     {
1281         /// @solidity memory-safe-assembly
1282         assembly {
1283             let w := not(0x1f)
1284             result := mload(0x40)
1285             let aLength := mload(a)
1286             // Copy `a` one word at a time, backwards.
1287             for { let o := and(add(aLength, 0x20), w) } 1 {} {
1288                 mstore(add(result, o), mload(add(a, o)))
1289                 o := add(o, w) // `sub(o, 0x20)`.
1290                 if iszero(o) { break }
1291             }
1292             let bLength := mload(b)
1293             let output := add(result, aLength)
1294             // Copy `b` one word at a time, backwards.
1295             for { let o := and(add(bLength, 0x20), w) } 1 {} {
1296                 mstore(add(output, o), mload(add(b, o)))
1297                 o := add(o, w) // `sub(o, 0x20)`.
1298                 if iszero(o) { break }
1299             }
1300             let totalLength := add(aLength, bLength)
1301             let last := add(add(result, 0x20), totalLength)
1302             // Zeroize the slot after the string.
1303             mstore(last, 0)
1304             // Stores the length.
1305             mstore(result, totalLength)
1306             // Allocate memory for the length and the bytes,
1307             // rounded up to a multiple of 32.
1308             mstore(0x40, and(add(last, 0x1f), w))
1309         }
1310     }



```

```
LibString.toHexStringNoPrefix(uint256,uint256) (LlamaFactory.sol#548-596) is never used and should be removed



    
548     function toHexStringNoPrefix(uint256 value, uint256 length)
549         internal
550         pure
551         returns (string memory str)
552     {
553         /// @solidity memory-safe-assembly
554         assembly {
555             // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes
556             // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.
557             // We add 0x20 to the total and round down to a multiple of 0x20.
558             // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.
559             str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))
560             // Allocate the memory.
561             mstore(0x40, add(str, 0x20))
562             // Zeroize the slot after the string.
563             mstore(str, 0)
564 
565             // Cache the end to calculate the length later.
566             let end := str
567             // Store "0123456789abcdef" in scratch space.
568             mstore(0x0f, 0x30313233343536373839616263646566)
569 
570             let start := sub(str, add(length, length))
571             let w := not(1) // Tsk.
572             let temp := value
573             // We write the string from rightmost digit to leftmost digit.
574             // The following is essentially a do-while loop that also handles the zero case.
575             for {} 1 {} {
576                 str := add(str, w) // `sub(str, 2)`.
577                 mstore8(add(str, 1), mload(and(temp, 15)))
578                 mstore8(str, mload(and(shr(4, temp), 15)))
579                 temp := shr(8, temp)
580                 if iszero(xor(str, start)) { break }
581             }
582 
583             if temp {
584                 // Store the function selector of `HexLengthInsufficient()`.
585                 mstore(0x00, 0x2194895a)
586                 // Revert with (offset, size).
587                 revert(0x1c, 0x04)
588             }
589 
590             // Compute the string's length.
591             let strLength := sub(end, str)
592             // Move the pointer and write the length.
593             str := sub(str, 0x20)
594             mstore(str, strLength)
595         }
596     }



```

```
Checkpoints._lowerBinaryLookup(Checkpoints.Checkpoint[],uint64,uint256,uint256) (LlamaFactory.sol#1725-1740) is never used and should be removed



    
1725     function _lowerBinaryLookup(
1726         Checkpoint[] storage self,
1727         uint64 timestamp,
1728         uint256 low,
1729         uint256 high
1730     ) private view returns (uint256) {
1731         while (low < high) {
1732             uint256 mid = average(low, high);
1733             if (_unsafeAccess(self, mid).timestamp < timestamp) {
1734                 low = mid + 1;
1735             } else {
1736                 high = mid;
1737             }
1738         }
1739         return high;
1740     }



```

```
LibString.split(string,string) (LlamaFactory.sol#1227-1272) is never used and should be removed



    
1227     function split(string memory subject, string memory delimiter)
1228         internal
1229         pure
1230         returns (string[] memory result)
1231     {
1232         uint256[] memory indices = indicesOf(subject, delimiter);
1233         /// @solidity memory-safe-assembly
1234         assembly {
1235             let w := not(0x1f)
1236             let indexPtr := add(indices, 0x20)
1237             let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))
1238             mstore(add(indicesEnd, w), mload(subject))
1239             mstore(indices, add(mload(indices), 1))
1240             let prevIndex := 0
1241             for {} 1 {} {
1242                 let index := mload(indexPtr)
1243                 mstore(indexPtr, 0x60)
1244                 if iszero(eq(index, prevIndex)) {
1245                     let element := mload(0x40)
1246                     let elementLength := sub(index, prevIndex)
1247                     mstore(element, elementLength)
1248                     // Copy the `subject` one word at a time, backwards.
1249                     for { let o := and(add(elementLength, 0x1f), w) } 1 {} {
1250                         mstore(add(element, o), mload(add(add(subject, prevIndex), o)))
1251                         o := add(o, w) // `sub(o, 0x20)`.
1252                         if iszero(o) { break }
1253                     }
1254                     // Zeroize the slot after the string.
1255                     mstore(add(add(element, 0x20), elementLength), 0)
1256                     // Allocate memory for the length and the bytes,
1257                     // rounded up to a multiple of 32.
1258                     mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))
1259                     // Store the `element` into the array.
1260                     mstore(indexPtr, element)
1261                 }
1262                 prevIndex := add(index, mload(delimiter))
1263                 indexPtr := add(indexPtr, 0x20)
1264                 if iszero(lt(indexPtr, indicesEnd)) { break }
1265             }
1266             result := indices
1267             if iszero(mload(delimiter)) {
1268                 result := add(indices, 0x20)
1269                 mstore(result, sub(mload(indices), 2))
1270             }
1271         }
1272     }



```

```
LibString.lower(string) (LlamaFactory.sol#1344-1346) is never used and should be removed



    
1344     function lower(string memory subject) internal pure returns (string memory result) {
1345         result = toCase(subject, false);
1346     }



```

```
LibString.packTwo(string,string) (LlamaFactory.sol#1483-1501) is never used and should be removed



    
1483     function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {
1484         /// @solidity memory-safe-assembly
1485         assembly {
1486             let aLength := mload(a)
1487             // We don't need to zero right pad the strings,
1488             // since this is our own custom non-standard packing scheme.
1489             result :=
1490                 mul(
1491                     // Load the length and the bytes of `a` and `b`.
1492                     or(
1493                         shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),
1494                         mload(sub(add(b, 0x1e), aLength))
1495                     ),
1496                     // `totalLength != 0 && totalLength < 31`. Abuses underflow.
1497                     // Assumes that the lengths are valid and within the block gas limit.
1498                     lt(sub(add(aLength, mload(b)), 1), 0x1e)
1499                 )
1500         }
1501     }



```

```
LibString.eq(string,string) (LlamaFactory.sol#1438-1442) is never used and should be removed



    
1438     function eq(string memory a, string memory b) internal pure returns (bool result) {
1439         assembly {
1440             result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))
1441         }
1442     }



```

```
LibString.repeat(string,uint256) (LlamaFactory.sol#1091-1121) is never used and should be removed



    
1091     function repeat(string memory subject, uint256 times)
1092         internal
1093         pure
1094         returns (string memory result)
1095     {
1096         /// @solidity memory-safe-assembly
1097         assembly {
1098             let subjectLength := mload(subject)
1099             if iszero(or(iszero(times), iszero(subjectLength))) {
1100                 subject := add(subject, 0x20)
1101                 result := mload(0x40)
1102                 let output := add(result, 0x20)
1103                 for {} 1 {} {
1104                     // Copy the `subject` one word at a time.
1105                     for { let o := 0 } 1 {} {
1106                         mstore(add(output, o), mload(add(subject, o)))
1107                         o := add(o, 0x20)
1108                         if iszero(lt(o, subjectLength)) { break }
1109                     }
1110                     output := add(output, subjectLength)
1111                     times := sub(times, 1)
1112                     if iszero(times) { break }
1113                 }
1114                 mstore(output, 0) // Zeroize the slot after the string.
1115                 let resultLength := sub(output, add(result, 0x20))
1116                 mstore(result, resultLength) // Store the length.
1117                 // Allocate the memory.
1118                 mstore(0x40, add(result, add(resultLength, 0x20)))
1119             }
1120         }
1121     }



```

### LlamaGovernanceScript.sol


```
LibString.indexOf(string,string) (LlamaGovernanceScript.sol#1009-1015) is never used and should be removed



    
1009     function indexOf(string memory subject, string memory search)
1010         internal
1011         pure
1012         returns (uint256 result)
1013     {
1014         result = indexOf(subject, search, 0);
1015     }



```

```
Initializable._isInitializing() (LlamaGovernanceScript.sol#346-348) is never used and should be removed



    
346     function _isInitializing() internal view returns (bool) {
347         return _initializing;
348     }



```

```
LibString.indexOf(string,string,uint256) (LlamaGovernanceScript.sol#951-1004) is never used and should be removed



    
951     function indexOf(string memory subject, string memory search, uint256 from)
952         internal
953         pure
954         returns (uint256 result)
955     {
956         /// @solidity memory-safe-assembly
957         assembly {
958             for { let subjectLength := mload(subject) } 1 {} {
959                 if iszero(mload(search)) {
960                     if iszero(gt(from, subjectLength)) {
961                         result := from
962                         break
963                     }
964                     result := subjectLength
965                     break
966                 }
967                 let searchLength := mload(search)
968                 let subjectStart := add(subject, 0x20)
969 
970                 result := not(0) // Initialize to `NOT_FOUND`.
971 
972                 subject := add(subjectStart, from)
973                 let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)
974 
975                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
976                 let s := mload(add(search, 0x20))
977 
978                 if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }
979 
980                 if iszero(lt(searchLength, 0x20)) {
981                     for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
982                         if iszero(shr(m, xor(mload(subject), s))) {
983                             if eq(keccak256(subject, searchLength), h) {
984                                 result := sub(subject, subjectStart)
985                                 break
986                             }
987                         }
988                         subject := add(subject, 1)
989                         if iszero(lt(subject, end)) { break }
990                     }
991                     break
992                 }
993                 for {} 1 {} {
994                     if iszero(shr(m, xor(mload(subject), s))) {
995                         result := sub(subject, subjectStart)
996                         break
997                     }
998                     subject := add(subject, 1)
999                     if iszero(lt(subject, end)) { break }
1000                 }
1001                 break
1002             }
1003         }
1004     }



```

```
Clones.predictDeterministicAddress(address,bytes32) (LlamaGovernanceScript.sol#160-165) is never used and should be removed



    
160     function predictDeterministicAddress(
161         address implementation,
162         bytes32 salt
163     ) internal view returns (address predicted) {
164         return predictDeterministicAddress(implementation, salt, address(this));
165     }



```

```
LibString.toHexString(bytes) (LlamaGovernanceScript.sol#782-791) is never used and should be removed



    
782     function toHexString(bytes memory raw) internal pure returns (string memory str) {
783         str = toHexStringNoPrefix(raw);
784         /// @solidity memory-safe-assembly
785         assembly {
786             let strLength := add(mload(str), 2) // Compute the length.
787             mstore(str, 0x3078) // Write the "0x" prefix.
788             str := sub(str, 2) // Move the pointer.
789             mstore(str, strLength) // Write the length.
790         }
791     }



```

```
LibString.toHexString(uint256,uint256) (LlamaGovernanceScript.sol#556-565) is never used and should be removed



    
556     function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {
557         str = toHexStringNoPrefix(value, length);
558         /// @solidity memory-safe-assembly
559         assembly {
560             let strLength := add(mload(str), 2) // Compute the length.
561             mstore(str, 0x3078) // Write the "0x" prefix.
562             str := sub(str, 2) // Move the pointer.
563             mstore(str, strLength) // Write the length.
564         }
565     }



```

```
LibString.escapeJSON(string) (LlamaGovernanceScript.sol#1413-1459) is never used and should be removed



    
1413     function escapeJSON(string memory s) internal pure returns (string memory result) {
1414         /// @solidity memory-safe-assembly
1415         assembly {
1416             for {
1417                 let end := add(s, mload(s))
1418                 result := add(mload(0x40), 0x20)
1419                 // Store "\\u0000" in scratch space.
1420                 // Store "0123456789abcdef" in scratch space.
1421                 // Also, store `{0x08:"b", 0x09:"t", 0x0a:"n", 0x0c:"f", 0x0d:"r"}`.
1422                 // into the scratch space.
1423                 mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)
1424                 // Bitmask for detecting `["\"","\\"]`.
1425                 let e := or(shl(0x22, 1), shl(0x5c, 1))
1426             } iszero(eq(s, end)) {} {
1427                 s := add(s, 1)
1428                 let c := and(mload(s), 0xff)
1429                 if iszero(lt(c, 0x20)) {
1430                     if iszero(and(shl(c, 1), e)) {
1431                         // Not in `["\"","\\"]`.
1432                         mstore8(result, c)
1433                         result := add(result, 1)
1434                         continue
1435                     }
1436                     mstore8(result, 0x5c) // "\\".
1437                     mstore8(add(result, 1), c)
1438                     result := add(result, 2)
1439                     continue
1440                 }
1441                 if iszero(and(shl(c, 1), 0x3700)) {
1442                     // Not in `["\b","\t","\n","\f","\d"]`.
1443                     mstore8(0x1d, mload(shr(4, c))) // Hex value.
1444                     mstore8(0x1e, mload(and(c, 15))) // Hex value.
1445                     mstore(result, mload(0x19)) // "\\u00XX".
1446                     result := add(result, 6)
1447                     continue
1448                 }
1449                 mstore8(result, 0x5c) // "\\".
1450                 mstore8(add(result, 1), mload(add(c, 8)))
1451                 result := add(result, 2)
1452             }
1453             let last := result
1454             mstore(last, 0) // Zeroize the slot after the string.
1455             result := mload(0x40)
1456             mstore(result, sub(last, add(result, 0x20))) // Store the length.
1457             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1458         }
1459     }



```

```
LibString.toHexStringNoPrefix(bytes) (LlamaGovernanceScript.sol#795-817) is never used and should be removed



    
795     function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {
796         /// @solidity memory-safe-assembly
797         assembly {
798             let length := mload(raw)
799             str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.
800             mstore(str, add(length, length)) // Store the length of the output.
801 
802             // Store "0123456789abcdef" in scratch space.
803             mstore(0x0f, 0x30313233343536373839616263646566)
804 
805             let o := add(str, 0x20)
806             let end := add(raw, length)
807 
808             for {} iszero(eq(raw, end)) {} {
809                 raw := add(raw, 1)
810                 mstore8(add(o, 1), mload(and(mload(raw), 15)))
811                 mstore8(o, mload(and(shr(4, mload(raw)), 15)))
812                 o := add(o, 2)
813             }
814             mstore(o, 0) // Zeroize the slot after the string.
815             mstore(0x40, add(o, 0x20)) // Allocate the memory.
816         }
817     }



```

```
LibString.lastIndexOf(string,string) (LlamaGovernanceScript.sol#1057-1063) is never used and should be removed



    
1057     function lastIndexOf(string memory subject, string memory search)
1058         internal
1059         pure
1060         returns (uint256 result)
1061     {
1062         result = lastIndexOf(subject, search, uint256(int256(-1)));
1063     }



```

```
LibString.startsWith(string,string) (LlamaGovernanceScript.sol#1066-1084) is never used and should be removed



    
1066     function startsWith(string memory subject, string memory search)
1067         internal
1068         pure
1069         returns (bool result)
1070     {
1071         /// @solidity memory-safe-assembly
1072         assembly {
1073             let searchLength := mload(search)
1074             // Just using keccak256 directly is actually cheaper.
1075             // forgefmt: disable-next-item
1076             result := and(
1077                 iszero(gt(searchLength, mload(subject))),
1078                 eq(
1079                     keccak256(add(subject, 0x20), searchLength),
1080                     keccak256(add(search, 0x20), searchLength)
1081                 )
1082             )
1083         }
1084     }



```

```
LibString.lastIndexOf(string,string,uint256) (LlamaGovernanceScript.sol#1020-1052) is never used and should be removed



    
1020     function lastIndexOf(string memory subject, string memory search, uint256 from)
1021         internal
1022         pure
1023         returns (uint256 result)
1024     {
1025         /// @solidity memory-safe-assembly
1026         assembly {
1027             for {} 1 {} {
1028                 result := not(0) // Initialize to `NOT_FOUND`.
1029                 let searchLength := mload(search)
1030                 if gt(searchLength, mload(subject)) { break }
1031                 let w := result
1032 
1033                 let fromMax := sub(mload(subject), searchLength)
1034                 if iszero(gt(fromMax, from)) { from := fromMax }
1035 
1036                 let end := add(add(subject, 0x20), w)
1037                 subject := add(add(subject, 0x20), from)
1038                 if iszero(gt(subject, end)) { break }
1039                 // As this function is not too often used,
1040                 // we shall simply use keccak256 for smaller bytecode size.
1041                 for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
1042                     if eq(keccak256(subject, searchLength), h) {
1043                         result := sub(subject, add(end, 1))
1044                         break
1045                     }
1046                     subject := add(subject, w) // `sub(subject, 1)`.
1047                     if iszero(gt(subject, end)) { break }
1048                 }
1049                 break
1050             }
1051         }
1052     }



```

```
LibString.toString(int256) (LlamaGovernanceScript.sol#529-545) is never used and should be removed



    
529     function toString(int256 value) internal pure returns (string memory str) {
530         if (value >= 0) {
531             return toString(uint256(value));
532         }
533         unchecked {
534             str = toString(uint256(-value));
535         }
536         /// @solidity memory-safe-assembly
537         assembly {
538             // We still have some spare memory space on the left,
539             // as we have allocated 3 words (96 bytes) for up to 78 digits.
540             let length := mload(str) // Load the string length.
541             mstore(str, 0x2d) // Store the '-' character.
542             str := sub(str, 1) // Move back the string pointer by a byte.
543             mstore(str, add(length, 1)) // Update the string length.
544         }
545     }



```

```
Clones.predictDeterministicAddress(address,bytes32,address) (LlamaGovernanceScript.sol#139-155) is never used and should be removed



    
139     function predictDeterministicAddress(
140         address implementation,
141         bytes32 salt,
142         address deployer
143     ) internal pure returns (address predicted) {
144         /// @solidity memory-safe-assembly
145         assembly {
146             let ptr := mload(0x40)
147             mstore(add(ptr, 0x38), deployer)
148             mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)
149             mstore(add(ptr, 0x14), implementation)
150             mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)
151             mstore(add(ptr, 0x58), salt)
152             mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))
153             predicted := keccak256(add(ptr, 0x43), 0x55)
154         }
155     }



```

```
LibString.directReturn(string) (LlamaGovernanceScript.sol#1555-1568) is never used and should be removed



    
1555     function directReturn(string memory a) internal pure {
1556         assembly {
1557             // Assumes that the string does not start from the scratch space.
1558             let retStart := sub(a, 0x20)
1559             let retSize := add(mload(a), 0x40)
1560             // Right pad with zeroes. Just in case the string is produced
1561             // by a method that doesn't zero right pad.
1562             mstore(add(retStart, retSize), 0)
1563             // Store the return offset.
1564             mstore(retStart, 0x20)
1565             // End the transaction, returning the string.
1566             return(retStart, retSize)
1567         }
1568     }



```

```
LibString.toMinimalHexStringNoPrefix(uint256) (LlamaGovernanceScript.sol#656-665) is never used and should be removed



    
656     function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {
657         str = toHexStringNoPrefix(value);
658         /// @solidity memory-safe-assembly
659         assembly {
660             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
661             let strLength := mload(str) // Get the length.
662             str := add(str, o) // Move the pointer, accounting for leading zero.
663             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
664         }
665     }



```

```
LibString.toMinimalHexString(uint256) (LlamaGovernanceScript.sol#641-651) is never used and should be removed



    
641     function toMinimalHexString(uint256 value) internal pure returns (string memory str) {
642         str = toHexStringNoPrefix(value);
643         /// @solidity memory-safe-assembly
644         assembly {
645             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
646             let strLength := add(mload(str), 2) // Compute the length.
647             mstore(add(str, o), 0x3078) // Write the "0x" prefix, accounting for leading zero.
648             str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.
649             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
650         }
651     }



```

```
LibString.toHexString(uint256) (LlamaGovernanceScript.sol#626-635) is never used and should be removed



    
626     function toHexString(uint256 value) internal pure returns (string memory str) {
627         str = toHexStringNoPrefix(value);
628         /// @solidity memory-safe-assembly
629         assembly {
630             let strLength := add(mload(str), 2) // Compute the length.
631             mstore(str, 0x3078) // Write the "0x" prefix.
632             str := sub(str, 2) // Move the pointer.
633             mstore(str, strLength) // Write the length.
634         }
635     }



```

```
ERC721NonTransferableMinimalProxy._safeMint(address,uint256,bytes) (LlamaGovernanceScript.sol#2023-2032) is never used and should be removed



    
2023   function _safeMint(address to, uint256 id, bytes memory data) internal virtual {
2024     _mint(to, id);
2025 
2026     require(
2027       to.code.length == 0
2028         || ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data)
2029           == ERC721TokenReceiver.onERC721Received.selector,
2030       "UNSAFE_RECIPIENT"
2031     );
2032   }



```

```
LibString.indicesOf(string,string) (LlamaGovernanceScript.sol#1192-1248) is never used and should be removed



    
1192     function indicesOf(string memory subject, string memory search)
1193         internal
1194         pure
1195         returns (uint256[] memory result)
1196     {
1197         /// @solidity memory-safe-assembly
1198         assembly {
1199             let subjectLength := mload(subject)
1200             let searchLength := mload(search)
1201 
1202             if iszero(gt(searchLength, subjectLength)) {
1203                 subject := add(subject, 0x20)
1204                 search := add(search, 0x20)
1205                 result := add(mload(0x40), 0x20)
1206 
1207                 let subjectStart := subject
1208                 let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)
1209                 let h := 0
1210                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
1211                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
1212                 let s := mload(search)
1213                 for {} 1 {} {
1214                     let t := mload(subject)
1215                     // Whether the first `searchLength % 32` bytes of
1216                     // `subject` and `search` matches.
1217                     if iszero(shr(m, xor(t, s))) {
1218                         if h {
1219                             if iszero(eq(keccak256(subject, searchLength), h)) {
1220                                 subject := add(subject, 1)
1221                                 if iszero(lt(subject, subjectSearchEnd)) { break }
1222                                 continue
1223                             }
1224                         }
1225                         // Append to `result`.
1226                         mstore(result, sub(subject, subjectStart))
1227                         result := add(result, 0x20)
1228                         // Advance `subject` by `searchLength`.
1229                         subject := add(subject, searchLength)
1230                         if searchLength {
1231                             if iszero(lt(subject, subjectSearchEnd)) { break }
1232                             continue
1233                         }
1234                     }
1235                     subject := add(subject, 1)
1236                     if iszero(lt(subject, subjectSearchEnd)) { break }
1237                 }
1238                 let resultEnd := result
1239                 // Assign `result` to the free memory pointer.
1240                 result := mload(0x40)
1241                 // Store the length of `result`.
1242                 mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))
1243                 // Allocate memory for result.
1244                 // We allocate one more word, so this array can be recycled for {split}.
1245                 mstore(0x40, add(resultEnd, 0x20))
1246             }
1247         }
1248     }



```

```
Initializable._checkInitializing() (LlamaGovernanceScript.sol#312-316) is never used and should be removed



    
312     function _checkInitializing() internal view virtual {
313         if (!_initializing) {
314             revert NotInitializing();
315         }
316     }



```

```
LibString.unpackOne(bytes32) (LlamaGovernanceScript.sol#1489-1503) is never used and should be removed



    
1489     function unpackOne(bytes32 packed) internal pure returns (string memory result) {
1490         /// @solidity memory-safe-assembly
1491         assembly {
1492             // Grab the free memory pointer.
1493             result := mload(0x40)
1494             // Allocate 2 words (1 for the length, 1 for the bytes).
1495             mstore(0x40, add(result, 0x40))
1496             // Zeroize the length slot.
1497             mstore(result, 0)
1498             // Store the length and bytes.
1499             mstore(add(result, 0x1f), packed)
1500             // Right pad with zeroes.
1501             mstore(add(add(result, 0x20), mload(result)), 0)
1502         }
1503     }



```

```
LibString.toString(uint256) (LlamaGovernanceScript.sol#491-526) is never used and should be removed



    
491     function toString(uint256 value) internal pure returns (string memory str) {
492         /// @solidity memory-safe-assembly
493         assembly {
494             // The maximum value of a uint256 contains 78 digits (1 byte per digit), but
495             // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.
496             // We will need 1 word for the trailing zeros padding, 1 word for the length,
497             // and 3 words for a maximum of 78 digits.
498             str := add(mload(0x40), 0x80)
499             // Update the free memory pointer to allocate.
500             mstore(0x40, add(str, 0x20))
501             // Zeroize the slot after the string.
502             mstore(str, 0)
503 
504             // Cache the end of the memory to calculate the length later.
505             let end := str
506 
507             let w := not(0) // Tsk.
508             // We write the string from rightmost digit to leftmost digit.
509             // The following is essentially a do-while loop that also handles the zero case.
510             for { let temp := value } 1 {} {
511                 str := add(str, w) // `sub(str, 1)`.
512                 // Write the character to the pointer.
513                 // The ASCII index of the '0' character is 48.
514                 mstore8(str, add(48, mod(temp, 10)))
515                 // Keep dividing `temp` until zero.
516                 temp := div(temp, 10)
517                 if iszero(temp) { break }
518             }
519 
520             let length := sub(end, str)
521             // Move the pointer 32 bytes leftwards to make room for the length.
522             str := sub(str, 0x20)
523             // Store the length.
524             mstore(str, length)
525         }
526     }



```

```
ERC721NonTransferableMinimalProxy._safeMint(address,uint256) (LlamaGovernanceScript.sol#2012-2021) is never used and should be removed



    
2012   function _safeMint(address to, uint256 id) internal virtual {
2013     _mint(to, id);
2014 
2015     require(
2016       to.code.length == 0
2017         || ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "")
2018           == ERC721TokenReceiver.onERC721Received.selector,
2019       "UNSAFE_RECIPIENT"
2020     );
2021   }



```

```
LibString.packOne(string) (LlamaGovernanceScript.sol#1470-1484) is never used and should be removed



    
1470     function packOne(string memory a) internal pure returns (bytes32 result) {
1471         /// @solidity memory-safe-assembly
1472         assembly {
1473             // We don't need to zero right pad the string,
1474             // since this is our own custom non-standard packing scheme.
1475             result :=
1476                 mul(
1477                     // Load the length and the bytes.
1478                     mload(add(a, 0x1f)),
1479                     // `length != 0 && length < 32`. Abuses underflow.
1480                     // Assumes that the length is valid and within the block gas limit.
1481                     lt(sub(mload(a), 1), 0x1f)
1482                 )
1483         }
1484     }



```

```
LibString.runeCount(string) (LlamaGovernanceScript.sol#824-838) is never used and should be removed



    
824     function runeCount(string memory s) internal pure returns (uint256 result) {
825         /// @solidity memory-safe-assembly
826         assembly {
827             if mload(s) {
828                 mstore(0x00, div(not(0), 255))
829                 mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)
830                 let o := add(s, 0x20)
831                 let end := add(o, mload(s))
832                 for { result := 1 } 1 { result := add(result, 1) } {
833                     o := add(o, byte(0, mload(shr(250, mload(o)))))
834                     if iszero(lt(o, end)) { break }
835                 }
836             }
837         }
838     }



```

```
LibString.unpackTwo(bytes32) (LlamaGovernanceScript.sol#1530-1552) is never used and should be removed



    
1530     function unpackTwo(bytes32 packed)
1531         internal
1532         pure
1533         returns (string memory resultA, string memory resultB)
1534     {
1535         /// @solidity memory-safe-assembly
1536         assembly {
1537             // Grab the free memory pointer.
1538             resultA := mload(0x40)
1539             resultB := add(resultA, 0x40)
1540             // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.
1541             mstore(0x40, add(resultB, 0x40))
1542             // Zeroize the length slots.
1543             mstore(resultA, 0)
1544             mstore(resultB, 0)
1545             // Store the lengths and bytes.
1546             mstore(add(resultA, 0x1f), packed)
1547             mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))
1548             // Right pad with zeroes.
1549             mstore(add(add(resultA, 0x20), mload(resultA)), 0)
1550             mstore(add(add(resultB, 0x20), mload(resultB)), 0)
1551         }
1552     }



```

```
LibString.endsWith(string,string) (LlamaGovernanceScript.sol#1087-1112) is never used and should be removed



    
1087     function endsWith(string memory subject, string memory search)
1088         internal
1089         pure
1090         returns (bool result)
1091     {
1092         /// @solidity memory-safe-assembly
1093         assembly {
1094             let searchLength := mload(search)
1095             let subjectLength := mload(subject)
1096             // Whether `search` is not longer than `subject`.
1097             let withinRange := iszero(gt(searchLength, subjectLength))
1098             // Just using keccak256 directly is actually cheaper.
1099             // forgefmt: disable-next-item
1100             result := and(
1101                 withinRange,
1102                 eq(
1103                     keccak256(
1104                         // `subject + 0x20 + max(subjectLength - searchLength, 0)`.
1105                         add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),
1106                         searchLength
1107                     ),
1108                     keccak256(add(search, 0x20), searchLength)
1109                 )
1110             )
1111         }
1112     }



```

```
LibString.escapeHTML(string) (LlamaGovernanceScript.sol#1379-1410) is never used and should be removed



    
1379     function escapeHTML(string memory s) internal pure returns (string memory result) {
1380         /// @solidity memory-safe-assembly
1381         assembly {
1382             for {
1383                 let end := add(s, mload(s))
1384                 result := add(mload(0x40), 0x20)
1385                 // Store the bytes of the packed offsets and strides into the scratch space.
1386                 // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.
1387                 mstore(0x1f, 0x900094)
1388                 mstore(0x08, 0xc0000000a6ab)
1389                 // Store "&quot;&amp;&#39;&lt;&gt;" into the scratch space.
1390                 mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))
1391             } iszero(eq(s, end)) {} {
1392                 s := add(s, 1)
1393                 let c := and(mload(s), 0xff)
1394                 // Not in `["\"","'","&","<",">"]`.
1395                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
1396                     mstore8(result, c)
1397                     result := add(result, 1)
1398                     continue
1399                 }
1400                 let t := shr(248, mload(c))
1401                 mstore(result, mload(and(t, 0x1f)))
1402                 result := add(result, shr(5, t))
1403             }
1404             let last := result
1405             mstore(last, 0) // Zeroize the slot after the string.
1406             result := mload(0x40)
1407             mstore(result, sub(last, add(result, 0x20))) // Store the length.
1408             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1409         }
1410     }



```

```
LibString.toHexStringChecksummed(address) (LlamaGovernanceScript.sol#711-728) is never used and should be removed



    
711     function toHexStringChecksummed(address value) internal pure returns (string memory str) {
712         str = toHexString(value);
713         /// @solidity memory-safe-assembly
714         assembly {
715             let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`
716             let o := add(str, 0x22)
717             let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `
718             let t := shl(240, 136) // `0b10001000 << 240`
719             for { let i := 0 } 1 {} {
720                 mstore(add(i, i), mul(t, byte(i, hashed)))
721                 i := add(i, 1)
722                 if eq(i, 20) { break }
723             }
724             mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))
725             o := add(o, 0x20)
726             mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))
727         }
728     }



```

```
LibString.toHexStringNoPrefix(uint256) (LlamaGovernanceScript.sol#671-705) is never used and should be removed



    
671     function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {
672         /// @solidity memory-safe-assembly
673         assembly {
674             // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,
675             // 0x02 bytes for the prefix, and 0x40 bytes for the digits.
676             // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.
677             str := add(mload(0x40), 0x80)
678             // Allocate the memory.
679             mstore(0x40, add(str, 0x20))
680             // Zeroize the slot after the string.
681             mstore(str, 0)
682 
683             // Cache the end to calculate the length later.
684             let end := str
685             // Store "0123456789abcdef" in scratch space.
686             mstore(0x0f, 0x30313233343536373839616263646566)
687 
688             let w := not(1) // Tsk.
689             // We write the string from rightmost digit to leftmost digit.
690             // The following is essentially a do-while loop that also handles the zero case.
691             for { let temp := value } 1 {} {
692                 str := add(str, w) // `sub(str, 2)`.
693                 mstore8(add(str, 1), mload(and(temp, 15)))
694                 mstore8(str, mload(and(shr(4, temp), 15)))
695                 temp := shr(8, temp)
696                 if iszero(temp) { break }
697             }
698 
699             // Compute the string's length.
700             let strLength := sub(end, str)
701             // Move the pointer and write the length.
702             str := sub(str, 0x20)
703             mstore(str, strLength)
704         }
705     }



```

```
Clones.clone(address) (LlamaGovernanceScript.sol#99-112) is never used and should be removed



    
99     function clone(address implementation) internal returns (address instance) {
100         /// @solidity memory-safe-assembly
101         assembly {
102             // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
103             // of the `implementation` address with the bytecode before the address.
104             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
105             // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
106             mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
107             instance := create(0, 0x09, 0x37)
108         }
109         if (instance == address(0)) {
110             revert ERC1167FailedCreateClone();
111         }
112     }



```

```
LibString.is7BitASCII(string) (LlamaGovernanceScript.sol#842-864) is never used and should be removed



    
842     function is7BitASCII(string memory s) internal pure returns (bool result) {
843         /// @solidity memory-safe-assembly
844         assembly {
845             let mask := shl(7, div(not(0), 255))
846             result := 1
847             let n := mload(s)
848             if n {
849                 let o := add(s, 0x20)
850                 let end := add(o, n)
851                 let last := mload(end)
852                 mstore(end, 0)
853                 for {} 1 {} {
854                     if and(mask, mload(o)) {
855                         result := 0
856                         break
857                     }
858                     o := add(o, 0x20)
859                     if iszero(lt(o, end)) { break }
860                 }
861                 mstore(end, last)
862             }
863         }
864     }



```

```
Initializable._getInitializedVersion() (LlamaGovernanceScript.sol#339-341) is never used and should be removed



    
339     function _getInitializedVersion() internal view returns (uint8) {
340         return _initialized;
341     }



```

```
Checkpoints.length(Checkpoints.History) (LlamaGovernanceScript.sol#1680-1682) is never used and should be removed



    
1680     function length(History storage self) internal view returns (uint256) {
1681         return self._checkpoints.length;
1682     }



```

```
LibString.slice(string,uint256) (LlamaGovernanceScript.sol#1182-1188) is never used and should be removed



    
1182     function slice(string memory subject, uint256 start)
1183         internal
1184         pure
1185         returns (string memory result)
1186     {
1187         result = slice(subject, start, uint256(int256(-1)));
1188     }



```

```
LibString.concat(string,string) (LlamaGovernanceScript.sol#1300-1334) is never used and should be removed



    
1300     function concat(string memory a, string memory b)
1301         internal
1302         pure
1303         returns (string memory result)
1304     {
1305         /// @solidity memory-safe-assembly
1306         assembly {
1307             let w := not(0x1f)
1308             result := mload(0x40)
1309             let aLength := mload(a)
1310             // Copy `a` one word at a time, backwards.
1311             for { let o := and(add(aLength, 0x20), w) } 1 {} {
1312                 mstore(add(result, o), mload(add(a, o)))
1313                 o := add(o, w) // `sub(o, 0x20)`.
1314                 if iszero(o) { break }
1315             }
1316             let bLength := mload(b)
1317             let output := add(result, aLength)
1318             // Copy `b` one word at a time, backwards.
1319             for { let o := and(add(bLength, 0x20), w) } 1 {} {
1320                 mstore(add(output, o), mload(add(b, o)))
1321                 o := add(o, w) // `sub(o, 0x20)`.
1322                 if iszero(o) { break }
1323             }
1324             let totalLength := add(aLength, bLength)
1325             let last := add(add(result, 0x20), totalLength)
1326             // Zeroize the slot after the string.
1327             mstore(last, 0)
1328             // Stores the length.
1329             mstore(result, totalLength)
1330             // Allocate memory for the length and the bytes,
1331             // rounded up to a multiple of 32.
1332             mstore(0x40, and(add(last, 0x1f), w))
1333         }
1334     }



```

```
LibString.toHexStringNoPrefix(uint256,uint256) (LlamaGovernanceScript.sol#572-620) is never used and should be removed



    
572     function toHexStringNoPrefix(uint256 value, uint256 length)
573         internal
574         pure
575         returns (string memory str)
576     {
577         /// @solidity memory-safe-assembly
578         assembly {
579             // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes
580             // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.
581             // We add 0x20 to the total and round down to a multiple of 0x20.
582             // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.
583             str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))
584             // Allocate the memory.
585             mstore(0x40, add(str, 0x20))
586             // Zeroize the slot after the string.
587             mstore(str, 0)
588 
589             // Cache the end to calculate the length later.
590             let end := str
591             // Store "0123456789abcdef" in scratch space.
592             mstore(0x0f, 0x30313233343536373839616263646566)
593 
594             let start := sub(str, add(length, length))
595             let w := not(1) // Tsk.
596             let temp := value
597             // We write the string from rightmost digit to leftmost digit.
598             // The following is essentially a do-while loop that also handles the zero case.
599             for {} 1 {} {
600                 str := add(str, w) // `sub(str, 2)`.
601                 mstore8(add(str, 1), mload(and(temp, 15)))
602                 mstore8(str, mload(and(shr(4, temp), 15)))
603                 temp := shr(8, temp)
604                 if iszero(xor(str, start)) { break }
605             }
606 
607             if temp {
608                 // Store the function selector of `HexLengthInsufficient()`.
609                 mstore(0x00, 0x2194895a)
610                 // Revert with (offset, size).
611                 revert(0x1c, 0x04)
612             }
613 
614             // Compute the string's length.
615             let strLength := sub(end, str)
616             // Move the pointer and write the length.
617             str := sub(str, 0x20)
618             mstore(str, strLength)
619         }
620     }



```

```
Checkpoints._lowerBinaryLookup(Checkpoints.Checkpoint[],uint64,uint256,uint256) (LlamaGovernanceScript.sol#1749-1764) is never used and should be removed



    
1749     function _lowerBinaryLookup(
1750         Checkpoint[] storage self,
1751         uint64 timestamp,
1752         uint256 low,
1753         uint256 high
1754     ) private view returns (uint256) {
1755         while (low < high) {
1756             uint256 mid = average(low, high);
1757             if (_unsafeAccess(self, mid).timestamp < timestamp) {
1758                 low = mid + 1;
1759             } else {
1760                 high = mid;
1761             }
1762         }
1763         return high;
1764     }



```

```
LibString.split(string,string) (LlamaGovernanceScript.sol#1251-1296) is never used and should be removed



    
1251     function split(string memory subject, string memory delimiter)
1252         internal
1253         pure
1254         returns (string[] memory result)
1255     {
1256         uint256[] memory indices = indicesOf(subject, delimiter);
1257         /// @solidity memory-safe-assembly
1258         assembly {
1259             let w := not(0x1f)
1260             let indexPtr := add(indices, 0x20)
1261             let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))
1262             mstore(add(indicesEnd, w), mload(subject))
1263             mstore(indices, add(mload(indices), 1))
1264             let prevIndex := 0
1265             for {} 1 {} {
1266                 let index := mload(indexPtr)
1267                 mstore(indexPtr, 0x60)
1268                 if iszero(eq(index, prevIndex)) {
1269                     let element := mload(0x40)
1270                     let elementLength := sub(index, prevIndex)
1271                     mstore(element, elementLength)
1272                     // Copy the `subject` one word at a time, backwards.
1273                     for { let o := and(add(elementLength, 0x1f), w) } 1 {} {
1274                         mstore(add(element, o), mload(add(add(subject, prevIndex), o)))
1275                         o := add(o, w) // `sub(o, 0x20)`.
1276                         if iszero(o) { break }
1277                     }
1278                     // Zeroize the slot after the string.
1279                     mstore(add(add(element, 0x20), elementLength), 0)
1280                     // Allocate memory for the length and the bytes,
1281                     // rounded up to a multiple of 32.
1282                     mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))
1283                     // Store the `element` into the array.
1284                     mstore(indexPtr, element)
1285                 }
1286                 prevIndex := add(index, mload(delimiter))
1287                 indexPtr := add(indexPtr, 0x20)
1288                 if iszero(lt(indexPtr, indicesEnd)) { break }
1289             }
1290             result := indices
1291             if iszero(mload(delimiter)) {
1292                 result := add(indices, 0x20)
1293                 mstore(result, sub(mload(indices), 2))
1294             }
1295         }
1296     }



```

```
LibString.lower(string) (LlamaGovernanceScript.sol#1368-1370) is never used and should be removed



    
1368     function lower(string memory subject) internal pure returns (string memory result) {
1369         result = toCase(subject, false);
1370     }



```

```
LibString.packTwo(string,string) (LlamaGovernanceScript.sol#1507-1525) is never used and should be removed



    
1507     function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {
1508         /// @solidity memory-safe-assembly
1509         assembly {
1510             let aLength := mload(a)
1511             // We don't need to zero right pad the strings,
1512             // since this is our own custom non-standard packing scheme.
1513             result :=
1514                 mul(
1515                     // Load the length and the bytes of `a` and `b`.
1516                     or(
1517                         shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),
1518                         mload(sub(add(b, 0x1e), aLength))
1519                     ),
1520                     // `totalLength != 0 && totalLength < 31`. Abuses underflow.
1521                     // Assumes that the lengths are valid and within the block gas limit.
1522                     lt(sub(add(aLength, mload(b)), 1), 0x1e)
1523                 )
1524         }
1525     }



```

```
LibString.eq(string,string) (LlamaGovernanceScript.sol#1462-1466) is never used and should be removed



    
1462     function eq(string memory a, string memory b) internal pure returns (bool result) {
1463         assembly {
1464             result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))
1465         }
1466     }



```

```
LibString.repeat(string,uint256) (LlamaGovernanceScript.sol#1115-1145) is never used and should be removed



    
1115     function repeat(string memory subject, uint256 times)
1116         internal
1117         pure
1118         returns (string memory result)
1119     {
1120         /// @solidity memory-safe-assembly
1121         assembly {
1122             let subjectLength := mload(subject)
1123             if iszero(or(iszero(times), iszero(subjectLength))) {
1124                 subject := add(subject, 0x20)
1125                 result := mload(0x40)
1126                 let output := add(result, 0x20)
1127                 for {} 1 {} {
1128                     // Copy the `subject` one word at a time.
1129                     for { let o := 0 } 1 {} {
1130                         mstore(add(output, o), mload(add(subject, o)))
1131                         o := add(o, 0x20)
1132                         if iszero(lt(o, subjectLength)) { break }
1133                     }
1134                     output := add(output, subjectLength)
1135                     times := sub(times, 1)
1136                     if iszero(times) { break }
1137                 }
1138                 mstore(output, 0) // Zeroize the slot after the string.
1139                 let resultLength := sub(output, add(result, 0x20))
1140                 mstore(result, resultLength) // Store the length.
1141                 // Allocate the memory.
1142                 mstore(0x40, add(result, add(resultLength, 0x20)))
1143             }
1144         }
1145     }



```

### LlamaPolicy.sol


```
LibString.indexOf(string,string) (LlamaPolicy.sol#545-551) is never used and should be removed



    
545     function indexOf(string memory subject, string memory search)
546         internal
547         pure
548         returns (uint256 result)
549     {
550         result = indexOf(subject, search, 0);
551     }



```

```
Initializable._isInitializing() (LlamaPolicy.sol#1595-1597) is never used and should be removed



    
1595     function _isInitializing() internal view returns (bool) {
1596         return _initializing;
1597     }



```

```
LibString.indexOf(string,string,uint256) (LlamaPolicy.sol#487-540) is never used and should be removed



    
487     function indexOf(string memory subject, string memory search, uint256 from)
488         internal
489         pure
490         returns (uint256 result)
491     {
492         /// @solidity memory-safe-assembly
493         assembly {
494             for { let subjectLength := mload(subject) } 1 {} {
495                 if iszero(mload(search)) {
496                     if iszero(gt(from, subjectLength)) {
497                         result := from
498                         break
499                     }
500                     result := subjectLength
501                     break
502                 }
503                 let searchLength := mload(search)
504                 let subjectStart := add(subject, 0x20)
505 
506                 result := not(0) // Initialize to `NOT_FOUND`.
507 
508                 subject := add(subjectStart, from)
509                 let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)
510 
511                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
512                 let s := mload(add(search, 0x20))
513 
514                 if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }
515 
516                 if iszero(lt(searchLength, 0x20)) {
517                     for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
518                         if iszero(shr(m, xor(mload(subject), s))) {
519                             if eq(keccak256(subject, searchLength), h) {
520                                 result := sub(subject, subjectStart)
521                                 break
522                             }
523                         }
524                         subject := add(subject, 1)
525                         if iszero(lt(subject, end)) { break }
526                     }
527                     break
528                 }
529                 for {} 1 {} {
530                     if iszero(shr(m, xor(mload(subject), s))) {
531                         result := sub(subject, subjectStart)
532                         break
533                     }
534                     subject := add(subject, 1)
535                     if iszero(lt(subject, end)) { break }
536                 }
537                 break
538             }
539         }
540     }



```

```
Clones.predictDeterministicAddress(address,bytes32) (LlamaPolicy.sol#1872-1877) is never used and should be removed



    
1872     function predictDeterministicAddress(
1873         address implementation,
1874         bytes32 salt
1875     ) internal view returns (address predicted) {
1876         return predictDeterministicAddress(implementation, salt, address(this));
1877     }



```

```
LibString.toHexString(bytes) (LlamaPolicy.sol#318-327) is never used and should be removed



    
318     function toHexString(bytes memory raw) internal pure returns (string memory str) {
319         str = toHexStringNoPrefix(raw);
320         /// @solidity memory-safe-assembly
321         assembly {
322             let strLength := add(mload(str), 2) // Compute the length.
323             mstore(str, 0x3078) // Write the "0x" prefix.
324             str := sub(str, 2) // Move the pointer.
325             mstore(str, strLength) // Write the length.
326         }
327     }



```

```
LibString.toHexString(uint256,uint256) (LlamaPolicy.sol#92-101) is never used and should be removed



    
92     function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {
93         str = toHexStringNoPrefix(value, length);
94         /// @solidity memory-safe-assembly
95         assembly {
96             let strLength := add(mload(str), 2) // Compute the length.
97             mstore(str, 0x3078) // Write the "0x" prefix.
98             str := sub(str, 2) // Move the pointer.
99             mstore(str, strLength) // Write the length.
100         }
101     }



```

```
LibString.escapeJSON(string) (LlamaPolicy.sol#949-995) is never used and should be removed



    
949     function escapeJSON(string memory s) internal pure returns (string memory result) {
950         /// @solidity memory-safe-assembly
951         assembly {
952             for {
953                 let end := add(s, mload(s))
954                 result := add(mload(0x40), 0x20)
955                 // Store "\\u0000" in scratch space.
956                 // Store "0123456789abcdef" in scratch space.
957                 // Also, store `{0x08:"b", 0x09:"t", 0x0a:"n", 0x0c:"f", 0x0d:"r"}`.
958                 // into the scratch space.
959                 mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)
960                 // Bitmask for detecting `["\"","\\"]`.
961                 let e := or(shl(0x22, 1), shl(0x5c, 1))
962             } iszero(eq(s, end)) {} {
963                 s := add(s, 1)
964                 let c := and(mload(s), 0xff)
965                 if iszero(lt(c, 0x20)) {
966                     if iszero(and(shl(c, 1), e)) {
967                         // Not in `["\"","\\"]`.
968                         mstore8(result, c)
969                         result := add(result, 1)
970                         continue
971                     }
972                     mstore8(result, 0x5c) // "\\".
973                     mstore8(add(result, 1), c)
974                     result := add(result, 2)
975                     continue
976                 }
977                 if iszero(and(shl(c, 1), 0x3700)) {
978                     // Not in `["\b","\t","\n","\f","\d"]`.
979                     mstore8(0x1d, mload(shr(4, c))) // Hex value.
980                     mstore8(0x1e, mload(and(c, 15))) // Hex value.
981                     mstore(result, mload(0x19)) // "\\u00XX".
982                     result := add(result, 6)
983                     continue
984                 }
985                 mstore8(result, 0x5c) // "\\".
986                 mstore8(add(result, 1), mload(add(c, 8)))
987                 result := add(result, 2)
988             }
989             let last := result
990             mstore(last, 0) // Zeroize the slot after the string.
991             result := mload(0x40)
992             mstore(result, sub(last, add(result, 0x20))) // Store the length.
993             mstore(0x40, add(last, 0x20)) // Allocate the memory.
994         }
995     }



```

```
LibString.toHexStringNoPrefix(bytes) (LlamaPolicy.sol#331-353) is never used and should be removed



    
331     function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {
332         /// @solidity memory-safe-assembly
333         assembly {
334             let length := mload(raw)
335             str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.
336             mstore(str, add(length, length)) // Store the length of the output.
337 
338             // Store "0123456789abcdef" in scratch space.
339             mstore(0x0f, 0x30313233343536373839616263646566)
340 
341             let o := add(str, 0x20)
342             let end := add(raw, length)
343 
344             for {} iszero(eq(raw, end)) {} {
345                 raw := add(raw, 1)
346                 mstore8(add(o, 1), mload(and(mload(raw), 15)))
347                 mstore8(o, mload(and(shr(4, mload(raw)), 15)))
348                 o := add(o, 2)
349             }
350             mstore(o, 0) // Zeroize the slot after the string.
351             mstore(0x40, add(o, 0x20)) // Allocate the memory.
352         }
353     }



```

```
LibString.lastIndexOf(string,string) (LlamaPolicy.sol#593-599) is never used and should be removed



    
593     function lastIndexOf(string memory subject, string memory search)
594         internal
595         pure
596         returns (uint256 result)
597     {
598         result = lastIndexOf(subject, search, uint256(int256(-1)));
599     }



```

```
LibString.startsWith(string,string) (LlamaPolicy.sol#602-620) is never used and should be removed



    
602     function startsWith(string memory subject, string memory search)
603         internal
604         pure
605         returns (bool result)
606     {
607         /// @solidity memory-safe-assembly
608         assembly {
609             let searchLength := mload(search)
610             // Just using keccak256 directly is actually cheaper.
611             // forgefmt: disable-next-item
612             result := and(
613                 iszero(gt(searchLength, mload(subject))),
614                 eq(
615                     keccak256(add(subject, 0x20), searchLength),
616                     keccak256(add(search, 0x20), searchLength)
617                 )
618             )
619         }
620     }



```

```
LibString.lastIndexOf(string,string,uint256) (LlamaPolicy.sol#556-588) is never used and should be removed



    
556     function lastIndexOf(string memory subject, string memory search, uint256 from)
557         internal
558         pure
559         returns (uint256 result)
560     {
561         /// @solidity memory-safe-assembly
562         assembly {
563             for {} 1 {} {
564                 result := not(0) // Initialize to `NOT_FOUND`.
565                 let searchLength := mload(search)
566                 if gt(searchLength, mload(subject)) { break }
567                 let w := result
568 
569                 let fromMax := sub(mload(subject), searchLength)
570                 if iszero(gt(fromMax, from)) { from := fromMax }
571 
572                 let end := add(add(subject, 0x20), w)
573                 subject := add(add(subject, 0x20), from)
574                 if iszero(gt(subject, end)) { break }
575                 // As this function is not too often used,
576                 // we shall simply use keccak256 for smaller bytecode size.
577                 for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
578                     if eq(keccak256(subject, searchLength), h) {
579                         result := sub(subject, add(end, 1))
580                         break
581                     }
582                     subject := add(subject, w) // `sub(subject, 1)`.
583                     if iszero(gt(subject, end)) { break }
584                 }
585                 break
586             }
587         }
588     }



```

```
LibString.toString(int256) (LlamaPolicy.sol#65-81) is never used and should be removed



    
65     function toString(int256 value) internal pure returns (string memory str) {
66         if (value >= 0) {
67             return toString(uint256(value));
68         }
69         unchecked {
70             str = toString(uint256(-value));
71         }
72         /// @solidity memory-safe-assembly
73         assembly {
74             // We still have some spare memory space on the left,
75             // as we have allocated 3 words (96 bytes) for up to 78 digits.
76             let length := mload(str) // Load the string length.
77             mstore(str, 0x2d) // Store the '-' character.
78             str := sub(str, 1) // Move back the string pointer by a byte.
79             mstore(str, add(length, 1)) // Update the string length.
80         }
81     }



```

```
Clones.predictDeterministicAddress(address,bytes32,address) (LlamaPolicy.sol#1851-1867) is never used and should be removed



    
1851     function predictDeterministicAddress(
1852         address implementation,
1853         bytes32 salt,
1854         address deployer
1855     ) internal pure returns (address predicted) {
1856         /// @solidity memory-safe-assembly
1857         assembly {
1858             let ptr := mload(0x40)
1859             mstore(add(ptr, 0x38), deployer)
1860             mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)
1861             mstore(add(ptr, 0x14), implementation)
1862             mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)
1863             mstore(add(ptr, 0x58), salt)
1864             mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))
1865             predicted := keccak256(add(ptr, 0x43), 0x55)
1866         }
1867     }



```

```
LibString.directReturn(string) (LlamaPolicy.sol#1091-1104) is never used and should be removed



    
1091     function directReturn(string memory a) internal pure {
1092         assembly {
1093             // Assumes that the string does not start from the scratch space.
1094             let retStart := sub(a, 0x20)
1095             let retSize := add(mload(a), 0x40)
1096             // Right pad with zeroes. Just in case the string is produced
1097             // by a method that doesn't zero right pad.
1098             mstore(add(retStart, retSize), 0)
1099             // Store the return offset.
1100             mstore(retStart, 0x20)
1101             // End the transaction, returning the string.
1102             return(retStart, retSize)
1103         }
1104     }



```

```
LibString.toMinimalHexStringNoPrefix(uint256) (LlamaPolicy.sol#192-201) is never used and should be removed



    
192     function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {
193         str = toHexStringNoPrefix(value);
194         /// @solidity memory-safe-assembly
195         assembly {
196             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
197             let strLength := mload(str) // Get the length.
198             str := add(str, o) // Move the pointer, accounting for leading zero.
199             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
200         }
201     }



```

```
LibString.toMinimalHexString(uint256) (LlamaPolicy.sol#177-187) is never used and should be removed



    
177     function toMinimalHexString(uint256 value) internal pure returns (string memory str) {
178         str = toHexStringNoPrefix(value);
179         /// @solidity memory-safe-assembly
180         assembly {
181             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
182             let strLength := add(mload(str), 2) // Compute the length.
183             mstore(add(str, o), 0x3078) // Write the "0x" prefix, accounting for leading zero.
184             str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.
185             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
186         }
187     }



```

```
LibString.toHexString(uint256) (LlamaPolicy.sol#162-171) is never used and should be removed



    
162     function toHexString(uint256 value) internal pure returns (string memory str) {
163         str = toHexStringNoPrefix(value);
164         /// @solidity memory-safe-assembly
165         assembly {
166             let strLength := add(mload(str), 2) // Compute the length.
167             mstore(str, 0x3078) // Write the "0x" prefix.
168             str := sub(str, 2) // Move the pointer.
169             mstore(str, strLength) // Write the length.
170         }
171     }



```

```
ERC721NonTransferableMinimalProxy._safeMint(address,uint256,bytes) (LlamaPolicy.sol#1767-1776) is never used and should be removed



    
1767   function _safeMint(address to, uint256 id, bytes memory data) internal virtual {
1768     _mint(to, id);
1769 
1770     require(
1771       to.code.length == 0
1772         || ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data)
1773           == ERC721TokenReceiver.onERC721Received.selector,
1774       "UNSAFE_RECIPIENT"
1775     );
1776   }



```

```
LibString.indicesOf(string,string) (LlamaPolicy.sol#728-784) is never used and should be removed



    
728     function indicesOf(string memory subject, string memory search)
729         internal
730         pure
731         returns (uint256[] memory result)
732     {
733         /// @solidity memory-safe-assembly
734         assembly {
735             let subjectLength := mload(subject)
736             let searchLength := mload(search)
737 
738             if iszero(gt(searchLength, subjectLength)) {
739                 subject := add(subject, 0x20)
740                 search := add(search, 0x20)
741                 result := add(mload(0x40), 0x20)
742 
743                 let subjectStart := subject
744                 let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)
745                 let h := 0
746                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
747                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
748                 let s := mload(search)
749                 for {} 1 {} {
750                     let t := mload(subject)
751                     // Whether the first `searchLength % 32` bytes of
752                     // `subject` and `search` matches.
753                     if iszero(shr(m, xor(t, s))) {
754                         if h {
755                             if iszero(eq(keccak256(subject, searchLength), h)) {
756                                 subject := add(subject, 1)
757                                 if iszero(lt(subject, subjectSearchEnd)) { break }
758                                 continue
759                             }
760                         }
761                         // Append to `result`.
762                         mstore(result, sub(subject, subjectStart))
763                         result := add(result, 0x20)
764                         // Advance `subject` by `searchLength`.
765                         subject := add(subject, searchLength)
766                         if searchLength {
767                             if iszero(lt(subject, subjectSearchEnd)) { break }
768                             continue
769                         }
770                     }
771                     subject := add(subject, 1)
772                     if iszero(lt(subject, subjectSearchEnd)) { break }
773                 }
774                 let resultEnd := result
775                 // Assign `result` to the free memory pointer.
776                 result := mload(0x40)
777                 // Store the length of `result`.
778                 mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))
779                 // Allocate memory for result.
780                 // We allocate one more word, so this array can be recycled for {split}.
781                 mstore(0x40, add(resultEnd, 0x20))
782             }
783         }
784     }



```

```
Initializable._checkInitializing() (LlamaPolicy.sol#1561-1565) is never used and should be removed



    
1561     function _checkInitializing() internal view virtual {
1562         if (!_initializing) {
1563             revert NotInitializing();
1564         }
1565     }



```

```
LibString.unpackOne(bytes32) (LlamaPolicy.sol#1025-1039) is never used and should be removed



    
1025     function unpackOne(bytes32 packed) internal pure returns (string memory result) {
1026         /// @solidity memory-safe-assembly
1027         assembly {
1028             // Grab the free memory pointer.
1029             result := mload(0x40)
1030             // Allocate 2 words (1 for the length, 1 for the bytes).
1031             mstore(0x40, add(result, 0x40))
1032             // Zeroize the length slot.
1033             mstore(result, 0)
1034             // Store the length and bytes.
1035             mstore(add(result, 0x1f), packed)
1036             // Right pad with zeroes.
1037             mstore(add(add(result, 0x20), mload(result)), 0)
1038         }
1039     }



```

```
LibString.toString(uint256) (LlamaPolicy.sol#27-62) is never used and should be removed



    
27     function toString(uint256 value) internal pure returns (string memory str) {
28         /// @solidity memory-safe-assembly
29         assembly {
30             // The maximum value of a uint256 contains 78 digits (1 byte per digit), but
31             // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.
32             // We will need 1 word for the trailing zeros padding, 1 word for the length,
33             // and 3 words for a maximum of 78 digits.
34             str := add(mload(0x40), 0x80)
35             // Update the free memory pointer to allocate.
36             mstore(0x40, add(str, 0x20))
37             // Zeroize the slot after the string.
38             mstore(str, 0)
39 
40             // Cache the end of the memory to calculate the length later.
41             let end := str
42 
43             let w := not(0) // Tsk.
44             // We write the string from rightmost digit to leftmost digit.
45             // The following is essentially a do-while loop that also handles the zero case.
46             for { let temp := value } 1 {} {
47                 str := add(str, w) // `sub(str, 1)`.
48                 // Write the character to the pointer.
49                 // The ASCII index of the '0' character is 48.
50                 mstore8(str, add(48, mod(temp, 10)))
51                 // Keep dividing `temp` until zero.
52                 temp := div(temp, 10)
53                 if iszero(temp) { break }
54             }
55 
56             let length := sub(end, str)
57             // Move the pointer 32 bytes leftwards to make room for the length.
58             str := sub(str, 0x20)
59             // Store the length.
60             mstore(str, length)
61         }
62     }



```

```
ERC721NonTransferableMinimalProxy._safeMint(address,uint256) (LlamaPolicy.sol#1756-1765) is never used and should be removed



    
1756   function _safeMint(address to, uint256 id) internal virtual {
1757     _mint(to, id);
1758 
1759     require(
1760       to.code.length == 0
1761         || ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "")
1762           == ERC721TokenReceiver.onERC721Received.selector,
1763       "UNSAFE_RECIPIENT"
1764     );
1765   }



```

```
LibString.packOne(string) (LlamaPolicy.sol#1006-1020) is never used and should be removed



    
1006     function packOne(string memory a) internal pure returns (bytes32 result) {
1007         /// @solidity memory-safe-assembly
1008         assembly {
1009             // We don't need to zero right pad the string,
1010             // since this is our own custom non-standard packing scheme.
1011             result :=
1012                 mul(
1013                     // Load the length and the bytes.
1014                     mload(add(a, 0x1f)),
1015                     // `length != 0 && length < 32`. Abuses underflow.
1016                     // Assumes that the length is valid and within the block gas limit.
1017                     lt(sub(mload(a), 1), 0x1f)
1018                 )
1019         }
1020     }



```

```
LibString.runeCount(string) (LlamaPolicy.sol#360-374) is never used and should be removed



    
360     function runeCount(string memory s) internal pure returns (uint256 result) {
361         /// @solidity memory-safe-assembly
362         assembly {
363             if mload(s) {
364                 mstore(0x00, div(not(0), 255))
365                 mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)
366                 let o := add(s, 0x20)
367                 let end := add(o, mload(s))
368                 for { result := 1 } 1 { result := add(result, 1) } {
369                     o := add(o, byte(0, mload(shr(250, mload(o)))))
370                     if iszero(lt(o, end)) { break }
371                 }
372             }
373         }
374     }



```

```
LibString.unpackTwo(bytes32) (LlamaPolicy.sol#1066-1088) is never used and should be removed



    
1066     function unpackTwo(bytes32 packed)
1067         internal
1068         pure
1069         returns (string memory resultA, string memory resultB)
1070     {
1071         /// @solidity memory-safe-assembly
1072         assembly {
1073             // Grab the free memory pointer.
1074             resultA := mload(0x40)
1075             resultB := add(resultA, 0x40)
1076             // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.
1077             mstore(0x40, add(resultB, 0x40))
1078             // Zeroize the length slots.
1079             mstore(resultA, 0)
1080             mstore(resultB, 0)
1081             // Store the lengths and bytes.
1082             mstore(add(resultA, 0x1f), packed)
1083             mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))
1084             // Right pad with zeroes.
1085             mstore(add(add(resultA, 0x20), mload(resultA)), 0)
1086             mstore(add(add(resultB, 0x20), mload(resultB)), 0)
1087         }
1088     }



```

```
LibString.endsWith(string,string) (LlamaPolicy.sol#623-648) is never used and should be removed



    
623     function endsWith(string memory subject, string memory search)
624         internal
625         pure
626         returns (bool result)
627     {
628         /// @solidity memory-safe-assembly
629         assembly {
630             let searchLength := mload(search)
631             let subjectLength := mload(subject)
632             // Whether `search` is not longer than `subject`.
633             let withinRange := iszero(gt(searchLength, subjectLength))
634             // Just using keccak256 directly is actually cheaper.
635             // forgefmt: disable-next-item
636             result := and(
637                 withinRange,
638                 eq(
639                     keccak256(
640                         // `subject + 0x20 + max(subjectLength - searchLength, 0)`.
641                         add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),
642                         searchLength
643                     ),
644                     keccak256(add(search, 0x20), searchLength)
645                 )
646             )
647         }
648     }



```

```
LibString.escapeHTML(string) (LlamaPolicy.sol#915-946) is never used and should be removed



    
915     function escapeHTML(string memory s) internal pure returns (string memory result) {
916         /// @solidity memory-safe-assembly
917         assembly {
918             for {
919                 let end := add(s, mload(s))
920                 result := add(mload(0x40), 0x20)
921                 // Store the bytes of the packed offsets and strides into the scratch space.
922                 // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.
923                 mstore(0x1f, 0x900094)
924                 mstore(0x08, 0xc0000000a6ab)
925                 // Store "&quot;&amp;&#39;&lt;&gt;" into the scratch space.
926                 mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))
927             } iszero(eq(s, end)) {} {
928                 s := add(s, 1)
929                 let c := and(mload(s), 0xff)
930                 // Not in `["\"","'","&","<",">"]`.
931                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
932                     mstore8(result, c)
933                     result := add(result, 1)
934                     continue
935                 }
936                 let t := shr(248, mload(c))
937                 mstore(result, mload(and(t, 0x1f)))
938                 result := add(result, shr(5, t))
939             }
940             let last := result
941             mstore(last, 0) // Zeroize the slot after the string.
942             result := mload(0x40)
943             mstore(result, sub(last, add(result, 0x20))) // Store the length.
944             mstore(0x40, add(last, 0x20)) // Allocate the memory.
945         }
946     }



```

```
LibString.toHexStringChecksummed(address) (LlamaPolicy.sol#247-264) is never used and should be removed



    
247     function toHexStringChecksummed(address value) internal pure returns (string memory str) {
248         str = toHexString(value);
249         /// @solidity memory-safe-assembly
250         assembly {
251             let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`
252             let o := add(str, 0x22)
253             let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `
254             let t := shl(240, 136) // `0b10001000 << 240`
255             for { let i := 0 } 1 {} {
256                 mstore(add(i, i), mul(t, byte(i, hashed)))
257                 i := add(i, 1)
258                 if eq(i, 20) { break }
259             }
260             mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))
261             o := add(o, 0x20)
262             mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))
263         }
264     }



```

```
LibString.toHexStringNoPrefix(uint256) (LlamaPolicy.sol#207-241) is never used and should be removed



    
207     function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {
208         /// @solidity memory-safe-assembly
209         assembly {
210             // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,
211             // 0x02 bytes for the prefix, and 0x40 bytes for the digits.
212             // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.
213             str := add(mload(0x40), 0x80)
214             // Allocate the memory.
215             mstore(0x40, add(str, 0x20))
216             // Zeroize the slot after the string.
217             mstore(str, 0)
218 
219             // Cache the end to calculate the length later.
220             let end := str
221             // Store "0123456789abcdef" in scratch space.
222             mstore(0x0f, 0x30313233343536373839616263646566)
223 
224             let w := not(1) // Tsk.
225             // We write the string from rightmost digit to leftmost digit.
226             // The following is essentially a do-while loop that also handles the zero case.
227             for { let temp := value } 1 {} {
228                 str := add(str, w) // `sub(str, 2)`.
229                 mstore8(add(str, 1), mload(and(temp, 15)))
230                 mstore8(str, mload(and(shr(4, temp), 15)))
231                 temp := shr(8, temp)
232                 if iszero(temp) { break }
233             }
234 
235             // Compute the string's length.
236             let strLength := sub(end, str)
237             // Move the pointer and write the length.
238             str := sub(str, 0x20)
239             mstore(str, strLength)
240         }
241     }



```

```
Clones.clone(address) (LlamaPolicy.sol#1811-1824) is never used and should be removed



    
1811     function clone(address implementation) internal returns (address instance) {
1812         /// @solidity memory-safe-assembly
1813         assembly {
1814             // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
1815             // of the `implementation` address with the bytecode before the address.
1816             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
1817             // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
1818             mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
1819             instance := create(0, 0x09, 0x37)
1820         }
1821         if (instance == address(0)) {
1822             revert ERC1167FailedCreateClone();
1823         }
1824     }



```

```
LibString.is7BitASCII(string) (LlamaPolicy.sol#378-400) is never used and should be removed



    
378     function is7BitASCII(string memory s) internal pure returns (bool result) {
379         /// @solidity memory-safe-assembly
380         assembly {
381             let mask := shl(7, div(not(0), 255))
382             result := 1
383             let n := mload(s)
384             if n {
385                 let o := add(s, 0x20)
386                 let end := add(o, n)
387                 let last := mload(end)
388                 mstore(end, 0)
389                 for {} 1 {} {
390                     if and(mask, mload(o)) {
391                         result := 0
392                         break
393                     }
394                     o := add(o, 0x20)
395                     if iszero(lt(o, end)) { break }
396                 }
397                 mstore(end, last)
398             }
399         }
400     }



```

```
Initializable._getInitializedVersion() (LlamaPolicy.sol#1588-1590) is never used and should be removed



    
1588     function _getInitializedVersion() internal view returns (uint8) {
1589         return _initialized;
1590     }



```

```
Checkpoints.length(Checkpoints.History) (LlamaPolicy.sol#1241-1243) is never used and should be removed



    
1241     function length(History storage self) internal view returns (uint256) {
1242         return self._checkpoints.length;
1243     }



```

```
LibString.slice(string,uint256) (LlamaPolicy.sol#718-724) is never used and should be removed



    
718     function slice(string memory subject, uint256 start)
719         internal
720         pure
721         returns (string memory result)
722     {
723         result = slice(subject, start, uint256(int256(-1)));
724     }



```

```
LibString.concat(string,string) (LlamaPolicy.sol#836-870) is never used and should be removed



    
836     function concat(string memory a, string memory b)
837         internal
838         pure
839         returns (string memory result)
840     {
841         /// @solidity memory-safe-assembly
842         assembly {
843             let w := not(0x1f)
844             result := mload(0x40)
845             let aLength := mload(a)
846             // Copy `a` one word at a time, backwards.
847             for { let o := and(add(aLength, 0x20), w) } 1 {} {
848                 mstore(add(result, o), mload(add(a, o)))
849                 o := add(o, w) // `sub(o, 0x20)`.
850                 if iszero(o) { break }
851             }
852             let bLength := mload(b)
853             let output := add(result, aLength)
854             // Copy `b` one word at a time, backwards.
855             for { let o := and(add(bLength, 0x20), w) } 1 {} {
856                 mstore(add(output, o), mload(add(b, o)))
857                 o := add(o, w) // `sub(o, 0x20)`.
858                 if iszero(o) { break }
859             }
860             let totalLength := add(aLength, bLength)
861             let last := add(add(result, 0x20), totalLength)
862             // Zeroize the slot after the string.
863             mstore(last, 0)
864             // Stores the length.
865             mstore(result, totalLength)
866             // Allocate memory for the length and the bytes,
867             // rounded up to a multiple of 32.
868             mstore(0x40, and(add(last, 0x1f), w))
869         }
870     }



```

```
LibString.toHexStringNoPrefix(uint256,uint256) (LlamaPolicy.sol#108-156) is never used and should be removed



    
108     function toHexStringNoPrefix(uint256 value, uint256 length)
109         internal
110         pure
111         returns (string memory str)
112     {
113         /// @solidity memory-safe-assembly
114         assembly {
115             // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes
116             // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.
117             // We add 0x20 to the total and round down to a multiple of 0x20.
118             // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.
119             str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))
120             // Allocate the memory.
121             mstore(0x40, add(str, 0x20))
122             // Zeroize the slot after the string.
123             mstore(str, 0)
124 
125             // Cache the end to calculate the length later.
126             let end := str
127             // Store "0123456789abcdef" in scratch space.
128             mstore(0x0f, 0x30313233343536373839616263646566)
129 
130             let start := sub(str, add(length, length))
131             let w := not(1) // Tsk.
132             let temp := value
133             // We write the string from rightmost digit to leftmost digit.
134             // The following is essentially a do-while loop that also handles the zero case.
135             for {} 1 {} {
136                 str := add(str, w) // `sub(str, 2)`.
137                 mstore8(add(str, 1), mload(and(temp, 15)))
138                 mstore8(str, mload(and(shr(4, temp), 15)))
139                 temp := shr(8, temp)
140                 if iszero(xor(str, start)) { break }
141             }
142 
143             if temp {
144                 // Store the function selector of `HexLengthInsufficient()`.
145                 mstore(0x00, 0x2194895a)
146                 // Revert with (offset, size).
147                 revert(0x1c, 0x04)
148             }
149 
150             // Compute the string's length.
151             let strLength := sub(end, str)
152             // Move the pointer and write the length.
153             str := sub(str, 0x20)
154             mstore(str, strLength)
155         }
156     }



```

```
Checkpoints._lowerBinaryLookup(Checkpoints.Checkpoint[],uint64,uint256,uint256) (LlamaPolicy.sol#1310-1325) is never used and should be removed



    
1310     function _lowerBinaryLookup(
1311         Checkpoint[] storage self,
1312         uint64 timestamp,
1313         uint256 low,
1314         uint256 high
1315     ) private view returns (uint256) {
1316         while (low < high) {
1317             uint256 mid = average(low, high);
1318             if (_unsafeAccess(self, mid).timestamp < timestamp) {
1319                 low = mid + 1;
1320             } else {
1321                 high = mid;
1322             }
1323         }
1324         return high;
1325     }



```

```
LibString.split(string,string) (LlamaPolicy.sol#787-832) is never used and should be removed



    
787     function split(string memory subject, string memory delimiter)
788         internal
789         pure
790         returns (string[] memory result)
791     {
792         uint256[] memory indices = indicesOf(subject, delimiter);
793         /// @solidity memory-safe-assembly
794         assembly {
795             let w := not(0x1f)
796             let indexPtr := add(indices, 0x20)
797             let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))
798             mstore(add(indicesEnd, w), mload(subject))
799             mstore(indices, add(mload(indices), 1))
800             let prevIndex := 0
801             for {} 1 {} {
802                 let index := mload(indexPtr)
803                 mstore(indexPtr, 0x60)
804                 if iszero(eq(index, prevIndex)) {
805                     let element := mload(0x40)
806                     let elementLength := sub(index, prevIndex)
807                     mstore(element, elementLength)
808                     // Copy the `subject` one word at a time, backwards.
809                     for { let o := and(add(elementLength, 0x1f), w) } 1 {} {
810                         mstore(add(element, o), mload(add(add(subject, prevIndex), o)))
811                         o := add(o, w) // `sub(o, 0x20)`.
812                         if iszero(o) { break }
813                     }
814                     // Zeroize the slot after the string.
815                     mstore(add(add(element, 0x20), elementLength), 0)
816                     // Allocate memory for the length and the bytes,
817                     // rounded up to a multiple of 32.
818                     mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))
819                     // Store the `element` into the array.
820                     mstore(indexPtr, element)
821                 }
822                 prevIndex := add(index, mload(delimiter))
823                 indexPtr := add(indexPtr, 0x20)
824                 if iszero(lt(indexPtr, indicesEnd)) { break }
825             }
826             result := indices
827             if iszero(mload(delimiter)) {
828                 result := add(indices, 0x20)
829                 mstore(result, sub(mload(indices), 2))
830             }
831         }
832     }



```

```
LibString.lower(string) (LlamaPolicy.sol#904-906) is never used and should be removed



    
904     function lower(string memory subject) internal pure returns (string memory result) {
905         result = toCase(subject, false);
906     }



```

```
LibString.packTwo(string,string) (LlamaPolicy.sol#1043-1061) is never used and should be removed



    
1043     function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {
1044         /// @solidity memory-safe-assembly
1045         assembly {
1046             let aLength := mload(a)
1047             // We don't need to zero right pad the strings,
1048             // since this is our own custom non-standard packing scheme.
1049             result :=
1050                 mul(
1051                     // Load the length and the bytes of `a` and `b`.
1052                     or(
1053                         shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),
1054                         mload(sub(add(b, 0x1e), aLength))
1055                     ),
1056                     // `totalLength != 0 && totalLength < 31`. Abuses underflow.
1057                     // Assumes that the lengths are valid and within the block gas limit.
1058                     lt(sub(add(aLength, mload(b)), 1), 0x1e)
1059                 )
1060         }
1061     }



```

```
LibString.eq(string,string) (LlamaPolicy.sol#998-1002) is never used and should be removed



    
998     function eq(string memory a, string memory b) internal pure returns (bool result) {
999         assembly {
1000             result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))
1001         }
1002     }



```

```
LibString.repeat(string,uint256) (LlamaPolicy.sol#651-681) is never used and should be removed



    
651     function repeat(string memory subject, uint256 times)
652         internal
653         pure
654         returns (string memory result)
655     {
656         /// @solidity memory-safe-assembly
657         assembly {
658             let subjectLength := mload(subject)
659             if iszero(or(iszero(times), iszero(subjectLength))) {
660                 subject := add(subject, 0x20)
661                 result := mload(0x40)
662                 let output := add(result, 0x20)
663                 for {} 1 {} {
664                     // Copy the `subject` one word at a time.
665                     for { let o := 0 } 1 {} {
666                         mstore(add(output, o), mload(add(subject, o)))
667                         o := add(o, 0x20)
668                         if iszero(lt(o, subjectLength)) { break }
669                     }
670                     output := add(output, subjectLength)
671                     times := sub(times, 1)
672                     if iszero(times) { break }
673                 }
674                 mstore(output, 0) // Zeroize the slot after the string.
675                 let resultLength := sub(output, add(result, 0x20))
676                 mstore(result, resultLength) // Store the length.
677                 // Allocate the memory.
678                 mstore(0x40, add(result, add(resultLength, 0x20)))
679             }
680         }
681     }



```

### LlamaPolicyMetadata.sol


```
LibString.indexOf(string,string) (LlamaPolicyMetadata.sol#633-639) is never used and should be removed



    
633     function indexOf(string memory subject, string memory search)
634         internal
635         pure
636         returns (uint256 result)
637     {
638         result = indexOf(subject, search, 0);
639     }



```

```
LibString.indexOf(string,string,uint256) (LlamaPolicyMetadata.sol#575-628) is never used and should be removed



    
575     function indexOf(string memory subject, string memory search, uint256 from)
576         internal
577         pure
578         returns (uint256 result)
579     {
580         /// @solidity memory-safe-assembly
581         assembly {
582             for { let subjectLength := mload(subject) } 1 {} {
583                 if iszero(mload(search)) {
584                     if iszero(gt(from, subjectLength)) {
585                         result := from
586                         break
587                     }
588                     result := subjectLength
589                     break
590                 }
591                 let searchLength := mload(search)
592                 let subjectStart := add(subject, 0x20)
593 
594                 result := not(0) // Initialize to `NOT_FOUND`.
595 
596                 subject := add(subjectStart, from)
597                 let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)
598 
599                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
600                 let s := mload(add(search, 0x20))
601 
602                 if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }
603 
604                 if iszero(lt(searchLength, 0x20)) {
605                     for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
606                         if iszero(shr(m, xor(mload(subject), s))) {
607                             if eq(keccak256(subject, searchLength), h) {
608                                 result := sub(subject, subjectStart)
609                                 break
610                             }
611                         }
612                         subject := add(subject, 1)
613                         if iszero(lt(subject, end)) { break }
614                     }
615                     break
616                 }
617                 for {} 1 {} {
618                     if iszero(shr(m, xor(mload(subject), s))) {
619                         result := sub(subject, subjectStart)
620                         break
621                     }
622                     subject := add(subject, 1)
623                     if iszero(lt(subject, end)) { break }
624                 }
625                 break
626             }
627         }
628     }



```

```
LibString.toHexString(bytes) (LlamaPolicyMetadata.sol#406-415) is never used and should be removed



    
406     function toHexString(bytes memory raw) internal pure returns (string memory str) {
407         str = toHexStringNoPrefix(raw);
408         /// @solidity memory-safe-assembly
409         assembly {
410             let strLength := add(mload(str), 2) // Compute the length.
411             mstore(str, 0x3078) // Write the "0x" prefix.
412             str := sub(str, 2) // Move the pointer.
413             mstore(str, strLength) // Write the length.
414         }
415     }



```

```
LibString.toHexString(uint256,uint256) (LlamaPolicyMetadata.sol#180-189) is never used and should be removed



    
180     function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {
181         str = toHexStringNoPrefix(value, length);
182         /// @solidity memory-safe-assembly
183         assembly {
184             let strLength := add(mload(str), 2) // Compute the length.
185             mstore(str, 0x3078) // Write the "0x" prefix.
186             str := sub(str, 2) // Move the pointer.
187             mstore(str, strLength) // Write the length.
188         }
189     }



```

```
LibString.escapeJSON(string) (LlamaPolicyMetadata.sol#1037-1083) is never used and should be removed



    
1037     function escapeJSON(string memory s) internal pure returns (string memory result) {
1038         /// @solidity memory-safe-assembly
1039         assembly {
1040             for {
1041                 let end := add(s, mload(s))
1042                 result := add(mload(0x40), 0x20)
1043                 // Store "\\u0000" in scratch space.
1044                 // Store "0123456789abcdef" in scratch space.
1045                 // Also, store `{0x08:"b", 0x09:"t", 0x0a:"n", 0x0c:"f", 0x0d:"r"}`.
1046                 // into the scratch space.
1047                 mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)
1048                 // Bitmask for detecting `["\"","\\"]`.
1049                 let e := or(shl(0x22, 1), shl(0x5c, 1))
1050             } iszero(eq(s, end)) {} {
1051                 s := add(s, 1)
1052                 let c := and(mload(s), 0xff)
1053                 if iszero(lt(c, 0x20)) {
1054                     if iszero(and(shl(c, 1), e)) {
1055                         // Not in `["\"","\\"]`.
1056                         mstore8(result, c)
1057                         result := add(result, 1)
1058                         continue
1059                     }
1060                     mstore8(result, 0x5c) // "\\".
1061                     mstore8(add(result, 1), c)
1062                     result := add(result, 2)
1063                     continue
1064                 }
1065                 if iszero(and(shl(c, 1), 0x3700)) {
1066                     // Not in `["\b","\t","\n","\f","\d"]`.
1067                     mstore8(0x1d, mload(shr(4, c))) // Hex value.
1068                     mstore8(0x1e, mload(and(c, 15))) // Hex value.
1069                     mstore(result, mload(0x19)) // "\\u00XX".
1070                     result := add(result, 6)
1071                     continue
1072                 }
1073                 mstore8(result, 0x5c) // "\\".
1074                 mstore8(add(result, 1), mload(add(c, 8)))
1075                 result := add(result, 2)
1076             }
1077             let last := result
1078             mstore(last, 0) // Zeroize the slot after the string.
1079             result := mload(0x40)
1080             mstore(result, sub(last, add(result, 0x20))) // Store the length.
1081             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1082         }
1083     }



```

```
LibString.toHexStringNoPrefix(bytes) (LlamaPolicyMetadata.sol#419-441) is never used and should be removed



    
419     function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {
420         /// @solidity memory-safe-assembly
421         assembly {
422             let length := mload(raw)
423             str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.
424             mstore(str, add(length, length)) // Store the length of the output.
425 
426             // Store "0123456789abcdef" in scratch space.
427             mstore(0x0f, 0x30313233343536373839616263646566)
428 
429             let o := add(str, 0x20)
430             let end := add(raw, length)
431 
432             for {} iszero(eq(raw, end)) {} {
433                 raw := add(raw, 1)
434                 mstore8(add(o, 1), mload(and(mload(raw), 15)))
435                 mstore8(o, mload(and(shr(4, mload(raw)), 15)))
436                 o := add(o, 2)
437             }
438             mstore(o, 0) // Zeroize the slot after the string.
439             mstore(0x40, add(o, 0x20)) // Allocate the memory.
440         }
441     }



```

```
LibString.lastIndexOf(string,string) (LlamaPolicyMetadata.sol#681-687) is never used and should be removed



    
681     function lastIndexOf(string memory subject, string memory search)
682         internal
683         pure
684         returns (uint256 result)
685     {
686         result = lastIndexOf(subject, search, uint256(int256(-1)));
687     }



```

```
LibString.replace(string,string,string) (LlamaPolicyMetadata.sol#498-570) is never used and should be removed



    
498     function replace(string memory subject, string memory search, string memory replacement)
499         internal
500         pure
501         returns (string memory result)
502     {
503         /// @solidity memory-safe-assembly
504         assembly {
505             let subjectLength := mload(subject)
506             let searchLength := mload(search)
507             let replacementLength := mload(replacement)
508 
509             subject := add(subject, 0x20)
510             search := add(search, 0x20)
511             replacement := add(replacement, 0x20)
512             result := add(mload(0x40), 0x20)
513 
514             let subjectEnd := add(subject, subjectLength)
515             if iszero(gt(searchLength, subjectLength)) {
516                 let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)
517                 let h := 0
518                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
519                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
520                 let s := mload(search)
521                 for {} 1 {} {
522                     let t := mload(subject)
523                     // Whether the first `searchLength % 32` bytes of
524                     // `subject` and `search` matches.
525                     if iszero(shr(m, xor(t, s))) {
526                         if h {
527                             if iszero(eq(keccak256(subject, searchLength), h)) {
528                                 mstore(result, t)
529                                 result := add(result, 1)
530                                 subject := add(subject, 1)
531                                 if iszero(lt(subject, subjectSearchEnd)) { break }
532                                 continue
533                             }
534                         }
535                         // Copy the `replacement` one word at a time.
536                         for { let o := 0 } 1 {} {
537                             mstore(add(result, o), mload(add(replacement, o)))
538                             o := add(o, 0x20)
539                             if iszero(lt(o, replacementLength)) { break }
540                         }
541                         result := add(result, replacementLength)
542                         subject := add(subject, searchLength)
543                         if searchLength {
544                             if iszero(lt(subject, subjectSearchEnd)) { break }
545                             continue
546                         }
547                     }
548                     mstore(result, t)
549                     result := add(result, 1)
550                     subject := add(subject, 1)
551                     if iszero(lt(subject, subjectSearchEnd)) { break }
552                 }
553             }
554 
555             let resultRemainder := result
556             result := add(mload(0x40), 0x20)
557             let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))
558             // Copy the rest of the string one word at a time.
559             for {} lt(subject, subjectEnd) {} {
560                 mstore(resultRemainder, mload(subject))
561                 resultRemainder := add(resultRemainder, 0x20)
562                 subject := add(subject, 0x20)
563             }
564             result := sub(result, 0x20)
565             let last := add(add(result, 0x20), k) // Zeroize the slot after the string.
566             mstore(last, 0)
567             mstore(0x40, add(last, 0x20)) // Allocate the memory.
568             mstore(result, k) // Store the length.
569         }
570     }



```

```
LibString.startsWith(string,string) (LlamaPolicyMetadata.sol#690-708) is never used and should be removed



    
690     function startsWith(string memory subject, string memory search)
691         internal
692         pure
693         returns (bool result)
694     {
695         /// @solidity memory-safe-assembly
696         assembly {
697             let searchLength := mload(search)
698             // Just using keccak256 directly is actually cheaper.
699             // forgefmt: disable-next-item
700             result := and(
701                 iszero(gt(searchLength, mload(subject))),
702                 eq(
703                     keccak256(add(subject, 0x20), searchLength),
704                     keccak256(add(search, 0x20), searchLength)
705                 )
706             )
707         }
708     }



```

```
LibString.lastIndexOf(string,string,uint256) (LlamaPolicyMetadata.sol#644-676) is never used and should be removed



    
644     function lastIndexOf(string memory subject, string memory search, uint256 from)
645         internal
646         pure
647         returns (uint256 result)
648     {
649         /// @solidity memory-safe-assembly
650         assembly {
651             for {} 1 {} {
652                 result := not(0) // Initialize to `NOT_FOUND`.
653                 let searchLength := mload(search)
654                 if gt(searchLength, mload(subject)) { break }
655                 let w := result
656 
657                 let fromMax := sub(mload(subject), searchLength)
658                 if iszero(gt(fromMax, from)) { from := fromMax }
659 
660                 let end := add(add(subject, 0x20), w)
661                 subject := add(add(subject, 0x20), from)
662                 if iszero(gt(subject, end)) { break }
663                 // As this function is not too often used,
664                 // we shall simply use keccak256 for smaller bytecode size.
665                 for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
666                     if eq(keccak256(subject, searchLength), h) {
667                         result := sub(subject, add(end, 1))
668                         break
669                     }
670                     subject := add(subject, w) // `sub(subject, 1)`.
671                     if iszero(gt(subject, end)) { break }
672                 }
673                 break
674             }
675         }
676     }



```

```
LibString.toString(int256) (LlamaPolicyMetadata.sol#153-169) is never used and should be removed



    
153     function toString(int256 value) internal pure returns (string memory str) {
154         if (value >= 0) {
155             return toString(uint256(value));
156         }
157         unchecked {
158             str = toString(uint256(-value));
159         }
160         /// @solidity memory-safe-assembly
161         assembly {
162             // We still have some spare memory space on the left,
163             // as we have allocated 3 words (96 bytes) for up to 78 digits.
164             let length := mload(str) // Load the string length.
165             mstore(str, 0x2d) // Store the '-' character.
166             str := sub(str, 1) // Move back the string pointer by a byte.
167             mstore(str, add(length, 1)) // Update the string length.
168         }
169     }



```

```
LibString.upper(string) (LlamaPolicyMetadata.sol#998-1000) is never used and should be removed



    
998     function upper(string memory subject) internal pure returns (string memory result) {
999         result = toCase(subject, true);
1000     }



```

```
LibString.directReturn(string) (LlamaPolicyMetadata.sol#1179-1192) is never used and should be removed



    
1179     function directReturn(string memory a) internal pure {
1180         assembly {
1181             // Assumes that the string does not start from the scratch space.
1182             let retStart := sub(a, 0x20)
1183             let retSize := add(mload(a), 0x40)
1184             // Right pad with zeroes. Just in case the string is produced
1185             // by a method that doesn't zero right pad.
1186             mstore(add(retStart, retSize), 0)
1187             // Store the return offset.
1188             mstore(retStart, 0x20)
1189             // End the transaction, returning the string.
1190             return(retStart, retSize)
1191         }
1192     }



```

```
LibString.toMinimalHexStringNoPrefix(uint256) (LlamaPolicyMetadata.sol#280-289) is never used and should be removed



    
280     function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {
281         str = toHexStringNoPrefix(value);
282         /// @solidity memory-safe-assembly
283         assembly {
284             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
285             let strLength := mload(str) // Get the length.
286             str := add(str, o) // Move the pointer, accounting for leading zero.
287             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
288         }
289     }



```

```
LibString.toMinimalHexString(uint256) (LlamaPolicyMetadata.sol#265-275) is never used and should be removed



    
265     function toMinimalHexString(uint256 value) internal pure returns (string memory str) {
266         str = toHexStringNoPrefix(value);
267         /// @solidity memory-safe-assembly
268         assembly {
269             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
270             let strLength := add(mload(str), 2) // Compute the length.
271             mstore(add(str, o), 0x3078) // Write the "0x" prefix, accounting for leading zero.
272             str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.
273             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
274         }
275     }



```

```
LibString.toHexString(uint256) (LlamaPolicyMetadata.sol#250-259) is never used and should be removed



    
250     function toHexString(uint256 value) internal pure returns (string memory str) {
251         str = toHexStringNoPrefix(value);
252         /// @solidity memory-safe-assembly
253         assembly {
254             let strLength := add(mload(str), 2) // Compute the length.
255             mstore(str, 0x3078) // Write the "0x" prefix.
256             str := sub(str, 2) // Move the pointer.
257             mstore(str, strLength) // Write the length.
258         }
259     }



```

```
LibString.indicesOf(string,string) (LlamaPolicyMetadata.sol#816-872) is never used and should be removed



    
816     function indicesOf(string memory subject, string memory search)
817         internal
818         pure
819         returns (uint256[] memory result)
820     {
821         /// @solidity memory-safe-assembly
822         assembly {
823             let subjectLength := mload(subject)
824             let searchLength := mload(search)
825 
826             if iszero(gt(searchLength, subjectLength)) {
827                 subject := add(subject, 0x20)
828                 search := add(search, 0x20)
829                 result := add(mload(0x40), 0x20)
830 
831                 let subjectStart := subject
832                 let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)
833                 let h := 0
834                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
835                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
836                 let s := mload(search)
837                 for {} 1 {} {
838                     let t := mload(subject)
839                     // Whether the first `searchLength % 32` bytes of
840                     // `subject` and `search` matches.
841                     if iszero(shr(m, xor(t, s))) {
842                         if h {
843                             if iszero(eq(keccak256(subject, searchLength), h)) {
844                                 subject := add(subject, 1)
845                                 if iszero(lt(subject, subjectSearchEnd)) { break }
846                                 continue
847                             }
848                         }
849                         // Append to `result`.
850                         mstore(result, sub(subject, subjectStart))
851                         result := add(result, 0x20)
852                         // Advance `subject` by `searchLength`.
853                         subject := add(subject, searchLength)
854                         if searchLength {
855                             if iszero(lt(subject, subjectSearchEnd)) { break }
856                             continue
857                         }
858                     }
859                     subject := add(subject, 1)
860                     if iszero(lt(subject, subjectSearchEnd)) { break }
861                 }
862                 let resultEnd := result
863                 // Assign `result` to the free memory pointer.
864                 result := mload(0x40)
865                 // Store the length of `result`.
866                 mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))
867                 // Allocate memory for result.
868                 // We allocate one more word, so this array can be recycled for {split}.
869                 mstore(0x40, add(resultEnd, 0x20))
870             }
871         }
872     }



```

```
LibString.unpackOne(bytes32) (LlamaPolicyMetadata.sol#1113-1127) is never used and should be removed



    
1113     function unpackOne(bytes32 packed) internal pure returns (string memory result) {
1114         /// @solidity memory-safe-assembly
1115         assembly {
1116             // Grab the free memory pointer.
1117             result := mload(0x40)
1118             // Allocate 2 words (1 for the length, 1 for the bytes).
1119             mstore(0x40, add(result, 0x40))
1120             // Zeroize the length slot.
1121             mstore(result, 0)
1122             // Store the length and bytes.
1123             mstore(add(result, 0x1f), packed)
1124             // Right pad with zeroes.
1125             mstore(add(add(result, 0x20), mload(result)), 0)
1126         }
1127     }



```

```
LibString.toString(uint256) (LlamaPolicyMetadata.sol#115-150) is never used and should be removed



    
115     function toString(uint256 value) internal pure returns (string memory str) {
116         /// @solidity memory-safe-assembly
117         assembly {
118             // The maximum value of a uint256 contains 78 digits (1 byte per digit), but
119             // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.
120             // We will need 1 word for the trailing zeros padding, 1 word for the length,
121             // and 3 words for a maximum of 78 digits.
122             str := add(mload(0x40), 0x80)
123             // Update the free memory pointer to allocate.
124             mstore(0x40, add(str, 0x20))
125             // Zeroize the slot after the string.
126             mstore(str, 0)
127 
128             // Cache the end of the memory to calculate the length later.
129             let end := str
130 
131             let w := not(0) // Tsk.
132             // We write the string from rightmost digit to leftmost digit.
133             // The following is essentially a do-while loop that also handles the zero case.
134             for { let temp := value } 1 {} {
135                 str := add(str, w) // `sub(str, 1)`.
136                 // Write the character to the pointer.
137                 // The ASCII index of the '0' character is 48.
138                 mstore8(str, add(48, mod(temp, 10)))
139                 // Keep dividing `temp` until zero.
140                 temp := div(temp, 10)
141                 if iszero(temp) { break }
142             }
143 
144             let length := sub(end, str)
145             // Move the pointer 32 bytes leftwards to make room for the length.
146             str := sub(str, 0x20)
147             // Store the length.
148             mstore(str, length)
149         }
150     }



```

```
LibString.packOne(string) (LlamaPolicyMetadata.sol#1094-1108) is never used and should be removed



    
1094     function packOne(string memory a) internal pure returns (bytes32 result) {
1095         /// @solidity memory-safe-assembly
1096         assembly {
1097             // We don't need to zero right pad the string,
1098             // since this is our own custom non-standard packing scheme.
1099             result :=
1100                 mul(
1101                     // Load the length and the bytes.
1102                     mload(add(a, 0x1f)),
1103                     // `length != 0 && length < 32`. Abuses underflow.
1104                     // Assumes that the length is valid and within the block gas limit.
1105                     lt(sub(mload(a), 1), 0x1f)
1106                 )
1107         }
1108     }



```

```
LibString.runeCount(string) (LlamaPolicyMetadata.sol#448-462) is never used and should be removed



    
448     function runeCount(string memory s) internal pure returns (uint256 result) {
449         /// @solidity memory-safe-assembly
450         assembly {
451             if mload(s) {
452                 mstore(0x00, div(not(0), 255))
453                 mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)
454                 let o := add(s, 0x20)
455                 let end := add(o, mload(s))
456                 for { result := 1 } 1 { result := add(result, 1) } {
457                     o := add(o, byte(0, mload(shr(250, mload(o)))))
458                     if iszero(lt(o, end)) { break }
459                 }
460             }
461         }
462     }



```

```
LibString.unpackTwo(bytes32) (LlamaPolicyMetadata.sol#1154-1176) is never used and should be removed



    
1154     function unpackTwo(bytes32 packed)
1155         internal
1156         pure
1157         returns (string memory resultA, string memory resultB)
1158     {
1159         /// @solidity memory-safe-assembly
1160         assembly {
1161             // Grab the free memory pointer.
1162             resultA := mload(0x40)
1163             resultB := add(resultA, 0x40)
1164             // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.
1165             mstore(0x40, add(resultB, 0x40))
1166             // Zeroize the length slots.
1167             mstore(resultA, 0)
1168             mstore(resultB, 0)
1169             // Store the lengths and bytes.
1170             mstore(add(resultA, 0x1f), packed)
1171             mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))
1172             // Right pad with zeroes.
1173             mstore(add(add(resultA, 0x20), mload(resultA)), 0)
1174             mstore(add(add(resultB, 0x20), mload(resultB)), 0)
1175         }
1176     }



```

```
LibString.endsWith(string,string) (LlamaPolicyMetadata.sol#711-736) is never used and should be removed



    
711     function endsWith(string memory subject, string memory search)
712         internal
713         pure
714         returns (bool result)
715     {
716         /// @solidity memory-safe-assembly
717         assembly {
718             let searchLength := mload(search)
719             let subjectLength := mload(subject)
720             // Whether `search` is not longer than `subject`.
721             let withinRange := iszero(gt(searchLength, subjectLength))
722             // Just using keccak256 directly is actually cheaper.
723             // forgefmt: disable-next-item
724             result := and(
725                 withinRange,
726                 eq(
727                     keccak256(
728                         // `subject + 0x20 + max(subjectLength - searchLength, 0)`.
729                         add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),
730                         searchLength
731                     ),
732                     keccak256(add(search, 0x20), searchLength)
733                 )
734             )
735         }
736     }



```

```
LibString.escapeHTML(string) (LlamaPolicyMetadata.sol#1003-1034) is never used and should be removed



    
1003     function escapeHTML(string memory s) internal pure returns (string memory result) {
1004         /// @solidity memory-safe-assembly
1005         assembly {
1006             for {
1007                 let end := add(s, mload(s))
1008                 result := add(mload(0x40), 0x20)
1009                 // Store the bytes of the packed offsets and strides into the scratch space.
1010                 // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.
1011                 mstore(0x1f, 0x900094)
1012                 mstore(0x08, 0xc0000000a6ab)
1013                 // Store "&quot;&amp;&#39;&lt;&gt;" into the scratch space.
1014                 mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))
1015             } iszero(eq(s, end)) {} {
1016                 s := add(s, 1)
1017                 let c := and(mload(s), 0xff)
1018                 // Not in `["\"","'","&","<",">"]`.
1019                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
1020                     mstore8(result, c)
1021                     result := add(result, 1)
1022                     continue
1023                 }
1024                 let t := shr(248, mload(c))
1025                 mstore(result, mload(and(t, 0x1f)))
1026                 result := add(result, shr(5, t))
1027             }
1028             let last := result
1029             mstore(last, 0) // Zeroize the slot after the string.
1030             result := mload(0x40)
1031             mstore(result, sub(last, add(result, 0x20))) // Store the length.
1032             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1033         }
1034     }



```

```
LibString.toHexStringChecksummed(address) (LlamaPolicyMetadata.sol#335-352) is never used and should be removed



    
335     function toHexStringChecksummed(address value) internal pure returns (string memory str) {
336         str = toHexString(value);
337         /// @solidity memory-safe-assembly
338         assembly {
339             let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`
340             let o := add(str, 0x22)
341             let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `
342             let t := shl(240, 136) // `0b10001000 << 240`
343             for { let i := 0 } 1 {} {
344                 mstore(add(i, i), mul(t, byte(i, hashed)))
345                 i := add(i, 1)
346                 if eq(i, 20) { break }
347             }
348             mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))
349             o := add(o, 0x20)
350             mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))
351         }
352     }



```

```
LibString.toHexStringNoPrefix(uint256) (LlamaPolicyMetadata.sol#295-329) is never used and should be removed



    
295     function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {
296         /// @solidity memory-safe-assembly
297         assembly {
298             // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,
299             // 0x02 bytes for the prefix, and 0x40 bytes for the digits.
300             // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.
301             str := add(mload(0x40), 0x80)
302             // Allocate the memory.
303             mstore(0x40, add(str, 0x20))
304             // Zeroize the slot after the string.
305             mstore(str, 0)
306 
307             // Cache the end to calculate the length later.
308             let end := str
309             // Store "0123456789abcdef" in scratch space.
310             mstore(0x0f, 0x30313233343536373839616263646566)
311 
312             let w := not(1) // Tsk.
313             // We write the string from rightmost digit to leftmost digit.
314             // The following is essentially a do-while loop that also handles the zero case.
315             for { let temp := value } 1 {} {
316                 str := add(str, w) // `sub(str, 2)`.
317                 mstore8(add(str, 1), mload(and(temp, 15)))
318                 mstore8(str, mload(and(shr(4, temp), 15)))
319                 temp := shr(8, temp)
320                 if iszero(temp) { break }
321             }
322 
323             // Compute the string's length.
324             let strLength := sub(end, str)
325             // Move the pointer and write the length.
326             str := sub(str, 0x20)
327             mstore(str, strLength)
328         }
329     }



```

```
LibString.is7BitASCII(string) (LlamaPolicyMetadata.sol#466-488) is never used and should be removed



    
466     function is7BitASCII(string memory s) internal pure returns (bool result) {
467         /// @solidity memory-safe-assembly
468         assembly {
469             let mask := shl(7, div(not(0), 255))
470             result := 1
471             let n := mload(s)
472             if n {
473                 let o := add(s, 0x20)
474                 let end := add(o, n)
475                 let last := mload(end)
476                 mstore(end, 0)
477                 for {} 1 {} {
478                     if and(mask, mload(o)) {
479                         result := 0
480                         break
481                     }
482                     o := add(o, 0x20)
483                     if iszero(lt(o, end)) { break }
484                 }
485                 mstore(end, last)
486             }
487         }
488     }



```

```
LibString.slice(string,uint256) (LlamaPolicyMetadata.sol#806-812) is never used and should be removed



    
806     function slice(string memory subject, uint256 start)
807         internal
808         pure
809         returns (string memory result)
810     {
811         result = slice(subject, start, uint256(int256(-1)));
812     }



```

```
LibString.concat(string,string) (LlamaPolicyMetadata.sol#924-958) is never used and should be removed



    
924     function concat(string memory a, string memory b)
925         internal
926         pure
927         returns (string memory result)
928     {
929         /// @solidity memory-safe-assembly
930         assembly {
931             let w := not(0x1f)
932             result := mload(0x40)
933             let aLength := mload(a)
934             // Copy `a` one word at a time, backwards.
935             for { let o := and(add(aLength, 0x20), w) } 1 {} {
936                 mstore(add(result, o), mload(add(a, o)))
937                 o := add(o, w) // `sub(o, 0x20)`.
938                 if iszero(o) { break }
939             }
940             let bLength := mload(b)
941             let output := add(result, aLength)
942             // Copy `b` one word at a time, backwards.
943             for { let o := and(add(bLength, 0x20), w) } 1 {} {
944                 mstore(add(output, o), mload(add(b, o)))
945                 o := add(o, w) // `sub(o, 0x20)`.
946                 if iszero(o) { break }
947             }
948             let totalLength := add(aLength, bLength)
949             let last := add(add(result, 0x20), totalLength)
950             // Zeroize the slot after the string.
951             mstore(last, 0)
952             // Stores the length.
953             mstore(result, totalLength)
954             // Allocate memory for the length and the bytes,
955             // rounded up to a multiple of 32.
956             mstore(0x40, and(add(last, 0x1f), w))
957         }
958     }



```

```
LibString.toHexStringNoPrefix(uint256,uint256) (LlamaPolicyMetadata.sol#196-244) is never used and should be removed



    
196     function toHexStringNoPrefix(uint256 value, uint256 length)
197         internal
198         pure
199         returns (string memory str)
200     {
201         /// @solidity memory-safe-assembly
202         assembly {
203             // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes
204             // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.
205             // We add 0x20 to the total and round down to a multiple of 0x20.
206             // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.
207             str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))
208             // Allocate the memory.
209             mstore(0x40, add(str, 0x20))
210             // Zeroize the slot after the string.
211             mstore(str, 0)
212 
213             // Cache the end to calculate the length later.
214             let end := str
215             // Store "0123456789abcdef" in scratch space.
216             mstore(0x0f, 0x30313233343536373839616263646566)
217 
218             let start := sub(str, add(length, length))
219             let w := not(1) // Tsk.
220             let temp := value
221             // We write the string from rightmost digit to leftmost digit.
222             // The following is essentially a do-while loop that also handles the zero case.
223             for {} 1 {} {
224                 str := add(str, w) // `sub(str, 2)`.
225                 mstore8(add(str, 1), mload(and(temp, 15)))
226                 mstore8(str, mload(and(shr(4, temp), 15)))
227                 temp := shr(8, temp)
228                 if iszero(xor(str, start)) { break }
229             }
230 
231             if temp {
232                 // Store the function selector of `HexLengthInsufficient()`.
233                 mstore(0x00, 0x2194895a)
234                 // Revert with (offset, size).
235                 revert(0x1c, 0x04)
236             }
237 
238             // Compute the string's length.
239             let strLength := sub(end, str)
240             // Move the pointer and write the length.
241             str := sub(str, 0x20)
242             mstore(str, strLength)
243         }
244     }



```

```
LibString.split(string,string) (LlamaPolicyMetadata.sol#875-920) is never used and should be removed



    
875     function split(string memory subject, string memory delimiter)
876         internal
877         pure
878         returns (string[] memory result)
879     {
880         uint256[] memory indices = indicesOf(subject, delimiter);
881         /// @solidity memory-safe-assembly
882         assembly {
883             let w := not(0x1f)
884             let indexPtr := add(indices, 0x20)
885             let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))
886             mstore(add(indicesEnd, w), mload(subject))
887             mstore(indices, add(mload(indices), 1))
888             let prevIndex := 0
889             for {} 1 {} {
890                 let index := mload(indexPtr)
891                 mstore(indexPtr, 0x60)
892                 if iszero(eq(index, prevIndex)) {
893                     let element := mload(0x40)
894                     let elementLength := sub(index, prevIndex)
895                     mstore(element, elementLength)
896                     // Copy the `subject` one word at a time, backwards.
897                     for { let o := and(add(elementLength, 0x1f), w) } 1 {} {
898                         mstore(add(element, o), mload(add(add(subject, prevIndex), o)))
899                         o := add(o, w) // `sub(o, 0x20)`.
900                         if iszero(o) { break }
901                     }
902                     // Zeroize the slot after the string.
903                     mstore(add(add(element, 0x20), elementLength), 0)
904                     // Allocate memory for the length and the bytes,
905                     // rounded up to a multiple of 32.
906                     mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))
907                     // Store the `element` into the array.
908                     mstore(indexPtr, element)
909                 }
910                 prevIndex := add(index, mload(delimiter))
911                 indexPtr := add(indexPtr, 0x20)
912                 if iszero(lt(indexPtr, indicesEnd)) { break }
913             }
914             result := indices
915             if iszero(mload(delimiter)) {
916                 result := add(indices, 0x20)
917                 mstore(result, sub(mload(indices), 2))
918             }
919         }
920     }



```

```
LibString.lower(string) (LlamaPolicyMetadata.sol#992-994) is never used and should be removed



    
992     function lower(string memory subject) internal pure returns (string memory result) {
993         result = toCase(subject, false);
994     }



```

```
LibString.packTwo(string,string) (LlamaPolicyMetadata.sol#1131-1149) is never used and should be removed



    
1131     function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {
1132         /// @solidity memory-safe-assembly
1133         assembly {
1134             let aLength := mload(a)
1135             // We don't need to zero right pad the strings,
1136             // since this is our own custom non-standard packing scheme.
1137             result :=
1138                 mul(
1139                     // Load the length and the bytes of `a` and `b`.
1140                     or(
1141                         shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),
1142                         mload(sub(add(b, 0x1e), aLength))
1143                     ),
1144                     // `totalLength != 0 && totalLength < 31`. Abuses underflow.
1145                     // Assumes that the lengths are valid and within the block gas limit.
1146                     lt(sub(add(aLength, mload(b)), 1), 0x1e)
1147                 )
1148         }
1149     }



```

```
LibString.eq(string,string) (LlamaPolicyMetadata.sol#1086-1090) is never used and should be removed



    
1086     function eq(string memory a, string memory b) internal pure returns (bool result) {
1087         assembly {
1088             result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))
1089         }
1090     }



```

```
LibString.toCase(string,bool) (LlamaPolicyMetadata.sol#962-988) is never used and should be removed



    
962     function toCase(string memory subject, bool toUpper)
963         internal
964         pure
965         returns (string memory result)
966     {
967         /// @solidity memory-safe-assembly
968         assembly {
969             let length := mload(subject)
970             if length {
971                 result := add(mload(0x40), 0x20)
972                 subject := add(subject, 1)
973                 let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)
974                 let w := not(0)
975                 for { let o := length } 1 {} {
976                     o := add(o, w)
977                     let b := and(0xff, mload(add(subject, o)))
978                     mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))
979                     if iszero(o) { break }
980                 }
981                 result := mload(0x40)
982                 mstore(result, length) // Store the length.
983                 let last := add(add(result, 0x20), length)
984                 mstore(last, 0) // Zeroize the slot after the string.
985                 mstore(0x40, add(last, 0x20)) // Allocate the memory.
986             }
987         }
988     }



```

```
LibString.repeat(string,uint256) (LlamaPolicyMetadata.sol#739-769) is never used and should be removed



    
739     function repeat(string memory subject, uint256 times)
740         internal
741         pure
742         returns (string memory result)
743     {
744         /// @solidity memory-safe-assembly
745         assembly {
746             let subjectLength := mload(subject)
747             if iszero(or(iszero(times), iszero(subjectLength))) {
748                 subject := add(subject, 0x20)
749                 result := mload(0x40)
750                 let output := add(result, 0x20)
751                 for {} 1 {} {
752                     // Copy the `subject` one word at a time.
753                     for { let o := 0 } 1 {} {
754                         mstore(add(output, o), mload(add(subject, o)))
755                         o := add(o, 0x20)
756                         if iszero(lt(o, subjectLength)) { break }
757                     }
758                     output := add(output, subjectLength)
759                     times := sub(times, 1)
760                     if iszero(times) { break }
761                 }
762                 mstore(output, 0) // Zeroize the slot after the string.
763                 let resultLength := sub(output, add(result, 0x20))
764                 mstore(result, resultLength) // Store the length.
765                 // Allocate the memory.
766                 mstore(0x40, add(result, add(resultLength, 0x20)))
767             }
768         }
769     }



```

### LlamaRelativeQuorum.sol


```
LibString.indexOf(string,string) (LlamaRelativeQuorum.sol#1241-1247) is never used and should be removed



    
1241     function indexOf(string memory subject, string memory search)
1242         internal
1243         pure
1244         returns (uint256 result)
1245     {
1246         result = indexOf(subject, search, 0);
1247     }



```

```
Initializable._isInitializing() (LlamaRelativeQuorum.sol#182-184) is never used and should be removed



    
182     function _isInitializing() internal view returns (bool) {
183         return _initializing;
184     }



```

```
FixedPointMathLib.unsafeMod(uint256,uint256) (LlamaRelativeQuorum.sol#412-419) is never used and should be removed



    
412     function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {
413         /// @solidity memory-safe-assembly
414         assembly {
415             // Mod x by y. Note this will return
416             // 0 instead of reverting if y is zero.
417             z := mod(x, y)
418         }
419     }



```

```
LibString.indexOf(string,string,uint256) (LlamaRelativeQuorum.sol#1183-1236) is never used and should be removed



    
1183     function indexOf(string memory subject, string memory search, uint256 from)
1184         internal
1185         pure
1186         returns (uint256 result)
1187     {
1188         /// @solidity memory-safe-assembly
1189         assembly {
1190             for { let subjectLength := mload(subject) } 1 {} {
1191                 if iszero(mload(search)) {
1192                     if iszero(gt(from, subjectLength)) {
1193                         result := from
1194                         break
1195                     }
1196                     result := subjectLength
1197                     break
1198                 }
1199                 let searchLength := mload(search)
1200                 let subjectStart := add(subject, 0x20)
1201 
1202                 result := not(0) // Initialize to `NOT_FOUND`.
1203 
1204                 subject := add(subjectStart, from)
1205                 let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)
1206 
1207                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
1208                 let s := mload(add(search, 0x20))
1209 
1210                 if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }
1211 
1212                 if iszero(lt(searchLength, 0x20)) {
1213                     for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
1214                         if iszero(shr(m, xor(mload(subject), s))) {
1215                             if eq(keccak256(subject, searchLength), h) {
1216                                 result := sub(subject, subjectStart)
1217                                 break
1218                             }
1219                         }
1220                         subject := add(subject, 1)
1221                         if iszero(lt(subject, end)) { break }
1222                     }
1223                     break
1224                 }
1225                 for {} 1 {} {
1226                     if iszero(shr(m, xor(mload(subject), s))) {
1227                         result := sub(subject, subjectStart)
1228                         break
1229                     }
1230                     subject := add(subject, 1)
1231                     if iszero(lt(subject, end)) { break }
1232                 }
1233                 break
1234             }
1235         }
1236     }



```

```
FixedPointMathLib.rpow(uint256,uint256,uint256) (LlamaRelativeQuorum.sol#254-341) is never used and should be removed



    
254     function rpow(
255         uint256 x,
256         uint256 n,
257         uint256 scalar
258     ) internal pure returns (uint256 z) {
259         /// @solidity memory-safe-assembly
260         assembly {
261             switch x
262             case 0 {
263                 switch n
264                 case 0 {
265                     // 0 ** 0 = 1
266                     z := scalar
267                 }
268                 default {
269                     // 0 ** n = 0
270                     z := 0
271                 }
272             }
273             default {
274                 switch mod(n, 2)
275                 case 0 {
276                     // If n is even, store scalar in z for now.
277                     z := scalar
278                 }
279                 default {
280                     // If n is odd, store x in z for now.
281                     z := x
282                 }
283 
284                 // Shifting right by 1 is like dividing by 2.
285                 let half := shr(1, scalar)
286 
287                 for {
288                     // Shift n right by 1 before looping to halve it.
289                     n := shr(1, n)
290                 } n {
291                     // Shift n right by 1 each iteration to halve it.
292                     n := shr(1, n)
293                 } {
294                     // Revert immediately if x ** 2 would overflow.
295                     // Equivalent to iszero(eq(div(xx, x), x)) here.
296                     if shr(128, x) {
297                         revert(0, 0)
298                     }
299 
300                     // Store x squared.
301                     let xx := mul(x, x)
302 
303                     // Round to the nearest number.
304                     let xxRound := add(xx, half)
305 
306                     // Revert if xx + half overflowed.
307                     if lt(xxRound, xx) {
308                         revert(0, 0)
309                     }
310 
311                     // Set x to scaled xxRound.
312                     x := div(xxRound, scalar)
313 
314                     // If n is even:
315                     if mod(n, 2) {
316                         // Compute z * x.
317                         let zx := mul(z, x)
318 
319                         // If z * x overflowed:
320                         if iszero(eq(div(zx, x), z)) {
321                             // Revert if x is non-zero.
322                             if iszero(iszero(x)) {
323                                 revert(0, 0)
324                             }
325                         }
326 
327                         // Round to the nearest number.
328                         let zxRound := add(zx, half)
329 
330                         // Revert if zx + half overflowed.
331                         if lt(zxRound, zx) {
332                             revert(0, 0)
333                         }
334 
335                         // Return properly scaled zxRound.
336                         z := div(zxRound, scalar)
337                     }
338                 }
339             }
340         }
341     }



```

```
Clones.predictDeterministicAddress(address,bytes32) (LlamaRelativeQuorum.sol#575-580) is never used and should be removed



    
575     function predictDeterministicAddress(
576         address implementation,
577         bytes32 salt
578     ) internal view returns (address predicted) {
579         return predictDeterministicAddress(implementation, salt, address(this));
580     }



```

```
LibString.toHexString(bytes) (LlamaRelativeQuorum.sol#1014-1023) is never used and should be removed



    
1014     function toHexString(bytes memory raw) internal pure returns (string memory str) {
1015         str = toHexStringNoPrefix(raw);
1016         /// @solidity memory-safe-assembly
1017         assembly {
1018             let strLength := add(mload(str), 2) // Compute the length.
1019             mstore(str, 0x3078) // Write the "0x" prefix.
1020             str := sub(str, 2) // Move the pointer.
1021             mstore(str, strLength) // Write the length.
1022         }
1023     }



```

```
LibString.toHexString(uint256,uint256) (LlamaRelativeQuorum.sol#788-797) is never used and should be removed



    
788     function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {
789         str = toHexStringNoPrefix(value, length);
790         /// @solidity memory-safe-assembly
791         assembly {
792             let strLength := add(mload(str), 2) // Compute the length.
793             mstore(str, 0x3078) // Write the "0x" prefix.
794             str := sub(str, 2) // Move the pointer.
795             mstore(str, strLength) // Write the length.
796         }
797     }



```

```
LibString.escapeJSON(string) (LlamaRelativeQuorum.sol#1645-1691) is never used and should be removed



    
1645     function escapeJSON(string memory s) internal pure returns (string memory result) {
1646         /// @solidity memory-safe-assembly
1647         assembly {
1648             for {
1649                 let end := add(s, mload(s))
1650                 result := add(mload(0x40), 0x20)
1651                 // Store "\\u0000" in scratch space.
1652                 // Store "0123456789abcdef" in scratch space.
1653                 // Also, store `{0x08:"b", 0x09:"t", 0x0a:"n", 0x0c:"f", 0x0d:"r"}`.
1654                 // into the scratch space.
1655                 mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)
1656                 // Bitmask for detecting `["\"","\\"]`.
1657                 let e := or(shl(0x22, 1), shl(0x5c, 1))
1658             } iszero(eq(s, end)) {} {
1659                 s := add(s, 1)
1660                 let c := and(mload(s), 0xff)
1661                 if iszero(lt(c, 0x20)) {
1662                     if iszero(and(shl(c, 1), e)) {
1663                         // Not in `["\"","\\"]`.
1664                         mstore8(result, c)
1665                         result := add(result, 1)
1666                         continue
1667                     }
1668                     mstore8(result, 0x5c) // "\\".
1669                     mstore8(add(result, 1), c)
1670                     result := add(result, 2)
1671                     continue
1672                 }
1673                 if iszero(and(shl(c, 1), 0x3700)) {
1674                     // Not in `["\b","\t","\n","\f","\d"]`.
1675                     mstore8(0x1d, mload(shr(4, c))) // Hex value.
1676                     mstore8(0x1e, mload(and(c, 15))) // Hex value.
1677                     mstore(result, mload(0x19)) // "\\u00XX".
1678                     result := add(result, 6)
1679                     continue
1680                 }
1681                 mstore8(result, 0x5c) // "\\".
1682                 mstore8(add(result, 1), mload(add(c, 8)))
1683                 result := add(result, 2)
1684             }
1685             let last := result
1686             mstore(last, 0) // Zeroize the slot after the string.
1687             result := mload(0x40)
1688             mstore(result, sub(last, add(result, 0x20))) // Store the length.
1689             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1690         }
1691     }



```

```
LibString.toHexStringNoPrefix(bytes) (LlamaRelativeQuorum.sol#1027-1049) is never used and should be removed



    
1027     function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {
1028         /// @solidity memory-safe-assembly
1029         assembly {
1030             let length := mload(raw)
1031             str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.
1032             mstore(str, add(length, length)) // Store the length of the output.
1033 
1034             // Store "0123456789abcdef" in scratch space.
1035             mstore(0x0f, 0x30313233343536373839616263646566)
1036 
1037             let o := add(str, 0x20)
1038             let end := add(raw, length)
1039 
1040             for {} iszero(eq(raw, end)) {} {
1041                 raw := add(raw, 1)
1042                 mstore8(add(o, 1), mload(and(mload(raw), 15)))
1043                 mstore8(o, mload(and(shr(4, mload(raw)), 15)))
1044                 o := add(o, 2)
1045             }
1046             mstore(o, 0) // Zeroize the slot after the string.
1047             mstore(0x40, add(o, 0x20)) // Allocate the memory.
1048         }
1049     }



```

```
LibString.lastIndexOf(string,string) (LlamaRelativeQuorum.sol#1289-1295) is never used and should be removed



    
1289     function lastIndexOf(string memory subject, string memory search)
1290         internal
1291         pure
1292         returns (uint256 result)
1293     {
1294         result = lastIndexOf(subject, search, uint256(int256(-1)));
1295     }



```

```
LibString.startsWith(string,string) (LlamaRelativeQuorum.sol#1298-1316) is never used and should be removed



    
1298     function startsWith(string memory subject, string memory search)
1299         internal
1300         pure
1301         returns (bool result)
1302     {
1303         /// @solidity memory-safe-assembly
1304         assembly {
1305             let searchLength := mload(search)
1306             // Just using keccak256 directly is actually cheaper.
1307             // forgefmt: disable-next-item
1308             result := and(
1309                 iszero(gt(searchLength, mload(subject))),
1310                 eq(
1311                     keccak256(add(subject, 0x20), searchLength),
1312                     keccak256(add(search, 0x20), searchLength)
1313                 )
1314             )
1315         }
1316     }



```

```
FixedPointMathLib.unsafeDiv(uint256,uint256) (LlamaRelativeQuorum.sol#421-428) is never used and should be removed



    
421     function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {
422         /// @solidity memory-safe-assembly
423         assembly {
424             // Divide x by y. Note this will return
425             // 0 instead of reverting if y is zero.
426             r := div(x, y)
427         }
428     }



```

```
LibString.lastIndexOf(string,string,uint256) (LlamaRelativeQuorum.sol#1252-1284) is never used and should be removed



    
1252     function lastIndexOf(string memory subject, string memory search, uint256 from)
1253         internal
1254         pure
1255         returns (uint256 result)
1256     {
1257         /// @solidity memory-safe-assembly
1258         assembly {
1259             for {} 1 {} {
1260                 result := not(0) // Initialize to `NOT_FOUND`.
1261                 let searchLength := mload(search)
1262                 if gt(searchLength, mload(subject)) { break }
1263                 let w := result
1264 
1265                 let fromMax := sub(mload(subject), searchLength)
1266                 if iszero(gt(fromMax, from)) { from := fromMax }
1267 
1268                 let end := add(add(subject, 0x20), w)
1269                 subject := add(add(subject, 0x20), from)
1270                 if iszero(gt(subject, end)) { break }
1271                 // As this function is not too often used,
1272                 // we shall simply use keccak256 for smaller bytecode size.
1273                 for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
1274                     if eq(keccak256(subject, searchLength), h) {
1275                         result := sub(subject, add(end, 1))
1276                         break
1277                     }
1278                     subject := add(subject, w) // `sub(subject, 1)`.
1279                     if iszero(gt(subject, end)) { break }
1280                 }
1281                 break
1282             }
1283         }
1284     }



```

```
LibString.toString(int256) (LlamaRelativeQuorum.sol#761-777) is never used and should be removed



    
761     function toString(int256 value) internal pure returns (string memory str) {
762         if (value >= 0) {
763             return toString(uint256(value));
764         }
765         unchecked {
766             str = toString(uint256(-value));
767         }
768         /// @solidity memory-safe-assembly
769         assembly {
770             // We still have some spare memory space on the left,
771             // as we have allocated 3 words (96 bytes) for up to 78 digits.
772             let length := mload(str) // Load the string length.
773             mstore(str, 0x2d) // Store the '-' character.
774             str := sub(str, 1) // Move back the string pointer by a byte.
775             mstore(str, add(length, 1)) // Update the string length.
776         }
777     }



```

```
Clones.predictDeterministicAddress(address,bytes32,address) (LlamaRelativeQuorum.sol#554-570) is never used and should be removed



    
554     function predictDeterministicAddress(
555         address implementation,
556         bytes32 salt,
557         address deployer
558     ) internal pure returns (address predicted) {
559         /// @solidity memory-safe-assembly
560         assembly {
561             let ptr := mload(0x40)
562             mstore(add(ptr, 0x38), deployer)
563             mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)
564             mstore(add(ptr, 0x14), implementation)
565             mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)
566             mstore(add(ptr, 0x58), salt)
567             mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))
568             predicted := keccak256(add(ptr, 0x43), 0x55)
569         }
570     }



```

```
LibString.directReturn(string) (LlamaRelativeQuorum.sol#1787-1800) is never used and should be removed



    
1787     function directReturn(string memory a) internal pure {
1788         assembly {
1789             // Assumes that the string does not start from the scratch space.
1790             let retStart := sub(a, 0x20)
1791             let retSize := add(mload(a), 0x40)
1792             // Right pad with zeroes. Just in case the string is produced
1793             // by a method that doesn't zero right pad.
1794             mstore(add(retStart, retSize), 0)
1795             // Store the return offset.
1796             mstore(retStart, 0x20)
1797             // End the transaction, returning the string.
1798             return(retStart, retSize)
1799         }
1800     }



```

```
LibString.toMinimalHexStringNoPrefix(uint256) (LlamaRelativeQuorum.sol#888-897) is never used and should be removed



    
888     function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {
889         str = toHexStringNoPrefix(value);
890         /// @solidity memory-safe-assembly
891         assembly {
892             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
893             let strLength := mload(str) // Get the length.
894             str := add(str, o) // Move the pointer, accounting for leading zero.
895             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
896         }
897     }



```

```
LibString.toMinimalHexString(uint256) (LlamaRelativeQuorum.sol#873-883) is never used and should be removed



    
873     function toMinimalHexString(uint256 value) internal pure returns (string memory str) {
874         str = toHexStringNoPrefix(value);
875         /// @solidity memory-safe-assembly
876         assembly {
877             let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.
878             let strLength := add(mload(str), 2) // Compute the length.
879             mstore(add(str, o), 0x3078) // Write the "0x" prefix, accounting for leading zero.
880             str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.
881             mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.
882         }
883     }



```

```
FixedPointMathLib.divWadDown(uint256,uint256) (LlamaRelativeQuorum.sol#207-209) is never used and should be removed



    
207     function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {
208         return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.
209     }



```

```
FixedPointMathLib.mulWadUp(uint256,uint256) (LlamaRelativeQuorum.sol#203-205) is never used and should be removed



    
203     function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {
204         return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.
205     }



```

```
LibString.toHexString(uint256) (LlamaRelativeQuorum.sol#858-867) is never used and should be removed



    
858     function toHexString(uint256 value) internal pure returns (string memory str) {
859         str = toHexStringNoPrefix(value);
860         /// @solidity memory-safe-assembly
861         assembly {
862             let strLength := add(mload(str), 2) // Compute the length.
863             mstore(str, 0x3078) // Write the "0x" prefix.
864             str := sub(str, 2) // Move the pointer.
865             mstore(str, strLength) // Write the length.
866         }
867     }



```

```
ERC721NonTransferableMinimalProxy._safeMint(address,uint256,bytes) (LlamaRelativeQuorum.sol#2255-2264) is never used and should be removed



    
2255   function _safeMint(address to, uint256 id, bytes memory data) internal virtual {
2256     _mint(to, id);
2257 
2258     require(
2259       to.code.length == 0
2260         || ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data)
2261           == ERC721TokenReceiver.onERC721Received.selector,
2262       "UNSAFE_RECIPIENT"
2263     );
2264   }



```

```
LibString.indicesOf(string,string) (LlamaRelativeQuorum.sol#1424-1480) is never used and should be removed



    
1424     function indicesOf(string memory subject, string memory search)
1425         internal
1426         pure
1427         returns (uint256[] memory result)
1428     {
1429         /// @solidity memory-safe-assembly
1430         assembly {
1431             let subjectLength := mload(subject)
1432             let searchLength := mload(search)
1433 
1434             if iszero(gt(searchLength, subjectLength)) {
1435                 subject := add(subject, 0x20)
1436                 search := add(search, 0x20)
1437                 result := add(mload(0x40), 0x20)
1438 
1439                 let subjectStart := subject
1440                 let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)
1441                 let h := 0
1442                 if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
1443                 let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
1444                 let s := mload(search)
1445                 for {} 1 {} {
1446                     let t := mload(subject)
1447                     // Whether the first `searchLength % 32` bytes of
1448                     // `subject` and `search` matches.
1449                     if iszero(shr(m, xor(t, s))) {
1450                         if h {
1451                             if iszero(eq(keccak256(subject, searchLength), h)) {
1452                                 subject := add(subject, 1)
1453                                 if iszero(lt(subject, subjectSearchEnd)) { break }
1454                                 continue
1455                             }
1456                         }
1457                         // Append to `result`.
1458                         mstore(result, sub(subject, subjectStart))
1459                         result := add(result, 0x20)
1460                         // Advance `subject` by `searchLength`.
1461                         subject := add(subject, searchLength)
1462                         if searchLength {
1463                             if iszero(lt(subject, subjectSearchEnd)) { break }
1464                             continue
1465                         }
1466                     }
1467                     subject := add(subject, 1)
1468                     if iszero(lt(subject, subjectSearchEnd)) { break }
1469                 }
1470                 let resultEnd := result
1471                 // Assign `result` to the free memory pointer.
1472                 result := mload(0x40)
1473                 // Store the length of `result`.
1474                 mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))
1475                 // Allocate memory for result.
1476                 // We allocate one more word, so this array can be recycled for {split}.
1477                 mstore(0x40, add(resultEnd, 0x20))
1478             }
1479         }
1480     }



```

```
Initializable._checkInitializing() (LlamaRelativeQuorum.sol#148-152) is never used and should be removed



    
148     function _checkInitializing() internal view virtual {
149         if (!_initializing) {
150             revert NotInitializing();
151         }
152     }



```

```
FixedPointMathLib.mulDivDown(uint256,uint256,uint256) (LlamaRelativeQuorum.sol#219-234) is never used and should be removed



    
219     function mulDivDown(
220         uint256 x,
221         uint256 y,
222         uint256 denominator
223     ) internal pure returns (uint256 z) {
224         /// @solidity memory-safe-assembly
225         assembly {
226             // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))
227             if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {
228                 revert(0, 0)
229             }
230 
231             // Divide x * y by the denominator.
232             z := div(mul(x, y), denominator)
233         }
234     }



```

```
LibString.unpackOne(bytes32) (LlamaRelativeQuorum.sol#1721-1735) is never used and should be removed



    
1721     function unpackOne(bytes32 packed) internal pure returns (string memory result) {
1722         /// @solidity memory-safe-assembly
1723         assembly {
1724             // Grab the free memory pointer.
1725             result := mload(0x40)
1726             // Allocate 2 words (1 for the length, 1 for the bytes).
1727             mstore(0x40, add(result, 0x40))
1728             // Zeroize the length slot.
1729             mstore(result, 0)
1730             // Store the length and bytes.
1731             mstore(add(result, 0x1f), packed)
1732             // Right pad with zeroes.
1733             mstore(add(add(result, 0x20), mload(result)), 0)
1734         }
1735     }



```

```
LibString.toString(uint256) (LlamaRelativeQuorum.sol#723-758) is never used and should be removed



    
723     function toString(uint256 value) internal pure returns (string memory str) {
724         /// @solidity memory-safe-assembly
725         assembly {
726             // The maximum value of a uint256 contains 78 digits (1 byte per digit), but
727             // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.
728             // We will need 1 word for the trailing zeros padding, 1 word for the length,
729             // and 3 words for a maximum of 78 digits.
730             str := add(mload(0x40), 0x80)
731             // Update the free memory pointer to allocate.
732             mstore(0x40, add(str, 0x20))
733             // Zeroize the slot after the string.
734             mstore(str, 0)
735 
736             // Cache the end of the memory to calculate the length later.
737             let end := str
738 
739             let w := not(0) // Tsk.
740             // We write the string from rightmost digit to leftmost digit.
741             // The following is essentially a do-while loop that also handles the zero case.
742             for { let temp := value } 1 {} {
743                 str := add(str, w) // `sub(str, 1)`.
744                 // Write the character to the pointer.
745                 // The ASCII index of the '0' character is 48.
746                 mstore8(str, add(48, mod(temp, 10)))
747                 // Keep dividing `temp` until zero.
748                 temp := div(temp, 10)
749                 if iszero(temp) { break }
750             }
751 
752             let length := sub(end, str)
753             // Move the pointer 32 bytes leftwards to make room for the length.
754             str := sub(str, 0x20)
755             // Store the length.
756             mstore(str, length)
757         }
758     }



```

```
ERC721NonTransferableMinimalProxy._safeMint(address,uint256) (LlamaRelativeQuorum.sol#2244-2253) is never used and should be removed



    
2244   function _safeMint(address to, uint256 id) internal virtual {
2245     _mint(to, id);
2246 
2247     require(
2248       to.code.length == 0
2249         || ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "")
2250           == ERC721TokenReceiver.onERC721Received.selector,
2251       "UNSAFE_RECIPIENT"
2252     );
2253   }



```

```
LibString.packOne(string) (LlamaRelativeQuorum.sol#1702-1716) is never used and should be removed



    
1702     function packOne(string memory a) internal pure returns (bytes32 result) {
1703         /// @solidity memory-safe-assembly
1704         assembly {
1705             // We don't need to zero right pad the string,
1706             // since this is our own custom non-standard packing scheme.
1707             result :=
1708                 mul(
1709                     // Load the length and the bytes.
1710                     mload(add(a, 0x1f)),
1711                     // `length != 0 && length < 32`. Abuses underflow.
1712                     // Assumes that the length is valid and within the block gas limit.
1713                     lt(sub(mload(a), 1), 0x1f)
1714                 )
1715         }
1716     }



```

```
LibString.runeCount(string) (LlamaRelativeQuorum.sol#1056-1070) is never used and should be removed



    
1056     function runeCount(string memory s) internal pure returns (uint256 result) {
1057         /// @solidity memory-safe-assembly
1058         assembly {
1059             if mload(s) {
1060                 mstore(0x00, div(not(0), 255))
1061                 mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)
1062                 let o := add(s, 0x20)
1063                 let end := add(o, mload(s))
1064                 for { result := 1 } 1 { result := add(result, 1) } {
1065                     o := add(o, byte(0, mload(shr(250, mload(o)))))
1066                     if iszero(lt(o, end)) { break }
1067                 }
1068             }
1069         }
1070     }



```

```
LibString.unpackTwo(bytes32) (LlamaRelativeQuorum.sol#1762-1784) is never used and should be removed



    
1762     function unpackTwo(bytes32 packed)
1763         internal
1764         pure
1765         returns (string memory resultA, string memory resultB)
1766     {
1767         /// @solidity memory-safe-assembly
1768         assembly {
1769             // Grab the free memory pointer.
1770             resultA := mload(0x40)
1771             resultB := add(resultA, 0x40)
1772             // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.
1773             mstore(0x40, add(resultB, 0x40))
1774             // Zeroize the length slots.
1775             mstore(resultA, 0)
1776             mstore(resultB, 0)
1777             // Store the lengths and bytes.
1778             mstore(add(resultA, 0x1f), packed)
1779             mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))
1780             // Right pad with zeroes.
1781             mstore(add(add(resultA, 0x20), mload(resultA)), 0)
1782             mstore(add(add(resultB, 0x20), mload(resultB)), 0)
1783         }
1784     }



```

```
LibString.endsWith(string,string) (LlamaRelativeQuorum.sol#1319-1344) is never used and should be removed



    
1319     function endsWith(string memory subject, string memory search)
1320         internal
1321         pure
1322         returns (bool result)
1323     {
1324         /// @solidity memory-safe-assembly
1325         assembly {
1326             let searchLength := mload(search)
1327             let subjectLength := mload(subject)
1328             // Whether `search` is not longer than `subject`.
1329             let withinRange := iszero(gt(searchLength, subjectLength))
1330             // Just using keccak256 directly is actually cheaper.
1331             // forgefmt: disable-next-item
1332             result := and(
1333                 withinRange,
1334                 eq(
1335                     keccak256(
1336                         // `subject + 0x20 + max(subjectLength - searchLength, 0)`.
1337                         add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),
1338                         searchLength
1339                     ),
1340                     keccak256(add(search, 0x20), searchLength)
1341                 )
1342             )
1343         }
1344     }



```

```
FixedPointMathLib.divWadUp(uint256,uint256) (LlamaRelativeQuorum.sol#211-213) is never used and should be removed



    
211     function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {
212         return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.
213     }



```

```
LibString.escapeHTML(string) (LlamaRelativeQuorum.sol#1611-1642) is never used and should be removed



    
1611     function escapeHTML(string memory s) internal pure returns (string memory result) {
1612         /// @solidity memory-safe-assembly
1613         assembly {
1614             for {
1615                 let end := add(s, mload(s))
1616                 result := add(mload(0x40), 0x20)
1617                 // Store the bytes of the packed offsets and strides into the scratch space.
1618                 // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.
1619                 mstore(0x1f, 0x900094)
1620                 mstore(0x08, 0xc0000000a6ab)
1621                 // Store "&quot;&amp;&#39;&lt;&gt;" into the scratch space.
1622                 mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))
1623             } iszero(eq(s, end)) {} {
1624                 s := add(s, 1)
1625                 let c := and(mload(s), 0xff)
1626                 // Not in `["\"","'","&","<",">"]`.
1627                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
1628                     mstore8(result, c)
1629                     result := add(result, 1)
1630                     continue
1631                 }
1632                 let t := shr(248, mload(c))
1633                 mstore(result, mload(and(t, 0x1f)))
1634                 result := add(result, shr(5, t))
1635             }
1636             let last := result
1637             mstore(last, 0) // Zeroize the slot after the string.
1638             result := mload(0x40)
1639             mstore(result, sub(last, add(result, 0x20))) // Store the length.
1640             mstore(0x40, add(last, 0x20)) // Allocate the memory.
1641         }
1642     }



```

```
LibString.toHexStringChecksummed(address) (LlamaRelativeQuorum.sol#943-960) is never used and should be removed



    
943     function toHexStringChecksummed(address value) internal pure returns (string memory str) {
944         str = toHexString(value);
945         /// @solidity memory-safe-assembly
946         assembly {
947             let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`
948             let o := add(str, 0x22)
949             let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `
950             let t := shl(240, 136) // `0b10001000 << 240`
951             for { let i := 0 } 1 {} {
952                 mstore(add(i, i), mul(t, byte(i, hashed)))
953                 i := add(i, 1)
954                 if eq(i, 20) { break }
955             }
956             mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))
957             o := add(o, 0x20)
958             mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))
959         }
960     }



```

```
LibString.toHexStringNoPrefix(uint256) (LlamaRelativeQuorum.sol#903-937) is never used and should be removed



    
903     function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {
904         /// @solidity memory-safe-assembly
905         assembly {
906             // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,
907             // 0x02 bytes for the prefix, and 0x40 bytes for the digits.
908             // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.
909             str := add(mload(0x40), 0x80)
910             // Allocate the memory.
911             mstore(0x40, add(str, 0x20))
912             // Zeroize the slot after the string.
913             mstore(str, 0)
914 
915             // Cache the end to calculate the length later.
916             let end := str
917             // Store "0123456789abcdef" in scratch space.
918             mstore(0x0f, 0x30313233343536373839616263646566)
919 
920             let w := not(1) // Tsk.
921             // We write the string from rightmost digit to leftmost digit.
922             // The following is essentially a do-while loop that also handles the zero case.
923             for { let temp := value } 1 {} {
924                 str := add(str, w) // `sub(str, 2)`.
925                 mstore8(add(str, 1), mload(and(temp, 15)))
926                 mstore8(str, mload(and(shr(4, temp), 15)))
927                 temp := shr(8, temp)
928                 if iszero(temp) { break }
929             }
930 
931             // Compute the string's length.
932             let strLength := sub(end, str)
933             // Move the pointer and write the length.
934             str := sub(str, 0x20)
935             mstore(str, strLength)
936         }
937     }



```

```
Clones.clone(address) (LlamaRelativeQuorum.sol#514-527) is never used and should be removed



    
514     function clone(address implementation) internal returns (address instance) {
515         /// @solidity memory-safe-assembly
516         assembly {
517             // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
518             // of the `implementation` address with the bytecode before the address.
519             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
520             // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
521             mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
522             instance := create(0, 0x09, 0x37)
523         }
524         if (instance == address(0)) {
525             revert ERC1167FailedCreateClone();
526         }
527     }



```

```
LibString.is7BitASCII(string) (LlamaRelativeQuorum.sol#1074-1096) is never used and should be removed



    
1074     function is7BitASCII(string memory s) internal pure returns (bool result) {
1075         /// @solidity memory-safe-assembly
1076         assembly {
1077             let mask := shl(7, div(not(0), 255))
1078             result := 1
1079             let n := mload(s)
1080             if n {
1081                 let o := add(s, 0x20)
1082                 let end := add(o, n)
1083                 let last := mload(end)
1084                 mstore(end, 0)
1085                 for {} 1 {} {
1086                     if and(mask, mload(o)) {
1087                         result := 0
1088                         break
1089                     }
1090                     o := add(o, 0x20)
1091                     if iszero(lt(o, end)) { break }
1092                 }
1093                 mstore(end, last)
1094             }
1095         }
1096     }



```

```
Initializable._getInitializedVersion() (LlamaRelativeQuorum.sol#175-177) is never used and should be removed



    
175     function _getInitializedVersion() internal view returns (uint8) {
176         return _initialized;
177     }



```

```
Checkpoints.length(Checkpoints.History) (LlamaRelativeQuorum.sol#1912-1914) is never used and should be removed



    
1912     function length(History storage self) internal view returns (uint256) {
1913         return self._checkpoints.length;
1914     }



```

```
FixedPointMathLib.sqrt(uint256) (LlamaRelativeQuorum.sol#347-410) is never used and should be removed



    
347     function sqrt(uint256 x) internal pure returns (uint256 z) {
348         /// @solidity memory-safe-assembly
349         assembly {
350             let y := x // We start y at x, which will help us make our initial estimate.
351 
352             z := 181 // The "correct" value is 1, but this saves a multiplication later.
353 
354             // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad
355             // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.
356 
357             // We check y >= 2^(k + 8) but shift right by k bits
358             // each branch to ensure that if x >= 256, then y >= 256.
359             if iszero(lt(y, 0x10000000000000000000000000000000000)) {
360                 y := shr(128, y)
361                 z := shl(64, z)
362             }
363             if iszero(lt(y, 0x1000000000000000000)) {
364                 y := shr(64, y)
365                 z := shl(32, z)
366             }
367             if iszero(lt(y, 0x10000000000)) {
368                 y := shr(32, y)
369                 z := shl(16, z)
370             }
371             if iszero(lt(y, 0x1000000)) {
372                 y := shr(16, y)
373                 z := shl(8, z)
374             }
375 
376             // Goal was to get z*z*y within a small factor of x. More iterations could
377             // get y in a tighter range. Currently, we will have y in [256, 256*2^16).
378             // We ensured y >= 256 so that the relative difference between y and y+1 is small.
379             // That's not possible if x < 256 but we can just verify those cases exhaustively.
380 
381             // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.
382             // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.
383             // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.
384 
385             // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range
386             // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.
387 
388             // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate
389             // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.
390 
391             // There is no overflow risk here since y < 2^136 after the first branch above.
392             z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.
393 
394             // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.
395             z := shr(1, add(z, div(x, z)))
396             z := shr(1, add(z, div(x, z)))
397             z := shr(1, add(z, div(x, z)))
398             z := shr(1, add(z, div(x, z)))
399             z := shr(1, add(z, div(x, z)))
400             z := shr(1, add(z, div(x, z)))
401             z := shr(1, add(z, div(x, z)))
402 
403             // If x+1 is a perfect square, the Babylonian method cycles between
404             // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.
405             // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division
406             // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.
407             // If you don't care whether the floor or ceil square root is returned, you can remove this statement.
408             z := sub(z, lt(div(x, z), z))
409         }
410     }



```

```
LibString.slice(string,uint256) (LlamaRelativeQuorum.sol#1414-1420) is never used and should be removed



    
1414     function slice(string memory subject, uint256 start)
1415         internal
1416         pure
1417         returns (string memory result)
1418     {
1419         result = slice(subject, start, uint256(int256(-1)));
1420     }



```

```
FixedPointMathLib.mulWadDown(uint256,uint256) (LlamaRelativeQuorum.sol#199-201) is never used and should be removed



    
199     function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {
200         return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.
201     }



```

```
LibString.concat(string,string) (LlamaRelativeQuorum.sol#1532-1566) is never used and should be removed



    
1532     function concat(string memory a, string memory b)
1533         internal
1534         pure
1535         returns (string memory result)
1536     {
1537         /// @solidity memory-safe-assembly
1538         assembly {
1539             let w := not(0x1f)
1540             result := mload(0x40)
1541             let aLength := mload(a)
1542             // Copy `a` one word at a time, backwards.
1543             for { let o := and(add(aLength, 0x20), w) } 1 {} {
1544                 mstore(add(result, o), mload(add(a, o)))
1545                 o := add(o, w) // `sub(o, 0x20)`.
1546                 if iszero(o) { break }
1547             }
1548             let bLength := mload(b)
1549             let output := add(result, aLength)
1550             // Copy `b` one word at a time, backwards.
1551             for { let o := and(add(bLength, 0x20), w) } 1 {} {
1552                 mstore(add(output, o), mload(add(b, o)))
1553                 o := add(o, w) // `sub(o, 0x20)`.
1554                 if iszero(o) { break }
1555             }
1556             let totalLength := add(aLength, bLength)
1557             let last := add(add(result, 0x20), totalLength)
1558             // Zeroize the slot after the string.
1559             mstore(last, 0)
1560             // Stores the length.
1561             mstore(result, totalLength)
1562             // Allocate memory for the length and the bytes,
1563             // rounded up to a multiple of 32.
1564             mstore(0x40, and(add(last, 0x1f), w))
1565         }
1566     }



```

```
LibString.toHexStringNoPrefix(uint256,uint256) (LlamaRelativeQuorum.sol#804-852) is never used and should be removed



    
804     function toHexStringNoPrefix(uint256 value, uint256 length)
805         internal
806         pure
807         returns (string memory str)
808     {
809         /// @solidity memory-safe-assembly
810         assembly {
811             // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes
812             // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.
813             // We add 0x20 to the total and round down to a multiple of 0x20.
814             // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.
815             str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))
816             // Allocate the memory.
817             mstore(0x40, add(str, 0x20))
818             // Zeroize the slot after the string.
819             mstore(str, 0)
820 
821             // Cache the end to calculate the length later.
822             let end := str
823             // Store "0123456789abcdef" in scratch space.
824             mstore(0x0f, 0x30313233343536373839616263646566)
825 
826             let start := sub(str, add(length, length))
827             let w := not(1) // Tsk.
828             let temp := value
829             // We write the string from rightmost digit to leftmost digit.
830             // The following is essentially a do-while loop that also handles the zero case.
831             for {} 1 {} {
832                 str := add(str, w) // `sub(str, 2)`.
833                 mstore8(add(str, 1), mload(and(temp, 15)))
834                 mstore8(str, mload(and(shr(4, temp), 15)))
835                 temp := shr(8, temp)
836                 if iszero(xor(str, start)) { break }
837             }
838 
839             if temp {
840                 // Store the function selector of `HexLengthInsufficient()`.
841                 mstore(0x00, 0x2194895a)
842                 // Revert with (offset, size).
843                 revert(0x1c, 0x04)
844             }
845 
846             // Compute the string's length.
847             let strLength := sub(end, str)
848             // Move the pointer and write the length.
849             str := sub(str, 0x20)
850             mstore(str, strLength)
851         }
852     }



```

```
Checkpoints._lowerBinaryLookup(Checkpoints.Checkpoint[],uint64,uint256,uint256) (LlamaRelativeQuorum.sol#1981-1996) is never used and should be removed



    
1981     function _lowerBinaryLookup(
1982         Checkpoint[] storage self,
1983         uint64 timestamp,
1984         uint256 low,
1985         uint256 high
1986     ) private view returns (uint256) {
1987         while (low < high) {
1988             uint256 mid = average(low, high);
1989             if (_unsafeAccess(self, mid).timestamp < timestamp) {
1990                 low = mid + 1;
1991             } else {
1992                 high = mid;
1993             }
1994         }
1995         return high;
1996     }



```

```
LibString.split(string,string) (LlamaRelativeQuorum.sol#1483-1528) is never used and should be removed



    
1483     function split(string memory subject, string memory delimiter)
1484         internal
1485         pure
1486         returns (string[] memory result)
1487     {
1488         uint256[] memory indices = indicesOf(subject, delimiter);
1489         /// @solidity memory-safe-assembly
1490         assembly {
1491             let w := not(0x1f)
1492             let indexPtr := add(indices, 0x20)
1493             let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))
1494             mstore(add(indicesEnd, w), mload(subject))
1495             mstore(indices, add(mload(indices), 1))
1496             let prevIndex := 0
1497             for {} 1 {} {
1498                 let index := mload(indexPtr)
1499                 mstore(indexPtr, 0x60)
1500                 if iszero(eq(index, prevIndex)) {
1501                     let element := mload(0x40)
1502                     let elementLength := sub(index, prevIndex)
1503                     mstore(element, elementLength)
1504                     // Copy the `subject` one word at a time, backwards.
1505                     for { let o := and(add(elementLength, 0x1f), w) } 1 {} {
1506                         mstore(add(element, o), mload(add(add(subject, prevIndex), o)))
1507                         o := add(o, w) // `sub(o, 0x20)`.
1508                         if iszero(o) { break }
1509                     }
1510                     // Zeroize the slot after the string.
1511                     mstore(add(add(element, 0x20), elementLength), 0)
1512                     // Allocate memory for the length and the bytes,
1513                     // rounded up to a multiple of 32.
1514                     mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))
1515                     // Store the `element` into the array.
1516                     mstore(indexPtr, element)
1517                 }
1518                 prevIndex := add(index, mload(delimiter))
1519                 indexPtr := add(indexPtr, 0x20)
1520                 if iszero(lt(indexPtr, indicesEnd)) { break }
1521             }
1522             result := indices
1523             if iszero(mload(delimiter)) {
1524                 result := add(indices, 0x20)
1525                 mstore(result, sub(mload(indices), 2))
1526             }
1527         }
1528     }



```

```
LibString.lower(string) (LlamaRelativeQuorum.sol#1600-1602) is never used and should be removed



    
1600     function lower(string memory subject) internal pure returns (string memory result) {
1601         result = toCase(subject, false);
1602     }



```

```
LibString.packTwo(string,string) (LlamaRelativeQuorum.sol#1739-1757) is never used and should be removed



    
1739     function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {
1740         /// @solidity memory-safe-assembly
1741         assembly {
1742             let aLength := mload(a)
1743             // We don't need to zero right pad the strings,
1744             // since this is our own custom non-standard packing scheme.
1745             result :=
1746                 mul(
1747                     // Load the length and the bytes of `a` and `b`.
1748                     or(
1749                         shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),
1750                         mload(sub(add(b, 0x1e), aLength))
1751                     ),
1752                     // `totalLength != 0 && totalLength < 31`. Abuses underflow.
1753                     // Assumes that the lengths are valid and within the block gas limit.
1754                     lt(sub(add(aLength, mload(b)), 1), 0x1e)
1755                 )
1756         }
1757     }



```

```
LibString.eq(string,string) (LlamaRelativeQuorum.sol#1694-1698) is never used and should be removed



    
1694     function eq(string memory a, string memory b) internal pure returns (bool result) {
1695         assembly {
1696             result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))
1697         }
1698     }



```

```
FixedPointMathLib.unsafeDivUp(uint256,uint256) (LlamaRelativeQuorum.sol#430-437) is never used and should be removed



    
430     function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {
431         /// @solidity memory-safe-assembly
432         assembly {
433             // Add 1 to x * y if x % y > 0. Note this will
434             // return 0 instead of reverting if y is zero.
435             z := add(gt(mod(x, y), 0), div(x, y))
436         }
437     }



```

```
LibString.repeat(string,uint256) (LlamaRelativeQuorum.sol#1347-1377) is never used and should be removed



    
1347     function repeat(string memory subject, uint256 times)
1348         internal
1349         pure
1350         returns (string memory result)
1351     {
1352         /// @solidity memory-safe-assembly
1353         assembly {
1354             let subjectLength := mload(subject)
1355             if iszero(or(iszero(times), iszero(subjectLength))) {
1356                 subject := add(subject, 0x20)
1357                 result := mload(0x40)
1358                 let output := add(result, 0x20)
1359                 for {} 1 {} {
1360                     // Copy the `subject` one word at a time.
1361                     for { let o := 0 } 1 {} {
1362                         mstore(add(output, o), mload(add(subject, o)))
1363                         o := add(o, 0x20)
1364                         if iszero(lt(o, subjectLength)) { break }
1365                     }
1366                     output := add(output, subjectLength)
1367                     times := sub(times, 1)
1368                     if iszero(times) { break }
1369                 }
1370                 mstore(output, 0) // Zeroize the slot after the string.
1371                 let resultLength := sub(output, add(result, 0x20))
1372                 mstore(result, resultLength) // Store the length.
1373                 // Allocate the memory.
1374                 mstore(0x40, add(result, add(resultLength, 0x20)))
1375             }
1376         }
1377     }



```

## solc-version
### Severity: Informational

### LlamaAbsolutePeerReview.sol


```
solc-0.8.19 is not recommended for deployment



```

```
Pragma version0.8.19 (LlamaAbsolutePeerReview.sol#2) necessitates a version too recent to be trusted. Consider deploying with 0.8.18.



    
2 pragma solidity 0.8.19;



```

### LlamaAbsoluteQuorum.sol


```
solc-0.8.19 is not recommended for deployment



```

```
Pragma version0.8.19 (LlamaAbsoluteQuorum.sol#2) necessitates a version too recent to be trusted. Consider deploying with 0.8.18.



    
2 pragma solidity 0.8.19;



```

### LlamaAccount.sol


```
solc-0.8.19 is not recommended for deployment



```

```
Pragma version0.8.19 (LlamaAccount.sol#2) necessitates a version too recent to be trusted. Consider deploying with 0.8.18.



    
2 pragma solidity 0.8.19;



```

### LlamaCore.sol


```
solc-0.8.19 is not recommended for deployment



```

```
Pragma version0.8.19 (LlamaCore.sol#2) necessitates a version too recent to be trusted. Consider deploying with 0.8.18.



    
2 pragma solidity 0.8.19;



```

### LlamaExecutor.sol


```
solc-0.8.19 is not recommended for deployment



```

```
Pragma version0.8.19 (LlamaExecutor.sol#2) necessitates a version too recent to be trusted. Consider deploying with 0.8.18.



    
2 pragma solidity 0.8.19;



```

### LlamaFactory.sol


```
solc-0.8.19 is not recommended for deployment



```

```
Pragma version0.8.19 (LlamaFactory.sol#2) necessitates a version too recent to be trusted. Consider deploying with 0.8.18.



    
2 pragma solidity 0.8.19;



```

### LlamaGovernanceScript.sol


```
solc-0.8.19 is not recommended for deployment



```

```
Pragma version^0.8.19 (LlamaGovernanceScript.sol#2) necessitates a version too recent to be trusted. Consider deploying with 0.8.18.



    
2 pragma solidity ^0.8.19;



```

### LlamaPolicy.sol


```
solc-0.8.19 is not recommended for deployment



```

```
Pragma version0.8.19 (LlamaPolicy.sol#2) necessitates a version too recent to be trusted. Consider deploying with 0.8.18.



    
2 pragma solidity 0.8.19;



```

### LlamaPolicyMetadata.sol


```
solc-0.8.19 is not recommended for deployment



```

```
Pragma version0.8.19 (LlamaPolicyMetadata.sol#2) necessitates a version too recent to be trusted. Consider deploying with 0.8.18.



    
2 pragma solidity 0.8.19;



```

### LlamaPolicyMetadataParamRegistry.sol


```
solc-0.8.19 is not recommended for deployment



```

```
Pragma version0.8.19 (LlamaPolicyMetadataParamRegistry.sol#2) necessitates a version too recent to be trusted. Consider deploying with 0.8.18.



    
2 pragma solidity 0.8.19;



```

### LlamaRelativeQuorum.sol


```
solc-0.8.19 is not recommended for deployment



```

```
Pragma version0.8.19 (LlamaRelativeQuorum.sol#2) necessitates a version too recent to be trusted. Consider deploying with 0.8.18.



    
2 pragma solidity 0.8.19;



```

## low-level-calls
### Severity: Informational

### LlamaAbsolutePeerReview.sol


```
Low level call in LlamaExecutor.execute(address,uint256,bool,bytes) (LlamaAbsolutePeerReview.sol#688-694):
	- (success,result) = target.delegatecall(data) (LlamaAbsolutePeerReview.sol#693)
	- (success,result) = target.call{value: value}(data) (LlamaAbsolutePeerReview.sol#693)



    
693     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



    
693     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



```

### LlamaAbsoluteQuorum.sol


```
Low level call in LlamaExecutor.execute(address,uint256,bool,bytes) (LlamaAbsoluteQuorum.sol#688-694):
	- (success,result) = target.delegatecall(data) (LlamaAbsoluteQuorum.sol#693)
	- (success,result) = target.call{value: value}(data) (LlamaAbsoluteQuorum.sol#693)



    
693     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



    
693     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



```

### LlamaAccount.sol


```
Low level call in LlamaAccount.execute(address,bool,bytes) (LlamaAccount.sol#5213-5247):
	- (success,result) = target.delegatecall(callData) (LlamaAccount.sol#5239)
	- (success,result) = target.call{value: msg.value}(callData) (LlamaAccount.sol#5242)



    
5239       (success, result) = target.delegatecall(callData);



    
5242       (success, result) = target.call{value: msg.value}(callData);



```

```
Low level call in Address.functionStaticCall(address,bytes,function()) (LlamaAccount.sol#454-461):
	- (success,returndata) = target.staticcall(data) (LlamaAccount.sol#459)



    
459         (bool success, bytes memory returndata) = target.staticcall(data);



```

```
Low level call in Address.sendValue(address,uint256) (LlamaAccount.sol#361-370):
	- (success) = recipient.call{value: amount}() (LlamaAccount.sol#366)



    
366         (bool success, ) = recipient.call{value: amount}("");



```

```
Low level call in Address.functionCallWithValue(address,bytes,uint256,function()) (LlamaAccount.sol#429-440):
	- (success,returndata) = target.call{value: value}(data) (LlamaAccount.sol#438)



    
438         (bool success, bytes memory returndata) = target.call{value: value}(data);



```

```
Low level call in Address.functionDelegateCall(address,bytes,function()) (LlamaAccount.sol#475-482):
	- (success,returndata) = target.delegatecall(data) (LlamaAccount.sol#480)



    
480         (bool success, bytes memory returndata) = target.delegatecall(data);



```

```
Low level call in SafeERC20._callOptionalReturnBool(IERC20,bytes) (LlamaAccount.sol#681-688):
	- (success,returndata) = address(token).call(data) (LlamaAccount.sol#686)



    
686         (bool success, bytes memory returndata) = address(token).call(data);



```

```
Low level call in LlamaExecutor.execute(address,uint256,bool,bytes) (LlamaAccount.sol#2863-2869):
	- (success,result) = target.delegatecall(data) (LlamaAccount.sol#2868)
	- (success,result) = target.call{value: value}(data) (LlamaAccount.sol#2868)



    
2868     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



    
2868     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



```

### LlamaCore.sol


```
Low level call in LlamaExecutor.execute(address,uint256,bool,bytes) (LlamaCore.sol#1925-1931):
	- (success,result) = target.delegatecall(data) (LlamaCore.sol#1930)
	- (success,result) = target.call{value: value}(data) (LlamaCore.sol#1930)



    
1930     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



    
1930     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



```

### LlamaExecutor.sol


```
Low level call in LlamaExecutor.execute(address,uint256,bool,bytes) (LlamaExecutor.sol#29-35):
	- (success,result) = target.delegatecall(data) (LlamaExecutor.sol#34)
	- (success,result) = target.call{value: value}(data) (LlamaExecutor.sol#34)



    
34     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



    
34     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



```

### LlamaFactory.sol


```
Low level call in LlamaExecutor.execute(address,uint256,bool,bytes) (LlamaFactory.sol#435-441):
	- (success,result) = target.delegatecall(data) (LlamaFactory.sol#440)
	- (success,result) = target.call{value: value}(data) (LlamaFactory.sol#440)



    
440     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



    
440     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



```

### LlamaGovernanceScript.sol


```
Low level call in LlamaGovernanceScript.aggregate(address[],bytes[]) (LlamaGovernanceScript.sol#4065-4082):
	- (success,response) = targets[i].call(data[i]) (LlamaGovernanceScript.sol#4078)



    
4078       (bool success, bytes memory response) = targets[i].call(data[i]);



```

```
Low level call in LlamaExecutor.execute(address,uint256,bool,bytes) (LlamaGovernanceScript.sol#456-462):
	- (success,result) = target.delegatecall(data) (LlamaGovernanceScript.sol#461)
	- (success,result) = target.call{value: value}(data) (LlamaGovernanceScript.sol#461)



    
461     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



    
461     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



```

### LlamaPolicy.sol


```
Low level call in LlamaExecutor.execute(address,uint256,bool,bytes) (LlamaPolicy.sol#1960-1966):
	- (success,result) = target.delegatecall(data) (LlamaPolicy.sol#1965)
	- (success,result) = target.call{value: value}(data) (LlamaPolicy.sol#1965)



    
1965     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



    
1965     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



```

### LlamaPolicyMetadataParamRegistry.sol


```
Low level call in LlamaExecutor.execute(address,uint256,bool,bytes) (LlamaPolicyMetadataParamRegistry.sol#29-35):
	- (success,result) = target.delegatecall(data) (LlamaPolicyMetadataParamRegistry.sol#34)
	- (success,result) = target.call{value: value}(data) (LlamaPolicyMetadataParamRegistry.sol#34)



    
34     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



    
34     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



```

### LlamaRelativeQuorum.sol


```
Low level call in LlamaExecutor.execute(address,uint256,bool,bytes) (LlamaRelativeQuorum.sol#688-694):
	- (success,result) = target.delegatecall(data) (LlamaRelativeQuorum.sol#693)
	- (success,result) = target.call{value: value}(data) (LlamaRelativeQuorum.sol#693)



    
693     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



    
693     (success, result) = isScript ? target.delegatecall(data) : target.call{value: value}(data);



```

## naming-convention
### Severity: Informational

### LlamaAbsolutePeerReview.sol


```
Parameter LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[])._policy (LlamaAbsolutePeerReview.sol#3567) is not in mixedCase



    
3567     LlamaPolicy _policy,



```

```
Parameter LlamaPolicy.initialize(string,RoleDescription[],RoleHolderData[],RolePermissionData[])._name (LlamaAbsolutePeerReview.sol#2403) is not in mixedCase



    
2403     string calldata _name,



```

```
Parameter LlamaPolicy.finalizeInitialization(address,bytes32)._llamaExecutor (LlamaAbsolutePeerReview.sol#2439) is not in mixedCase



    
2439   function finalizeInitialization(address _llamaExecutor, bytes32 bootstrapPermissionId) external {



```

```
Function ERC721NonTransferableMinimalProxy.__initializeERC721MinimalProxy(string,string) (LlamaAbsolutePeerReview.sol#2143-2146) is not in mixedCase



    
2143   function __initializeERC721MinimalProxy (string memory _name, string memory _symbol) internal {
2144     name = _name;
2145     symbol = _symbol;
2146   }



```

```
Parameter ERC721NonTransferableMinimalProxy.__initializeERC721MinimalProxy(string,string)._symbol (LlamaAbsolutePeerReview.sol#2143) is not in mixedCase



    
2143   function __initializeERC721MinimalProxy (string memory _name, string memory _symbol) internal {



```

```
Parameter ERC721NonTransferableMinimalProxy.__initializeERC721MinimalProxy(string,string)._name (LlamaAbsolutePeerReview.sol#2143) is not in mixedCase



    
2143   function __initializeERC721MinimalProxy (string memory _name, string memory _symbol) internal {



```

```
Variable ERC721NonTransferableMinimalProxy._ownerOf (LlamaAbsolutePeerReview.sol#2117) is not in mixedCase



    
2117   mapping(uint256 => address) internal _ownerOf;



```

```
Variable LlamaFactory.LLAMA_POLICY_METADATA_PARAM_REGISTRY (LlamaAbsolutePeerReview.sol#3144) is not in mixedCase



    
3144   LlamaPolicyMetadataParamRegistry public immutable LLAMA_POLICY_METADATA_PARAM_REGISTRY;



```

```
Parameter LlamaFactory.setPolicyMetadata(LlamaPolicyMetadata)._llamaPolicyMetadata (LlamaAbsolutePeerReview.sol#3264) is not in mixedCase



    
3264   function setPolicyMetadata(LlamaPolicyMetadata _llamaPolicyMetadata) external onlyRootLlama {



```

```
Variable ERC721NonTransferableMinimalProxy._balanceOf (LlamaAbsolutePeerReview.sol#2119) is not in mixedCase



    
2119   mapping(address => uint256) internal _balanceOf;



```

```
Variable LlamaPolicyMetadataParamRegistry.LLAMA_FACTORY (LlamaAbsolutePeerReview.sol#3032) is not in mixedCase



    
3032   address public immutable LLAMA_FACTORY;



```

```
Parameter LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[])._name (LlamaAbsolutePeerReview.sol#3566) is not in mixedCase



    
3566     string memory _name,



```

```
Variable LlamaFactory.ROOT_LLAMA_EXECUTOR (LlamaAbsolutePeerReview.sol#3147) is not in mixedCase



    
3147   LlamaExecutor public immutable ROOT_LLAMA_EXECUTOR;



```

```
Parameter LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[])._llamaAccountLogic (LlamaAbsolutePeerReview.sol#3569) is not in mixedCase



    
3569     ILlamaAccount _llamaAccountLogic,



```

```
Variable LlamaFactory.ROOT_LLAMA_CORE (LlamaAbsolutePeerReview.sol#3150) is not in mixedCase



    
3150   LlamaCore public immutable ROOT_LLAMA_CORE;



```

```
Variable LlamaFactory.LLAMA_POLICY_LOGIC (LlamaAbsolutePeerReview.sol#3141) is not in mixedCase



    
3141   LlamaPolicy public immutable LLAMA_POLICY_LOGIC;



```

```
Parameter LlamaPolicyMetadataParamRegistry.setLogo(LlamaExecutor,string)._logo (LlamaAbsolutePeerReview.sol#3078) is not in mixedCase



    
3078   function setLogo(LlamaExecutor llamaExecutor, string memory _logo) public onlyAuthorized(llamaExecutor) {



```

```
Variable LlamaExecutor.LLAMA_CORE (LlamaAbsolutePeerReview.sol#671) is not in mixedCase



    
671   address public immutable LLAMA_CORE;



```

```
Parameter LlamaPolicyMetadataParamRegistry.setColor(LlamaExecutor,string)._color (LlamaAbsolutePeerReview.sol#3070) is not in mixedCase



    
3070   function setColor(LlamaExecutor llamaExecutor, string memory _color) public onlyAuthorized(llamaExecutor) {



```

```
Parameter LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[])._llamaStrategyLogic (LlamaAbsolutePeerReview.sol#3568) is not in mixedCase



    
3568     ILlamaStrategy _llamaStrategyLogic,



```

```
Variable LlamaPolicyMetadataParamRegistry.ROOT_LLAMA_EXECUTOR (LlamaAbsolutePeerReview.sol#3029) is not in mixedCase



    
3029   LlamaExecutor public immutable ROOT_LLAMA_EXECUTOR;



```

```
Variable LlamaFactory.LLAMA_CORE_LOGIC (LlamaAbsolutePeerReview.sol#3138) is not in mixedCase



    
3138   LlamaCore public immutable LLAMA_CORE_LOGIC;



```

### LlamaAbsoluteQuorum.sol


```
Parameter LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[])._policy (LlamaAbsoluteQuorum.sol#3567) is not in mixedCase



    
3567     LlamaPolicy _policy,



```

```
Parameter LlamaPolicy.initialize(string,RoleDescription[],RoleHolderData[],RolePermissionData[])._name (LlamaAbsoluteQuorum.sol#2403) is not in mixedCase



    
2403     string calldata _name,



```

```
Parameter LlamaPolicy.finalizeInitialization(address,bytes32)._llamaExecutor (LlamaAbsoluteQuorum.sol#2439) is not in mixedCase



    
2439   function finalizeInitialization(address _llamaExecutor, bytes32 bootstrapPermissionId) external {



```

```
Function ERC721NonTransferableMinimalProxy.__initializeERC721MinimalProxy(string,string) (LlamaAbsoluteQuorum.sol#2143-2146) is not in mixedCase



    
2143   function __initializeERC721MinimalProxy (string memory _name, string memory _symbol) internal {
2144     name = _name;
2145     symbol = _symbol;
2146   }



```

```
Parameter ERC721NonTransferableMinimalProxy.__initializeERC721MinimalProxy(string,string)._symbol (LlamaAbsoluteQuorum.sol#2143) is not in mixedCase



    
2143   function __initializeERC721MinimalProxy (string memory _name, string memory _symbol) internal {



```

```
Parameter ERC721NonTransferableMinimalProxy.__initializeERC721MinimalProxy(string,string)._name (LlamaAbsoluteQuorum.sol#2143) is not in mixedCase



    
2143   function __initializeERC721MinimalProxy (string memory _name, string memory _symbol) internal {



```

```
Variable ERC721NonTransferableMinimalProxy._ownerOf (LlamaAbsoluteQuorum.sol#2117) is not in mixedCase



    
2117   mapping(uint256 => address) internal _ownerOf;



```

```
Variable LlamaFactory.LLAMA_POLICY_METADATA_PARAM_REGISTRY (LlamaAbsoluteQuorum.sol#3144) is not in mixedCase



    
3144   LlamaPolicyMetadataParamRegistry public immutable LLAMA_POLICY_METADATA_PARAM_REGISTRY;



```

```
Parameter LlamaFactory.setPolicyMetadata(LlamaPolicyMetadata)._llamaPolicyMetadata (LlamaAbsoluteQuorum.sol#3264) is not in mixedCase



    
3264   function setPolicyMetadata(LlamaPolicyMetadata _llamaPolicyMetadata) external onlyRootLlama {



```

```
Variable ERC721NonTransferableMinimalProxy._balanceOf (LlamaAbsoluteQuorum.sol#2119) is not in mixedCase



    
2119   mapping(address => uint256) internal _balanceOf;



```

```
Variable LlamaPolicyMetadataParamRegistry.LLAMA_FACTORY (LlamaAbsoluteQuorum.sol#3032) is not in mixedCase



    
3032   address public immutable LLAMA_FACTORY;



```

```
Parameter LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[])._name (LlamaAbsoluteQuorum.sol#3566) is not in mixedCase



    
3566     string memory _name,



```

```
Variable LlamaFactory.ROOT_LLAMA_EXECUTOR (LlamaAbsoluteQuorum.sol#3147) is not in mixedCase



    
3147   LlamaExecutor public immutable ROOT_LLAMA_EXECUTOR;



```

```
Parameter LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[])._llamaAccountLogic (LlamaAbsoluteQuorum.sol#3569) is not in mixedCase



    
3569     ILlamaAccount _llamaAccountLogic,



```

```
Variable LlamaFactory.ROOT_LLAMA_CORE (LlamaAbsoluteQuorum.sol#3150) is not in mixedCase



    
3150   LlamaCore public immutable ROOT_LLAMA_CORE;



```

```
Variable LlamaFactory.LLAMA_POLICY_LOGIC (LlamaAbsoluteQuorum.sol#3141) is not in mixedCase



    
3141   LlamaPolicy public immutable LLAMA_POLICY_LOGIC;



```

```
Parameter LlamaPolicyMetadataParamRegistry.setLogo(LlamaExecutor,string)._logo (LlamaAbsoluteQuorum.sol#3078) is not in mixedCase



    
3078   function setLogo(LlamaExecutor llamaExecutor, string memory _logo) public onlyAuthorized(llamaExecutor) {



```

```
Variable LlamaExecutor.LLAMA_CORE (LlamaAbsoluteQuorum.sol#671) is not in mixedCase



    
671   address public immutable LLAMA_CORE;



```

```
Parameter LlamaPolicyMetadataParamRegistry.setColor(LlamaExecutor,string)._color (LlamaAbsoluteQuorum.sol#3070) is not in mixedCase



    
3070   function setColor(LlamaExecutor llamaExecutor, string memory _color) public onlyAuthorized(llamaExecutor) {



```

```
Parameter LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[])._llamaStrategyLogic (LlamaAbsoluteQuorum.sol#3568) is not in mixedCase



    
3568     ILlamaStrategy _llamaStrategyLogic,



```

```
Variable LlamaPolicyMetadataParamRegistry.ROOT_LLAMA_EXECUTOR (LlamaAbsoluteQuorum.sol#3029) is not in mixedCase



    
3029   LlamaExecutor public immutable ROOT_LLAMA_EXECUTOR;



```

```
Variable LlamaFactory.LLAMA_CORE_LOGIC (LlamaAbsoluteQuorum.sol#3138) is not in mixedCase



    
3138   LlamaCore public immutable LLAMA_CORE_LOGIC;



```

### LlamaAccount.sol


```
Parameter LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[])._policy (LlamaAccount.sol#4354) is not in mixedCase



    
4354     LlamaPolicy _policy,



```

```
Parameter LlamaPolicy.initialize(string,RoleDescription[],RoleHolderData[],RolePermissionData[])._name (LlamaAccount.sol#3561) is not in mixedCase



    
3561     string calldata _name,



```

```
Parameter LlamaPolicy.finalizeInitialization(address,bytes32)._llamaExecutor (LlamaAccount.sol#3597) is not in mixedCase



    
3597   function finalizeInitialization(address _llamaExecutor, bytes32 bootstrapPermissionId) external {



```

```
Function ERC721NonTransferableMinimalProxy.__initializeERC721MinimalProxy(string,string) (LlamaAccount.sol#2703-2706) is not in mixedCase



    
2703   function __initializeERC721MinimalProxy (string memory _name, string memory _symbol) internal {
2704     name = _name;
2705     symbol = _symbol;
2706   }



```

```
Parameter ERC721NonTransferableMinimalProxy.__initializeERC721MinimalProxy(string,string)._symbol (LlamaAccount.sol#2703) is not in mixedCase



    
2703   function __initializeERC721MinimalProxy (string memory _name, string memory _symbol) internal {



```

```
Parameter ERC721NonTransferableMinimalProxy.__initializeERC721MinimalProxy(string,string)._name (LlamaAccount.sol#2703) is not in mixedCase



    
2703   function __initializeERC721MinimalProxy (string memory _name, string memory _symbol) internal {



```

```
Variable ERC721NonTransferableMinimalProxy._ownerOf (LlamaAccount.sol#2677) is not in mixedCase



    
2677   mapping(uint256 => address) internal _ownerOf;



```

```
Variable LlamaFactory.LLAMA_POLICY_METADATA_PARAM_REGISTRY (LlamaAccount.sol#3219) is not in mixedCase



    
3219   LlamaPolicyMetadataParamRegistry public immutable LLAMA_POLICY_METADATA_PARAM_REGISTRY;



```

```
Parameter LlamaFactory.setPolicyMetadata(LlamaPolicyMetadata)._llamaPolicyMetadata (LlamaAccount.sol#3339) is not in mixedCase



    
3339   function setPolicyMetadata(LlamaPolicyMetadata _llamaPolicyMetadata) external onlyRootLlama {



```

```
Variable ERC721NonTransferableMinimalProxy._balanceOf (LlamaAccount.sol#2679) is not in mixedCase



    
2679   mapping(address => uint256) internal _balanceOf;



```

```
Variable LlamaPolicyMetadataParamRegistry.LLAMA_FACTORY (LlamaAccount.sol#3107) is not in mixedCase



    
3107   address public immutable LLAMA_FACTORY;



```

```
Parameter LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[])._name (LlamaAccount.sol#4353) is not in mixedCase



    
4353     string memory _name,



```

```
Variable LlamaFactory.ROOT_LLAMA_EXECUTOR (LlamaAccount.sol#3222) is not in mixedCase



    
3222   LlamaExecutor public immutable ROOT_LLAMA_EXECUTOR;



```

```
Function IERC20Permit.DOMAIN_SEPARATOR() (LlamaAccount.sol#321) is not in mixedCase



    
321     function DOMAIN_SEPARATOR() external view returns (bytes32);



```

```
Parameter LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[])._llamaAccountLogic (LlamaAccount.sol#4356) is not in mixedCase



    
4356     ILlamaAccount _llamaAccountLogic,



```

```
Variable LlamaFactory.ROOT_LLAMA_CORE (LlamaAccount.sol#3225) is not in mixedCase



    
3225   LlamaCore public immutable ROOT_LLAMA_CORE;



```

```
Variable LlamaFactory.LLAMA_POLICY_LOGIC (LlamaAccount.sol#3216) is not in mixedCase



    
3216   LlamaPolicy public immutable LLAMA_POLICY_LOGIC;



```

```
Parameter LlamaPolicyMetadataParamRegistry.setLogo(LlamaExecutor,string)._logo (LlamaAccount.sol#3153) is not in mixedCase



    
3153   function setLogo(LlamaExecutor llamaExecutor, string memory _logo) public onlyAuthorized(llamaExecutor) {



```

```
Variable LlamaExecutor.LLAMA_CORE (LlamaAccount.sol#2846) is not in mixedCase



    
2846   address public immutable LLAMA_CORE;



```

```
Parameter LlamaPolicyMetadataParamRegistry.setColor(LlamaExecutor,string)._color (LlamaAccount.sol#3145) is not in mixedCase



    
3145   function setColor(LlamaExecutor llamaExecutor, string memory _color) public onlyAuthorized(llamaExecutor) {



```

```
Parameter LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[])._llamaStrategyLogic (LlamaAccount.sol#4355) is not in mixedCase



    
4355     ILlamaStrategy _llamaStrategyLogic,



```

```
Variable LlamaPolicyMetadataParamRegistry.ROOT_LLAMA_EXECUTOR (LlamaAccount.sol#3104) is not in mixedCase



    
3104   LlamaExecutor public immutable ROOT_LLAMA_EXECUTOR;



```

```
Variable LlamaFactory.LLAMA_CORE_LOGIC (LlamaAccount.sol#3213) is not in mixedCase



    
3213   LlamaCore public immutable LLAMA_CORE_LOGIC;



```

### LlamaCore.sol


```
Parameter LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[])._policy (LlamaCore.sol#3416) is not in mixedCase



    
3416     LlamaPolicy _policy,



```

```
Parameter LlamaPolicy.initialize(string,RoleDescription[],RoleHolderData[],RolePermissionData[])._name (LlamaCore.sol#2623) is not in mixedCase



    
2623     string calldata _name,



```

```
Parameter LlamaPolicy.finalizeInitialization(address,bytes32)._llamaExecutor (LlamaCore.sol#2659) is not in mixedCase



    
2659   function finalizeInitialization(address _llamaExecutor, bytes32 bootstrapPermissionId) external {



```

```
Function ERC721NonTransferableMinimalProxy.__initializeERC721MinimalProxy(string,string) (LlamaCore.sol#1765-1768) is not in mixedCase



    
1765   function __initializeERC721MinimalProxy (string memory _name, string memory _symbol) internal {
1766     name = _name;
1767     symbol = _symbol;
1768   }



```

```
Parameter ERC721NonTransferableMinimalProxy.__initializeERC721MinimalProxy(string,string)._symbol (LlamaCore.sol#1765) is not in mixedCase



    
1765   function __initializeERC721MinimalProxy (string memory _name, string memory _symbol) internal {



```

```
Parameter ERC721NonTransferableMinimalProxy.__initializeERC721MinimalProxy(string,string)._name (LlamaCore.sol#1765) is not in mixedCase



    
1765   function __initializeERC721MinimalProxy (string memory _name, string memory _symbol) internal {



```

```
Variable ERC721NonTransferableMinimalProxy._ownerOf (LlamaCore.sol#1739) is not in mixedCase



    
1739   mapping(uint256 => address) internal _ownerOf;



```

```
Variable LlamaFactory.LLAMA_POLICY_METADATA_PARAM_REGISTRY (LlamaCore.sol#2281) is not in mixedCase



    
2281   LlamaPolicyMetadataParamRegistry public immutable LLAMA_POLICY_METADATA_PARAM_REGISTRY;



```

```
Parameter LlamaFactory.setPolicyMetadata(LlamaPolicyMetadata)._llamaPolicyMetadata (LlamaCore.sol#2401) is not in mixedCase



    
2401   function setPolicyMetadata(LlamaPolicyMetadata _llamaPolicyMetadata) external onlyRootLlama {



```

```
Variable ERC721NonTransferableMinimalProxy._balanceOf (LlamaCore.sol#1741) is not in mixedCase



    
1741   mapping(address => uint256) internal _balanceOf;



```

```
Variable LlamaPolicyMetadataParamRegistry.LLAMA_FACTORY (LlamaCore.sol#2169) is not in mixedCase



    
2169   address public immutable LLAMA_FACTORY;



```

```
Parameter LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[])._name (LlamaCore.sol#3415) is not in mixedCase



    
3415     string memory _name,



```

```
Variable LlamaFactory.ROOT_LLAMA_EXECUTOR (LlamaCore.sol#2284) is not in mixedCase



    
2284   LlamaExecutor public immutable ROOT_LLAMA_EXECUTOR;



```

```
Parameter LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[])._llamaAccountLogic (LlamaCore.sol#3418) is not in mixedCase



    
3418     ILlamaAccount _llamaAccountLogic,



```

```
Variable LlamaFactory.ROOT_LLAMA_CORE (LlamaCore.sol#2287) is not in mixedCase



    
2287   LlamaCore public immutable ROOT_LLAMA_CORE;



```

```
Variable LlamaFactory.LLAMA_POLICY_LOGIC (LlamaCore.sol#2278) is not in mixedCase



    
2278   LlamaPolicy public immutable LLAMA_POLICY_LOGIC;



```

```
Parameter LlamaPolicyMetadataParamRegistry.setLogo(LlamaExecutor,string)._logo (LlamaCore.sol#2215) is not in mixedCase



    
2215   function setLogo(LlamaExecutor llamaExecutor, string memory _logo) public onlyAuthorized(llamaExecutor) {



```

```
Variable LlamaExecutor.LLAMA_CORE (LlamaCore.sol#1908) is not in mixedCase



    
1908   address public immutable LLAMA_CORE;



```

```
Parameter LlamaPolicyMetadataParamRegistry.setColor(LlamaExecutor,string)._color (LlamaCore.sol#2207) is not in mixedCase



    
2207   function setColor(LlamaExecutor llamaExecutor, string memory _color) public onlyAuthorized(llamaExecutor) {



```

```
Parameter LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[])._llamaStrategyLogic (LlamaCore.sol#3417) is not in mixedCase



    
3417     ILlamaStrategy _llamaStrategyLogic,



```

```
Variable LlamaPolicyMetadataParamRegistry.ROOT_LLAMA_EXECUTOR (LlamaCore.sol#2166) is not in mixedCase



    
2166   LlamaExecutor public immutable ROOT_LLAMA_EXECUTOR;



```

```
Variable LlamaFactory.LLAMA_CORE_LOGIC (LlamaCore.sol#2275) is not in mixedCase



    
2275   LlamaCore public immutable LLAMA_CORE_LOGIC;



```

### LlamaExecutor.sol


```
Variable LlamaExecutor.LLAMA_CORE (LlamaExecutor.sol#12) is not in mixedCase



    
12   address public immutable LLAMA_CORE;



```

### LlamaFactory.sol


```
Parameter LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[])._policy (LlamaFactory.sol#2753) is not in mixedCase



    
2753     LlamaPolicy _policy,



```

```
Parameter LlamaPolicy.initialize(string,RoleDescription[],RoleHolderData[],RolePermissionData[])._name (LlamaFactory.sol#2150) is not in mixedCase



    
2150     string calldata _name,



```

```
Parameter LlamaPolicy.finalizeInitialization(address,bytes32)._llamaExecutor (LlamaFactory.sol#2186) is not in mixedCase



    
2186   function finalizeInitialization(address _llamaExecutor, bytes32 bootstrapPermissionId) external {



```

```
Function ERC721NonTransferableMinimalProxy.__initializeERC721MinimalProxy(string,string) (LlamaFactory.sol#1887-1890) is not in mixedCase



    
1887   function __initializeERC721MinimalProxy (string memory _name, string memory _symbol) internal {
1888     name = _name;
1889     symbol = _symbol;
1890   }



```

```
Parameter ERC721NonTransferableMinimalProxy.__initializeERC721MinimalProxy(string,string)._symbol (LlamaFactory.sol#1887) is not in mixedCase



    
1887   function __initializeERC721MinimalProxy (string memory _name, string memory _symbol) internal {



```

```
Parameter ERC721NonTransferableMinimalProxy.__initializeERC721MinimalProxy(string,string)._name (LlamaFactory.sol#1887) is not in mixedCase



    
1887   function __initializeERC721MinimalProxy (string memory _name, string memory _symbol) internal {



```

```
Variable ERC721NonTransferableMinimalProxy._ownerOf (LlamaFactory.sol#1861) is not in mixedCase



    
1861   mapping(uint256 => address) internal _ownerOf;



```

```
Variable LlamaFactory.LLAMA_POLICY_METADATA_PARAM_REGISTRY (LlamaFactory.sol#3781) is not in mixedCase



    
3781   LlamaPolicyMetadataParamRegistry public immutable LLAMA_POLICY_METADATA_PARAM_REGISTRY;



```

```
Parameter LlamaFactory.setPolicyMetadata(LlamaPolicyMetadata)._llamaPolicyMetadata (LlamaFactory.sol#3901) is not in mixedCase



    
3901   function setPolicyMetadata(LlamaPolicyMetadata _llamaPolicyMetadata) external onlyRootLlama {



```

```
Variable ERC721NonTransferableMinimalProxy._balanceOf (LlamaFactory.sol#1863) is not in mixedCase



    
1863   mapping(address => uint256) internal _balanceOf;



```

```
Variable LlamaPolicyMetadataParamRegistry.LLAMA_FACTORY (LlamaFactory.sol#3669) is not in mixedCase



    
3669   address public immutable LLAMA_FACTORY;



```

```
Parameter LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[])._name (LlamaFactory.sol#2752) is not in mixedCase



    
2752     string memory _name,



```

```
Variable LlamaFactory.ROOT_LLAMA_EXECUTOR (LlamaFactory.sol#3784) is not in mixedCase



    
3784   LlamaExecutor public immutable ROOT_LLAMA_EXECUTOR;



```

```
Parameter LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[])._llamaAccountLogic (LlamaFactory.sol#2755) is not in mixedCase



    
2755     ILlamaAccount _llamaAccountLogic,



```

```
Variable LlamaFactory.ROOT_LLAMA_CORE (LlamaFactory.sol#3787) is not in mixedCase



    
3787   LlamaCore public immutable ROOT_LLAMA_CORE;



```

```
Variable LlamaFactory.LLAMA_POLICY_LOGIC (LlamaFactory.sol#3778) is not in mixedCase



    
3778   LlamaPolicy public immutable LLAMA_POLICY_LOGIC;



```

```
Parameter LlamaPolicyMetadataParamRegistry.setLogo(LlamaExecutor,string)._logo (LlamaFactory.sol#3715) is not in mixedCase



    
3715   function setLogo(LlamaExecutor llamaExecutor, string memory _logo) public onlyAuthorized(llamaExecutor) {



```

```
Variable LlamaExecutor.LLAMA_CORE (LlamaFactory.sol#418) is not in mixedCase



    
418   address public immutable LLAMA_CORE;



```

```
Parameter LlamaPolicyMetadataParamRegistry.setColor(LlamaExecutor,string)._color (LlamaFactory.sol#3707) is not in mixedCase



    
3707   function setColor(LlamaExecutor llamaExecutor, string memory _color) public onlyAuthorized(llamaExecutor) {



```

```
Parameter LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[])._llamaStrategyLogic (LlamaFactory.sol#2754) is not in mixedCase



    
2754     ILlamaStrategy _llamaStrategyLogic,



```

```
Variable LlamaPolicyMetadataParamRegistry.ROOT_LLAMA_EXECUTOR (LlamaFactory.sol#3666) is not in mixedCase



    
3666   LlamaExecutor public immutable ROOT_LLAMA_EXECUTOR;



```

```
Variable LlamaFactory.LLAMA_CORE_LOGIC (LlamaFactory.sol#3775) is not in mixedCase



    
3775   LlamaCore public immutable LLAMA_CORE_LOGIC;



```

### LlamaGovernanceScript.sol


```
Parameter LlamaGovernanceScript.initializeRolesAndSetRoleHoldersAndSetRolePermissions(RoleDescription[],RoleHolderData[],RolePermissionData[])._setRolePermissions (LlamaGovernanceScript.sol#4107) is not in mixedCase



    
4107     RolePermissionData[] calldata _setRolePermissions



```

```
Parameter LlamaGovernanceScript.setRolePermissions(RolePermissionData[])._setRolePermissions (LlamaGovernanceScript.sol#4199) is not in mixedCase



    
4199   function setRolePermissions(RolePermissionData[] calldata _setRolePermissions) public onlyDelegateCall {



```

```
Parameter LlamaGovernanceScript.createNewStrategiesAndSetRolePermissions(LlamaGovernanceScript.CreateStrategies,RolePermissionData[])._createStrategies (LlamaGovernanceScript.sol#4135) is not in mixedCase



    
4135     CreateStrategies calldata _createStrategies,



```

```
Parameter LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[])._policy (LlamaGovernanceScript.sol#3335) is not in mixedCase



    
3335     LlamaPolicy _policy,



```

```
Parameter LlamaGovernanceScript.createNewStrategiesAndInitializeRolesAndSetRoleHolders(LlamaGovernanceScript.CreateStrategies,RoleDescription[],RoleHolderData[])._setRoleHolders (LlamaGovernanceScript.sol#4126) is not in mixedCase



    
4126     RoleHolderData[] calldata _setRoleHolders



```

```
Parameter LlamaPolicy.initialize(string,RoleDescription[],RoleHolderData[],RolePermissionData[])._name (LlamaGovernanceScript.sol#2171) is not in mixedCase



    
2171     string calldata _name,



```

```
Variable LlamaBaseScript.SELF (LlamaGovernanceScript.sol#18) is not in mixedCase



    
18   address internal immutable SELF;



```

```
Parameter LlamaPolicy.finalizeInitialization(address,bytes32)._llamaExecutor (LlamaGovernanceScript.sol#2207) is not in mixedCase



    
2207   function finalizeInitialization(address _llamaExecutor, bytes32 bootstrapPermissionId) external {



```

```
Function ERC721NonTransferableMinimalProxy.__initializeERC721MinimalProxy(string,string) (LlamaGovernanceScript.sol#1911-1914) is not in mixedCase



    
1911   function __initializeERC721MinimalProxy (string memory _name, string memory _symbol) internal {
1912     name = _name;
1913     symbol = _symbol;
1914   }



```

```
Parameter ERC721NonTransferableMinimalProxy.__initializeERC721MinimalProxy(string,string)._symbol (LlamaGovernanceScript.sol#1911) is not in mixedCase



    
1911   function __initializeERC721MinimalProxy (string memory _name, string memory _symbol) internal {



```

```
Parameter LlamaGovernanceScript.initializeRolesAndSetRoleHolders(RoleDescription[],RoleHolderData[])._setRoleHolders (LlamaGovernanceScript.sol#4090) is not in mixedCase



    
4090     RoleHolderData[] calldata _setRoleHolders



```

```
Parameter ERC721NonTransferableMinimalProxy.__initializeERC721MinimalProxy(string,string)._name (LlamaGovernanceScript.sol#1911) is not in mixedCase



    
1911   function __initializeERC721MinimalProxy (string memory _name, string memory _symbol) internal {



```

```
Parameter LlamaGovernanceScript.revokePoliciesAndUpdateRoleDescriptionsAndSetRoleHolders(address[],LlamaGovernanceScript.UpdateRoleDescription[],RoleHolderData[])._revokePolicies (LlamaGovernanceScript.sol#4165) is not in mixedCase



    
4165     address[] calldata _revokePolicies,



```

```
Variable ERC721NonTransferableMinimalProxy._ownerOf (LlamaGovernanceScript.sol#1885) is not in mixedCase



    
1885   mapping(uint256 => address) internal _ownerOf;



```

```
Parameter LlamaGovernanceScript.revokePoliciesAndUpdateRoleDescriptions(address[],LlamaGovernanceScript.UpdateRoleDescription[])._revokePolicies (LlamaGovernanceScript.sol#4157) is not in mixedCase



    
4157     address[] calldata _revokePolicies,



```

```
Variable LlamaFactory.LLAMA_POLICY_METADATA_PARAM_REGISTRY (LlamaGovernanceScript.sol#2912) is not in mixedCase



    
2912   LlamaPolicyMetadataParamRegistry public immutable LLAMA_POLICY_METADATA_PARAM_REGISTRY;



```

```
Parameter LlamaFactory.setPolicyMetadata(LlamaPolicyMetadata)._llamaPolicyMetadata (LlamaGovernanceScript.sol#3032) is not in mixedCase



    
3032   function setPolicyMetadata(LlamaPolicyMetadata _llamaPolicyMetadata) external onlyRootLlama {



```

```
Variable ERC721NonTransferableMinimalProxy._balanceOf (LlamaGovernanceScript.sol#1887) is not in mixedCase



    
1887   mapping(address => uint256) internal _balanceOf;



```

```
Variable LlamaPolicyMetadataParamRegistry.LLAMA_FACTORY (LlamaGovernanceScript.sol#2800) is not in mixedCase



    
2800   address public immutable LLAMA_FACTORY;



```

```
Parameter LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[])._name (LlamaGovernanceScript.sol#3334) is not in mixedCase



    
3334     string memory _name,



```

```
Parameter LlamaGovernanceScript.createNewStrategiesAndInitializeRolesAndSetRoleHolders(LlamaGovernanceScript.CreateStrategies,RoleDescription[],RoleHolderData[])._createStrategies (LlamaGovernanceScript.sol#4124) is not in mixedCase



    
4124     CreateStrategies calldata _createStrategies,



```

```
Variable LlamaFactory.ROOT_LLAMA_EXECUTOR (LlamaGovernanceScript.sol#2915) is not in mixedCase



    
2915   LlamaExecutor public immutable ROOT_LLAMA_EXECUTOR;



```

```
Parameter LlamaGovernanceScript.createNewStrategiesAndNewRolesAndSetRoleHoldersAndSetRolePermissions(LlamaGovernanceScript.CreateStrategies,RoleDescription[],RoleHolderData[],RolePermissionData[])._createStrategies (LlamaGovernanceScript.sol#4144) is not in mixedCase



    
4144     CreateStrategies calldata _createStrategies,



```

```
Parameter LlamaGovernanceScript.createNewStrategiesAndNewRolesAndSetRoleHoldersAndSetRolePermissions(LlamaGovernanceScript.CreateStrategies,RoleDescription[],RoleHolderData[],RolePermissionData[])._setRolePermissions (LlamaGovernanceScript.sol#4147) is not in mixedCase



    
4147     RolePermissionData[] calldata _setRolePermissions



```

```
Parameter LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[])._llamaAccountLogic (LlamaGovernanceScript.sol#3337) is not in mixedCase



    
3337     ILlamaAccount _llamaAccountLogic,



```

```
Parameter LlamaGovernanceScript.initializeRolesAndSetRolePermissions(RoleDescription[],RolePermissionData[])._setRolePermissions (LlamaGovernanceScript.sol#4098) is not in mixedCase



    
4098     RolePermissionData[] calldata _setRolePermissions



```

```
Variable LlamaFactory.ROOT_LLAMA_CORE (LlamaGovernanceScript.sol#2918) is not in mixedCase



    
2918   LlamaCore public immutable ROOT_LLAMA_CORE;



```

```
Parameter LlamaGovernanceScript.createNewStrategiesAndSetRolePermissions(LlamaGovernanceScript.CreateStrategies,RolePermissionData[])._setRolePermissions (LlamaGovernanceScript.sol#4136) is not in mixedCase



    
4136     RolePermissionData[] calldata _setRolePermissions



```

```
Variable LlamaFactory.LLAMA_POLICY_LOGIC (LlamaGovernanceScript.sol#2909) is not in mixedCase



    
2909   LlamaPolicy public immutable LLAMA_POLICY_LOGIC;



```

```
Parameter LlamaPolicyMetadataParamRegistry.setLogo(LlamaExecutor,string)._logo (LlamaGovernanceScript.sol#2846) is not in mixedCase



    
2846   function setLogo(LlamaExecutor llamaExecutor, string memory _logo) public onlyAuthorized(llamaExecutor) {



```

```
Parameter LlamaGovernanceScript.createNewStrategiesAndSetRoleHolders(LlamaGovernanceScript.CreateStrategies,RoleHolderData[])._setRoleHolders (LlamaGovernanceScript.sol#4116) is not in mixedCase



    
4116     RoleHolderData[] calldata _setRoleHolders



```

```
Parameter LlamaGovernanceScript.createNewStrategiesAndNewRolesAndSetRoleHoldersAndSetRolePermissions(LlamaGovernanceScript.CreateStrategies,RoleDescription[],RoleHolderData[],RolePermissionData[])._setRoleHolders (LlamaGovernanceScript.sol#4146) is not in mixedCase



    
4146     RoleHolderData[] calldata _setRoleHolders,



```

```
Variable LlamaExecutor.LLAMA_CORE (LlamaGovernanceScript.sol#439) is not in mixedCase



    
439   address public immutable LLAMA_CORE;



```

```
Parameter LlamaPolicyMetadataParamRegistry.setColor(LlamaExecutor,string)._color (LlamaGovernanceScript.sol#2838) is not in mixedCase



    
2838   function setColor(LlamaExecutor llamaExecutor, string memory _color) public onlyAuthorized(llamaExecutor) {



```

```
Parameter LlamaGovernanceScript.revokePolicies(address[])._revokePolicies (LlamaGovernanceScript.sol#4211) is not in mixedCase



    
4211   function revokePolicies(address[] calldata _revokePolicies) public onlyDelegateCall {



```

```
Parameter LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[])._llamaStrategyLogic (LlamaGovernanceScript.sol#3336) is not in mixedCase



    
3336     ILlamaStrategy _llamaStrategyLogic,



```

```
Parameter LlamaGovernanceScript.setRoleHolders(RoleHolderData[])._setRoleHolders (LlamaGovernanceScript.sol#4186) is not in mixedCase



    
4186   function setRoleHolders(RoleHolderData[] calldata _setRoleHolders) public onlyDelegateCall {



```

```
Parameter LlamaGovernanceScript.initializeRolesAndSetRoleHoldersAndSetRolePermissions(RoleDescription[],RoleHolderData[],RolePermissionData[])._setRoleHolders (LlamaGovernanceScript.sol#4106) is not in mixedCase



    
4106     RoleHolderData[] calldata _setRoleHolders,



```

```
Parameter LlamaGovernanceScript.revokePoliciesAndUpdateRoleDescriptionsAndSetRoleHolders(address[],LlamaGovernanceScript.UpdateRoleDescription[],RoleHolderData[])._setRoleHolders (LlamaGovernanceScript.sol#4167) is not in mixedCase



    
4167     RoleHolderData[] calldata _setRoleHolders



```

```
Parameter LlamaGovernanceScript.revokePoliciesAndUpdateRoleDescriptionsAndSetRoleHolders(address[],LlamaGovernanceScript.UpdateRoleDescription[],RoleHolderData[])._updateRoleDescriptions (LlamaGovernanceScript.sol#4166) is not in mixedCase



    
4166     UpdateRoleDescription[] calldata _updateRoleDescriptions,



```

```
Parameter LlamaGovernanceScript.revokePoliciesAndUpdateRoleDescriptions(address[],LlamaGovernanceScript.UpdateRoleDescription[])._updateRoleDescriptions (LlamaGovernanceScript.sol#4158) is not in mixedCase



    
4158     UpdateRoleDescription[] calldata _updateRoleDescriptions



```

```
Parameter LlamaGovernanceScript.createNewStrategiesAndSetRoleHolders(LlamaGovernanceScript.CreateStrategies,RoleHolderData[])._createStrategies (LlamaGovernanceScript.sol#4115) is not in mixedCase



    
4115     CreateStrategies calldata _createStrategies,



```

```
Variable LlamaPolicyMetadataParamRegistry.ROOT_LLAMA_EXECUTOR (LlamaGovernanceScript.sol#2797) is not in mixedCase



    
2797   LlamaExecutor public immutable ROOT_LLAMA_EXECUTOR;



```

```
Variable LlamaFactory.LLAMA_CORE_LOGIC (LlamaGovernanceScript.sol#2906) is not in mixedCase



    
2906   LlamaCore public immutable LLAMA_CORE_LOGIC;



```

### LlamaPolicy.sol


```
Parameter LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[])._policy (LlamaPolicy.sol#2742) is not in mixedCase



    
2742     LlamaPolicy _policy,



```

```
Parameter LlamaPolicy.initialize(string,RoleDescription[],RoleHolderData[],RolePermissionData[])._name (LlamaPolicy.sol#3601) is not in mixedCase



    
3601     string calldata _name,



```

```
Parameter LlamaPolicy.finalizeInitialization(address,bytes32)._llamaExecutor (LlamaPolicy.sol#3637) is not in mixedCase



    
3637   function finalizeInitialization(address _llamaExecutor, bytes32 bootstrapPermissionId) external {



```

```
Function ERC721NonTransferableMinimalProxy.__initializeERC721MinimalProxy(string,string) (LlamaPolicy.sol#1655-1658) is not in mixedCase



    
1655   function __initializeERC721MinimalProxy (string memory _name, string memory _symbol) internal {
1656     name = _name;
1657     symbol = _symbol;
1658   }



```

```
Parameter ERC721NonTransferableMinimalProxy.__initializeERC721MinimalProxy(string,string)._symbol (LlamaPolicy.sol#1655) is not in mixedCase



    
1655   function __initializeERC721MinimalProxy (string memory _name, string memory _symbol) internal {



```

```
Parameter ERC721NonTransferableMinimalProxy.__initializeERC721MinimalProxy(string,string)._name (LlamaPolicy.sol#1655) is not in mixedCase



    
1655   function __initializeERC721MinimalProxy (string memory _name, string memory _symbol) internal {



```

```
Variable ERC721NonTransferableMinimalProxy._ownerOf (LlamaPolicy.sol#1629) is not in mixedCase



    
1629   mapping(uint256 => address) internal _ownerOf;



```

```
Variable LlamaFactory.LLAMA_POLICY_METADATA_PARAM_REGISTRY (LlamaPolicy.sol#2319) is not in mixedCase



    
2319   LlamaPolicyMetadataParamRegistry public immutable LLAMA_POLICY_METADATA_PARAM_REGISTRY;



```

```
Parameter LlamaFactory.setPolicyMetadata(LlamaPolicyMetadata)._llamaPolicyMetadata (LlamaPolicy.sol#2439) is not in mixedCase



    
2439   function setPolicyMetadata(LlamaPolicyMetadata _llamaPolicyMetadata) external onlyRootLlama {



```

```
Variable ERC721NonTransferableMinimalProxy._balanceOf (LlamaPolicy.sol#1631) is not in mixedCase



    
1631   mapping(address => uint256) internal _balanceOf;



```

```
Variable LlamaPolicyMetadataParamRegistry.LLAMA_FACTORY (LlamaPolicy.sol#2207) is not in mixedCase



    
2207   address public immutable LLAMA_FACTORY;



```

```
Parameter LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[])._name (LlamaPolicy.sol#2741) is not in mixedCase



    
2741     string memory _name,



```

```
Variable LlamaFactory.ROOT_LLAMA_EXECUTOR (LlamaPolicy.sol#2322) is not in mixedCase



    
2322   LlamaExecutor public immutable ROOT_LLAMA_EXECUTOR;



```

```
Parameter LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[])._llamaAccountLogic (LlamaPolicy.sol#2744) is not in mixedCase



    
2744     ILlamaAccount _llamaAccountLogic,



```

```
Variable LlamaFactory.ROOT_LLAMA_CORE (LlamaPolicy.sol#2325) is not in mixedCase



    
2325   LlamaCore public immutable ROOT_LLAMA_CORE;



```

```
Variable LlamaFactory.LLAMA_POLICY_LOGIC (LlamaPolicy.sol#2316) is not in mixedCase



    
2316   LlamaPolicy public immutable LLAMA_POLICY_LOGIC;



```

```
Parameter LlamaPolicyMetadataParamRegistry.setLogo(LlamaExecutor,string)._logo (LlamaPolicy.sol#2253) is not in mixedCase



    
2253   function setLogo(LlamaExecutor llamaExecutor, string memory _logo) public onlyAuthorized(llamaExecutor) {



```

```
Variable LlamaExecutor.LLAMA_CORE (LlamaPolicy.sol#1943) is not in mixedCase



    
1943   address public immutable LLAMA_CORE;



```

```
Parameter LlamaPolicyMetadataParamRegistry.setColor(LlamaExecutor,string)._color (LlamaPolicy.sol#2245) is not in mixedCase



    
2245   function setColor(LlamaExecutor llamaExecutor, string memory _color) public onlyAuthorized(llamaExecutor) {



```

```
Parameter LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[])._llamaStrategyLogic (LlamaPolicy.sol#2743) is not in mixedCase



    
2743     ILlamaStrategy _llamaStrategyLogic,



```

```
Variable LlamaPolicyMetadataParamRegistry.ROOT_LLAMA_EXECUTOR (LlamaPolicy.sol#2204) is not in mixedCase



    
2204   LlamaExecutor public immutable ROOT_LLAMA_EXECUTOR;



```

```
Variable LlamaFactory.LLAMA_CORE_LOGIC (LlamaPolicy.sol#2313) is not in mixedCase



    
2313   LlamaCore public immutable LLAMA_CORE_LOGIC;



```

### LlamaPolicyMetadataParamRegistry.sol


```
Variable LlamaPolicyMetadataParamRegistry.LLAMA_FACTORY (LlamaPolicyMetadataParamRegistry.sol#76) is not in mixedCase



    
76   address public immutable LLAMA_FACTORY;



```

```
Parameter LlamaPolicyMetadataParamRegistry.setLogo(LlamaExecutor,string)._logo (LlamaPolicyMetadataParamRegistry.sol#122) is not in mixedCase



    
122   function setLogo(LlamaExecutor llamaExecutor, string memory _logo) public onlyAuthorized(llamaExecutor) {



```

```
Variable LlamaExecutor.LLAMA_CORE (LlamaPolicyMetadataParamRegistry.sol#12) is not in mixedCase



    
12   address public immutable LLAMA_CORE;



```

```
Parameter LlamaPolicyMetadataParamRegistry.setColor(LlamaExecutor,string)._color (LlamaPolicyMetadataParamRegistry.sol#114) is not in mixedCase



    
114   function setColor(LlamaExecutor llamaExecutor, string memory _color) public onlyAuthorized(llamaExecutor) {



```

```
Variable LlamaPolicyMetadataParamRegistry.ROOT_LLAMA_EXECUTOR (LlamaPolicyMetadataParamRegistry.sol#73) is not in mixedCase



    
73   LlamaExecutor public immutable ROOT_LLAMA_EXECUTOR;



```

### LlamaRelativeQuorum.sol


```
Parameter LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[])._policy (LlamaRelativeQuorum.sol#3567) is not in mixedCase



    
3567     LlamaPolicy _policy,



```

```
Parameter LlamaPolicy.initialize(string,RoleDescription[],RoleHolderData[],RolePermissionData[])._name (LlamaRelativeQuorum.sol#2403) is not in mixedCase



    
2403     string calldata _name,



```

```
Parameter LlamaPolicy.finalizeInitialization(address,bytes32)._llamaExecutor (LlamaRelativeQuorum.sol#2439) is not in mixedCase



    
2439   function finalizeInitialization(address _llamaExecutor, bytes32 bootstrapPermissionId) external {



```

```
Function ERC721NonTransferableMinimalProxy.__initializeERC721MinimalProxy(string,string) (LlamaRelativeQuorum.sol#2143-2146) is not in mixedCase



    
2143   function __initializeERC721MinimalProxy (string memory _name, string memory _symbol) internal {
2144     name = _name;
2145     symbol = _symbol;
2146   }



```

```
Parameter ERC721NonTransferableMinimalProxy.__initializeERC721MinimalProxy(string,string)._symbol (LlamaRelativeQuorum.sol#2143) is not in mixedCase



    
2143   function __initializeERC721MinimalProxy (string memory _name, string memory _symbol) internal {



```

```
Parameter ERC721NonTransferableMinimalProxy.__initializeERC721MinimalProxy(string,string)._name (LlamaRelativeQuorum.sol#2143) is not in mixedCase



    
2143   function __initializeERC721MinimalProxy (string memory _name, string memory _symbol) internal {



```

```
Variable ERC721NonTransferableMinimalProxy._ownerOf (LlamaRelativeQuorum.sol#2117) is not in mixedCase



    
2117   mapping(uint256 => address) internal _ownerOf;



```

```
Variable LlamaFactory.LLAMA_POLICY_METADATA_PARAM_REGISTRY (LlamaRelativeQuorum.sol#3144) is not in mixedCase



    
3144   LlamaPolicyMetadataParamRegistry public immutable LLAMA_POLICY_METADATA_PARAM_REGISTRY;



```

```
Parameter LlamaFactory.setPolicyMetadata(LlamaPolicyMetadata)._llamaPolicyMetadata (LlamaRelativeQuorum.sol#3264) is not in mixedCase



    
3264   function setPolicyMetadata(LlamaPolicyMetadata _llamaPolicyMetadata) external onlyRootLlama {



```

```
Variable ERC721NonTransferableMinimalProxy._balanceOf (LlamaRelativeQuorum.sol#2119) is not in mixedCase



    
2119   mapping(address => uint256) internal _balanceOf;



```

```
Variable LlamaPolicyMetadataParamRegistry.LLAMA_FACTORY (LlamaRelativeQuorum.sol#3032) is not in mixedCase



    
3032   address public immutable LLAMA_FACTORY;



```

```
Parameter LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[])._name (LlamaRelativeQuorum.sol#3566) is not in mixedCase



    
3566     string memory _name,



```

```
Variable LlamaFactory.ROOT_LLAMA_EXECUTOR (LlamaRelativeQuorum.sol#3147) is not in mixedCase



    
3147   LlamaExecutor public immutable ROOT_LLAMA_EXECUTOR;



```

```
Parameter LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[])._llamaAccountLogic (LlamaRelativeQuorum.sol#3569) is not in mixedCase



    
3569     ILlamaAccount _llamaAccountLogic,



```

```
Variable LlamaFactory.ROOT_LLAMA_CORE (LlamaRelativeQuorum.sol#3150) is not in mixedCase



    
3150   LlamaCore public immutable ROOT_LLAMA_CORE;



```

```
Variable LlamaFactory.LLAMA_POLICY_LOGIC (LlamaRelativeQuorum.sol#3141) is not in mixedCase



    
3141   LlamaPolicy public immutable LLAMA_POLICY_LOGIC;



```

```
Parameter LlamaPolicyMetadataParamRegistry.setLogo(LlamaExecutor,string)._logo (LlamaRelativeQuorum.sol#3078) is not in mixedCase



    
3078   function setLogo(LlamaExecutor llamaExecutor, string memory _logo) public onlyAuthorized(llamaExecutor) {



```

```
Variable LlamaExecutor.LLAMA_CORE (LlamaRelativeQuorum.sol#671) is not in mixedCase



    
671   address public immutable LLAMA_CORE;



```

```
Parameter LlamaPolicyMetadataParamRegistry.setColor(LlamaExecutor,string)._color (LlamaRelativeQuorum.sol#3070) is not in mixedCase



    
3070   function setColor(LlamaExecutor llamaExecutor, string memory _color) public onlyAuthorized(llamaExecutor) {



```

```
Parameter LlamaCore.initialize(string,LlamaPolicy,ILlamaStrategy,ILlamaAccount,bytes[],bytes[])._llamaStrategyLogic (LlamaRelativeQuorum.sol#3568) is not in mixedCase



    
3568     ILlamaStrategy _llamaStrategyLogic,



```

```
Variable LlamaPolicyMetadataParamRegistry.ROOT_LLAMA_EXECUTOR (LlamaRelativeQuorum.sol#3029) is not in mixedCase



    
3029   LlamaExecutor public immutable ROOT_LLAMA_EXECUTOR;



```

```
Variable LlamaFactory.LLAMA_CORE_LOGIC (LlamaRelativeQuorum.sol#3138) is not in mixedCase



    
3138   LlamaCore public immutable LLAMA_CORE_LOGIC;



```

## too-many-digits
### Severity: Informational

### LlamaAbsolutePeerReview.sol


```
FixedPointMathLib.sqrt(uint256) (LlamaAbsolutePeerReview.sol#347-410) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x10000000000 (LlamaAbsolutePeerReview.sol#367-370)



    
367             if iszero(lt(y, 0x10000000000)) {
368                 y := shr(32, y)
369                 z := shl(16, z)
370             }



```

```
FixedPointMathLib.sqrt(uint256) (LlamaAbsolutePeerReview.sol#347-410) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x1000000 (LlamaAbsolutePeerReview.sol#371-374)



    
371             if iszero(lt(y, 0x1000000)) {
372                 y := shr(16, y)
373                 z := shl(8, z)
374             }



```

```
LibString.escapeHTML(string) (LlamaAbsolutePeerReview.sol#1611-1642) uses literals with too many digits:
	- ! 1 << c_escapeHTML_asm_0 & 0x500000c400000000 (LlamaAbsolutePeerReview.sol#1627-1631)



    
1627                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
1628                     mstore8(result, c)
1629                     result := add(result, 1)
1630                     continue
1631                 }



```

```
FixedPointMathLib.sqrt(uint256) (LlamaAbsolutePeerReview.sol#347-410) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x1000000000000000000 (LlamaAbsolutePeerReview.sol#363-366)



    
363             if iszero(lt(y, 0x1000000000000000000)) {
364                 y := shr(64, y)
365                 z := shl(32, z)
366             }



```

```
FixedPointMathLib.sqrt(uint256) (LlamaAbsolutePeerReview.sol#347-410) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x10000000000000000000000000000000000 (LlamaAbsolutePeerReview.sol#359-362)



    
359             if iszero(lt(y, 0x10000000000000000000000000000000000)) {
360                 y := shr(128, y)
361                 z := shl(64, z)
362             }



```

```
Checkpoints.sqrt(uint256) (LlamaAbsolutePeerReview.sol#2021-2083) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x10000000000000000000000000000000000 (LlamaAbsolutePeerReview.sol#2032-2035)



    
2032             if iszero(lt(y, 0x10000000000000000000000000000000000)) {
2033                 y := shr(128, y)
2034                 z := shl(64, z)
2035             }



```

```
Clones.clone(address) (LlamaAbsolutePeerReview.sol#514-527) uses literals with too many digits:
	- mstore(uint256,uint256)(0x00,implementation << 0x60 >> 0xe8 | 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000) (LlamaAbsolutePeerReview.sol#519)



    
519             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))



```

```
Checkpoints.sqrt(uint256) (LlamaAbsolutePeerReview.sol#2021-2083) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x1000000000000000000 (LlamaAbsolutePeerReview.sol#2036-2039)



    
2036             if iszero(lt(y, 0x1000000000000000000)) {
2037                 y := shr(64, y)
2038                 z := shl(32, z)
2039             }



```

```
LibString.escapeHTML(string) (LlamaAbsolutePeerReview.sol#1611-1642) uses literals with too many digits:
	- mstore(uint256,uint256)(0x08,0xc0000000a6ab) (LlamaAbsolutePeerReview.sol#1620)



    
1620                 mstore(0x08, 0xc0000000a6ab)



```

```
Checkpoints.sqrt(uint256) (LlamaAbsolutePeerReview.sol#2021-2083) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x10000000000 (LlamaAbsolutePeerReview.sol#2040-2043)



    
2040             if iszero(lt(y, 0x10000000000)) {
2041                 y := shr(32, y)
2042                 z := shl(16, z)
2043             }



```

```
Checkpoints.sqrt(uint256) (LlamaAbsolutePeerReview.sol#2021-2083) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x1000000 (LlamaAbsolutePeerReview.sol#2044-2047)



    
2044             if iszero(lt(y, 0x1000000)) {
2045                 y := shr(16, y)
2046                 z := shl(8, z)
2047             }



```

```
Clones.cloneDeterministic(address,bytes32) (LlamaAbsolutePeerReview.sol#536-549) uses literals with too many digits:
	- mstore(uint256,uint256)(0x00,implementation << 0x60 >> 0xe8 | 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000) (LlamaAbsolutePeerReview.sol#541)



    
541             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))



```

### LlamaAbsoluteQuorum.sol


```
FixedPointMathLib.sqrt(uint256) (LlamaAbsoluteQuorum.sol#347-410) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x10000000000 (LlamaAbsoluteQuorum.sol#367-370)



    
367             if iszero(lt(y, 0x10000000000)) {
368                 y := shr(32, y)
369                 z := shl(16, z)
370             }



```

```
FixedPointMathLib.sqrt(uint256) (LlamaAbsoluteQuorum.sol#347-410) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x1000000 (LlamaAbsoluteQuorum.sol#371-374)



    
371             if iszero(lt(y, 0x1000000)) {
372                 y := shr(16, y)
373                 z := shl(8, z)
374             }



```

```
LibString.escapeHTML(string) (LlamaAbsoluteQuorum.sol#1611-1642) uses literals with too many digits:
	- ! 1 << c_escapeHTML_asm_0 & 0x500000c400000000 (LlamaAbsoluteQuorum.sol#1627-1631)



    
1627                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
1628                     mstore8(result, c)
1629                     result := add(result, 1)
1630                     continue
1631                 }



```

```
FixedPointMathLib.sqrt(uint256) (LlamaAbsoluteQuorum.sol#347-410) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x1000000000000000000 (LlamaAbsoluteQuorum.sol#363-366)



    
363             if iszero(lt(y, 0x1000000000000000000)) {
364                 y := shr(64, y)
365                 z := shl(32, z)
366             }



```

```
FixedPointMathLib.sqrt(uint256) (LlamaAbsoluteQuorum.sol#347-410) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x10000000000000000000000000000000000 (LlamaAbsoluteQuorum.sol#359-362)



    
359             if iszero(lt(y, 0x10000000000000000000000000000000000)) {
360                 y := shr(128, y)
361                 z := shl(64, z)
362             }



```

```
Checkpoints.sqrt(uint256) (LlamaAbsoluteQuorum.sol#2021-2083) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x10000000000000000000000000000000000 (LlamaAbsoluteQuorum.sol#2032-2035)



    
2032             if iszero(lt(y, 0x10000000000000000000000000000000000)) {
2033                 y := shr(128, y)
2034                 z := shl(64, z)
2035             }



```

```
Clones.clone(address) (LlamaAbsoluteQuorum.sol#514-527) uses literals with too many digits:
	- mstore(uint256,uint256)(0x00,implementation << 0x60 >> 0xe8 | 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000) (LlamaAbsoluteQuorum.sol#519)



    
519             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))



```

```
Checkpoints.sqrt(uint256) (LlamaAbsoluteQuorum.sol#2021-2083) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x1000000000000000000 (LlamaAbsoluteQuorum.sol#2036-2039)



    
2036             if iszero(lt(y, 0x1000000000000000000)) {
2037                 y := shr(64, y)
2038                 z := shl(32, z)
2039             }



```

```
LibString.escapeHTML(string) (LlamaAbsoluteQuorum.sol#1611-1642) uses literals with too many digits:
	- mstore(uint256,uint256)(0x08,0xc0000000a6ab) (LlamaAbsoluteQuorum.sol#1620)



    
1620                 mstore(0x08, 0xc0000000a6ab)



```

```
Checkpoints.sqrt(uint256) (LlamaAbsoluteQuorum.sol#2021-2083) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x10000000000 (LlamaAbsoluteQuorum.sol#2040-2043)



    
2040             if iszero(lt(y, 0x10000000000)) {
2041                 y := shr(32, y)
2042                 z := shl(16, z)
2043             }



```

```
Checkpoints.sqrt(uint256) (LlamaAbsoluteQuorum.sol#2021-2083) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x1000000 (LlamaAbsoluteQuorum.sol#2044-2047)



    
2044             if iszero(lt(y, 0x1000000)) {
2045                 y := shr(16, y)
2046                 z := shl(8, z)
2047             }



```

```
Clones.cloneDeterministic(address,bytes32) (LlamaAbsoluteQuorum.sol#536-549) uses literals with too many digits:
	- mstore(uint256,uint256)(0x00,implementation << 0x60 >> 0xe8 | 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000) (LlamaAbsoluteQuorum.sol#541)



    
541             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))



```

### LlamaAccount.sol


```
Clones.cloneDeterministic(address,bytes32) (LlamaAccount.sol#1213-1226) uses literals with too many digits:
	- mstore(uint256,uint256)(0x00,implementation << 0x60 >> 0xe8 | 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000) (LlamaAccount.sol#1218)



    
1218             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))



```

```
LibString.escapeHTML(string) (LlamaAccount.sol#2171-2202) uses literals with too many digits:
	- mstore(uint256,uint256)(0x08,0xc0000000a6ab) (LlamaAccount.sol#2180)



    
2180                 mstore(0x08, 0xc0000000a6ab)



```

```
Checkpoints.sqrt(uint256) (LlamaAccount.sol#2581-2643) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x10000000000 (LlamaAccount.sol#2600-2603)



    
2600             if iszero(lt(y, 0x10000000000)) {
2601                 y := shr(32, y)
2602                 z := shl(16, z)
2603             }



```

```
Checkpoints.sqrt(uint256) (LlamaAccount.sol#2581-2643) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x1000000000000000000 (LlamaAccount.sol#2596-2599)



    
2596             if iszero(lt(y, 0x1000000000000000000)) {
2597                 y := shr(64, y)
2598                 z := shl(32, z)
2599             }



```

```
LibString.escapeHTML(string) (LlamaAccount.sol#2171-2202) uses literals with too many digits:
	- ! 1 << c_escapeHTML_asm_0 & 0x500000c400000000 (LlamaAccount.sol#2187-2191)



    
2187                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
2188                     mstore8(result, c)
2189                     result := add(result, 1)
2190                     continue
2191                 }



```

```
Checkpoints.sqrt(uint256) (LlamaAccount.sol#2581-2643) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x1000000 (LlamaAccount.sol#2604-2607)



    
2604             if iszero(lt(y, 0x1000000)) {
2605                 y := shr(16, y)
2606                 z := shl(8, z)
2607             }



```

```
Checkpoints.sqrt(uint256) (LlamaAccount.sol#2581-2643) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x10000000000000000000000000000000000 (LlamaAccount.sol#2592-2595)



    
2592             if iszero(lt(y, 0x10000000000000000000000000000000000)) {
2593                 y := shr(128, y)
2594                 z := shl(64, z)
2595             }



```

```
Clones.clone(address) (LlamaAccount.sol#1191-1204) uses literals with too many digits:
	- mstore(uint256,uint256)(0x00,implementation << 0x60 >> 0xe8 | 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000) (LlamaAccount.sol#1196)



    
1196             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))



```

### LlamaCore.sol


```
Clones.cloneDeterministic(address,bytes32) (LlamaCore.sol#50-63) uses literals with too many digits:
	- mstore(uint256,uint256)(0x00,implementation << 0x60 >> 0xe8 | 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000) (LlamaCore.sol#55)



    
55             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))



```

```
Checkpoints.sqrt(uint256) (LlamaCore.sol#1643-1705) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x1000000 (LlamaCore.sol#1666-1669)



    
1666             if iszero(lt(y, 0x1000000)) {
1667                 y := shr(16, y)
1668                 z := shl(8, z)
1669             }



```

```
Checkpoints.sqrt(uint256) (LlamaCore.sol#1643-1705) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x1000000000000000000 (LlamaCore.sol#1658-1661)



    
1658             if iszero(lt(y, 0x1000000000000000000)) {
1659                 y := shr(64, y)
1660                 z := shl(32, z)
1661             }



```

```
Checkpoints.sqrt(uint256) (LlamaCore.sol#1643-1705) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x10000000000 (LlamaCore.sol#1662-1665)



    
1662             if iszero(lt(y, 0x10000000000)) {
1663                 y := shr(32, y)
1664                 z := shl(16, z)
1665             }



```

```
LibString.escapeHTML(string) (LlamaCore.sol#1208-1239) uses literals with too many digits:
	- mstore(uint256,uint256)(0x08,0xc0000000a6ab) (LlamaCore.sol#1217)



    
1217                 mstore(0x08, 0xc0000000a6ab)



```

```
LibString.escapeHTML(string) (LlamaCore.sol#1208-1239) uses literals with too many digits:
	- ! 1 << c_escapeHTML_asm_0 & 0x500000c400000000 (LlamaCore.sol#1224-1228)



    
1224                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
1225                     mstore8(result, c)
1226                     result := add(result, 1)
1227                     continue
1228                 }



```

```
Clones.clone(address) (LlamaCore.sol#28-41) uses literals with too many digits:
	- mstore(uint256,uint256)(0x00,implementation << 0x60 >> 0xe8 | 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000) (LlamaCore.sol#33)



    
33             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))



```

```
Checkpoints.sqrt(uint256) (LlamaCore.sol#1643-1705) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x10000000000000000000000000000000000 (LlamaCore.sol#1654-1657)



    
1654             if iszero(lt(y, 0x10000000000000000000000000000000000)) {
1655                 y := shr(128, y)
1656                 z := shl(64, z)
1657             }



```

### LlamaFactory.sol


```
Clones.cloneDeterministic(address,bytes32) (LlamaFactory.sol#50-63) uses literals with too many digits:
	- mstore(uint256,uint256)(0x00,implementation << 0x60 >> 0xe8 | 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000) (LlamaFactory.sol#55)



    
55             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))



```

```
Checkpoints.sqrt(uint256) (LlamaFactory.sol#1765-1827) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x1000000000000000000 (LlamaFactory.sol#1780-1783)



    
1780             if iszero(lt(y, 0x1000000000000000000)) {
1781                 y := shr(64, y)
1782                 z := shl(32, z)
1783             }



```

```
LibString.escapeHTML(string) (LlamaFactory.sol#1355-1386) uses literals with too many digits:
	- ! 1 << c_escapeHTML_asm_0 & 0x500000c400000000 (LlamaFactory.sol#1371-1375)



    
1371                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
1372                     mstore8(result, c)
1373                     result := add(result, 1)
1374                     continue
1375                 }



```

```
LibString.escapeHTML(string) (LlamaFactory.sol#1355-1386) uses literals with too many digits:
	- mstore(uint256,uint256)(0x08,0xc0000000a6ab) (LlamaFactory.sol#1364)



    
1364                 mstore(0x08, 0xc0000000a6ab)



```

```
Checkpoints.sqrt(uint256) (LlamaFactory.sol#1765-1827) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x10000000000000000000000000000000000 (LlamaFactory.sol#1776-1779)



    
1776             if iszero(lt(y, 0x10000000000000000000000000000000000)) {
1777                 y := shr(128, y)
1778                 z := shl(64, z)
1779             }



```

```
Clones.clone(address) (LlamaFactory.sol#28-41) uses literals with too many digits:
	- mstore(uint256,uint256)(0x00,implementation << 0x60 >> 0xe8 | 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000) (LlamaFactory.sol#33)



    
33             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))



```

```
Checkpoints.sqrt(uint256) (LlamaFactory.sol#1765-1827) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x10000000000 (LlamaFactory.sol#1784-1787)



    
1784             if iszero(lt(y, 0x10000000000)) {
1785                 y := shr(32, y)
1786                 z := shl(16, z)
1787             }



```

```
Checkpoints.sqrt(uint256) (LlamaFactory.sol#1765-1827) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x1000000 (LlamaFactory.sol#1788-1791)



    
1788             if iszero(lt(y, 0x1000000)) {
1789                 y := shr(16, y)
1790                 z := shl(8, z)
1791             }



```

### LlamaGovernanceScript.sol


```
LibString.escapeHTML(string) (LlamaGovernanceScript.sol#1379-1410) uses literals with too many digits:
	- ! 1 << c_escapeHTML_asm_0 & 0x500000c400000000 (LlamaGovernanceScript.sol#1395-1399)



    
1395                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
1396                     mstore8(result, c)
1397                     result := add(result, 1)
1398                     continue
1399                 }



```

```
Checkpoints.sqrt(uint256) (LlamaGovernanceScript.sol#1789-1851) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x1000000 (LlamaGovernanceScript.sol#1812-1815)



    
1812             if iszero(lt(y, 0x1000000)) {
1813                 y := shr(16, y)
1814                 z := shl(8, z)
1815             }



```

```
Checkpoints.sqrt(uint256) (LlamaGovernanceScript.sol#1789-1851) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x10000000000000000000000000000000000 (LlamaGovernanceScript.sol#1800-1803)



    
1800             if iszero(lt(y, 0x10000000000000000000000000000000000)) {
1801                 y := shr(128, y)
1802                 z := shl(64, z)
1803             }



```

```
Clones.clone(address) (LlamaGovernanceScript.sol#99-112) uses literals with too many digits:
	- mstore(uint256,uint256)(0x00,implementation << 0x60 >> 0xe8 | 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000) (LlamaGovernanceScript.sol#104)



    
104             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))



```

```
Clones.cloneDeterministic(address,bytes32) (LlamaGovernanceScript.sol#121-134) uses literals with too many digits:
	- mstore(uint256,uint256)(0x00,implementation << 0x60 >> 0xe8 | 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000) (LlamaGovernanceScript.sol#126)



    
126             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))



```

```
Checkpoints.sqrt(uint256) (LlamaGovernanceScript.sol#1789-1851) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x1000000000000000000 (LlamaGovernanceScript.sol#1804-1807)



    
1804             if iszero(lt(y, 0x1000000000000000000)) {
1805                 y := shr(64, y)
1806                 z := shl(32, z)
1807             }



```

```
Checkpoints.sqrt(uint256) (LlamaGovernanceScript.sol#1789-1851) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x10000000000 (LlamaGovernanceScript.sol#1808-1811)



    
1808             if iszero(lt(y, 0x10000000000)) {
1809                 y := shr(32, y)
1810                 z := shl(16, z)
1811             }



```

```
LibString.escapeHTML(string) (LlamaGovernanceScript.sol#1379-1410) uses literals with too many digits:
	- mstore(uint256,uint256)(0x08,0xc0000000a6ab) (LlamaGovernanceScript.sol#1388)



    
1388                 mstore(0x08, 0xc0000000a6ab)



```

### LlamaPolicy.sol


```
Checkpoints.sqrt(uint256) (LlamaPolicy.sol#1350-1412) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x10000000000 (LlamaPolicy.sol#1369-1372)



    
1369             if iszero(lt(y, 0x10000000000)) {
1370                 y := shr(32, y)
1371                 z := shl(16, z)
1372             }



```

```
LibString.escapeHTML(string) (LlamaPolicy.sol#915-946) uses literals with too many digits:
	- mstore(uint256,uint256)(0x08,0xc0000000a6ab) (LlamaPolicy.sol#924)



    
924                 mstore(0x08, 0xc0000000a6ab)



```

```
Checkpoints.sqrt(uint256) (LlamaPolicy.sol#1350-1412) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x1000000 (LlamaPolicy.sol#1373-1376)



    
1373             if iszero(lt(y, 0x1000000)) {
1374                 y := shr(16, y)
1375                 z := shl(8, z)
1376             }



```

```
LibString.escapeHTML(string) (LlamaPolicy.sol#915-946) uses literals with too many digits:
	- ! 1 << c_escapeHTML_asm_0 & 0x500000c400000000 (LlamaPolicy.sol#931-935)



    
931                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
932                     mstore8(result, c)
933                     result := add(result, 1)
934                     continue
935                 }



```

```
Clones.clone(address) (LlamaPolicy.sol#1811-1824) uses literals with too many digits:
	- mstore(uint256,uint256)(0x00,implementation << 0x60 >> 0xe8 | 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000) (LlamaPolicy.sol#1816)



    
1816             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))



```

```
Clones.cloneDeterministic(address,bytes32) (LlamaPolicy.sol#1833-1846) uses literals with too many digits:
	- mstore(uint256,uint256)(0x00,implementation << 0x60 >> 0xe8 | 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000) (LlamaPolicy.sol#1838)



    
1838             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))



```

```
Checkpoints.sqrt(uint256) (LlamaPolicy.sol#1350-1412) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x1000000000000000000 (LlamaPolicy.sol#1365-1368)



    
1365             if iszero(lt(y, 0x1000000000000000000)) {
1366                 y := shr(64, y)
1367                 z := shl(32, z)
1368             }



```

```
Checkpoints.sqrt(uint256) (LlamaPolicy.sol#1350-1412) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x10000000000000000000000000000000000 (LlamaPolicy.sol#1361-1364)



    
1361             if iszero(lt(y, 0x10000000000000000000000000000000000)) {
1362                 y := shr(128, y)
1363                 z := shl(64, z)
1364             }



```

### LlamaPolicyMetadata.sol


```
LibString.escapeHTML(string) (LlamaPolicyMetadata.sol#1003-1034) uses literals with too many digits:
	- ! 1 << c_escapeHTML_asm_0 & 0x500000c400000000 (LlamaPolicyMetadata.sol#1019-1023)



    
1019                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
1020                     mstore8(result, c)
1021                     result := add(result, 1)
1022                     continue
1023                 }



```

```
LibString.escapeHTML(string) (LlamaPolicyMetadata.sol#1003-1034) uses literals with too many digits:
	- mstore(uint256,uint256)(0x08,0xc0000000a6ab) (LlamaPolicyMetadata.sol#1012)



    
1012                 mstore(0x08, 0xc0000000a6ab)



```

### LlamaRelativeQuorum.sol


```
FixedPointMathLib.sqrt(uint256) (LlamaRelativeQuorum.sol#347-410) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x10000000000 (LlamaRelativeQuorum.sol#367-370)



    
367             if iszero(lt(y, 0x10000000000)) {
368                 y := shr(32, y)
369                 z := shl(16, z)
370             }



```

```
FixedPointMathLib.sqrt(uint256) (LlamaRelativeQuorum.sol#347-410) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x1000000 (LlamaRelativeQuorum.sol#371-374)



    
371             if iszero(lt(y, 0x1000000)) {
372                 y := shr(16, y)
373                 z := shl(8, z)
374             }



```

```
LibString.escapeHTML(string) (LlamaRelativeQuorum.sol#1611-1642) uses literals with too many digits:
	- ! 1 << c_escapeHTML_asm_0 & 0x500000c400000000 (LlamaRelativeQuorum.sol#1627-1631)



    
1627                 if iszero(and(shl(c, 1), 0x500000c400000000)) {
1628                     mstore8(result, c)
1629                     result := add(result, 1)
1630                     continue
1631                 }



```

```
FixedPointMathLib.sqrt(uint256) (LlamaRelativeQuorum.sol#347-410) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x1000000000000000000 (LlamaRelativeQuorum.sol#363-366)



    
363             if iszero(lt(y, 0x1000000000000000000)) {
364                 y := shr(64, y)
365                 z := shl(32, z)
366             }



```

```
FixedPointMathLib.sqrt(uint256) (LlamaRelativeQuorum.sol#347-410) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x10000000000000000000000000000000000 (LlamaRelativeQuorum.sol#359-362)



    
359             if iszero(lt(y, 0x10000000000000000000000000000000000)) {
360                 y := shr(128, y)
361                 z := shl(64, z)
362             }



```

```
Checkpoints.sqrt(uint256) (LlamaRelativeQuorum.sol#2021-2083) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x10000000000000000000000000000000000 (LlamaRelativeQuorum.sol#2032-2035)



    
2032             if iszero(lt(y, 0x10000000000000000000000000000000000)) {
2033                 y := shr(128, y)
2034                 z := shl(64, z)
2035             }



```

```
Clones.clone(address) (LlamaRelativeQuorum.sol#514-527) uses literals with too many digits:
	- mstore(uint256,uint256)(0x00,implementation << 0x60 >> 0xe8 | 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000) (LlamaRelativeQuorum.sol#519)



    
519             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))



```

```
Checkpoints.sqrt(uint256) (LlamaRelativeQuorum.sol#2021-2083) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x1000000000000000000 (LlamaRelativeQuorum.sol#2036-2039)



    
2036             if iszero(lt(y, 0x1000000000000000000)) {
2037                 y := shr(64, y)
2038                 z := shl(32, z)
2039             }



```

```
LibString.escapeHTML(string) (LlamaRelativeQuorum.sol#1611-1642) uses literals with too many digits:
	- mstore(uint256,uint256)(0x08,0xc0000000a6ab) (LlamaRelativeQuorum.sol#1620)



    
1620                 mstore(0x08, 0xc0000000a6ab)



```

```
Checkpoints.sqrt(uint256) (LlamaRelativeQuorum.sol#2021-2083) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x10000000000 (LlamaRelativeQuorum.sol#2040-2043)



    
2040             if iszero(lt(y, 0x10000000000)) {
2041                 y := shr(32, y)
2042                 z := shl(16, z)
2043             }



```

```
Checkpoints.sqrt(uint256) (LlamaRelativeQuorum.sol#2021-2083) uses literals with too many digits:
	- ! y_sqrt_asm_0 < 0x1000000 (LlamaRelativeQuorum.sol#2044-2047)



    
2044             if iszero(lt(y, 0x1000000)) {
2045                 y := shr(16, y)
2046                 z := shl(8, z)
2047             }



```

```
Clones.cloneDeterministic(address,bytes32) (LlamaRelativeQuorum.sol#536-549) uses literals with too many digits:
	- mstore(uint256,uint256)(0x00,implementation << 0x60 >> 0xe8 | 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000) (LlamaRelativeQuorum.sol#541)



    
541             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))



```

## unused-state
### Severity: Informational

### LlamaAbsolutePeerReview.sol


```
LibString.NOT_FOUND (LlamaAbsolutePeerReview.sol#716) is never used in LibString (LlamaAbsolutePeerReview.sol#703-1801)



    
716     uint256 internal constant NOT_FOUND = type(uint256).max;



```

### LlamaAbsoluteQuorum.sol


```
LibString.NOT_FOUND (LlamaAbsoluteQuorum.sol#716) is never used in LibString (LlamaAbsoluteQuorum.sol#703-1801)



    
716     uint256 internal constant NOT_FOUND = type(uint256).max;



```

### LlamaAccount.sol


```
LibString.NOT_FOUND (LlamaAccount.sol#1276) is never used in LibString (LlamaAccount.sol#1263-2361)



    
1276     uint256 internal constant NOT_FOUND = type(uint256).max;



```

### LlamaCore.sol


```
LibString.NOT_FOUND (LlamaCore.sol#313) is never used in LibString (LlamaCore.sol#300-1398)



    
313     uint256 internal constant NOT_FOUND = type(uint256).max;



```

### LlamaFactory.sol


```
LibString.NOT_FOUND (LlamaFactory.sol#460) is never used in LibString (LlamaFactory.sol#447-1545)



    
460     uint256 internal constant NOT_FOUND = type(uint256).max;



```

### LlamaGovernanceScript.sol


```
LibString.NOT_FOUND (LlamaGovernanceScript.sol#484) is never used in LibString (LlamaGovernanceScript.sol#471-1569)



    
484     uint256 internal constant NOT_FOUND = type(uint256).max;



```

### LlamaPolicy.sol


```
LibString.NOT_FOUND (LlamaPolicy.sol#20) is never used in LibString (LlamaPolicy.sol#7-1105)



    
20     uint256 internal constant NOT_FOUND = type(uint256).max;



```

### LlamaPolicyMetadata.sol


```
LibString.NOT_FOUND (LlamaPolicyMetadata.sol#108) is never used in LibString (LlamaPolicyMetadata.sol#95-1193)



    
108     uint256 internal constant NOT_FOUND = type(uint256).max;



```

### LlamaRelativeQuorum.sol


```
LibString.NOT_FOUND (LlamaRelativeQuorum.sol#716) is never used in LibString (LlamaRelativeQuorum.sol#703-1801)



    
716     uint256 internal constant NOT_FOUND = type(uint256).max;



```

## missing-inheritance
### Severity: Informational

### LlamaAccount.sol


```
ERC721TokenReceiver (LlamaAccount.sol#2829-2833) should inherit from IERC721Receiver (LlamaAccount.sol#851-867)



    
2829 abstract contract ERC721TokenReceiver {
2830   function onERC721Received(address, address, uint256, bytes calldata) external virtual returns (bytes4) {
2831     return ERC721TokenReceiver.onERC721Received.selector;
2832   }
2833 }



```
